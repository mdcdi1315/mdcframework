/* 
 * Licensed to the .NET Foundation under one or more agreements.
 * The .NET Foundation licenses this file to you under the MIT license.
 * See the LICENSE file in the project root for more information.
*/

using System.Reflection;
using System.Collections;
using System.Diagnostics;
using System.Globalization;
using System.ComponentModel;
using System.Collections.Generic;
using System.Runtime.InteropServices;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;

#nullable enable
namespace System.Text.Json
{
    using System.IO;
    using System.Buffers;
    using System.Numerics;
    using System.Threading;
    using System.Buffers.Text;
    using System.Text.Json.Nodes;
    using System.Threading.Tasks;
    using System.Text.Encodings.Web;
    using System.Text.Json.Reflection;
    using System.Text.Json.Serialization;
    using System.Collections.Concurrent;
    using System.Runtime.Serialization;
    using System.Runtime.ExceptionServices;
    using System.Text.Json.Serialization.Metadata;


    internal static class AppContextSwitchHelper
    {
        private static readonly bool s_isSourceGenReflectionFallbackEnabled = AppContext.TryGetSwitch("System.Text.Json.Serialization.EnableSourceGenReflectionFallback", out var isEnabled) && isEnabled;

        public static bool IsSourceGenReflectionFallbackEnabled => s_isSourceGenReflectionFallbackEnabled;
    }

    /// <summary>
	/// Constructor arguments for objects with parameterized ctors with less than 5 parameters.
	/// This is to avoid boxing for small, immutable objects.
	/// </summary>
	internal sealed class Arguments<TArg0, TArg1, TArg2, TArg3>
    {
        public TArg0 Arg0;

        public TArg1 Arg1;

        public TArg2 Arg2;

        public TArg3 Arg3;
    }

    /// <summary>
	/// Holds relevant state when deserializing objects with parameterized constructors.
	/// Lives on the current ReadStackFrame.
	/// </summary>
	internal sealed class ArgumentState
    {
        public object Arguments;

        public (JsonPropertyInfo, JsonReaderState, long, byte[], string)[] FoundProperties;

        public (JsonPropertyInfo, object, string)[] FoundPropertiesAsync;

        public int FoundPropertyCount;

        public JsonParameterInfo JsonParameterInfo;

        public int ParameterIndex;

        public List<ParameterRef> ParameterRefCache;
    }

    internal struct BitStack
    {
        private const int AllocationFreeMaxDepth = 64;

        private const int DefaultInitialArraySize = 2;

        private int[] _array;

        private ulong _allocationFreeContainer;

        private int _currentDepth;

        public int CurrentDepth => _currentDepth;

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushTrue()
        {
            if (_currentDepth < 64)
            {
                _allocationFreeContainer = (_allocationFreeContainer << 1) | 1;
            }
            else
            {
                PushToArray(value: true);
            }
            _currentDepth++;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void PushFalse()
        {
            if (_currentDepth < 64)
            {
                _allocationFreeContainer <<= 1;
            }
            else
            {
                PushToArray(value: false);
            }
            _currentDepth++;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private void PushToArray(bool value)
        {
            if (_array == null)
            {
                _array = new int[2];
            }
            int number = _currentDepth - 64;
            int remainder;
            int num = Div32Rem(number, out remainder);
            if (num >= _array.Length)
            {
                DoubleArray(num);
            }
            int num2 = _array[num];
            num2 = ((!value) ? (num2 & ~(1 << remainder)) : (num2 | (1 << remainder)));
            _array[num] = num2;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Pop()
        {
            _currentDepth--;
            if (_currentDepth < 64)
            {
                _allocationFreeContainer >>= 1;
                return (_allocationFreeContainer & 1) != 0;
            }
            if (_currentDepth == 64)
            {
                return (_allocationFreeContainer & 1) != 0;
            }
            return PopFromArray();
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private bool PopFromArray()
        {
            int number = _currentDepth - 64 - 1;
            int remainder;
            int num = Div32Rem(number, out remainder);
            return (_array[num] & (1 << remainder)) != 0;
        }

        private void DoubleArray(int minSize)
        {
            int newSize = Math.Max(minSize + 1, _array.Length * 2);
            Array.Resize(ref _array, newSize);
        }

        public void SetFirstBit()
        {
            _currentDepth++;
            _allocationFreeContainer = 1uL;
        }

        public void ResetFirstBit()
        {
            _currentDepth++;
            _allocationFreeContainer = 0uL;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static int Div32Rem(int number, out int remainder)
        {
            uint result = (uint)number / 32u;
            remainder = number & 0x1F;
            return (int)result;
        }
    }

    /// <summary>
	/// This enum captures the tri-state return value when trying to read a
	/// JSON number.
	/// </summary>
	internal enum ConsumeNumberResult : byte
    {
        /// <summary>
        /// Reached a valid end of number and hence no action is required.
        /// </summary>
        Success,
        /// <summary>
        /// Successfully processed a portion of the number and need to
        /// read to the next region of the number.
        /// </summary>
        OperationIncomplete,
        /// <summary>
        /// Observed incomplete data.
        /// Return false if we have more data to follow. Otherwise throw.
        /// </summary>
        NeedMoreData
    }

    /// <summary>
	/// This enum captures the tri-state return value when trying to read the
	/// next JSON token.
	/// </summary>
	internal enum ConsumeTokenResult : byte
    {
        /// <summary>
        /// Reached a valid end of token and hence no action is required.
        /// </summary>
        Success,
        /// <summary>
        /// Observed incomplete data but progressed state partially in looking ahead.
        /// Return false and roll-back to a previously saved state.
        /// </summary>
        NotEnoughDataRollBackState,
        /// <summary>
        /// Observed incomplete data but no change was made to the state.
        /// Return false, but do not roll-back anything since nothing changed.
        /// </summary>
        IncompleteNoRollBackNecessary
    }

    /// <summary>
	/// Determines how a given class is treated when it is (de)serialized.
	/// </summary>
	/// <remarks>
	/// Although bit flags are used, a given ConverterStrategy can only be one value.
	/// Bit flags are used to efficiently compare against more than one value.
	/// </remarks>
	internal enum ConverterStrategy : byte
    {
        /// <summary>
        /// Default value; not used by any converter.
        /// </summary>
        None = 0,
        /// <summary>
        /// Objects with properties.
        /// </summary>
        Object = 1,
        /// <summary>
        /// Simple values or user-provided custom converters.
        /// </summary>
        Value = 2,
        /// <summary>
        /// Enumerable collections except dictionaries.
        /// </summary>
        Enumerable = 8,
        /// <summary>
        /// Dictionary types.
        /// </summary>
        Dictionary = 0x10
    }

    internal enum DataType
    {
        Boolean,
        DateOnly,
        DateTime,
        DateTimeOffset,
        TimeOnly,
        TimeSpan,
        Base64String,
        Guid,
        Version
    }

    internal enum ExceptionResource
    {
        ArrayDepthTooLarge,
        EndOfCommentNotFound,
        EndOfStringNotFound,
        RequiredDigitNotFoundAfterDecimal,
        RequiredDigitNotFoundAfterSign,
        RequiredDigitNotFoundEndOfData,
        ExpectedEndAfterSingleJson,
        ExpectedEndOfDigitNotFound,
        ExpectedFalse,
        ExpectedNextDigitEValueNotFound,
        ExpectedNull,
        ExpectedSeparatorAfterPropertyNameNotFound,
        ExpectedStartOfPropertyNotFound,
        ExpectedStartOfPropertyOrValueNotFound,
        ExpectedStartOfPropertyOrValueAfterComment,
        ExpectedStartOfValueNotFound,
        ExpectedTrue,
        ExpectedValueAfterPropertyNameNotFound,
        FoundInvalidCharacter,
        InvalidCharacterWithinString,
        InvalidCharacterAfterEscapeWithinString,
        InvalidHexCharacterWithinString,
        InvalidEndOfJsonNonPrimitive,
        MismatchedObjectArray,
        ObjectDepthTooLarge,
        ZeroDepthAtEnd,
        DepthTooLarge,
        CannotStartObjectArrayWithoutProperty,
        CannotStartObjectArrayAfterPrimitiveOrClose,
        CannotWriteValueWithinObject,
        CannotWriteValueAfterPrimitiveOrClose,
        CannotWritePropertyWithinArray,
        ExpectedJsonTokens,
        TrailingCommaNotAllowedBeforeArrayEnd,
        TrailingCommaNotAllowedBeforeObjectEnd,
        InvalidCharacterAtStartOfComment,
        UnexpectedEndOfDataWhileReadingComment,
        UnexpectedEndOfLineSeparator,
        ExpectedOneCompleteToken,
        NotEnoughData,
        InvalidLeadingZeroInNumber
    }

    internal sealed class JsonCamelCaseNamingPolicy : JsonNamingPolicy
    {
        public override string ConvertName(string name)
        {
            if (string.IsNullOrEmpty(name) || !char.IsUpper(name[0]))
            {
                return name;
            }
            char[] array = name.ToCharArray();
            FixCasing(array);
            return new string(array);
        }

        private static void FixCasing(Span<char> chars)
        {
            for (int i = 0; i < chars.Length && (i != 1 || char.IsUpper(chars[i])); i++)
            {
                bool flag = i + 1 < chars.Length;
                if (i > 0 && flag && !char.IsUpper(chars[i + 1]))
                {
                    if (chars[i + 1] == ' ')
                    {
                        chars[i] = char.ToLowerInvariant(chars[i]);
                    }
                    break;
                }
                chars[i] = char.ToLowerInvariant(chars[i]);
            }
        }
    }

    /// <summary>
	/// This enum defines the various ways the <see cref="Utf8JsonReader" /> can deal with comments.
	/// </summary>
	public enum JsonCommentHandling : byte
    {
        /// <summary>
        /// By default, do no allow comments within the JSON input.
        /// Comments are treated as invalid JSON if found and a
        /// <see cref="T:System.Text.Json.JsonException" /> is thrown.
        /// </summary>
        Disallow,
        /// <summary>
        /// Allow comments within the JSON input and ignore them.
        /// The <see cref="T:System.Text.Json.Utf8JsonReader" /> will behave as if no comments were present.
        /// </summary>
        Skip,
        /// <summary>
        /// Allow comments within the JSON input and treat them as valid tokens.
        /// While reading, the caller will be able to access the comment values.
        /// </summary>
        Allow
    }

    internal static class JsonConstants
    {
        public const int MaxParameterCount = 64;

        public const string DoubleFormatString = "G17";

        public const string SingleFormatString = "G9";

        public const byte OpenBrace = 123;

        public const byte CloseBrace = 125;

        public const byte OpenBracket = 91;

        public const byte CloseBracket = 93;

        public const byte Space = 32;

        public const byte CarriageReturn = 13;

        public const byte LineFeed = 10;

        public const byte Tab = 9;

        public const byte ListSeparator = 44;

        public const byte KeyValueSeparator = 58;

        public const byte Quote = 34;

        public const byte BackSlash = 92;

        public const byte Slash = 47;

        public const byte BackSpace = 8;

        public const byte FormFeed = 12;

        public const byte Asterisk = 42;

        public const byte Colon = 58;

        public const byte Period = 46;

        public const byte Plus = 43;

        public const byte Hyphen = 45;

        public const byte UtcOffsetToken = 90;

        public const byte TimePrefix = 84;

        public const byte StartingByteOfNonStandardSeparator = 226;

        public const int SpacesPerIndent = 2;

        public const int RemoveFlagsBitMask = int.MaxValue;

        public const int StackallocByteThreshold = 256;

        public const int StackallocCharThreshold = 128;

        public const int MaxExpansionFactorWhileEscaping = 6;

        public const int MaxExpansionFactorWhileTranscoding = 3;

        public const long ArrayPoolMaxSizeBeforeUsingNormalAlloc = 1048576L;

        public const int MaxUtf16RawValueLength = 715827882;

        public const int MaxEscapedTokenSize = 1000000000;

        public const int MaxUnescapedTokenSize = 166666666;

        public const int MaxBase64ValueTokenSize = 125000000;

        public const int MaxCharacterTokenSize = 166666666;

        public const int MaximumFormatBooleanLength = 5;

        public const int MaximumFormatInt64Length = 20;

        public const int MaximumFormatUInt64Length = 20;

        public const int MaximumFormatDoubleLength = 128;

        public const int MaximumFormatSingleLength = 128;

        public const int MaximumFormatDecimalLength = 31;

        public const int MaximumFormatGuidLength = 36;

        public const int MaximumEscapedGuidLength = 216;

        public const int MaximumFormatDateTimeLength = 27;

        public const int MaximumFormatDateTimeOffsetLength = 33;

        public const int MaxDateTimeUtcOffsetHours = 14;

        public const int DateTimeNumFractionDigits = 7;

        public const int MaxDateTimeFraction = 9999999;

        public const int DateTimeParseNumFractionDigits = 16;

        public const int MaximumDateTimeOffsetParseLength = 42;

        public const int MinimumDateTimeParseLength = 10;

        public const int MaximumEscapedDateTimeOffsetParseLength = 252;

        public const int MaximumLiteralLength = 5;

        public const char HighSurrogateStart = '\ud800';

        public const char HighSurrogateEnd = '\udbff';

        public const char LowSurrogateStart = '\udc00';

        public const char LowSurrogateEnd = '\udfff';

        public const int UnicodePlane01StartValue = 65536;

        public const int HighSurrogateStartValue = 55296;

        public const int HighSurrogateEndValue = 56319;

        public const int LowSurrogateStartValue = 56320;

        public const int LowSurrogateEndValue = 57343;

        public const int BitShiftBy10 = 1024;

        public const int UnboxedParameterCountThreshold = 4;

        public static ReadOnlySpan<byte> Utf8Bom => new byte[3] { 239, 187, 191 };

        public static ReadOnlySpan<byte> TrueValue => new byte[4] { 116, 114, 117, 101 };

        public static ReadOnlySpan<byte> FalseValue => new byte[5] { 102, 97, 108, 115, 101 };

        public static ReadOnlySpan<byte> NullValue => new byte[4] { 110, 117, 108, 108 };

        public static ReadOnlySpan<byte> NaNValue => new byte[3] { 78, 97, 78 };

        public static ReadOnlySpan<byte> PositiveInfinityValue => new byte[8] { 73, 110, 102, 105, 110, 105, 116, 121 };

        public static ReadOnlySpan<byte> NegativeInfinityValue => new byte[9] { 45, 73, 110, 102, 105, 110, 105, 116, 121 };

        public static ReadOnlySpan<byte> Delimiters => new byte[8] { 44, 125, 93, 32, 10, 13, 9, 47 };

        public static ReadOnlySpan<byte> EscapableChars => new byte[8] { 34, 110, 114, 116, 47, 117, 98, 102 };
    }

    /// <summary>
	///   Represents the structure of a JSON value in a lightweight, read-only form.
	/// </summary>
	/// <remarks>
	///   This class utilizes resources from pooled memory to minimize the garbage collector (GC)
	///   impact in high-usage scenarios. Failure to properly Dispose this object will result in
	///   the memory not being returned to the pool, which will cause an increase in GC impact across
	///   various parts of the framework.
	/// </remarks>
	public sealed class JsonDocument : IDisposable
    {
        internal readonly struct DbRow
        {
            internal const int Size = 12;

            private readonly int _location;

            private readonly int _sizeOrLengthUnion;

            private readonly int _numberOfRowsAndTypeUnion;

            internal const int UnknownSize = -1;

            /// <summary>
            /// Index into the payload
            /// </summary>
            internal int Location => _location;

            /// <summary>
            /// length of text in JSON payload (or number of elements if its a JSON array)
            /// </summary>
            internal int SizeOrLength => _sizeOrLengthUnion & 0x7FFFFFFF;

            internal bool IsUnknownSize => _sizeOrLengthUnion == -1;

            /// <summary>
            /// String/PropertyName: Unescaping is required.
            /// Array: At least one element is an object/array.
            /// Otherwise; false
            /// </summary>
            internal bool HasComplexChildren => _sizeOrLengthUnion < 0;

            internal int NumberOfRows => _numberOfRowsAndTypeUnion & 0xFFFFFFF;

            internal JsonTokenType TokenType => (JsonTokenType)((uint)_numberOfRowsAndTypeUnion >> 28);

            internal bool IsSimpleValue => (int)TokenType >= 5;

            internal DbRow(JsonTokenType jsonTokenType, int location, int sizeOrLength)
            {
                _location = location;
                _sizeOrLengthUnion = sizeOrLength;
                _numberOfRowsAndTypeUnion = (int)((uint)jsonTokenType << 28);
            }
        }

        private struct MetadataDb : IDisposable
        {
            private const int SizeOrLengthOffset = 4;

            private const int NumberOfRowsOffset = 8;

            private byte[] _data;

            private bool _convertToAlloc;

            private bool _isLocked;

            internal int Length { get; private set; }

            private MetadataDb(byte[] initialDb, bool isLocked, bool convertToAlloc)
            {
                _data = initialDb;
                _isLocked = isLocked;
                _convertToAlloc = convertToAlloc;
                Length = 0;
            }

            internal MetadataDb(byte[] completeDb)
            {
                _data = completeDb;
                _isLocked = true;
                _convertToAlloc = false;
                Length = completeDb.Length;
            }

            internal static MetadataDb CreateRented(int payloadLength, bool convertToAlloc)
            {
                int num = payloadLength + 12;
                if (num > 1048576 && num <= 4194304)
                {
                    num = 1048576;
                }
                byte[] initialDb = ArrayPool<byte>.Shared.Rent(num);
                return new MetadataDb(initialDb, isLocked: false, convertToAlloc);
            }

            internal static MetadataDb CreateLocked(int payloadLength)
            {
                int num = payloadLength + 12;
                byte[] initialDb = new byte[num];
                return new MetadataDb(initialDb, isLocked: true, convertToAlloc: false);
            }

            public void Dispose()
            {
                byte[] array = Interlocked.Exchange(ref _data, null);
                if (array != null)
                {
                    ArrayPool<byte>.Shared.Return(array);
                    Length = 0;
                }
            }

            /// <summary>
            /// If using array pools, trim excess if necessary.
            /// If not using array pools, release the temporary array pool and alloc.
            /// </summary>
            internal void CompleteAllocations()
            {
                if (_isLocked)
                {
                    return;
                }
                if (_convertToAlloc)
                {
                    byte[] data = _data;
                    _data = _data.AsSpan(0, Length).ToArray();
                    _isLocked = true;
                    _convertToAlloc = false;
                    ArrayPool<byte>.Shared.Return(data);
                }
                else if (Length <= _data.Length / 2)
                {
                    byte[] array = ArrayPool<byte>.Shared.Rent(Length);
                    byte[] array2 = array;
                    if (array.Length < _data.Length)
                    {
                        Buffer.BlockCopy(_data, 0, array, 0, Length);
                        array2 = _data;
                        _data = array;
                    }
                    ArrayPool<byte>.Shared.Return(array2);
                }
            }

            internal void Append(JsonTokenType tokenType, int startLocation, int length)
            {
                if (Length >= _data.Length - 12)
                {
                    Enlarge();
                }
                DbRow value = new DbRow(tokenType, startLocation, length);
                MemoryMarshal.Write(_data.AsSpan(Length), ref value);
                Length += 12;
            }

            private void Enlarge()
            {
                byte[] data = _data;
                _data = ArrayPool<byte>.Shared.Rent(data.Length * 2);
                Buffer.BlockCopy(data, 0, _data, 0, data.Length);
                ArrayPool<byte>.Shared.Return(data);
            }

            [Conditional("DEBUG")]
            private void AssertValidIndex(int index)
            {
            }

            internal void SetLength(int index, int length)
            {
                Span<byte> destination = _data.AsSpan(index + 4);
                MemoryMarshal.Write(destination, ref length);
            }

            internal void SetNumberOfRows(int index, int numberOfRows)
            {
                Span<byte> span = _data.AsSpan(index + 8);
                int num = MemoryMarshal.Read<int>(span);
                int value = (num & -268435456) | numberOfRows;
                MemoryMarshal.Write(span, ref value);
            }

            internal void SetHasComplexChildren(int index)
            {
                Span<byte> span = _data.AsSpan(index + 4);
                int num = MemoryMarshal.Read<int>(span);
                int value = num | int.MinValue;
                MemoryMarshal.Write(span, ref value);
            }

            internal int FindIndexOfFirstUnsetSizeOrLength(JsonTokenType lookupType)
            {
                return FindOpenElement(lookupType);
            }

            private int FindOpenElement(JsonTokenType lookupType)
            {
                Span<byte> span = _data.AsSpan(0, Length);
                for (int num = Length - 12; num >= 0; num -= 12)
                {
                    DbRow dbRow = MemoryMarshal.Read<DbRow>(span.Slice(num));
                    if (dbRow.IsUnknownSize && dbRow.TokenType == lookupType)
                    {
                        return num;
                    }
                }
                return -1;
            }

            internal DbRow Get(int index)
            {
                return MemoryMarshal.Read<DbRow>(_data.AsSpan(index));
            }

            internal JsonTokenType GetJsonTokenType(int index)
            {
                uint num = MemoryMarshal.Read<uint>(_data.AsSpan(index + 8));
                return (JsonTokenType)(num >> 28);
            }

            internal MetadataDb CopySegment(int startIndex, int endIndex)
            {
                DbRow dbRow = Get(startIndex);
                int num = endIndex - startIndex;
                byte[] array = new byte[num];
                _data.AsSpan(startIndex, num).CopyTo(array);
                Span<int> span = MemoryMarshal.Cast<byte, int>(array);
                int num2 = span[0];
                if (dbRow.TokenType == JsonTokenType.String)
                {
                    num2--;
                }
                for (int num3 = (num - 12) / 4; num3 >= 0; num3 -= 3)
                {
                    span[num3] -= num2;
                }
                return new MetadataDb(array);
            }
        }

        private struct StackRow
        {
            internal const int Size = 8;

            internal int SizeOrLength;

            internal int NumberOfRows;

            internal StackRow(int sizeOrLength = 0, int numberOfRows = -1)
            {
                SizeOrLength = sizeOrLength;
                NumberOfRows = numberOfRows;
            }
        }

        private struct StackRowStack : IDisposable
        {
            private byte[] _rentedBuffer;

            private int _topOfStack;

            public StackRowStack(int initialSize)
            {
                _rentedBuffer = ArrayPool<byte>.Shared.Rent(initialSize);
                _topOfStack = _rentedBuffer.Length;
            }

            public void Dispose()
            {
                byte[] rentedBuffer = _rentedBuffer;
                _rentedBuffer = null;
                _topOfStack = 0;
                if (rentedBuffer != null)
                {
                    ArrayPool<byte>.Shared.Return(rentedBuffer);
                }
            }

            internal void Push(StackRow row)
            {
                if (_topOfStack < 8)
                {
                    Enlarge();
                }
                _topOfStack -= 8;
                MemoryMarshal.Write(_rentedBuffer.AsSpan(_topOfStack), ref row);
            }

            internal StackRow Pop()
            {
                StackRow result = MemoryMarshal.Read<StackRow>(_rentedBuffer.AsSpan(_topOfStack));
                _topOfStack += 8;
                return result;
            }

            private void Enlarge()
            {
                byte[] rentedBuffer = _rentedBuffer;
                _rentedBuffer = ArrayPool<byte>.Shared.Rent(rentedBuffer.Length * 2);
                Buffer.BlockCopy(rentedBuffer, _topOfStack, _rentedBuffer, _rentedBuffer.Length - rentedBuffer.Length + _topOfStack, rentedBuffer.Length - _topOfStack);
                _topOfStack += _rentedBuffer.Length - rentedBuffer.Length;
                ArrayPool<byte>.Shared.Return(rentedBuffer);
            }
        }

        private ReadOnlyMemory<byte> _utf8Json;

        private MetadataDb _parsedData;

        private byte[] _extraRentedArrayPoolBytes;

        private PooledByteBufferWriter _extraPooledByteBufferWriter;

        private (int, string) _lastIndexAndString = (-1, null);

        private static JsonDocument s_nullLiteral;

        private static JsonDocument s_trueLiteral;

        private static JsonDocument s_falseLiteral;

        private const int UnseekableStreamInitialRentSize = 4096;

        internal bool IsDisposable { get; }

        /// <summary>
        ///   The <see cref="T:System.Text.Json.JsonElement" /> representing the value of the document.
        /// </summary>
        public JsonElement RootElement => new JsonElement(this, 0);

        private JsonDocument(ReadOnlyMemory<byte> utf8Json, MetadataDb parsedData, byte[] extraRentedArrayPoolBytes = null, PooledByteBufferWriter extraPooledByteBufferWriter = null, bool isDisposable = true)
        {
            _utf8Json = utf8Json;
            _parsedData = parsedData;
            _extraRentedArrayPoolBytes = extraRentedArrayPoolBytes;
            _extraPooledByteBufferWriter = extraPooledByteBufferWriter;
            IsDisposable = isDisposable;
        }

        /// <inheritdoc />
        public void Dispose()
        {
            int length = _utf8Json.Length;
            if (length == 0 || !IsDisposable)
            {
                return;
            }
            _parsedData.Dispose();
            _utf8Json = ReadOnlyMemory<byte>.Empty;
            if (_extraRentedArrayPoolBytes != null)
            {
                byte[] array = Interlocked.Exchange(ref _extraRentedArrayPoolBytes, null);
                if (array != null)
                {
                    array.AsSpan(0, length).Clear();
                    ArrayPool<byte>.Shared.Return(array);
                }
            }
            else if (_extraPooledByteBufferWriter != null)
            {
                Interlocked.Exchange(ref _extraPooledByteBufferWriter, null)?.Dispose();
            }
        }

        /// <summary>
        ///  Write the document into the provided writer as a JSON value.
        /// </summary>
        /// <param name="writer"></param>
        /// <exception cref="T:System.ArgumentNullException">
        ///   The <paramref name="writer" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This <see cref="P:System.Text.Json.JsonDocument.RootElement" />'s <see cref="P:System.Text.Json.JsonElement.ValueKind" /> would result in an invalid JSON.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public void WriteTo(Utf8JsonWriter writer)
        {
            if (writer == null)
            {
                ThrowHelper.ThrowArgumentNullException("writer");
            }
            RootElement.WriteTo(writer);
        }

        internal JsonTokenType GetJsonTokenType(int index)
        {
            CheckNotDisposed();
            return _parsedData.GetJsonTokenType(index);
        }

        internal int GetArrayLength(int index)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            CheckExpectedType(JsonTokenType.StartArray, dbRow.TokenType);
            return dbRow.SizeOrLength;
        }

        internal JsonElement GetArrayIndexElement(int currentIndex, int arrayIndex)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(currentIndex);
            CheckExpectedType(JsonTokenType.StartArray, dbRow.TokenType);
            int sizeOrLength = dbRow.SizeOrLength;
            if ((uint)arrayIndex >= (uint)sizeOrLength)
            {
                throw new IndexOutOfRangeException();
            }
            if (!dbRow.HasComplexChildren)
            {
                return new JsonElement(this, currentIndex + (arrayIndex + 1) * 12);
            }
            int num = 0;
            for (int i = currentIndex + 12; i < _parsedData.Length; i += 12)
            {
                if (arrayIndex == num)
                {
                    return new JsonElement(this, i);
                }
                dbRow = _parsedData.Get(i);
                if (!dbRow.IsSimpleValue)
                {
                    i += 12 * dbRow.NumberOfRows;
                }
                num++;
            }
            throw new IndexOutOfRangeException();
        }

        internal int GetEndIndex(int index, bool includeEndElement)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            if (dbRow.IsSimpleValue)
            {
                return index + 12;
            }
            int num = index + 12 * dbRow.NumberOfRows;
            if (includeEndElement)
            {
                num += 12;
            }
            return num;
        }

        internal ReadOnlyMemory<byte> GetRootRawValue()
        {
            return GetRawValue(0, includeQuotes: true);
        }

        internal ReadOnlyMemory<byte> GetRawValue(int index, bool includeQuotes)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            if (dbRow.IsSimpleValue)
            {
                if (includeQuotes && dbRow.TokenType == JsonTokenType.String)
                {
                    return _utf8Json.Slice(dbRow.Location - 1, dbRow.SizeOrLength + 2);
                }
                return _utf8Json.Slice(dbRow.Location, dbRow.SizeOrLength);
            }
            int endIndex = GetEndIndex(index, includeEndElement: false);
            int location = dbRow.Location;
            dbRow = _parsedData.Get(endIndex);
            return _utf8Json.Slice(location, dbRow.Location - location + dbRow.SizeOrLength);
        }

        private ReadOnlyMemory<byte> GetPropertyRawValue(int valueIndex)
        {
            CheckNotDisposed();
            int num = _parsedData.Get(valueIndex - 12).Location - 1;
            DbRow dbRow = _parsedData.Get(valueIndex);
            int num2;
            if (dbRow.IsSimpleValue)
            {
                num2 = dbRow.Location + dbRow.SizeOrLength;
                if (dbRow.TokenType == JsonTokenType.String)
                {
                    num2++;
                }
                return _utf8Json.Slice(num, num2 - num);
            }
            int endIndex = GetEndIndex(valueIndex, includeEndElement: false);
            dbRow = _parsedData.Get(endIndex);
            num2 = dbRow.Location + dbRow.SizeOrLength;
            return _utf8Json.Slice(num, num2 - num);
        }

        internal string GetString(int index, JsonTokenType expectedType)
        {
            CheckNotDisposed();
            int num;
            string result;
            (num, result) = _lastIndexAndString;
            if (num == index)
            {
                return result;
            }
            DbRow dbRow = _parsedData.Get(index);
            JsonTokenType tokenType = dbRow.TokenType;
            if (tokenType == JsonTokenType.Null)
            {
                return null;
            }
            CheckExpectedType(expectedType, tokenType);
            ReadOnlySpan<byte> readOnlySpan = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
            result = ((!dbRow.HasComplexChildren) ? JsonReaderHelper.TranscodeHelper(readOnlySpan) : JsonReaderHelper.GetUnescapedString(readOnlySpan));
            _lastIndexAndString = (index, result);
            return result;
        }

        internal bool TextEquals(int index, ReadOnlySpan<char> otherText, bool isPropertyName)
        {
            CheckNotDisposed();
            int num = (isPropertyName ? (index - 12) : index);
            var (num2, text) = _lastIndexAndString;
            if (num2 == num)
            {
                return otherText.SequenceEqual(text.AsSpan());
            }
            byte[] array = null;
            int num3 = checked(otherText.Length * 3);
            Span<byte> span = ((num3 > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(num3))) : stackalloc byte[256]);
            Span<byte> utf8Destination = span;
            ReadOnlySpan<byte> utf16Source = MemoryMarshal.AsBytes(otherText);
            int bytesConsumed;
            int bytesWritten;
            OperationStatus operationStatus = JsonWriterHelper.ToUtf8(utf16Source, utf8Destination, out bytesConsumed, out bytesWritten);
            bool result = operationStatus <= OperationStatus.DestinationTooSmall && TextEquals(index, utf8Destination.Slice(0, bytesWritten), isPropertyName, shouldUnescape: true);
            if (array != null)
            {
                utf8Destination.Slice(0, bytesWritten).Clear();
                ArrayPool<byte>.Shared.Return(array);
            }
            return result;
        }

        internal bool TextEquals(int index, ReadOnlySpan<byte> otherUtf8Text, bool isPropertyName, bool shouldUnescape)
        {
            CheckNotDisposed();
            int index2 = (isPropertyName ? (index - 12) : index);
            DbRow dbRow = _parsedData.Get(index2);
            CheckExpectedType(isPropertyName ? JsonTokenType.PropertyName : JsonTokenType.String, dbRow.TokenType);
            ReadOnlySpan<byte> span = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
            if (otherUtf8Text.Length > span.Length || (!shouldUnescape && otherUtf8Text.Length != span.Length))
            {
                return false;
            }
            if (dbRow.HasComplexChildren && shouldUnescape)
            {
                if (otherUtf8Text.Length < span.Length / 6)
                {
                    return false;
                }
                int num = span.IndexOf<byte>(92);
                if (!otherUtf8Text.StartsWith(span.Slice(0, num)))
                {
                    return false;
                }
                return JsonReaderHelper.UnescapeAndCompare(span.Slice(num), otherUtf8Text.Slice(num));
            }
            return span.SequenceEqual(otherUtf8Text);
        }

        internal string GetNameOfPropertyValue(int index)
        {
            return GetString(index - 12, JsonTokenType.PropertyName);
        }

        internal bool TryGetValue(int index, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out byte[] value)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            CheckExpectedType(JsonTokenType.String, dbRow.TokenType);
            ReadOnlySpan<byte> readOnlySpan = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
            if (dbRow.HasComplexChildren)
            {
                return JsonReaderHelper.TryGetUnescapedBase64Bytes(readOnlySpan, out value);
            }
            return JsonReaderHelper.TryDecodeBase64(readOnlySpan, out value);
        }

        internal bool TryGetValue(int index, out sbyte value)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
            ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
            if (Utf8Parser.TryParse(source, out sbyte value2, out int bytesConsumed, '\0') && bytesConsumed == source.Length)
            {
                value = value2;
                return true;
            }
            value = 0;
            return false;
        }

        internal bool TryGetValue(int index, out byte value)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
            ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
            if (Utf8Parser.TryParse(source, out byte value2, out int bytesConsumed, '\0') && bytesConsumed == source.Length)
            {
                value = value2;
                return true;
            }
            value = 0;
            return false;
        }

        internal bool TryGetValue(int index, out short value)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
            ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
            if (Utf8Parser.TryParse(source, out short value2, out int bytesConsumed, '\0') && bytesConsumed == source.Length)
            {
                value = value2;
                return true;
            }
            value = 0;
            return false;
        }

        internal bool TryGetValue(int index, out ushort value)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
            ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
            if (Utf8Parser.TryParse(source, out ushort value2, out int bytesConsumed, '\0') && bytesConsumed == source.Length)
            {
                value = value2;
                return true;
            }
            value = 0;
            return false;
        }

        internal bool TryGetValue(int index, out int value)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
            ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
            if (Utf8Parser.TryParse(source, out int value2, out int bytesConsumed, '\0') && bytesConsumed == source.Length)
            {
                value = value2;
                return true;
            }
            value = 0;
            return false;
        }

        internal bool TryGetValue(int index, out uint value)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
            ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
            if (Utf8Parser.TryParse(source, out uint value2, out int bytesConsumed, '\0') && bytesConsumed == source.Length)
            {
                value = value2;
                return true;
            }
            value = 0u;
            return false;
        }

        internal bool TryGetValue(int index, out long value)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
            ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
            if (Utf8Parser.TryParse(source, out long value2, out int bytesConsumed, '\0') && bytesConsumed == source.Length)
            {
                value = value2;
                return true;
            }
            value = 0L;
            return false;
        }

        internal bool TryGetValue(int index, out ulong value)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
            ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
            if (Utf8Parser.TryParse(source, out ulong value2, out int bytesConsumed, '\0') && bytesConsumed == source.Length)
            {
                value = value2;
                return true;
            }
            value = 0uL;
            return false;
        }

        internal bool TryGetValue(int index, out double value)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
            ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
            if (Utf8Parser.TryParse(source, out double value2, out int bytesConsumed, '\0') && source.Length == bytesConsumed)
            {
                value = value2;
                return true;
            }
            value = 0.0;
            return false;
        }

        internal bool TryGetValue(int index, out float value)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
            ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
            if (Utf8Parser.TryParse(source, out float value2, out int bytesConsumed, '\0') && source.Length == bytesConsumed)
            {
                value = value2;
                return true;
            }
            value = 0f;
            return false;
        }

        internal bool TryGetValue(int index, out decimal value)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            CheckExpectedType(JsonTokenType.Number, dbRow.TokenType);
            ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
            if (Utf8Parser.TryParse(source, out decimal value2, out int bytesConsumed, '\0') && source.Length == bytesConsumed)
            {
                value = value2;
                return true;
            }
            value = default(decimal);
            return false;
        }

        internal bool TryGetValue(int index, out DateTime value)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            CheckExpectedType(JsonTokenType.String, dbRow.TokenType);
            ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
            if (!JsonHelpers.IsValidDateTimeOffsetParseLength(source.Length))
            {
                value = default(DateTime);
                return false;
            }
            if (dbRow.HasComplexChildren)
            {
                return JsonReaderHelper.TryGetEscapedDateTime(source, out value);
            }
            if (JsonHelpers.TryParseAsISO(source, out DateTime value2))
            {
                value = value2;
                return true;
            }
            value = default(DateTime);
            return false;
        }

        internal bool TryGetValue(int index, out DateTimeOffset value)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            CheckExpectedType(JsonTokenType.String, dbRow.TokenType);
            ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
            if (!JsonHelpers.IsValidDateTimeOffsetParseLength(source.Length))
            {
                value = default(DateTimeOffset);
                return false;
            }
            if (dbRow.HasComplexChildren)
            {
                return JsonReaderHelper.TryGetEscapedDateTimeOffset(source, out value);
            }
            if (JsonHelpers.TryParseAsISO(source, out DateTimeOffset value2))
            {
                value = value2;
                return true;
            }
            value = default(DateTimeOffset);
            return false;
        }

        internal bool TryGetValue(int index, out Guid value)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            CheckExpectedType(JsonTokenType.String, dbRow.TokenType);
            ReadOnlySpan<byte> source = _utf8Json.Span.Slice(dbRow.Location, dbRow.SizeOrLength);
            if (source.Length > 216)
            {
                value = default(Guid);
                return false;
            }
            if (dbRow.HasComplexChildren)
            {
                return JsonReaderHelper.TryGetEscapedGuid(source, out value);
            }
            if (source.Length == 36 && Utf8Parser.TryParse(source, out Guid value2, out int _, 'D'))
            {
                value = value2;
                return true;
            }
            value = default(Guid);
            return false;
        }

        internal string GetRawValueAsString(int index)
        {
            return JsonReaderHelper.TranscodeHelper(GetRawValue(index, includeQuotes: true).Span);
        }

        internal string GetPropertyRawValueAsString(int valueIndex)
        {
            return JsonReaderHelper.TranscodeHelper(GetPropertyRawValue(valueIndex).Span);
        }

        internal JsonElement CloneElement(int index)
        {
            int endIndex = GetEndIndex(index, includeEndElement: true);
            MetadataDb parsedData = _parsedData.CopySegment(index, endIndex);
            ReadOnlyMemory<byte> utf8Json = GetRawValue(index, includeQuotes: true).ToArray();
            JsonDocument jsonDocument = new JsonDocument(utf8Json, parsedData, null, null, isDisposable: false);
            return jsonDocument.RootElement;
        }

        internal void WriteElementTo(int index, Utf8JsonWriter writer)
        {
            CheckNotDisposed();
            DbRow row = _parsedData.Get(index);
            switch (row.TokenType)
            {
                case JsonTokenType.StartObject:
                    writer.WriteStartObject();
                    WriteComplexElement(index, writer);
                    break;
                case JsonTokenType.StartArray:
                    writer.WriteStartArray();
                    WriteComplexElement(index, writer);
                    break;
                case JsonTokenType.String:
                    WriteString(in row, writer);
                    break;
                case JsonTokenType.Number:
                    writer.WriteNumberValue(_utf8Json.Slice(row.Location, row.SizeOrLength).Span);
                    break;
                case JsonTokenType.True:
                    writer.WriteBooleanValue(value: true);
                    break;
                case JsonTokenType.False:
                    writer.WriteBooleanValue(value: false);
                    break;
                case JsonTokenType.Null:
                    writer.WriteNullValue();
                    break;
                case JsonTokenType.EndObject:
                case JsonTokenType.EndArray:
                case JsonTokenType.PropertyName:
                case JsonTokenType.Comment:
                    break;
            }
        }

        private void WriteComplexElement(int index, Utf8JsonWriter writer)
        {
            int endIndex = GetEndIndex(index, includeEndElement: true);
            for (int i = index + 12; i < endIndex; i += 12)
            {
                DbRow row = _parsedData.Get(i);
                switch (row.TokenType)
                {
                    case JsonTokenType.String:
                        WriteString(in row, writer);
                        break;
                    case JsonTokenType.Number:
                        writer.WriteNumberValue(_utf8Json.Slice(row.Location, row.SizeOrLength).Span);
                        break;
                    case JsonTokenType.True:
                        writer.WriteBooleanValue(value: true);
                        break;
                    case JsonTokenType.False:
                        writer.WriteBooleanValue(value: false);
                        break;
                    case JsonTokenType.Null:
                        writer.WriteNullValue();
                        break;
                    case JsonTokenType.StartObject:
                        writer.WriteStartObject();
                        break;
                    case JsonTokenType.EndObject:
                        writer.WriteEndObject();
                        break;
                    case JsonTokenType.StartArray:
                        writer.WriteStartArray();
                        break;
                    case JsonTokenType.EndArray:
                        writer.WriteEndArray();
                        break;
                    case JsonTokenType.PropertyName:
                        WritePropertyName(in row, writer);
                        break;
                }
            }
        }

        private ReadOnlySpan<byte> UnescapeString(in DbRow row, out ArraySegment<byte> rented)
        {
            int location = row.Location;
            int sizeOrLength = row.SizeOrLength;
            ReadOnlySpan<byte> span = _utf8Json.Slice(location, sizeOrLength).Span;
            if (!row.HasComplexChildren)
            {
                rented = default(ArraySegment<byte>);
                return span;
            }
            byte[] array = ArrayPool<byte>.Shared.Rent(sizeOrLength);
            JsonReaderHelper.Unescape(span, array, out var written);
            rented = new ArraySegment<byte>(array, 0, written);
            return rented.AsSpan();
        }

        private static void ClearAndReturn(ArraySegment<byte> rented)
        {
            if (rented.Array != null)
            {
                rented.AsSpan().Clear();
                ArrayPool<byte>.Shared.Return(rented.Array);
            }
        }

        private void WritePropertyName(in DbRow row, Utf8JsonWriter writer)
        {
            ArraySegment<byte> rented = default(ArraySegment<byte>);
            try
            {
                writer.WritePropertyName(UnescapeString(in row, out rented));
            }
            finally
            {
                ClearAndReturn(rented);
            }
        }

        private void WriteString(in DbRow row, Utf8JsonWriter writer)
        {
            ArraySegment<byte> rented = default(ArraySegment<byte>);
            try
            {
                writer.WriteStringValue(UnescapeString(in row, out rented));
            }
            finally
            {
                ClearAndReturn(rented);
            }
        }

        private static void Parse(ReadOnlySpan<byte> utf8JsonSpan, JsonReaderOptions readerOptions, ref MetadataDb database, ref StackRowStack stack)
        {
            bool flag = false;
            int num = 0;
            int num2 = 0;
            int num3 = 0;
            Utf8JsonReader utf8JsonReader = new Utf8JsonReader(utf8JsonSpan, isFinalBlock: true, new JsonReaderState(readerOptions));
            while (utf8JsonReader.Read())
            {
                JsonTokenType tokenType = utf8JsonReader.TokenType;
                int num4 = (int)utf8JsonReader.TokenStartIndex;
                switch (tokenType)
                {
                    case JsonTokenType.StartObject:
                        {
                            if (flag)
                            {
                                num++;
                            }
                            num3++;
                            database.Append(tokenType, num4, -1);
                            StackRow row2 = new StackRow(num2 + 1);
                            stack.Push(row2);
                            num2 = 0;
                            break;
                        }
                    case JsonTokenType.EndObject:
                        {
                            int index = database.FindIndexOfFirstUnsetSizeOrLength(JsonTokenType.StartObject);
                            num3++;
                            num2++;
                            database.SetLength(index, num2);
                            int length2 = database.Length;
                            database.Append(tokenType, num4, utf8JsonReader.ValueSpan.Length);
                            database.SetNumberOfRows(index, num2);
                            database.SetNumberOfRows(length2, num2);
                            num2 += stack.Pop().SizeOrLength;
                            break;
                        }
                    case JsonTokenType.StartArray:
                        {
                            if (flag)
                            {
                                num++;
                            }
                            num2++;
                            database.Append(tokenType, num4, -1);
                            StackRow row = new StackRow(num, num3 + 1);
                            stack.Push(row);
                            num = 0;
                            num3 = 0;
                            break;
                        }
                    case JsonTokenType.EndArray:
                        {
                            int num5 = database.FindIndexOfFirstUnsetSizeOrLength(JsonTokenType.StartArray);
                            num3++;
                            num2++;
                            database.SetLength(num5, num);
                            database.SetNumberOfRows(num5, num3);
                            if (num + 1 != num3)
                            {
                                database.SetHasComplexChildren(num5);
                            }
                            int length = database.Length;
                            database.Append(tokenType, num4, utf8JsonReader.ValueSpan.Length);
                            database.SetNumberOfRows(length, num3);
                            StackRow stackRow = stack.Pop();
                            num = stackRow.SizeOrLength;
                            num3 += stackRow.NumberOfRows;
                            break;
                        }
                    case JsonTokenType.PropertyName:
                        num3++;
                        num2++;
                        database.Append(tokenType, num4 + 1, utf8JsonReader.ValueSpan.Length);
                        if (utf8JsonReader.ValueIsEscaped)
                        {
                            database.SetHasComplexChildren(database.Length - 12);
                        }
                        break;
                    default:
                        num3++;
                        num2++;
                        if (flag)
                        {
                            num++;
                        }
                        if (tokenType == JsonTokenType.String)
                        {
                            database.Append(tokenType, num4 + 1, utf8JsonReader.ValueSpan.Length);
                            if (utf8JsonReader.ValueIsEscaped)
                            {
                                database.SetHasComplexChildren(database.Length - 12);
                            }
                        }
                        else
                        {
                            database.Append(tokenType, num4, utf8JsonReader.ValueSpan.Length);
                        }
                        break;
                }
                flag = utf8JsonReader.IsInArray;
            }
            database.CompleteAllocations();
        }

        private void CheckNotDisposed()
        {
            if (_utf8Json.IsEmpty)
            {
                ThrowHelper.ThrowObjectDisposedException_JsonDocument();
            }
        }

        private static void CheckExpectedType(JsonTokenType expected, JsonTokenType actual)
        {
            if (expected != actual)
            {
                ThrowHelper.ThrowJsonElementWrongTypeException(expected, actual);
            }
        }

        private static void CheckSupportedOptions(JsonReaderOptions readerOptions, string paramName)
        {
            if (readerOptions.CommentHandling == JsonCommentHandling.Allow)
            {
                throw new ArgumentException(MDCFR.Properties.Resources.JsonDocumentDoesNotSupportComments, paramName);
            }
        }

        /// <summary>
        ///   Parse memory as UTF-8-encoded text representing a single JSON value into a JsonDocument.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     The <see cref="T:System.ReadOnlyMemory`1" /> value will be used for the entire lifetime of the
        ///     JsonDocument object, and the caller must ensure that the data therein does not change during
        ///     the object lifetime.
        ///   </para>
        ///
        ///   <para>
        ///     Because the input is considered to be text, a UTF-8 Byte-Order-Mark (BOM) must not be present.
        ///   </para>
        /// </remarks>
        /// <param name="utf8Json">JSON text to parse.</param>
        /// <param name="options">Options to control the reader behavior during parsing.</param>
        /// <returns>
        ///   A JsonDocument representation of the JSON value.
        /// </returns>
        /// <exception cref="T:System.Text.Json.JsonException">
        ///   <paramref name="utf8Json" /> does not represent a valid single JSON value.
        /// </exception>
        /// <exception cref="T:System.ArgumentException">
        ///   <paramref name="options" /> contains unsupported options.
        /// </exception>
        public static JsonDocument Parse(ReadOnlyMemory<byte> utf8Json, JsonDocumentOptions options = default(JsonDocumentOptions))
        {
            return Parse(utf8Json, options.GetReaderOptions());
        }

        /// <summary>
        ///   Parse a sequence as UTF-8-encoded text representing a single JSON value into a JsonDocument.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     The <see cref="T:System.Buffers.ReadOnlySequence`1" /> may be used for the entire lifetime of the
        ///     JsonDocument object, and the caller must ensure that the data therein does not change during
        ///     the object lifetime.
        ///   </para>
        ///
        ///   <para>
        ///     Because the input is considered to be text, a UTF-8 Byte-Order-Mark (BOM) must not be present.
        ///   </para>
        /// </remarks>
        /// <param name="utf8Json">JSON text to parse.</param>
        /// <param name="options">Options to control the reader behavior during parsing.</param>
        /// <returns>
        ///   A JsonDocument representation of the JSON value.
        /// </returns>
        /// <exception cref="T:System.Text.Json.JsonException">
        ///   <paramref name="utf8Json" /> does not represent a valid single JSON value.
        /// </exception>
        /// <exception cref="T:System.ArgumentException">
        ///   <paramref name="options" /> contains unsupported options.
        /// </exception>
        public static JsonDocument Parse(ReadOnlySequence<byte> utf8Json, JsonDocumentOptions options = default(JsonDocumentOptions))
        {
            JsonReaderOptions readerOptions = options.GetReaderOptions();
            if (utf8Json.IsSingleSegment)
            {
                return Parse(utf8Json.First, readerOptions);
            }
            int num = checked((int)utf8Json.Length);
            byte[] array = ArrayPool<byte>.Shared.Rent(num);
            try
            {
                utf8Json.CopyTo(array.AsSpan());
                return Parse(array.AsMemory(0, num), readerOptions, array);
            }
            catch
            {
                array.AsSpan(0, num).Clear();
                ArrayPool<byte>.Shared.Return(array);
                throw;
            }
        }

        /// <summary>
        ///   Parse a <see cref="T:System.IO.Stream" /> as UTF-8-encoded data representing a single JSON value into a
        ///   JsonDocument.  The Stream will be read to completion.
        /// </summary>
        /// <param name="utf8Json">JSON data to parse.</param>
        /// <param name="options">Options to control the reader behavior during parsing.</param>
        /// <returns>
        ///   A JsonDocument representation of the JSON value.
        /// </returns>
        /// <exception cref="T:System.Text.Json.JsonException">
        ///   <paramref name="utf8Json" /> does not represent a valid single JSON value.
        /// </exception>
        /// <exception cref="T:System.ArgumentException">
        ///   <paramref name="options" /> contains unsupported options.
        /// </exception>
        public static JsonDocument Parse(Stream utf8Json, JsonDocumentOptions options = default(JsonDocumentOptions))
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            ArraySegment<byte> segment = ReadToEnd(utf8Json);
            try
            {
                return Parse(segment.AsMemory(), options.GetReaderOptions(), segment.Array);
            }
            catch
            {
                segment.AsSpan().Clear();
                ArrayPool<byte>.Shared.Return(segment.Array);
                throw;
            }
        }

        internal static JsonDocument ParseRented(PooledByteBufferWriter utf8Json, JsonDocumentOptions options = default(JsonDocumentOptions))
        {
            return Parse(utf8Json.WrittenMemory, options.GetReaderOptions(), null, utf8Json);
        }

        internal static JsonDocument ParseValue(Stream utf8Json, JsonDocumentOptions options)
        {
            ArraySegment<byte> segment = ReadToEnd(utf8Json);
            byte[] array = new byte[segment.Count];
            Buffer.BlockCopy(segment.Array, 0, array, 0, segment.Count);
            segment.AsSpan().Clear();
            ArrayPool<byte>.Shared.Return(segment.Array);
            return ParseUnrented(array.AsMemory(), options.GetReaderOptions());
        }

        internal static JsonDocument ParseValue(ReadOnlySpan<byte> utf8Json, JsonDocumentOptions options)
        {
            byte[] array = new byte[utf8Json.Length];
            utf8Json.CopyTo(array);
            return ParseUnrented(array.AsMemory(), options.GetReaderOptions());
        }

        internal static JsonDocument ParseValue(string json, JsonDocumentOptions options)
        {
            return ParseValue(json.AsMemory(), options);
        }

        /// <summary>
        ///   Parse a <see cref="T:System.IO.Stream" /> as UTF-8-encoded data representing a single JSON value into a
        ///   JsonDocument.  The Stream will be read to completion.
        /// </summary>
        /// <param name="utf8Json">JSON data to parse.</param>
        /// <param name="options">Options to control the reader behavior during parsing.</param>
        /// <param name="cancellationToken">The token to monitor for cancellation requests.</param>
        /// <returns>
        ///   A Task to produce a JsonDocument representation of the JSON value.
        /// </returns>
        /// <exception cref="T:System.Text.Json.JsonException">
        ///   <paramref name="utf8Json" /> does not represent a valid single JSON value.
        /// </exception>
        /// <exception cref="T:System.ArgumentException">
        ///   <paramref name="options" /> contains unsupported options.
        /// </exception>
        public static Task<JsonDocument> ParseAsync(Stream utf8Json, JsonDocumentOptions options = default(JsonDocumentOptions), CancellationToken cancellationToken = default(CancellationToken))
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            return ParseAsyncCore(utf8Json, options, cancellationToken);
        }

        private static async Task<JsonDocument> ParseAsyncCore(Stream utf8Json, JsonDocumentOptions options = default(JsonDocumentOptions), CancellationToken cancellationToken = default(CancellationToken))
        {
            ArraySegment<byte> segment = await ReadToEndAsync(utf8Json, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
            try
            {
                return Parse(segment.AsMemory(), options.GetReaderOptions(), segment.Array);
            }
            catch
            {
                segment.AsSpan().Clear();
                ArrayPool<byte>.Shared.Return(segment.Array);
                throw;
            }
        }

        /// <summary>
        ///   Parses text representing a single JSON value into a JsonDocument.
        /// </summary>
        /// <remarks>
        ///   The <see cref="T:System.ReadOnlyMemory`1" /> value may be used for the entire lifetime of the
        ///   JsonDocument object, and the caller must ensure that the data therein does not change during
        ///   the object lifetime.
        /// </remarks>
        /// <param name="json">JSON text to parse.</param>
        /// <param name="options">Options to control the reader behavior during parsing.</param>
        /// <returns>
        ///   A JsonDocument representation of the JSON value.
        /// </returns>
        /// <exception cref="T:System.Text.Json.JsonException">
        ///   <paramref name="json" /> does not represent a valid single JSON value.
        /// </exception>
        /// <exception cref="T:System.ArgumentException">
        ///   <paramref name="options" /> contains unsupported options.
        /// </exception>
        public static JsonDocument Parse([StringSyntax("Json")] ReadOnlyMemory<char> json, JsonDocumentOptions options = default(JsonDocumentOptions))
        {
            ReadOnlySpan<char> span = json.Span;
            int utf8ByteCount = JsonReaderHelper.GetUtf8ByteCount(span);
            byte[] array = ArrayPool<byte>.Shared.Rent(utf8ByteCount);
            try
            {
                int utf8FromText = JsonReaderHelper.GetUtf8FromText(span, array);
                return Parse(array.AsMemory(0, utf8FromText), options.GetReaderOptions(), array);
            }
            catch
            {
                array.AsSpan(0, utf8ByteCount).Clear();
                ArrayPool<byte>.Shared.Return(array);
                throw;
            }
        }

        internal static JsonDocument ParseValue(ReadOnlyMemory<char> json, JsonDocumentOptions options)
        {
            ReadOnlySpan<char> span = json.Span;
            int utf8ByteCount = JsonReaderHelper.GetUtf8ByteCount(span);
            byte[] array = ArrayPool<byte>.Shared.Rent(utf8ByteCount);
            byte[] array2;
            try
            {
                int utf8FromText = JsonReaderHelper.GetUtf8FromText(span, array);
                array2 = new byte[utf8FromText];
                Buffer.BlockCopy(array, 0, array2, 0, utf8FromText);
            }
            finally
            {
                array.AsSpan(0, utf8ByteCount).Clear();
                ArrayPool<byte>.Shared.Return(array);
            }
            return ParseUnrented(array2.AsMemory(), options.GetReaderOptions());
        }

        /// <summary>
        ///   Parses text representing a single JSON value into a JsonDocument.
        /// </summary>
        /// <param name="json">JSON text to parse.</param>
        /// <param name="options">Options to control the reader behavior during parsing.</param>
        /// <returns>
        ///   A JsonDocument representation of the JSON value.
        /// </returns>
        /// <exception cref="T:System.Text.Json.JsonException">
        ///   <paramref name="json" /> does not represent a valid single JSON value.
        /// </exception>
        /// <exception cref="T:System.ArgumentException">
        ///   <paramref name="options" /> contains unsupported options.
        /// </exception>
        public static JsonDocument Parse([StringSyntax("Json")] string json, JsonDocumentOptions options = default(JsonDocumentOptions))
        {
            if (json == null)
            {
                ThrowHelper.ThrowArgumentNullException("json");
            }
            return Parse(json.AsMemory(), options);
        }

        /// <summary>
        ///   Attempts to parse one JSON value (including objects or arrays) from the provided reader.
        /// </summary>
        /// <param name="reader">The reader to read.</param>
        /// <param name="document">Receives the parsed document.</param>
        /// <returns>
        ///   <see langword="true" /> if a value was read and parsed into a JsonDocument,
        ///   <see langword="false" /> if the reader ran out of data while parsing.
        ///   All other situations result in an exception being thrown.
        /// </returns>
        /// <remarks>
        ///   <para>
        ///     If the <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> property of <paramref name="reader" />
        ///     is <see cref="F:System.Text.Json.JsonTokenType.PropertyName" /> or <see cref="F:System.Text.Json.JsonTokenType.None" />, the
        ///     reader will be advanced by one call to <see cref="M:System.Text.Json.Utf8JsonReader.Read" /> to determine
        ///     the start of the value.
        ///   </para>
        ///
        ///   <para>
        ///     Upon completion of this method, <paramref name="reader" /> will be positioned at the
        ///     final token in the JSON value.  If an exception is thrown, or <see langword="false" />
        ///     is returned, the reader is reset to the state it was in when the method was called.
        ///   </para>
        ///
        ///   <para>
        ///     This method makes a copy of the data the reader acted on, so there is no caller
        ///     requirement to maintain data integrity beyond the return of this method.
        ///   </para>
        /// </remarks>
        /// <exception cref="T:System.ArgumentException">
        ///   <paramref name="reader" /> is using unsupported options.
        /// </exception>
        /// <exception cref="T:System.ArgumentException">
        ///   The current <paramref name="reader" /> token does not start or represent a value.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        ///   A value could not be read from the reader.
        /// </exception>
        public static bool TryParseValue(ref Utf8JsonReader reader, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out JsonDocument? document)
        {
            return TryParseValue(ref reader, out document, shouldThrow: false, useArrayPools: true);
        }

        /// <summary>
        ///   Parses one JSON value (including objects or arrays) from the provided reader.
        /// </summary>
        /// <param name="reader">The reader to read.</param>
        /// <returns>
        ///   A JsonDocument representing the value (and nested values) read from the reader.
        /// </returns>
        /// <remarks>
        ///   <para>
        ///     If the <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> property of <paramref name="reader" />
        ///     is <see cref="F:System.Text.Json.JsonTokenType.PropertyName" /> or <see cref="F:System.Text.Json.JsonTokenType.None" />, the
        ///     reader will be advanced by one call to <see cref="M:System.Text.Json.Utf8JsonReader.Read" /> to determine
        ///     the start of the value.
        ///   </para>
        ///
        ///   <para>
        ///     Upon completion of this method, <paramref name="reader" /> will be positioned at the
        ///     final token in the JSON value. If an exception is thrown, the reader is reset to
        ///     the state it was in when the method was called.
        ///   </para>
        ///
        ///   <para>
        ///     This method makes a copy of the data the reader acted on, so there is no caller
        ///     requirement to maintain data integrity beyond the return of this method.
        ///   </para>
        /// </remarks>
        /// <exception cref="T:System.ArgumentException">
        ///   <paramref name="reader" /> is using unsupported options.
        /// </exception>
        /// <exception cref="T:System.ArgumentException">
        ///   The current <paramref name="reader" /> token does not start or represent a value.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        ///   A value could not be read from the reader.
        /// </exception>
        public static JsonDocument ParseValue(ref Utf8JsonReader reader)
        {
            JsonDocument document;
            bool flag = TryParseValue(ref reader, out document, shouldThrow: true, useArrayPools: true);
            return document;
        }

        internal static bool TryParseValue(ref Utf8JsonReader reader, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out JsonDocument document, bool shouldThrow, bool useArrayPools)
        {
            JsonReaderState currentState = reader.CurrentState;
            CheckSupportedOptions(currentState.Options, "reader");
            Utf8JsonReader utf8JsonReader = reader;
            ReadOnlySpan<byte> readOnlySpan = default(ReadOnlySpan<byte>);
            ReadOnlySequence<byte> sequence = default(ReadOnlySequence<byte>);
            try
            {
                JsonTokenType tokenType = reader.TokenType;
                ReadOnlySpan<byte> bytes;
                if ((tokenType == JsonTokenType.None || tokenType == JsonTokenType.PropertyName) && !reader.Read())
                {
                    if (shouldThrow)
                    {
                        bytes = default(ReadOnlySpan<byte>);
                        ThrowHelper.ThrowJsonReaderException(ref reader, ExceptionResource.ExpectedJsonTokens, 0, bytes);
                    }
                    reader = utf8JsonReader;
                    document = null;
                    return false;
                }
                switch (reader.TokenType)
                {
                    case JsonTokenType.StartObject:
                    case JsonTokenType.StartArray:
                        {
                            long tokenStartIndex = reader.TokenStartIndex;
                            if (!reader.TrySkip())
                            {
                                if (shouldThrow)
                                {
                                    bytes = default(ReadOnlySpan<byte>);
                                    ThrowHelper.ThrowJsonReaderException(ref reader, ExceptionResource.ExpectedJsonTokens, 0, bytes);
                                }
                                reader = utf8JsonReader;
                                document = null;
                                return false;
                            }
                            long num3 = reader.BytesConsumed - tokenStartIndex;
                            ReadOnlySequence<byte> originalSequence2 = reader.OriginalSequence;
                            if (originalSequence2.IsEmpty)
                            {
                                bytes = reader.OriginalSpan;
                                readOnlySpan = checked(bytes.Slice((int)tokenStartIndex, (int)num3));
                            }
                            else
                            {
                                sequence = originalSequence2.Slice(tokenStartIndex, num3);
                            }
                            break;
                        }
                    case JsonTokenType.True:
                    case JsonTokenType.False:
                    case JsonTokenType.Null:
                        if (useArrayPools)
                        {
                            if (reader.HasValueSequence)
                            {
                                sequence = reader.ValueSequence;
                            }
                            else
                            {
                                readOnlySpan = reader.ValueSpan;
                            }
                            break;
                        }
                        document = CreateForLiteral(reader.TokenType);
                        return true;
                    case JsonTokenType.Number:
                        if (reader.HasValueSequence)
                        {
                            sequence = reader.ValueSequence;
                        }
                        else
                        {
                            readOnlySpan = reader.ValueSpan;
                        }
                        break;
                    case JsonTokenType.String:
                        {
                            ReadOnlySequence<byte> originalSequence = reader.OriginalSequence;
                            if (originalSequence.IsEmpty)
                            {
                                bytes = reader.ValueSpan;
                                int length = bytes.Length + 2;
                                readOnlySpan = reader.OriginalSpan.Slice((int)reader.TokenStartIndex, length);
                                break;
                            }
                            long num = 2L;
                            if (reader.HasValueSequence)
                            {
                                num += reader.ValueSequence.Length;
                            }
                            else
                            {
                                long num2 = num;
                                bytes = reader.ValueSpan;
                                num = num2 + bytes.Length;
                            }
                            sequence = originalSequence.Slice(reader.TokenStartIndex, num);
                            break;
                        }
                    default:
                        if (shouldThrow)
                        {
                            bytes = reader.ValueSpan;
                            byte nextByte = bytes[0];
                            bytes = default(ReadOnlySpan<byte>);
                            ThrowHelper.ThrowJsonReaderException(ref reader, ExceptionResource.ExpectedStartOfValueNotFound, nextByte, bytes);
                        }
                        reader = utf8JsonReader;
                        document = null;
                        return false;
                }
            }
            catch
            {
                reader = utf8JsonReader;
                throw;
            }
            int num4 = (readOnlySpan.IsEmpty ? checked((int)sequence.Length) : readOnlySpan.Length);
            if (useArrayPools)
            {
                byte[] array = ArrayPool<byte>.Shared.Rent(num4);
                Span<byte> destination = array.AsSpan(0, num4);
                try
                {
                    if (readOnlySpan.IsEmpty)
                    {
                        sequence.CopyTo(destination);
                    }
                    else
                    {
                        readOnlySpan.CopyTo(destination);
                    }
                    document = Parse(array.AsMemory(0, num4), currentState.Options, array);
                }
                catch
                {
                    destination.Clear();
                    ArrayPool<byte>.Shared.Return(array);
                    throw;
                }
            }
            else
            {
                byte[] array2 = ((!readOnlySpan.IsEmpty) ? readOnlySpan.ToArray() : BuffersExtensions.ToArray(in sequence));
                document = ParseUnrented(array2, currentState.Options, reader.TokenType);
            }
            return true;
        }

        private static JsonDocument CreateForLiteral(JsonTokenType tokenType)
        {
            switch (tokenType)
            {
                case JsonTokenType.False:
                    if (s_falseLiteral == null)
                    {
                        s_falseLiteral = Create(JsonConstants.FalseValue.ToArray());
                    }
                    return s_falseLiteral;
                case JsonTokenType.True:
                    if (s_trueLiteral == null)
                    {
                        s_trueLiteral = Create(JsonConstants.TrueValue.ToArray());
                    }
                    return s_trueLiteral;
                default:
                    if (s_nullLiteral == null)
                    {
                        s_nullLiteral = Create(JsonConstants.NullValue.ToArray());
                    }
                    return s_nullLiteral;
            }
            JsonDocument Create(byte[] utf8Json)
            {
                MetadataDb parsedData = MetadataDb.CreateLocked(utf8Json.Length);
                parsedData.Append(tokenType, 0, utf8Json.Length);
                return new JsonDocument(utf8Json, parsedData);
            }
        }

        private static JsonDocument Parse(ReadOnlyMemory<byte> utf8Json, JsonReaderOptions readerOptions, byte[] extraRentedArrayPoolBytes = null, PooledByteBufferWriter extraPooledByteBufferWriter = null)
        {
            ReadOnlySpan<byte> span = utf8Json.Span;
            MetadataDb database = MetadataDb.CreateRented(utf8Json.Length, convertToAlloc: false);
            StackRowStack stack = new StackRowStack(512);
            try
            {
                Parse(span, readerOptions, ref database, ref stack);
            }
            catch
            {
                database.Dispose();
                throw;
            }
            finally
            {
                stack.Dispose();
            }
            return new JsonDocument(utf8Json, database, extraRentedArrayPoolBytes, extraPooledByteBufferWriter);
        }

        private static JsonDocument ParseUnrented(ReadOnlyMemory<byte> utf8Json, JsonReaderOptions readerOptions, JsonTokenType tokenType = JsonTokenType.None)
        {
            ReadOnlySpan<byte> span = utf8Json.Span;
            MetadataDb database;
            if (tokenType == JsonTokenType.String || tokenType == JsonTokenType.Number)
            {
                database = MetadataDb.CreateLocked(utf8Json.Length);
                StackRowStack stack = default(StackRowStack);
                Parse(span, readerOptions, ref database, ref stack);
            }
            else
            {
                database = MetadataDb.CreateRented(utf8Json.Length, convertToAlloc: true);
                StackRowStack stack2 = new StackRowStack(512);
                try
                {
                    Parse(span, readerOptions, ref database, ref stack2);
                }
                finally
                {
                    stack2.Dispose();
                }
            }
            return new JsonDocument(utf8Json, database);
        }

        private static ArraySegment<byte> ReadToEnd(Stream stream)
        {
            int num = 0;
            byte[] array = null;
            ReadOnlySpan<byte> utf8Bom = JsonConstants.Utf8Bom;
            try
            {
                if (stream.CanSeek)
                {
                    long num2 = Math.Max(utf8Bom.Length, stream.Length - stream.Position) + 1;
                    array = ArrayPool<byte>.Shared.Rent(checked((int)num2));
                }
                else
                {
                    array = ArrayPool<byte>.Shared.Rent(4096);
                }
                int num3;
                do
                {
                    num3 = stream.Read(array, num, utf8Bom.Length - num);
                    num += num3;
                }
                while (num3 > 0 && num < utf8Bom.Length);
                if (num == utf8Bom.Length && utf8Bom.SequenceEqual(array.AsSpan(0, utf8Bom.Length)))
                {
                    num = 0;
                }
                do
                {
                    if (array.Length == num)
                    {
                        byte[] array2 = array;
                        array = ArrayPool<byte>.Shared.Rent(checked(array2.Length * 2));
                        Buffer.BlockCopy(array2, 0, array, 0, array2.Length);
                        ArrayPool<byte>.Shared.Return(array2, clearArray: true);
                    }
                    num3 = stream.Read(array, num, array.Length - num);
                    num += num3;
                }
                while (num3 > 0);
                return new ArraySegment<byte>(array, 0, num);
            }
            catch
            {
                if (array != null)
                {
                    array.AsSpan(0, num).Clear();
                    ArrayPool<byte>.Shared.Return(array);
                }
                throw;
            }
        }

        private static async Task<ArraySegment<byte>> ReadToEndAsync(Stream stream, CancellationToken cancellationToken)
        {
            int written = 0;
            byte[] rented = null;
            try
            {
                int utf8BomLength = JsonConstants.Utf8Bom.Length;
                if (stream.CanSeek)
                {
                    long num = Math.Max(utf8BomLength, stream.Length - stream.Position) + 1;
                    rented = ArrayPool<byte>.Shared.Rent(checked((int)num));
                }
                else
                {
                    rented = ArrayPool<byte>.Shared.Rent(4096);
                }
                int num2;
                do
                {
                    num2 = await stream.ReadAsync(rented, written, utf8BomLength - written, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
                    written += num2;
                }
                while (num2 > 0 && written < utf8BomLength);
                if (written == utf8BomLength && JsonConstants.Utf8Bom.SequenceEqual(rented.AsSpan(0, utf8BomLength)))
                {
                    written = 0;
                }
                do
                {
                    if (rented.Length == written)
                    {
                        byte[] array = rented;
                        rented = ArrayPool<byte>.Shared.Rent(array.Length * 2);
                        Buffer.BlockCopy(array, 0, rented, 0, array.Length);
                        ArrayPool<byte>.Shared.Return(array, clearArray: true);
                    }
                    num2 = await stream.ReadAsync(rented, written, rented.Length - written, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
                    written += num2;
                }
                while (num2 > 0);
                return new ArraySegment<byte>(rented, 0, written);
            }
            catch
            {
                if (rented != null)
                {
                    rented.AsSpan(0, written).Clear();
                    ArrayPool<byte>.Shared.Return(rented);
                }
                throw;
            }
        }

        internal bool TryGetNamedPropertyValue(int index, ReadOnlySpan<char> propertyName, out JsonElement value)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            CheckExpectedType(JsonTokenType.StartObject, dbRow.TokenType);
            if (dbRow.NumberOfRows == 1)
            {
                value = default(JsonElement);
                return false;
            }
            int maxByteCount = JsonReaderHelper.s_utf8Encoding.GetMaxByteCount(propertyName.Length);
            int startIndex = index + 12;
            int num = checked(dbRow.NumberOfRows * 12 + index);
            if (maxByteCount < 256)
            {
                Span<byte> span = stackalloc byte[256];
                int utf8FromText = JsonReaderHelper.GetUtf8FromText(propertyName, span);
                span = span.Slice(0, utf8FromText);
                return TryGetNamedPropertyValue(startIndex, num, span, out value);
            }
            int length = propertyName.Length;
            int num2;
            for (num2 = num - 12; num2 > index; num2 -= 12)
            {
                int num3 = num2;
                dbRow = _parsedData.Get(num2);
                num2 = ((!dbRow.IsSimpleValue) ? (num2 - 12 * (dbRow.NumberOfRows + 1)) : (num2 - 12));
                if (_parsedData.Get(num2).SizeOrLength >= length)
                {
                    byte[] array = ArrayPool<byte>.Shared.Rent(maxByteCount);
                    Span<byte> span2 = default(Span<byte>);
                    try
                    {
                        int utf8FromText2 = JsonReaderHelper.GetUtf8FromText(propertyName, array);
                        span2 = array.AsSpan(0, utf8FromText2);
                        return TryGetNamedPropertyValue(startIndex, num3 + 12, span2, out value);
                    }
                    finally
                    {
                        span2.Clear();
                        ArrayPool<byte>.Shared.Return(array);
                    }
                }
            }
            value = default(JsonElement);
            return false;
        }

        internal bool TryGetNamedPropertyValue(int index, ReadOnlySpan<byte> propertyName, out JsonElement value)
        {
            CheckNotDisposed();
            DbRow dbRow = _parsedData.Get(index);
            CheckExpectedType(JsonTokenType.StartObject, dbRow.TokenType);
            if (dbRow.NumberOfRows == 1)
            {
                value = default(JsonElement);
                return false;
            }
            int endIndex = checked(dbRow.NumberOfRows * 12 + index);
            return TryGetNamedPropertyValue(index + 12, endIndex, propertyName, out value);
        }

        private bool TryGetNamedPropertyValue(int startIndex, int endIndex, ReadOnlySpan<byte> propertyName, out JsonElement value)
        {
            ReadOnlySpan<byte> span = _utf8Json.Span;
            Span<byte> span2 = stackalloc byte[256];
            int num;
            for (num = endIndex - 12; num > startIndex; num -= 12)
            {
                DbRow dbRow = _parsedData.Get(num);
                num = ((!dbRow.IsSimpleValue) ? (num - 12 * (dbRow.NumberOfRows + 1)) : (num - 12));
                dbRow = _parsedData.Get(num);
                ReadOnlySpan<byte> span3 = span.Slice(dbRow.Location, dbRow.SizeOrLength);
                if (dbRow.HasComplexChildren)
                {
                    if (span3.Length > propertyName.Length)
                    {
                        int num2 = span3.IndexOf<byte>(92);
                        if (propertyName.Length > num2 && span3.Slice(0, num2).SequenceEqual(propertyName.Slice(0, num2)))
                        {
                            int num3 = span3.Length - num2;
                            int written = 0;
                            byte[] array = null;
                            try
                            {
                                Span<byte> destination = ((num3 <= span2.Length) ? span2 : ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(num3))));
                                JsonReaderHelper.Unescape(span3.Slice(num2), destination, 0, out written);
                                if (destination.Slice(0, written).SequenceEqual(propertyName.Slice(num2)))
                                {
                                    value = new JsonElement(this, num + 12);
                                    return true;
                                }
                            }
                            finally
                            {
                                if (array != null)
                                {
                                    array.AsSpan(0, written).Clear();
                                    ArrayPool<byte>.Shared.Return(array);
                                }
                            }
                        }
                    }
                }
                else if (span3.SequenceEqual(propertyName))
                {
                    value = new JsonElement(this, num + 12);
                    return true;
                }
            }
            value = default(JsonElement);
            return false;
        }
    }

    /// <summary>
	/// Provides the ability for the user to define custom behavior when parsing JSON to create a <see cref="T:System.Text.Json.JsonDocument" />.
	/// </summary>
	public struct JsonDocumentOptions
    {
        internal const int DefaultMaxDepth = 64;

        private int _maxDepth;

        private JsonCommentHandling _commentHandling;

        /// <summary>
        /// Defines how the <see cref="T:System.Text.Json.Utf8JsonReader" /> should handle comments when reading through the JSON.
        /// </summary>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        /// Thrown when the comment handling enum is set to a value that is not supported (or not within the <see cref="T:System.Text.Json.JsonCommentHandling" /> enum range).
        /// </exception>
        /// <remarks>
        /// By default <exception cref="T:System.Text.Json.JsonException" /> is thrown if a comment is encountered.
        /// </remarks>
        public JsonCommentHandling CommentHandling
        {
            readonly get
            {
                return _commentHandling;
            }
            set
            {
                if ((int)value > 1)
                {
                    throw new ArgumentOutOfRangeException("value", MDCFR.Properties.Resources.JsonDocumentDoesNotSupportComments);
                }
                _commentHandling = value;
            }
        }

        /// <summary>
        /// Gets or sets the maximum depth allowed when reading JSON, with the default (i.e. 0) indicating a max depth of 64.
        /// </summary>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        /// Thrown when the max depth is set to a negative value.
        /// </exception>
        /// <remarks>
        /// Reading past this depth will throw a <exception cref="T:System.Text.Json.JsonException" />.
        /// </remarks>
        public int MaxDepth
        {
            readonly get
            {
                return _maxDepth;
            }
            set
            {
                if (value < 0)
                {
                    ThrowHelper.ThrowArgumentOutOfRangeException_MaxDepthMustBePositive("value");
                }
                _maxDepth = value;
            }
        }

        /// <summary>
        /// Defines whether an extra comma at the end of a list of JSON values in an object or array
        /// is allowed (and ignored) within the JSON payload being read.
        /// </summary>
        /// <remarks>
        /// By default, it's set to false, and <exception cref="T:System.Text.Json.JsonException" /> is thrown if a trailing comma is encountered.
        /// </remarks>
        public bool AllowTrailingCommas { get; set; }

        internal JsonReaderOptions GetReaderOptions()
        {
            JsonReaderOptions result = default(JsonReaderOptions);
            result.AllowTrailingCommas = AllowTrailingCommas;
            result.CommentHandling = CommentHandling;
            result.MaxDepth = MaxDepth;
            return result;
        }
    }

    /// <summary>
	///   Represents a specific JSON value within a <see cref="T:System.Text.Json.JsonDocument" />.
	/// </summary>
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
    public readonly struct JsonElement
    {
        /// <summary>
        ///   An enumerable and enumerator for the contents of a JSON array.
        /// </summary>
        [DebuggerDisplay("{Current,nq}")]
        public struct ArrayEnumerator : IEnumerable<JsonElement>, IEnumerable, IEnumerator<JsonElement>, IDisposable, IEnumerator
        {
            private readonly JsonElement _target;

            private int _curIdx;

            private readonly int _endIdxOrVersion;

            /// <inheritdoc />
            public JsonElement Current
            {
                get
                {
                    if (_curIdx < 0)
                    {
                        return default(JsonElement);
                    }
                    return new JsonElement(_target._parent, _curIdx);
                }
            }

            /// <inheritdoc />
            object IEnumerator.Current => Current;

            internal ArrayEnumerator(JsonElement target)
            {
                _target = target;
                _curIdx = -1;
                _endIdxOrVersion = target._parent.GetEndIndex(_target._idx, includeEndElement: false);
            }

            /// <summary>
            ///   Returns an enumerator that iterates through a collection.
            /// </summary>
            /// <returns>
            ///   An <see cref="T:System.Text.Json.JsonElement.ArrayEnumerator" /> value that can be used to iterate
            ///   through the array.
            /// </returns>
            public ArrayEnumerator GetEnumerator()
            {
                ArrayEnumerator result = this;
                result._curIdx = -1;
                return result;
            }

            /// <inheritdoc />
            IEnumerator IEnumerable.GetEnumerator()
            {
                return GetEnumerator();
            }

            /// <inheritdoc />
            IEnumerator<JsonElement> IEnumerable<JsonElement>.GetEnumerator()
            {
                return GetEnumerator();
            }

            /// <inheritdoc />
            public void Dispose()
            {
                _curIdx = _endIdxOrVersion;
            }

            /// <inheritdoc />
            public void Reset()
            {
                _curIdx = -1;
            }

            /// <inheritdoc />
            public bool MoveNext()
            {
                if (_curIdx >= _endIdxOrVersion)
                {
                    return false;
                }
                if (_curIdx < 0)
                {
                    _curIdx = _target._idx + 12;
                }
                else
                {
                    _curIdx = _target._parent.GetEndIndex(_curIdx, includeEndElement: true);
                }
                return _curIdx < _endIdxOrVersion;
            }
        }

        /// <summary>
        ///   An enumerable and enumerator for the properties of a JSON object.
        /// </summary>
        [DebuggerDisplay("{Current,nq}")]
        public struct ObjectEnumerator : IEnumerable<JsonProperty>, IEnumerable, IEnumerator<JsonProperty>, IDisposable, IEnumerator
        {
            private readonly JsonElement _target;

            private int _curIdx;

            private readonly int _endIdxOrVersion;

            /// <inheritdoc />
            public JsonProperty Current
            {
                get
                {
                    if (_curIdx < 0)
                    {
                        return default(JsonProperty);
                    }
                    return new JsonProperty(new JsonElement(_target._parent, _curIdx));
                }
            }

            /// <inheritdoc />
            object IEnumerator.Current => Current;

            internal ObjectEnumerator(JsonElement target)
            {
                _target = target;
                _curIdx = -1;
                _endIdxOrVersion = target._parent.GetEndIndex(_target._idx, includeEndElement: false);
            }

            /// <summary>
            ///   Returns an enumerator that iterates the properties of an object.
            /// </summary>
            /// <returns>
            ///   An <see cref="T:System.Text.Json.JsonElement.ObjectEnumerator" /> value that can be used to iterate
            ///   through the object.
            /// </returns>
            /// <remarks>
            ///   The enumerator will enumerate the properties in the order they are
            ///   declared, and when an object has multiple definitions of a single
            ///   property they will all individually be returned (each in the order
            ///   they appear in the content).
            /// </remarks>
            public ObjectEnumerator GetEnumerator()
            {
                ObjectEnumerator result = this;
                result._curIdx = -1;
                return result;
            }

            /// <inheritdoc />
            IEnumerator IEnumerable.GetEnumerator()
            {
                return GetEnumerator();
            }

            /// <inheritdoc />
            IEnumerator<JsonProperty> IEnumerable<JsonProperty>.GetEnumerator()
            {
                return GetEnumerator();
            }

            /// <inheritdoc />
            public void Dispose()
            {
                _curIdx = _endIdxOrVersion;
            }

            /// <inheritdoc />
            public void Reset()
            {
                _curIdx = -1;
            }

            /// <inheritdoc />
            public bool MoveNext()
            {
                if (_curIdx >= _endIdxOrVersion)
                {
                    return false;
                }
                if (_curIdx < 0)
                {
                    _curIdx = _target._idx + 12;
                }
                else
                {
                    _curIdx = _target._parent.GetEndIndex(_curIdx, includeEndElement: true);
                }
                _curIdx += 12;
                return _curIdx < _endIdxOrVersion;
            }
        }

        private readonly JsonDocument _parent;

        private readonly int _idx;

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private JsonTokenType TokenType => _parent?.GetJsonTokenType(_idx) ?? JsonTokenType.None;

        /// <summary>
        ///   The <see cref="T:System.Text.Json.JsonValueKind" /> that the value is.
        /// </summary>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public JsonValueKind ValueKind => TokenType.ToValueKind();

        /// <summary>
        ///   Get the value at a specified index when the current value is a
        ///   <see cref="F:System.Text.Json.JsonValueKind.Array" />.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Array" />.
        /// </exception>
        /// <exception cref="T:System.IndexOutOfRangeException">
        ///   <paramref name="index" /> is not in the range [0, <see cref="M:System.Text.Json.JsonElement.GetArrayLength" />()).
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public JsonElement this[int index]
        {
            get
            {
                CheckValidInstance();
                return _parent.GetArrayIndexElement(_idx, index);
            }
        }

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private string DebuggerDisplay => $"ValueKind = {ValueKind} : \"{ToString()}\"";

        internal JsonElement(JsonDocument parent, int idx)
        {
            _parent = parent;
            _idx = idx;
        }

        /// <summary>
        ///   Get the number of values contained within the current array value.
        /// </summary>
        /// <returns>The number of values contained within the current array value.</returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Array" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public int GetArrayLength()
        {
            CheckValidInstance();
            return _parent.GetArrayLength(_idx);
        }

        /// <summary>
        ///   Gets a <see cref="T:System.Text.Json.JsonElement" /> representing the value of a required property identified
        ///   by <paramref name="propertyName" />.
        /// </summary>
        /// <remarks>
        ///   Property name matching is performed as an ordinal, case-sensitive, comparison.
        ///
        ///   If a property is defined multiple times for the same object, the last such definition is
        ///   what is matched.
        /// </remarks>
        /// <param name="propertyName">Name of the property whose value to return.</param>
        /// <returns>
        ///   A <see cref="T:System.Text.Json.JsonElement" /> representing the value of the requested property.
        /// </returns>
        /// <seealso cref="M:System.Text.Json.JsonElement.EnumerateObject" />
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Object" />.
        /// </exception>
        /// <exception cref="T:System.Collections.Generic.KeyNotFoundException">
        ///   No property was found with the requested name.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        ///   <paramref name="propertyName" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public JsonElement GetProperty(string propertyName)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            if (TryGetProperty(propertyName, out var value))
            {
                return value;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        ///   Gets a <see cref="T:System.Text.Json.JsonElement" /> representing the value of a required property identified
        ///   by <paramref name="propertyName" />.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     Property name matching is performed as an ordinal, case-sensitive, comparison.
        ///   </para>
        ///
        ///   <para>
        ///     If a property is defined multiple times for the same object, the last such definition is
        ///     what is matched.
        ///   </para>
        /// </remarks>
        /// <param name="propertyName">Name of the property whose value to return.</param>
        /// <returns>
        ///   A <see cref="T:System.Text.Json.JsonElement" /> representing the value of the requested property.
        /// </returns>
        /// <seealso cref="M:System.Text.Json.JsonElement.EnumerateObject" />
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Object" />.
        /// </exception>
        /// <exception cref="T:System.Collections.Generic.KeyNotFoundException">
        ///   No property was found with the requested name.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public JsonElement GetProperty(ReadOnlySpan<char> propertyName)
        {
            if (TryGetProperty(propertyName, out var value))
            {
                return value;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        ///   Gets a <see cref="T:System.Text.Json.JsonElement" /> representing the value of a required property identified
        ///   by <paramref name="utf8PropertyName" />.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     Property name matching is performed as an ordinal, case-sensitive, comparison.
        ///   </para>
        ///
        ///   <para>
        ///     If a property is defined multiple times for the same object, the last such definition is
        ///     what is matched.
        ///   </para>
        /// </remarks>
        /// <param name="utf8PropertyName">
        ///   The UTF-8 (with no Byte-Order-Mark (BOM)) representation of the name of the property to return.
        /// </param>
        /// <returns>
        ///   A <see cref="T:System.Text.Json.JsonElement" /> representing the value of the requested property.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Object" />.
        /// </exception>
        /// <exception cref="T:System.Collections.Generic.KeyNotFoundException">
        ///   No property was found with the requested name.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        /// <seealso cref="M:System.Text.Json.JsonElement.EnumerateObject" />
        public JsonElement GetProperty(ReadOnlySpan<byte> utf8PropertyName)
        {
            if (TryGetProperty(utf8PropertyName, out var value))
            {
                return value;
            }
            throw new KeyNotFoundException();
        }

        /// <summary>
        ///   Looks for a property named <paramref name="propertyName" /> in the current object, returning
        ///   whether or not such a property existed. When the property exists <paramref name="value" />
        ///   is assigned to the value of that property.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     Property name matching is performed as an ordinal, case-sensitive, comparison.
        ///   </para>
        ///
        ///   <para>
        ///     If a property is defined multiple times for the same object, the last such definition is
        ///     what is matched.
        ///   </para>
        /// </remarks>
        /// <param name="propertyName">Name of the property to find.</param>
        /// <param name="value">Receives the value of the located property.</param>
        /// <returns>
        ///   <see langword="true" /> if the property was found, <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Object" />.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        ///   <paramref name="propertyName" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        /// <seealso cref="M:System.Text.Json.JsonElement.EnumerateObject" />
        public bool TryGetProperty(string propertyName, out JsonElement value)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            return TryGetProperty(propertyName.AsSpan(), out value);
        }

        /// <summary>
        ///   Looks for a property named <paramref name="propertyName" /> in the current object, returning
        ///   whether or not such a property existed. When the property exists <paramref name="value" />
        ///   is assigned to the value of that property.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     Property name matching is performed as an ordinal, case-sensitive, comparison.
        ///   </para>
        ///
        ///   <para>
        ///     If a property is defined multiple times for the same object, the last such definition is
        ///     what is matched.
        ///   </para>
        /// </remarks>
        /// <param name="propertyName">Name of the property to find.</param>
        /// <param name="value">Receives the value of the located property.</param>
        /// <returns>
        ///   <see langword="true" /> if the property was found, <see langword="false" /> otherwise.
        /// </returns>
        /// <seealso cref="M:System.Text.Json.JsonElement.EnumerateObject" />
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Object" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public bool TryGetProperty(ReadOnlySpan<char> propertyName, out JsonElement value)
        {
            CheckValidInstance();
            return _parent.TryGetNamedPropertyValue(_idx, propertyName, out value);
        }

        /// <summary>
        ///   Looks for a property named <paramref name="utf8PropertyName" /> in the current object, returning
        ///   whether or not such a property existed. When the property exists <paramref name="value" />
        ///   is assigned to the value of that property.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     Property name matching is performed as an ordinal, case-sensitive, comparison.
        ///   </para>
        ///
        ///   <para>
        ///     If a property is defined multiple times for the same object, the last such definition is
        ///     what is matched.
        ///   </para>
        /// </remarks>
        /// <param name="utf8PropertyName">
        ///   The UTF-8 (with no Byte-Order-Mark (BOM)) representation of the name of the property to return.
        /// </param>
        /// <param name="value">Receives the value of the located property.</param>
        /// <returns>
        ///   <see langword="true" /> if the property was found, <see langword="false" /> otherwise.
        /// </returns>
        /// <seealso cref="M:System.Text.Json.JsonElement.EnumerateObject" />
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Object" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public bool TryGetProperty(ReadOnlySpan<byte> utf8PropertyName, out JsonElement value)
        {
            CheckValidInstance();
            return _parent.TryGetNamedPropertyValue(_idx, utf8PropertyName, out value);
        }

        /// <summary>
        ///   Gets the value of the element as a <see cref="T:System.Boolean" />.
        /// </summary>
        /// <remarks>
        ///   This method does not parse the contents of a JSON string value.
        /// </remarks>
        /// <returns>The value of the element as a <see cref="T:System.Boolean" />.</returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is neither <see cref="F:System.Text.Json.JsonValueKind.True" /> or
        ///   <see cref="F:System.Text.Json.JsonValueKind.False" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public bool GetBoolean()
        {
            JsonTokenType tokenType = TokenType;
            return tokenType switch
            {
                JsonTokenType.False => false,
                JsonTokenType.True => true,
                _ => ThrowJsonElementWrongTypeException(tokenType),
            };
            static bool ThrowJsonElementWrongTypeException(JsonTokenType actualType)
            {
                throw ThrowHelper.GetJsonElementWrongTypeException("Boolean", actualType.ToValueKind());
            }
        }

        /// <summary>
        ///   Gets the value of the element as a <see cref="T:System.String" />.
        /// </summary>
        /// <remarks>
        ///   This method does not create a string representation of values other than JSON strings.
        /// </remarks>
        /// <returns>The value of the element as a <see cref="T:System.String" />.</returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is neither <see cref="F:System.Text.Json.JsonValueKind.String" /> nor <see cref="F:System.Text.Json.JsonValueKind.Null" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        /// <seealso cref="M:System.Text.Json.JsonElement.ToString" />
        public string? GetString()
        {
            CheckValidInstance();
            return _parent.GetString(_idx, JsonTokenType.String);
        }

        /// <summary>
        ///   Attempts to represent the current JSON string as bytes assuming it is Base64 encoded.
        /// </summary>
        /// <param name="value">Receives the value.</param>
        /// <remarks>
        ///  This method does not create a byte[] representation of values other than base 64 encoded JSON strings.
        /// </remarks>
        /// <returns>
        ///   <see langword="true" /> if the entire token value is encoded as valid Base64 text and can be successfully decoded to bytes.
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.String" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public bool TryGetBytesFromBase64([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out byte[]? value)
        {
            CheckValidInstance();
            return _parent.TryGetValue(_idx, out value);
        }

        /// <summary>
        ///   Gets the value of the element as bytes.
        /// </summary>
        /// <remarks>
        ///   This method does not create a byte[] representation of values other than Base64 encoded JSON strings.
        /// </remarks>
        /// <returns>The value decode to bytes.</returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.String" />.
        /// </exception>
        /// <exception cref="T:System.FormatException">
        ///   The value is not encoded as Base64 text and hence cannot be decoded to bytes.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        /// <seealso cref="M:System.Text.Json.JsonElement.ToString" />
        public byte[] GetBytesFromBase64()
        {
            if (!TryGetBytesFromBase64(out byte[] value))
            {
                ThrowHelper.ThrowFormatException();
            }
            return value;
        }

        /// <summary>
        ///   Attempts to represent the current JSON number as an <see cref="T:System.SByte" />.
        /// </summary>
        /// <param name="value">Receives the value.</param>
        /// <remarks>
        ///   This method does not parse the contents of a JSON string value.
        /// </remarks>
        /// <returns>
        ///   <see langword="true" /> if the number can be represented as an <see cref="T:System.SByte" />,
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        [CLSCompliant(false)]
        public bool TryGetSByte(out sbyte value)
        {
            CheckValidInstance();
            return _parent.TryGetValue(_idx, out value);
        }

        /// <summary>
        ///   Gets the current JSON number as an <see cref="T:System.SByte" />.
        /// </summary>
        /// <returns>The current JSON number as an <see cref="T:System.SByte" />.</returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.FormatException">
        ///   The value cannot be represented as an <see cref="T:System.SByte" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        [CLSCompliant(false)]
        public sbyte GetSByte()
        {
            if (TryGetSByte(out var value))
            {
                return value;
            }
            throw new FormatException();
        }

        /// <summary>
        ///   Attempts to represent the current JSON number as a <see cref="T:System.Byte" />.
        /// </summary>
        /// <param name="value">Receives the value.</param>
        /// <remarks>
        ///   This method does not parse the contents of a JSON string value.
        /// </remarks>
        /// <returns>
        ///   <see langword="true" /> if the number can be represented as a <see cref="T:System.Byte" />,
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public bool TryGetByte(out byte value)
        {
            CheckValidInstance();
            return _parent.TryGetValue(_idx, out value);
        }

        /// <summary>
        ///   Gets the current JSON number as a <see cref="T:System.Byte" />.
        /// </summary>
        /// <returns>The current JSON number as a <see cref="T:System.Byte" />.</returns>
        /// <remarks>
        ///   This method does not parse the contents of a JSON string value.
        /// </remarks>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.FormatException">
        ///   The value cannot be represented as a <see cref="T:System.Byte" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public byte GetByte()
        {
            if (TryGetByte(out var value))
            {
                return value;
            }
            throw new FormatException();
        }

        /// <summary>
        ///   Attempts to represent the current JSON number as an <see cref="T:System.Int16" />.
        /// </summary>
        /// <param name="value">Receives the value.</param>
        /// <remarks>
        ///   This method does not parse the contents of a JSON string value.
        /// </remarks>
        /// <returns>
        ///   <see langword="true" /> if the number can be represented as an <see cref="T:System.Int16" />,
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public bool TryGetInt16(out short value)
        {
            CheckValidInstance();
            return _parent.TryGetValue(_idx, out value);
        }

        /// <summary>
        ///   Gets the current JSON number as an <see cref="T:System.Int16" />.
        /// </summary>
        /// <returns>The current JSON number as an <see cref="T:System.Int16" />.</returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.FormatException">
        ///   The value cannot be represented as an <see cref="T:System.Int16" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public short GetInt16()
        {
            if (TryGetInt16(out var value))
            {
                return value;
            }
            throw new FormatException();
        }

        /// <summary>
        ///   Attempts to represent the current JSON number as a <see cref="T:System.UInt16" />.
        /// </summary>
        /// <param name="value">Receives the value.</param>
        /// <remarks>
        ///   This method does not parse the contents of a JSON string value.
        /// </remarks>
        /// <returns>
        ///   <see langword="true" /> if the number can be represented as a <see cref="T:System.UInt16" />,
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        [CLSCompliant(false)]
        public bool TryGetUInt16(out ushort value)
        {
            CheckValidInstance();
            return _parent.TryGetValue(_idx, out value);
        }

        /// <summary>
        ///   Gets the current JSON number as a <see cref="T:System.UInt16" />.
        /// </summary>
        /// <returns>The current JSON number as a <see cref="T:System.UInt16" />.</returns>
        /// <remarks>
        ///   This method does not parse the contents of a JSON string value.
        /// </remarks>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.FormatException">
        ///   The value cannot be represented as a <see cref="T:System.UInt16" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        [CLSCompliant(false)]
        public ushort GetUInt16()
        {
            if (TryGetUInt16(out var value))
            {
                return value;
            }
            throw new FormatException();
        }

        /// <summary>
        ///   Attempts to represent the current JSON number as an <see cref="T:System.Int32" />.
        /// </summary>
        /// <param name="value">Receives the value.</param>
        /// <remarks>
        ///   This method does not parse the contents of a JSON string value.
        /// </remarks>
        /// <returns>
        ///   <see langword="true" /> if the number can be represented as an <see cref="T:System.Int32" />,
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public bool TryGetInt32(out int value)
        {
            CheckValidInstance();
            return _parent.TryGetValue(_idx, out value);
        }

        /// <summary>
        ///   Gets the current JSON number as an <see cref="T:System.Int32" />.
        /// </summary>
        /// <returns>The current JSON number as an <see cref="T:System.Int32" />.</returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.FormatException">
        ///   The value cannot be represented as an <see cref="T:System.Int32" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public int GetInt32()
        {
            if (!TryGetInt32(out var value))
            {
                ThrowHelper.ThrowFormatException();
            }
            return value;
        }

        /// <summary>
        ///   Attempts to represent the current JSON number as a <see cref="T:System.UInt32" />.
        /// </summary>
        /// <param name="value">Receives the value.</param>
        /// <remarks>
        ///   This method does not parse the contents of a JSON string value.
        /// </remarks>
        /// <returns>
        ///   <see langword="true" /> if the number can be represented as a <see cref="T:System.UInt32" />,
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        [CLSCompliant(false)]
        public bool TryGetUInt32(out uint value)
        {
            CheckValidInstance();
            return _parent.TryGetValue(_idx, out value);
        }

        /// <summary>
        ///   Gets the current JSON number as a <see cref="T:System.UInt32" />.
        /// </summary>
        /// <returns>The current JSON number as a <see cref="T:System.UInt32" />.</returns>
        /// <remarks>
        ///   This method does not parse the contents of a JSON string value.
        /// </remarks>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.FormatException">
        ///   The value cannot be represented as a <see cref="T:System.UInt32" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        [CLSCompliant(false)]
        public uint GetUInt32()
        {
            if (!TryGetUInt32(out var value))
            {
                ThrowHelper.ThrowFormatException();
            }
            return value;
        }

        /// <summary>
        ///   Attempts to represent the current JSON number as a <see cref="T:System.Int64" />.
        /// </summary>
        /// <param name="value">Receives the value.</param>
        /// <remarks>
        ///   This method does not parse the contents of a JSON string value.
        /// </remarks>
        /// <returns>
        ///   <see langword="true" /> if the number can be represented as a <see cref="T:System.Int64" />,
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public bool TryGetInt64(out long value)
        {
            CheckValidInstance();
            return _parent.TryGetValue(_idx, out value);
        }

        /// <summary>
        ///   Gets the current JSON number as a <see cref="T:System.Int64" />.
        /// </summary>
        /// <returns>The current JSON number as a <see cref="T:System.Int64" />.</returns>
        /// <remarks>
        ///   This method does not parse the contents of a JSON string value.
        /// </remarks>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.FormatException">
        ///   The value cannot be represented as a <see cref="T:System.Int64" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public long GetInt64()
        {
            if (!TryGetInt64(out var value))
            {
                ThrowHelper.ThrowFormatException();
            }
            return value;
        }

        /// <summary>
        ///   Attempts to represent the current JSON number as a <see cref="T:System.UInt64" />.
        /// </summary>
        /// <param name="value">Receives the value.</param>
        /// <remarks>
        ///   This method does not parse the contents of a JSON string value.
        /// </remarks>
        /// <returns>
        ///   <see langword="true" /> if the number can be represented as a <see cref="T:System.UInt64" />,
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        [CLSCompliant(false)]
        public bool TryGetUInt64(out ulong value)
        {
            CheckValidInstance();
            return _parent.TryGetValue(_idx, out value);
        }

        /// <summary>
        ///   Gets the current JSON number as a <see cref="T:System.UInt64" />.
        /// </summary>
        /// <returns>The current JSON number as a <see cref="T:System.UInt64" />.</returns>
        /// <remarks>
        ///   This method does not parse the contents of a JSON string value.
        /// </remarks>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.FormatException">
        ///   The value cannot be represented as a <see cref="T:System.UInt64" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        [CLSCompliant(false)]
        public ulong GetUInt64()
        {
            if (!TryGetUInt64(out var value))
            {
                ThrowHelper.ThrowFormatException();
            }
            return value;
        }

        /// <summary>
        ///   Attempts to represent the current JSON number as a <see cref="T:System.Double" />.
        /// </summary>
        /// <param name="value">Receives the value.</param>
        /// <remarks>
        ///   <para>
        ///     This method does not parse the contents of a JSON string value.
        ///   </para>
        ///
        ///   <para>
        ///     On .NET Core this method does not return <see langword="false" /> for values larger than
        ///     <see cref="F:System.Double.MaxValue" /> (or smaller than <see cref="F:System.Double.MinValue" />),
        ///     instead <see langword="true" /> is returned and <see cref="F:System.Double.PositiveInfinity" /> (or
        ///     <see cref="F:System.Double.NegativeInfinity" />) is emitted.
        ///   </para>
        /// </remarks>
        /// <returns>
        ///   <see langword="true" /> if the number can be represented as a <see cref="T:System.Double" />,
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public bool TryGetDouble(out double value)
        {
            CheckValidInstance();
            return _parent.TryGetValue(_idx, out value);
        }

        /// <summary>
        ///   Gets the current JSON number as a <see cref="T:System.Double" />.
        /// </summary>
        /// <returns>The current JSON number as a <see cref="T:System.Double" />.</returns>
        /// <remarks>
        ///   <para>
        ///     This method does not parse the contents of a JSON string value.
        ///   </para>
        ///
        ///   <para>
        ///     On .NET Core this method returns <see cref="F:System.Double.PositiveInfinity" /> (or
        ///     <see cref="F:System.Double.NegativeInfinity" />) for values larger than
        ///     <see cref="F:System.Double.MaxValue" /> (or smaller than <see cref="F:System.Double.MinValue" />).
        ///   </para>
        /// </remarks>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.FormatException">
        ///   The value cannot be represented as a <see cref="T:System.Double" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public double GetDouble()
        {
            if (!TryGetDouble(out var value))
            {
                ThrowHelper.ThrowFormatException();
            }
            return value;
        }

        /// <summary>
        ///   Attempts to represent the current JSON number as a <see cref="T:System.Single" />.
        /// </summary>
        /// <param name="value">Receives the value.</param>
        /// <remarks>
        ///   <para>
        ///     This method does not parse the contents of a JSON string value.
        ///   </para>
        ///
        ///   <para>
        ///     On .NET Core this method does not return <see langword="false" /> for values larger than
        ///     <see cref="F:System.Single.MaxValue" /> (or smaller than <see cref="F:System.Single.MinValue" />),
        ///     instead <see langword="true" /> is returned and <see cref="F:System.Single.PositiveInfinity" /> (or
        ///     <see cref="F:System.Single.NegativeInfinity" />) is emitted.
        ///   </para>
        /// </remarks>
        /// <returns>
        ///   <see langword="true" /> if the number can be represented as a <see cref="T:System.Single" />,
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public bool TryGetSingle(out float value)
        {
            CheckValidInstance();
            return _parent.TryGetValue(_idx, out value);
        }

        /// <summary>
        ///   Gets the current JSON number as a <see cref="T:System.Single" />.
        /// </summary>
        /// <returns>The current JSON number as a <see cref="T:System.Single" />.</returns>
        /// <remarks>
        ///   <para>
        ///     This method does not parse the contents of a JSON string value.
        ///   </para>
        ///
        ///   <para>
        ///     On .NET Core this method returns <see cref="F:System.Single.PositiveInfinity" /> (or
        ///     <see cref="F:System.Single.NegativeInfinity" />) for values larger than
        ///     <see cref="F:System.Single.MaxValue" /> (or smaller than <see cref="F:System.Single.MinValue" />).
        ///   </para>
        /// </remarks>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.FormatException">
        ///   The value cannot be represented as a <see cref="T:System.Single" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public float GetSingle()
        {
            if (!TryGetSingle(out var value))
            {
                ThrowHelper.ThrowFormatException();
            }
            return value;
        }

        /// <summary>
        ///   Attempts to represent the current JSON number as a <see cref="T:System.Decimal" />.
        /// </summary>
        /// <param name="value">Receives the value.</param>
        /// <remarks>
        ///   This method does not parse the contents of a JSON string value.
        /// </remarks>
        /// <returns>
        ///   <see langword="true" /> if the number can be represented as a <see cref="T:System.Decimal" />,
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        /// <seealso cref="M:System.Text.Json.JsonElement.GetRawText" />
        public bool TryGetDecimal(out decimal value)
        {
            CheckValidInstance();
            return _parent.TryGetValue(_idx, out value);
        }

        /// <summary>
        ///   Gets the current JSON number as a <see cref="T:System.Decimal" />.
        /// </summary>
        /// <returns>The current JSON number as a <see cref="T:System.Decimal" />.</returns>
        /// <remarks>
        ///   This method does not parse the contents of a JSON string value.
        /// </remarks>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Number" />.
        /// </exception>
        /// <exception cref="T:System.FormatException">
        ///   The value cannot be represented as a <see cref="T:System.Decimal" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        /// <seealso cref="M:System.Text.Json.JsonElement.GetRawText" />
        public decimal GetDecimal()
        {
            if (!TryGetDecimal(out var value))
            {
                ThrowHelper.ThrowFormatException();
            }
            return value;
        }

        /// <summary>
        ///   Attempts to represent the current JSON string as a <see cref="T:System.DateTime" />.
        /// </summary>
        /// <param name="value">Receives the value.</param>
        /// <remarks>
        ///   This method does not create a DateTime representation of values other than JSON strings.
        /// </remarks>
        /// <returns>
        ///   <see langword="true" /> if the string can be represented as a <see cref="T:System.DateTime" />,
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.String" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public bool TryGetDateTime(out DateTime value)
        {
            CheckValidInstance();
            return _parent.TryGetValue(_idx, out value);
        }

        /// <summary>
        ///   Gets the value of the element as a <see cref="T:System.DateTime" />.
        /// </summary>
        /// <remarks>
        ///   This method does not create a DateTime representation of values other than JSON strings.
        /// </remarks>
        /// <returns>The value of the element as a <see cref="T:System.DateTime" />.</returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.String" />.
        /// </exception>
        /// <exception cref="T:System.FormatException">
        ///   The value cannot be represented as a <see cref="T:System.DateTime" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        /// <seealso cref="M:System.Text.Json.JsonElement.ToString" />
        public DateTime GetDateTime()
        {
            if (!TryGetDateTime(out var value))
            {
                ThrowHelper.ThrowFormatException();
            }
            return value;
        }

        /// <summary>
        ///   Attempts to represent the current JSON string as a <see cref="T:System.DateTimeOffset" />.
        /// </summary>
        /// <param name="value">Receives the value.</param>
        /// <remarks>
        ///   This method does not create a DateTimeOffset representation of values other than JSON strings.
        /// </remarks>
        /// <returns>
        ///   <see langword="true" /> if the string can be represented as a <see cref="T:System.DateTimeOffset" />,
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.String" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public bool TryGetDateTimeOffset(out DateTimeOffset value)
        {
            CheckValidInstance();
            return _parent.TryGetValue(_idx, out value);
        }

        /// <summary>
        ///   Gets the value of the element as a <see cref="T:System.DateTimeOffset" />.
        /// </summary>
        /// <remarks>
        ///   This method does not create a DateTimeOffset representation of values other than JSON strings.
        /// </remarks>
        /// <returns>The value of the element as a <see cref="T:System.DateTimeOffset" />.</returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.String" />.
        /// </exception>
        /// <exception cref="T:System.FormatException">
        ///   The value cannot be represented as a <see cref="T:System.DateTimeOffset" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        /// <seealso cref="M:System.Text.Json.JsonElement.ToString" />
        public DateTimeOffset GetDateTimeOffset()
        {
            if (!TryGetDateTimeOffset(out var value))
            {
                ThrowHelper.ThrowFormatException();
            }
            return value;
        }

        /// <summary>
        ///   Attempts to represent the current JSON string as a <see cref="T:System.Guid" />.
        /// </summary>
        /// <param name="value">Receives the value.</param>
        /// <remarks>
        ///   This method does not create a Guid representation of values other than JSON strings.
        /// </remarks>
        /// <returns>
        ///   <see langword="true" /> if the string can be represented as a <see cref="T:System.Guid" />,
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.String" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public bool TryGetGuid(out Guid value)
        {
            CheckValidInstance();
            return _parent.TryGetValue(_idx, out value);
        }

        /// <summary>
        ///   Gets the value of the element as a <see cref="T:System.Guid" />.
        /// </summary>
        /// <remarks>
        ///   This method does not create a Guid representation of values other than JSON strings.
        /// </remarks>
        /// <returns>The value of the element as a <see cref="T:System.Guid" />.</returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.String" />.
        /// </exception>
        /// <exception cref="T:System.FormatException">
        ///   The value cannot be represented as a <see cref="T:System.Guid" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        /// <seealso cref="M:System.Text.Json.JsonElement.ToString" />
        public Guid GetGuid()
        {
            if (!TryGetGuid(out var value))
            {
                ThrowHelper.ThrowFormatException();
            }
            return value;
        }

        internal string GetPropertyName()
        {
            CheckValidInstance();
            return _parent.GetNameOfPropertyValue(_idx);
        }

        /// <summary>
        ///   Gets the original input data backing this value, returning it as a <see cref="T:System.String" />.
        /// </summary>
        /// <returns>
        ///   The original input data backing this value, returning it as a <see cref="T:System.String" />.
        /// </returns>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public string GetRawText()
        {
            CheckValidInstance();
            return _parent.GetRawValueAsString(_idx);
        }

        internal ReadOnlyMemory<byte> GetRawValue()
        {
            CheckValidInstance();
            return _parent.GetRawValue(_idx, includeQuotes: true);
        }

        internal string GetPropertyRawText()
        {
            CheckValidInstance();
            return _parent.GetPropertyRawValueAsString(_idx);
        }

        /// <summary>
        ///   Compares <paramref name="text" /> to the string value of this element.
        /// </summary>
        /// <param name="text">The text to compare against.</param>
        /// <returns>
        ///   <see langword="true" /> if the string value of this element matches <paramref name="text" />,
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.String" />.
        /// </exception>
        /// <remarks>
        ///   This method is functionally equal to doing an ordinal comparison of <paramref name="text" /> and
        ///   the result of calling <see cref="M:System.Text.Json.JsonElement.GetString" />, but avoids creating the string instance.
        /// </remarks>
        public bool ValueEquals(string? text)
        {
            if (TokenType == JsonTokenType.Null)
            {
                return text == null;
            }
            return TextEqualsHelper(text.AsSpan(), isPropertyName: false);
        }

        /// <summary>
        ///   Compares the text represented by <paramref name="utf8Text" /> to the string value of this element.
        /// </summary>
        /// <param name="utf8Text">The UTF-8 encoded text to compare against.</param>
        /// <returns>
        ///   <see langword="true" /> if the string value of this element has the same UTF-8 encoding as
        ///   <paramref name="utf8Text" />, <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.String" />.
        /// </exception>
        /// <remarks>
        ///   This method is functionally equal to doing an ordinal comparison of the string produced by UTF-8 decoding
        ///   <paramref name="utf8Text" /> with the result of calling <see cref="M:System.Text.Json.JsonElement.GetString" />, but avoids creating the
        ///   string instances.
        /// </remarks>
        public bool ValueEquals(ReadOnlySpan<byte> utf8Text)
        {
            if (TokenType == JsonTokenType.Null)
            {
                return utf8Text == default(ReadOnlySpan<byte>);
            }
            return TextEqualsHelper(utf8Text, isPropertyName: false, shouldUnescape: true);
        }

        /// <summary>
        ///   Compares <paramref name="text" /> to the string value of this element.
        /// </summary>
        /// <param name="text">The text to compare against.</param>
        /// <returns>
        ///   <see langword="true" /> if the string value of this element matches <paramref name="text" />,
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.String" />.
        /// </exception>
        /// <remarks>
        ///   This method is functionally equal to doing an ordinal comparison of <paramref name="text" /> and
        ///   the result of calling <see cref="M:System.Text.Json.JsonElement.GetString" />, but avoids creating the string instance.
        /// </remarks>
        public bool ValueEquals(ReadOnlySpan<char> text)
        {
            if (TokenType == JsonTokenType.Null)
            {
                return text == default(ReadOnlySpan<char>);
            }
            return TextEqualsHelper(text, isPropertyName: false);
        }

        internal bool TextEqualsHelper(ReadOnlySpan<byte> utf8Text, bool isPropertyName, bool shouldUnescape)
        {
            CheckValidInstance();
            return _parent.TextEquals(_idx, utf8Text, isPropertyName, shouldUnescape);
        }

        internal bool TextEqualsHelper(ReadOnlySpan<char> text, bool isPropertyName)
        {
            CheckValidInstance();
            return _parent.TextEquals(_idx, text, isPropertyName);
        }

        /// <summary>
        ///   Write the element into the provided writer as a JSON value.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <exception cref="T:System.ArgumentNullException">
        ///   The <paramref name="writer" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is <see cref="F:System.Text.Json.JsonValueKind.Undefined" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public void WriteTo(Utf8JsonWriter writer)
        {
            if (writer == null)
            {
                ThrowHelper.ThrowArgumentNullException("writer");
            }
            CheckValidInstance();
            _parent.WriteElementTo(_idx, writer);
        }

        /// <summary>
        ///   Get an enumerator to enumerate the values in the JSON array represented by this JsonElement.
        /// </summary>
        /// <returns>
        ///   An enumerator to enumerate the values in the JSON array represented by this JsonElement.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Array" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public ArrayEnumerator EnumerateArray()
        {
            CheckValidInstance();
            JsonTokenType tokenType = TokenType;
            if (tokenType != JsonTokenType.StartArray)
            {
                ThrowHelper.ThrowJsonElementWrongTypeException(JsonTokenType.StartArray, tokenType);
            }
            return new ArrayEnumerator(this);
        }

        /// <summary>
        ///   Get an enumerator to enumerate the properties in the JSON object represented by this JsonElement.
        /// </summary>
        /// <returns>
        ///   An enumerator to enumerate the properties in the JSON object represented by this JsonElement.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="P:System.Text.Json.JsonElement.ValueKind" /> is not <see cref="F:System.Text.Json.JsonValueKind.Object" />.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public ObjectEnumerator EnumerateObject()
        {
            CheckValidInstance();
            JsonTokenType tokenType = TokenType;
            if (tokenType != JsonTokenType.StartObject)
            {
                ThrowHelper.ThrowJsonElementWrongTypeException(JsonTokenType.StartObject, tokenType);
            }
            return new ObjectEnumerator(this);
        }

        /// <summary>
        ///   Gets a string representation for the current value appropriate to the value type.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     For JsonElement built from <see cref="T:System.Text.Json.JsonDocument" />:
        ///   </para>
        ///
        ///   <para>
        ///     For <see cref="F:System.Text.Json.JsonValueKind.Null" />, <see cref="F:System.String.Empty" /> is returned.
        ///   </para>
        ///
        ///   <para>
        ///     For <see cref="F:System.Text.Json.JsonValueKind.True" />, <see cref="F:System.Boolean.TrueString" /> is returned.
        ///   </para>
        ///
        ///   <para>
        ///     For <see cref="F:System.Text.Json.JsonValueKind.False" />, <see cref="F:System.Boolean.FalseString" /> is returned.
        ///   </para>
        ///
        ///   <para>
        ///     For <see cref="F:System.Text.Json.JsonValueKind.String" />, the value of <see cref="M:System.Text.Json.JsonElement.GetString" />() is returned.
        ///   </para>
        ///
        ///   <para>
        ///     For other types, the value of <see cref="M:System.Text.Json.JsonElement.GetRawText" />() is returned.
        ///   </para>
        /// </remarks>
        /// <returns>
        ///   A string representation for the current value appropriate to the value type.
        /// </returns>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>
        public override string ToString()
        {
            switch (TokenType)
            {
                case JsonTokenType.None:
                case JsonTokenType.Null:
                    return string.Empty;
                case JsonTokenType.True:
                    return bool.TrueString;
                case JsonTokenType.False:
                    return bool.FalseString;
                case JsonTokenType.StartObject:
                case JsonTokenType.StartArray:
                case JsonTokenType.Number:
                    return _parent.GetRawValueAsString(_idx);
                case JsonTokenType.String:
                    return GetString();
                default:
                    return string.Empty;
            }
        }

        /// <summary>
        ///   Get a JsonElement which can be safely stored beyond the lifetime of the
        ///   original <see cref="T:System.Text.Json.JsonDocument" />.
        /// </summary>
        /// <returns>
        ///   A JsonElement which can be safely stored beyond the lifetime of the
        ///   original <see cref="T:System.Text.Json.JsonDocument" />.
        /// </returns>
        /// <remarks>
        ///   <para>
        ///     If this JsonElement is itself the output of a previous call to Clone, or
        ///     a value contained within another JsonElement which was the output of a previous
        ///     call to Clone, this method results in no additional memory allocation.
        ///   </para>
        /// </remarks>
        public JsonElement Clone()
        {
            CheckValidInstance();
            if (!_parent.IsDisposable)
            {
                return this;
            }
            return _parent.CloneElement(_idx);
        }

        private void CheckValidInstance()
        {
            if (_parent == null)
            {
                throw new InvalidOperationException();
            }
        }

        /// <summary>
        ///   Parses one JSON value (including objects or arrays) from the provided reader.
        /// </summary>
        /// <param name="reader">The reader to read.</param>
        /// <returns>
        ///   A JsonElement representing the value (and nested values) read from the reader.
        /// </returns>
        /// <remarks>
        ///   <para>
        ///     If the <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> property of <paramref name="reader" />
        ///     is <see cref="F:System.Text.Json.JsonTokenType.PropertyName" /> or <see cref="F:System.Text.Json.JsonTokenType.None" />, the
        ///     reader will be advanced by one call to <see cref="M:System.Text.Json.Utf8JsonReader.Read" /> to determine
        ///     the start of the value.
        ///   </para>
        ///
        ///   <para>
        ///     Upon completion of this method, <paramref name="reader" /> will be positioned at the
        ///     final token in the JSON value. If an exception is thrown, the reader is reset to
        ///     the state it was in when the method was called.
        ///   </para>
        ///
        ///   <para>
        ///     This method makes a copy of the data the reader acted on, so there is no caller
        ///     requirement to maintain data integrity beyond the return of this method.
        ///   </para>
        /// </remarks>
        /// <exception cref="T:System.ArgumentException">
        ///   <paramref name="reader" /> is using unsupported options.
        /// </exception>
        /// <exception cref="T:System.ArgumentException">
        ///   The current <paramref name="reader" /> token does not start or represent a value.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        ///   A value could not be read from the reader.
        /// </exception>
        public static JsonElement ParseValue(ref Utf8JsonReader reader)
        {
            JsonDocument document;
            bool flag = JsonDocument.TryParseValue(ref reader, out document, shouldThrow: true, useArrayPools: false);
            return document.RootElement;
        }

        internal static JsonElement ParseValue(Stream utf8Json, JsonDocumentOptions options)
        {
            JsonDocument jsonDocument = JsonDocument.ParseValue(utf8Json, options);
            return jsonDocument.RootElement;
        }

        internal static JsonElement ParseValue(ReadOnlySpan<byte> utf8Json, JsonDocumentOptions options)
        {
            JsonDocument jsonDocument = JsonDocument.ParseValue(utf8Json, options);
            return jsonDocument.RootElement;
        }

        internal static JsonElement ParseValue(string json, JsonDocumentOptions options)
        {
            JsonDocument jsonDocument = JsonDocument.ParseValue(json, options);
            return jsonDocument.RootElement;
        }

        /// <summary>
        ///   Attempts to parse one JSON value (including objects or arrays) from the provided reader.
        /// </summary>
        /// <param name="reader">The reader to read.</param>
        /// <param name="element">Receives the parsed element.</param>
        /// <returns>
        ///   <see langword="true" /> if a value was read and parsed into a JsonElement;
        ///   <see langword="false" /> if the reader ran out of data while parsing.
        ///   All other situations result in an exception being thrown.
        /// </returns>
        /// <remarks>
        ///   <para>
        ///     If the <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> property of <paramref name="reader" />
        ///     is <see cref="F:System.Text.Json.JsonTokenType.PropertyName" /> or <see cref="F:System.Text.Json.JsonTokenType.None" />, the
        ///     reader will be advanced by one call to <see cref="M:System.Text.Json.Utf8JsonReader.Read" /> to determine
        ///     the start of the value.
        ///   </para>
        ///
        ///   <para>
        ///     Upon completion of this method, <paramref name="reader" /> will be positioned at the
        ///     final token in the JSON value.  If an exception is thrown, or <see langword="false" />
        ///     is returned, the reader is reset to the state it was in when the method was called.
        ///   </para>
        ///
        ///   <para>
        ///     This method makes a copy of the data the reader acted on, so there is no caller
        ///     requirement to maintain data integrity beyond the return of this method.
        ///   </para>
        /// </remarks>
        /// <exception cref="T:System.ArgumentException">
        ///   <paramref name="reader" /> is using unsupported options.
        /// </exception>
        /// <exception cref="T:System.ArgumentException">
        ///   The current <paramref name="reader" /> token does not start or represent a value.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        ///   A value could not be read from the reader.
        /// </exception>
        public static bool TryParseValue(ref Utf8JsonReader reader, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out JsonElement? element)
        {
            JsonDocument document;
            bool result = JsonDocument.TryParseValue(ref reader, out document, shouldThrow: false, useArrayPools: false);
            element = document?.RootElement;
            return result;
        }
    }

    /// <summary>
	/// Provides a way to transform UTF-8 or UTF-16 encoded text into a form that is suitable for JSON.
	/// </summary>
	/// <remarks>
	/// This can be used to cache and store known strings used for writing JSON ahead of time by pre-encoding them up front.
	/// </remarks>
	public readonly struct JsonEncodedText : IEquatable<JsonEncodedText>
    {
        internal readonly byte[] _utf8Value;

        internal readonly string _value;

        /// <summary>
        /// Returns the UTF-8 encoded representation of the pre-encoded JSON text.
        /// </summary>
        public ReadOnlySpan<byte> EncodedUtf8Bytes => _utf8Value;

        private JsonEncodedText(byte[] utf8Value)
        {
            _value = JsonReaderHelper.GetTextFromUtf8(utf8Value);
            _utf8Value = utf8Value;
        }

        /// <summary>
        /// Encodes the string text value as a JSON string.
        /// </summary>
        /// <param name="value">The value to be transformed as JSON encoded text.</param>
        /// <param name="encoder">The encoder to use when escaping the string, or <see langword="null" /> to use the default encoder.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// Thrown if value is null.
        /// </exception>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified value is too large or if it contains invalid UTF-16 characters.
        /// </exception>
        public static JsonEncodedText Encode(string value, JavaScriptEncoder? encoder = null)
        {
            if (value == null)
            {
                ThrowHelper.ThrowArgumentNullException("value");
            }
            return Encode(value.AsSpan(), encoder);
        }

        /// <summary>
        /// Encodes the text value as a JSON string.
        /// </summary>
        /// <param name="value">The value to be transformed as JSON encoded text.</param>
        /// <param name="encoder">The encoder to use when escaping the string, or <see langword="null" /> to use the default encoder.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified value is too large or if it contains invalid UTF-16 characters.
        /// </exception>
        public static JsonEncodedText Encode(ReadOnlySpan<char> value, JavaScriptEncoder? encoder = null)
        {
            if (value.Length == 0)
            {
                return new JsonEncodedText(Array.Empty<byte>());
            }
            return TranscodeAndEncode(value, encoder);
        }

        private static JsonEncodedText TranscodeAndEncode(ReadOnlySpan<char> value, JavaScriptEncoder encoder)
        {
            JsonWriterHelper.ValidateValue(value);
            int utf8ByteCount = JsonReaderHelper.GetUtf8ByteCount(value);
            byte[] array = ArrayPool<byte>.Shared.Rent(utf8ByteCount);
            int utf8FromText = JsonReaderHelper.GetUtf8FromText(value, array);
            JsonEncodedText result = EncodeHelper(array.AsSpan(0, utf8FromText), encoder);
            array.AsSpan(0, utf8ByteCount).Clear();
            ArrayPool<byte>.Shared.Return(array);
            return result;
        }

        /// <summary>
        /// Encodes the UTF-8 text value as a JSON string.
        /// </summary>
        /// <param name="utf8Value">The UTF-8 encoded value to be transformed as JSON encoded text.</param>
        /// <param name="encoder">The encoder to use when escaping the string, or <see langword="null" /> to use the default encoder.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified value is too large or if it contains invalid UTF-8 bytes.
        /// </exception>
        public static JsonEncodedText Encode(ReadOnlySpan<byte> utf8Value, JavaScriptEncoder? encoder = null)
        {
            if (utf8Value.Length == 0)
            {
                return new JsonEncodedText(Array.Empty<byte>());
            }
            JsonWriterHelper.ValidateValue(utf8Value);
            return EncodeHelper(utf8Value, encoder);
        }

        private static JsonEncodedText EncodeHelper(ReadOnlySpan<byte> utf8Value, JavaScriptEncoder encoder)
        {
            int num = JsonWriterHelper.NeedsEscaping(utf8Value, encoder);
            if (num != -1)
            {
                return new JsonEncodedText(JsonHelpers.EscapeValue(utf8Value, num, encoder));
            }
            return new JsonEncodedText(utf8Value.ToArray());
        }

        /// <summary>
        /// Determines whether this instance and another specified <see cref="T:System.Text.Json.JsonEncodedText" /> instance have the same value.
        /// </summary>
        /// <remarks>
        /// Default instances of <see cref="T:System.Text.Json.JsonEncodedText" /> are treated as equal.
        /// </remarks>
        public bool Equals(JsonEncodedText other)
        {
            if (_value == null)
            {
                return other._value == null;
            }
            return _value.Equals(other._value);
        }

        /// <summary>
        /// Determines whether this instance and a specified object, which must also be a <see cref="T:System.Text.Json.JsonEncodedText" /> instance, have the same value.
        /// </summary>
        /// <remarks>
        /// If <paramref name="obj" /> is null, the method returns false.
        /// </remarks>
        public override bool Equals([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] object? obj)
        {
            if (obj is JsonEncodedText other)
            {
                return Equals(other);
            }
            return false;
        }

        /// <summary>
        /// Converts the value of this instance to a <see cref="T:System.String" />.
        /// </summary>
        /// <remarks>
        /// Returns an empty string on a default instance of <see cref="T:System.Text.Json.JsonEncodedText" />.
        /// </remarks>
        /// <returns>
        /// Returns the underlying UTF-16 encoded string.
        /// </returns>
        public override string ToString()
        {
            return _value ?? string.Empty;
        }

        /// <summary>
        /// Returns the hash code for this <see cref="T:System.Text.Json.JsonEncodedText" />.
        /// </summary>
        /// <remarks>
        /// Returns 0 on a default instance of <see cref="T:System.Text.Json.JsonEncodedText" />.
        /// </remarks>
        public override int GetHashCode()
        {
            if (_value != null)
            {
                return _value.GetHashCode();
            }
            return 0;
        }
    }

    /// <summary>
	/// Defines a custom exception object that is thrown when invalid JSON text is encountered, when the defined maximum depth is passed,
	/// or the JSON text is not compatible with the type of a property on an object.
	/// </summary>
	[Serializable]
    public class JsonException : Exception
    {
        internal string _message;

        /// <summary>
        /// Specifies that 'try' logic should append Path information to the exception message.
        /// </summary>
        internal bool AppendPathInformation { get; set; }

        /// <summary>
        /// The number of lines read so far before the exception (starting at 0).
        /// </summary>
        public long? LineNumber { get; internal set; }

        /// <summary>
        /// The number of bytes read within the current line before the exception (starting at 0).
        /// </summary>
        public long? BytePositionInLine { get; internal set; }

        /// <summary>
        /// The path within the JSON where the exception was encountered.
        /// </summary>
        public string? Path { get; internal set; }

        /// <summary>
        /// Gets a message that describes the current exception.
        /// </summary>
        public override string Message => _message ?? base.Message;

        /// <summary>
        /// Creates a new exception object to relay error information to the user.
        /// </summary>
        /// <param name="message">The context specific error message.</param>
        /// <param name="lineNumber">The line number at which the invalid JSON was encountered (starting at 0) when deserializing.</param>
        /// <param name="bytePositionInLine">The byte count within the current line where the invalid JSON was encountered (starting at 0).</param>
        /// <param name="path">The path where the invalid JSON was encountered.</param>
        /// <param name="innerException">The exception that caused the current exception.</param>
        /// <remarks>
        /// Note that the <paramref name="bytePositionInLine" /> counts the number of bytes (i.e. UTF-8 code units) and not characters or scalars.
        /// </remarks>
        public JsonException(string? message, string? path, long? lineNumber, long? bytePositionInLine, Exception? innerException)
            : base(message, innerException)
        {
            _message = message;
            LineNumber = lineNumber;
            BytePositionInLine = bytePositionInLine;
            Path = path;
        }

        /// <summary>
        /// Creates a new exception object to relay error information to the user.
        /// </summary>
        /// <param name="message">The context specific error message.</param>
        /// <param name="path">The path where the invalid JSON was encountered.</param>
        /// <param name="lineNumber">The line number at which the invalid JSON was encountered (starting at 0) when deserializing.</param>
        /// <param name="bytePositionInLine">The byte count within the current line where the invalid JSON was encountered (starting at 0).</param>
        /// <remarks>
        /// Note that the <paramref name="bytePositionInLine" /> counts the number of bytes (i.e. UTF-8 code units) and not characters or scalars.
        /// </remarks>
        public JsonException(string? message, string? path, long? lineNumber, long? bytePositionInLine)
            : base(message)
        {
            _message = message;
            LineNumber = lineNumber;
            BytePositionInLine = bytePositionInLine;
            Path = path;
        }

        /// <summary>
        /// Creates a new exception object to relay error information to the user.
        /// </summary>
        /// <param name="message">The context specific error message.</param>
        /// <param name="innerException">The exception that caused the current exception.</param>
        public JsonException(string? message, Exception? innerException)
            : base(message, innerException)
        {
            _message = message;
        }

        /// <summary>
        /// Creates a new exception object to relay error information to the user.
        /// </summary>
        /// <param name="message">The context specific error message.</param>
        public JsonException(string? message)
            : base(message)
        {
            _message = message;
        }

        /// <summary>
        /// Creates a new exception object to relay error information to the user.
        /// </summary>
        public JsonException()
        {
        }

        /// <summary>
        /// Creates a new exception object with serialized data.
        /// </summary>
        /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// Thrown when <paramref name="info" /> is <see langword="null" />.
        /// </exception>
        protected JsonException(SerializationInfo info, StreamingContext context)
            : base(info, context)
        {
            LineNumber = (long?)info.GetValue("LineNumber", typeof(long?));
            BytePositionInLine = (long?)info.GetValue("BytePositionInLine", typeof(long?));
            Path = info.GetString("Path");
            SetMessage(info.GetString("ActualMessage"));
        }

        /// <summary>
        ///  Sets the <see cref="T:System.Runtime.Serialization.SerializationInfo" /> with information about the exception.
        /// </summary>
        /// <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
        /// <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
        public override void GetObjectData(SerializationInfo info, StreamingContext context)
        {
            base.GetObjectData(info, context);
            info.AddValue("LineNumber", LineNumber, typeof(long?));
            info.AddValue("BytePositionInLine", BytePositionInLine, typeof(long?));
            info.AddValue("Path", Path, typeof(string));
            info.AddValue("ActualMessage", Message, typeof(string));
        }

        internal void SetMessage(string message)
        {
            _message = message;
        }
    }

    internal static class JsonHelpers
    {
        [StructLayout(LayoutKind.Auto)]
        private struct DateTimeParseData
        {
            public int Year;

            public int Month;

            public int Day;

            public bool IsCalendarDateOnly;

            public int Hour;

            public int Minute;

            public int Second;

            public int Fraction;

            public int OffsetHours;

            public int OffsetMinutes;

            public byte OffsetToken;

            public bool OffsetNegative => OffsetToken == 45;
        }

        private static readonly int[] s_daysToMonth365 = new int[13] { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365 };

        private static readonly int[] s_daysToMonth366 = new int[13] { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366 };

        /// <summary>
        /// Emulates Dictionary.TryAdd on netstandard.
        /// </summary>
        public static bool TryAdd<TKey, TValue>(this Dictionary<TKey, TValue> dictionary, in TKey key, in TValue value)
        {
            if (!dictionary.ContainsKey(key))
            {
                dictionary[key] = value;
                return true;
            }
            return false;
        }

        /// <summary>
        /// Provides an in-place, stable sorting implementation for List.
        /// </summary>
        internal static void StableSortByKey<T, TKey>(this List<T> items, Func<T, TKey> keySelector) where TKey : unmanaged, IComparable<TKey>
        {
            T[] array = items.ToArray();
            (TKey, int)[] array2 = new (TKey, int)[array.Length];
            for (int i = 0; i < array2.Length; i++)
            {
                array2[i] = (keySelector(array[i]), i);
            }
            Array.Sort(array2, array);
            items.Clear();
            items.AddRange(array);
        }

        /// <summary>
        /// Returns the span for the given reader.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ReadOnlySpan<byte> GetSpan( this ref Utf8JsonReader reader)
        {
            if (!reader.HasValueSequence)
            {
                return reader.ValueSpan;
            }
            ReadOnlySequence<byte> sequence = reader.ValueSequence;
            return BuffersExtensions.ToArray(in sequence);
        }

        /// <summary>
        /// Returns <see langword="true" /> if <paramref name="value" /> is a valid Unicode scalar
        /// value, i.e., is in [ U+0000..U+D7FF ], inclusive; or [ U+E000..U+10FFFF ], inclusive.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsValidUnicodeScalar(uint value)
        {
            return IsInRangeInclusive(value ^ 0xD800u, 2048u, 1114111u);
        }

        /// <summary>
        /// Returns <see langword="true" /> if <paramref name="value" /> is between
        /// <paramref name="lowerBound" /> and <paramref name="upperBound" />, inclusive.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsInRangeInclusive(uint value, uint lowerBound, uint upperBound)
        {
            return value - lowerBound <= upperBound - lowerBound;
        }

        /// <summary>
        /// Returns <see langword="true" /> if <paramref name="value" /> is between
        /// <paramref name="lowerBound" /> and <paramref name="upperBound" />, inclusive.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsInRangeInclusive(int value, int lowerBound, int upperBound)
        {
            return (uint)(value - lowerBound) <= (uint)(upperBound - lowerBound);
        }

        /// <summary>
        /// Returns <see langword="true" /> if <paramref name="value" /> is between
        /// <paramref name="lowerBound" /> and <paramref name="upperBound" />, inclusive.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsInRangeInclusive(long value, long lowerBound, long upperBound)
        {
            return (ulong)(value - lowerBound) <= (ulong)(upperBound - lowerBound);
        }

        /// <summary>
        /// Returns <see langword="true" /> if <paramref name="value" /> is between
        /// <paramref name="lowerBound" /> and <paramref name="upperBound" />, inclusive.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsInRangeInclusive(JsonTokenType value, JsonTokenType lowerBound, JsonTokenType upperBound)
        {
            return value - lowerBound <= upperBound - lowerBound;
        }

        /// <summary>
        /// Returns <see langword="true" /> if <paramref name="value" /> is in the range [0..9].
        /// Otherwise, returns <see langword="false" />.
        /// </summary>
        public static bool IsDigit(byte value)
        {
            return (uint)(value - 48) <= 9u;
        }

        /// <summary>
        /// Perform a Read() with a Debug.Assert verifying the reader did not return false.
        /// This should be called when the Read() return value is not used, such as non-Stream cases where there is only one buffer.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ReadWithVerify(this ref Utf8JsonReader reader)
        {
            bool flag = reader.Read();
        }

        /// <summary>
        /// Calls Encoding.UTF8.GetString that supports netstandard.
        /// </summary>
        /// <param name="bytes">The utf8 bytes to convert.</param>
        /// <returns></returns>
        public static string Utf8GetString(ReadOnlySpan<byte> bytes)
        {
            return Encoding.UTF8.GetString(bytes.ToArray());
        }

        /// <summary>
        /// Emulates Dictionary(IEnumerable{KeyValuePair}) on netstandard.
        /// </summary>
        public static Dictionary<TKey, TValue> CreateDictionaryFromCollection<TKey, TValue>(IEnumerable<KeyValuePair<TKey, TValue>> collection, IEqualityComparer<TKey> comparer)
        {
            Dictionary<TKey, TValue> dictionary = new Dictionary<TKey, TValue>(comparer);
            foreach (KeyValuePair<TKey, TValue> item in collection)
            {
                dictionary.Add(item.Key, item.Value);
            }
            return dictionary;
        }

        public static bool IsFinite(double value)
        {
            if (!double.IsNaN(value))
            {
                return !double.IsInfinity(value);
            }
            return false;
        }

        public static bool IsFinite(float value)
        {
            if (!float.IsNaN(value))
            {
                return !float.IsInfinity(value);
            }
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ValidateInt32MaxArrayLength(uint length)
        {
            if (length > 2146435071)
            {
                ThrowHelper.ThrowOutOfMemoryException(length);
            }
        }

        public static bool AllBitsEqual(this BitArray bitArray, bool value)
        {
            for (int i = 0; i < bitArray.Count; i++)
            {
                if (bitArray[i] != value)
                {
                    return false;
                }
            }
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsValidDateTimeOffsetParseLength(int length)
        {
            return IsInRangeInclusive(length, 10, 252);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsValidUnescapedDateTimeOffsetParseLength(int length)
        {
            return IsInRangeInclusive(length, 10, 42);
        }

        /// <summary>
        /// Parse the given UTF-8 <paramref name="source" /> as extended ISO 8601 format.
        /// </summary>
        /// <param name="source">UTF-8 source to parse.</param>
        /// <param name="value">The parsed <see cref="T:System.DateTime" /> if successful.</param>
        /// <returns>"true" if successfully parsed.</returns>
        public static bool TryParseAsISO(ReadOnlySpan<byte> source, out DateTime value)
        {
            if (!TryParseDateTimeOffset(source, out var parseData))
            {
                value = default(DateTime);
                return false;
            }
            if (parseData.OffsetToken == 90)
            {
                return TryCreateDateTime(parseData, DateTimeKind.Utc, out value);
            }
            if (parseData.OffsetToken == 43 || parseData.OffsetToken == 45)
            {
                if (!TryCreateDateTimeOffset(ref parseData, out var value2))
                {
                    value = default(DateTime);
                    return false;
                }
                value = value2.LocalDateTime;
                return true;
            }
            return TryCreateDateTime(parseData, DateTimeKind.Unspecified, out value);
        }

        /// <summary>
        /// Parse the given UTF-8 <paramref name="source" /> as extended ISO 8601 format.
        /// </summary>
        /// <param name="source">UTF-8 source to parse.</param>
        /// <param name="value">The parsed <see cref="T:System.DateTimeOffset" /> if successful.</param>
        /// <returns>"true" if successfully parsed.</returns>
        public static bool TryParseAsISO(ReadOnlySpan<byte> source, out DateTimeOffset value)
        {
            if (!TryParseDateTimeOffset(source, out var parseData))
            {
                value = default(DateTimeOffset);
                return false;
            }
            if (parseData.OffsetToken == 90 || parseData.OffsetToken == 43 || parseData.OffsetToken == 45)
            {
                return TryCreateDateTimeOffset(ref parseData, out value);
            }
            return TryCreateDateTimeOffsetInterpretingDataAsLocalTime(parseData, out value);
        }

        /// <summary>
        /// ISO 8601 date time parser (ISO 8601-1:2019).
        /// </summary>
        /// <param name="source">The date/time to parse in UTF-8 format.</param>
        /// <param name="parseData">The parsed <see cref="T:System.Text.Json.JsonHelpers.DateTimeParseData" /> for the given <paramref name="source" />.</param>
        /// <remarks>
        /// Supports extended calendar date (5.2.2.1) and complete (5.4.2.1) calendar date/time of day
        /// representations with optional specification of seconds and fractional seconds.
        ///
        /// Times can be explicitly specified as UTC ("Z" - 5.3.3) or offsets from UTC ("+/-hh:mm" 5.3.4.2).
        /// If unspecified they are considered to be local per spec.
        ///
        /// Examples: (TZD is either "Z" or hh:mm offset from UTC)
        ///
        ///  YYYY-MM-DD               (eg 1997-07-16)
        ///  YYYY-MM-DDThh:mm         (eg 1997-07-16T19:20)
        ///  YYYY-MM-DDThh:mm:ss      (eg 1997-07-16T19:20:30)
        ///  YYYY-MM-DDThh:mm:ss.s    (eg 1997-07-16T19:20:30.45)
        ///  YYYY-MM-DDThh:mmTZD      (eg 1997-07-16T19:20+01:00)
        ///  YYYY-MM-DDThh:mm:ssTZD   (eg 1997-07-16T19:20:3001:00)
        ///  YYYY-MM-DDThh:mm:ss.sTZD (eg 1997-07-16T19:20:30.45Z)
        ///
        /// Generally speaking we always require the "extended" option when one exists (3.1.3.5).
        /// The extended variants have separator characters between components ('-', ':', '.', etc.).
        /// Spaces are not permitted.
        /// </remarks>
        /// <returns>"true" if successfully parsed.</returns>
        private static bool TryParseDateTimeOffset(ReadOnlySpan<byte> source, out DateTimeParseData parseData)
        {
            parseData = default(DateTimeParseData);
            uint num = (uint)(source[0] - 48);
            uint num2 = (uint)(source[1] - 48);
            uint num3 = (uint)(source[2] - 48);
            uint num4 = (uint)(source[3] - 48);
            if (num > 9 || num2 > 9 || num3 > 9 || num4 > 9)
            {
                return false;
            }
            parseData.Year = (int)(num * 1000 + num2 * 100 + num3 * 10 + num4);
            if (source[4] != 45 || !TryGetNextTwoDigits(source.Slice(5, 2), ref parseData.Month) || source[7] != 45 || !TryGetNextTwoDigits(source.Slice(8, 2), ref parseData.Day))
            {
                return false;
            }
            if (source.Length == 10)
            {
                parseData.IsCalendarDateOnly = true;
                return true;
            }
            if (source.Length < 16)
            {
                return false;
            }
            if (source[10] != 84 || source[13] != 58 || !TryGetNextTwoDigits(source.Slice(11, 2), ref parseData.Hour) || !TryGetNextTwoDigits(source.Slice(14, 2), ref parseData.Minute))
            {
                return false;
            }
            if (source.Length == 16)
            {
                return true;
            }
            byte b = source[16];
            int num5 = 17;
            switch (b)
            {
                case 90:
                    parseData.OffsetToken = 90;
                    return num5 == source.Length;
                case 43:
                case 45:
                    parseData.OffsetToken = b;
                    return ParseOffset(ref parseData, source.Slice(num5));
                default:
                    return false;
                case 58:
                    if (source.Length < 19 || !TryGetNextTwoDigits(source.Slice(17, 2), ref parseData.Second))
                    {
                        return false;
                    }
                    if (source.Length == 19)
                    {
                        return true;
                    }
                    b = source[19];
                    num5 = 20;
                    switch (b)
                    {
                        case 90:
                            parseData.OffsetToken = 90;
                            return num5 == source.Length;
                        case 43:
                        case 45:
                            parseData.OffsetToken = b;
                            return ParseOffset(ref parseData, source.Slice(num5));
                        default:
                            return false;
                        case 46:
                            {
                                if (source.Length < 21)
                                {
                                    return false;
                                }
                                int i = 0;
                                for (int num6 = Math.Min(num5 + 16, source.Length); num5 < num6; num5++)
                                {
                                    if (!IsDigit(b = source[num5]))
                                    {
                                        break;
                                    }
                                    if (i < 7)
                                    {
                                        parseData.Fraction = parseData.Fraction * 10 + (b - 48);
                                        i++;
                                    }
                                }
                                if (parseData.Fraction != 0)
                                {
                                    for (; i < 7; i++)
                                    {
                                        parseData.Fraction *= 10;
                                    }
                                }
                                if (num5 == source.Length)
                                {
                                    return true;
                                }
                                b = source[num5++];
                                switch (b)
                                {
                                    case 90:
                                        parseData.OffsetToken = 90;
                                        return num5 == source.Length;
                                    case 43:
                                    case 45:
                                        parseData.OffsetToken = b;
                                        return ParseOffset(ref parseData, source.Slice(num5));
                                    default:
                                        return false;
                                }
                            }
                    }
            }
            static bool ParseOffset(ref DateTimeParseData parseData, ReadOnlySpan<byte> offsetData)
            {
                if (offsetData.Length < 2 || !TryGetNextTwoDigits(offsetData.Slice(0, 2), ref parseData.OffsetHours))
                {
                    return false;
                }
                if (offsetData.Length == 2)
                {
                    return true;
                }
                if (offsetData.Length != 5 || offsetData[2] != 58 || !TryGetNextTwoDigits(offsetData.Slice(3), ref parseData.OffsetMinutes))
                {
                    return false;
                }
                return true;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool TryGetNextTwoDigits(ReadOnlySpan<byte> source, ref int value)
        {
            uint num = (uint)(source[0] - 48);
            uint num2 = (uint)(source[1] - 48);
            if (num > 9 || num2 > 9)
            {
                value = 0;
                return false;
            }
            value = (int)(num * 10 + num2);
            return true;
        }

        /// <summary>
        /// Overflow-safe DateTimeOffset factory.
        /// </summary>
        private static bool TryCreateDateTimeOffset(DateTime dateTime, ref DateTimeParseData parseData, out DateTimeOffset value)
        {
            if ((uint)parseData.OffsetHours > 14u)
            {
                value = default(DateTimeOffset);
                return false;
            }
            if ((uint)parseData.OffsetMinutes > 59u)
            {
                value = default(DateTimeOffset);
                return false;
            }
            if (parseData.OffsetHours == 14 && parseData.OffsetMinutes != 0)
            {
                value = default(DateTimeOffset);
                return false;
            }
            long num = ((long)parseData.OffsetHours * 3600L + (long)parseData.OffsetMinutes * 60L) * 10000000;
            if (parseData.OffsetNegative)
            {
                num = -num;
            }
            try
            {
                value = new DateTimeOffset(dateTime.Ticks, new TimeSpan(num));
            }
            catch (ArgumentOutOfRangeException)
            {
                value = default(DateTimeOffset);
                return false;
            }
            return true;
        }

        /// <summary>
        /// Overflow-safe DateTimeOffset factory.
        /// </summary>
        private static bool TryCreateDateTimeOffset(ref DateTimeParseData parseData, out DateTimeOffset value)
        {
            if (!TryCreateDateTime(parseData, DateTimeKind.Unspecified, out var value2))
            {
                value = default(DateTimeOffset);
                return false;
            }
            if (!TryCreateDateTimeOffset(value2, ref parseData, out value))
            {
                value = default(DateTimeOffset);
                return false;
            }
            return true;
        }

        /// <summary>
        /// Overflow-safe DateTimeOffset/Local time conversion factory.
        /// </summary>
        private static bool TryCreateDateTimeOffsetInterpretingDataAsLocalTime(DateTimeParseData parseData, out DateTimeOffset value)
        {
            if (!TryCreateDateTime(parseData, DateTimeKind.Local, out var value2))
            {
                value = default(DateTimeOffset);
                return false;
            }
            try
            {
                value = new DateTimeOffset(value2);
            }
            catch (ArgumentOutOfRangeException)
            {
                value = default(DateTimeOffset);
                return false;
            }
            return true;
        }

        /// <summary>
        /// Overflow-safe DateTime factory.
        /// </summary>
        private static bool TryCreateDateTime(DateTimeParseData parseData, DateTimeKind kind, out DateTime value)
        {
            if (parseData.Year == 0)
            {
                value = default(DateTime);
                return false;
            }
            if ((uint)(parseData.Month - 1) >= 12u)
            {
                value = default(DateTime);
                return false;
            }
            uint num = (uint)(parseData.Day - 1);
            if (num >= 28 && num >= DateTime.DaysInMonth(parseData.Year, parseData.Month))
            {
                value = default(DateTime);
                return false;
            }
            if ((uint)parseData.Hour > 23u)
            {
                value = default(DateTime);
                return false;
            }
            if ((uint)parseData.Minute > 59u)
            {
                value = default(DateTime);
                return false;
            }
            if ((uint)parseData.Second > 59u)
            {
                value = default(DateTime);
                return false;
            }
            int[] array = (DateTime.IsLeapYear(parseData.Year) ? s_daysToMonth366 : s_daysToMonth365);
            int num2 = parseData.Year - 1;
            int num3 = num2 * 365 + num2 / 4 - num2 / 100 + num2 / 400 + array[parseData.Month - 1] + parseData.Day - 1;
            long num4 = num3 * 864000000000L;
            int num5 = parseData.Hour * 3600 + parseData.Minute * 60 + parseData.Second;
            num4 += (long)num5 * 10000000L;
            num4 += parseData.Fraction;
            value = new DateTime(num4, kind);
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte[] GetEscapedPropertyNameSection(ReadOnlySpan<byte> utf8Value, JavaScriptEncoder encoder)
        {
            int num = JsonWriterHelper.NeedsEscaping(utf8Value, encoder);
            if (num != -1)
            {
                return GetEscapedPropertyNameSection(utf8Value, num, encoder);
            }
            return GetPropertyNameSection(utf8Value);
        }

        public static byte[] EscapeValue(ReadOnlySpan<byte> utf8Value, int firstEscapeIndexVal, JavaScriptEncoder encoder)
        {
            byte[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8Value.Length, firstEscapeIndexVal);
            Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
            Span<byte> destination = span;
            JsonWriterHelper.EscapeString(utf8Value, destination, firstEscapeIndexVal, encoder, out var written);
            byte[] result = destination.Slice(0, written).ToArray();
            if (array != null)
            {
                ArrayPool<byte>.Shared.Return(array);
            }
            return result;
        }

        private static byte[] GetEscapedPropertyNameSection(ReadOnlySpan<byte> utf8Value, int firstEscapeIndexVal, JavaScriptEncoder encoder)
        {
            byte[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8Value.Length, firstEscapeIndexVal);
            Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
            Span<byte> destination = span;
            JsonWriterHelper.EscapeString(utf8Value, destination, firstEscapeIndexVal, encoder, out var written);
            byte[] propertyNameSection = GetPropertyNameSection(destination.Slice(0, written));
            if (array != null)
            {
                ArrayPool<byte>.Shared.Return(array);
            }
            return propertyNameSection;
        }

        private static byte[] GetPropertyNameSection(ReadOnlySpan<byte> utf8Value)
        {
            int length = utf8Value.Length;
            byte[] array = new byte[length + 3];
            array[0] = 34;
            utf8Value.CopyTo(array.AsSpan(1, length));
            array[++length] = 34;
            array[++length] = 58;
            return array;
        }
    }

    /// <summary>
	/// Determines the naming policy used to convert a string-based name to another format, such as a camel-casing format.
	/// </summary>
	public abstract class JsonNamingPolicy
    {
        /// <summary>
        /// Returns the naming policy for camel-casing.
        /// </summary>
        public static JsonNamingPolicy CamelCase { get; } = new JsonCamelCaseNamingPolicy();


        /// <summary>
        /// Initializes a new instance of <see cref="T:System.Text.Json.JsonNamingPolicy" />.
        /// </summary>
        protected JsonNamingPolicy()
        {
        }

        /// <summary>
        /// When overridden in a derived class, converts the specified name according to the policy.
        /// </summary>
        /// <param name="name">The name to convert.</param>
        /// <returns>The converted name.</returns>
        public abstract string ConvertName(string name);
    }

    /// <summary>
	///   Represents a single property for a JSON object.
	/// </summary>
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
    public readonly struct JsonProperty
    {
        /// <summary>
        ///   The value of this property.
        /// </summary>
        public JsonElement Value { get; }

        private string? _name { get; }

        /// <summary>
        ///   The name of this property.
        /// </summary>
        public string Name => _name ?? Value.GetPropertyName();

        private string DebuggerDisplay
        {
            get
            {
                if (Value.ValueKind != 0)
                {
                    return "\"" + ToString() + "\"";
                }
                return "<Undefined>";
            }
        }

        internal JsonProperty(JsonElement value, string name = null)
        {
            Value = value;
            _name = name;
        }

        /// <summary>
        ///   Compares <paramref name="text" /> to the name of this property.
        /// </summary>
        /// <param name="text">The text to compare against.</param>
        /// <returns>
        ///   <see langword="true" /> if the name of this property matches <paramref name="text" />,
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="T:System.Type" /> is not <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />.
        /// </exception>
        /// <remarks>
        ///   This method is functionally equal to doing an ordinal comparison of <paramref name="text" /> and
        ///   <see cref="P:System.Text.Json.JsonProperty.Name" />, but can avoid creating the string instance.
        /// </remarks>
        public bool NameEquals(string? text)
        {
            return NameEquals(text.AsSpan());
        }

        /// <summary>
        ///   Compares the text represented by <paramref name="utf8Text" /> to the name of this property.
        /// </summary>
        /// <param name="utf8Text">The UTF-8 encoded text to compare against.</param>
        /// <returns>
        ///   <see langword="true" /> if the name of this property has the same UTF-8 encoding as
        ///   <paramref name="utf8Text" />, <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="T:System.Type" /> is not <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />.
        /// </exception>
        /// <remarks>
        ///   This method is functionally equal to doing an ordinal comparison of <paramref name="utf8Text" /> and
        ///   <see cref="P:System.Text.Json.JsonProperty.Name" />, but can avoid creating the string instance.
        /// </remarks>
        public bool NameEquals(ReadOnlySpan<byte> utf8Text)
        {
            return Value.TextEqualsHelper(utf8Text, isPropertyName: true, shouldUnescape: true);
        }

        /// <summary>
        ///   Compares <paramref name="text" /> to the name of this property.
        /// </summary>
        /// <param name="text">The text to compare against.</param>
        /// <returns>
        ///   <see langword="true" /> if the name of this property matches <paramref name="text" />,
        ///   <see langword="false" /> otherwise.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This value's <see cref="T:System.Type" /> is not <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />.
        /// </exception>
        /// <remarks>
        ///   This method is functionally equal to doing an ordinal comparison of <paramref name="text" /> and
        ///   <see cref="P:System.Text.Json.JsonProperty.Name" />, but can avoid creating the string instance.
        /// </remarks>
        public bool NameEquals(ReadOnlySpan<char> text)
        {
            return Value.TextEqualsHelper(text, isPropertyName: true);
        }

        internal bool EscapedNameEquals(ReadOnlySpan<byte> utf8Text)
        {
            return Value.TextEqualsHelper(utf8Text, isPropertyName: true, shouldUnescape: false);
        }

        /// <summary>
        ///   Write the property into the provided writer as a named JSON object property.
        /// </summary>
        /// <param name="writer">The writer.</param>
        /// <exception cref="T:System.ArgumentNullException">
        ///   The <paramref name="writer" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.ArgumentException">
        ///   This <see cref="P:System.Text.Json.JsonProperty.Name" />'s length is too large to be a JSON object property.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        ///   This <see cref="P:System.Text.Json.JsonProperty.Value" />'s <see cref="P:System.Text.Json.JsonElement.ValueKind" /> would result in an invalid JSON.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The parent <see cref="T:System.Text.Json.JsonDocument" /> has been disposed.
        /// </exception>&gt;
        public void WriteTo(Utf8JsonWriter writer)
        {
            if (writer == null)
            {
                ThrowHelper.ThrowArgumentNullException("writer");
            }
            writer.WritePropertyName(Name);
            Value.WriteTo(writer);
        }

        /// <summary>
        ///   Provides a <see cref="T:System.String" /> representation of the property for
        ///   debugging purposes.
        /// </summary>
        /// <returns>
        ///   A string containing the un-interpreted value of the property, beginning
        ///   at the declaring open-quote and ending at the last character that is part of
        ///   the value.
        /// </returns>
        public override string ToString()
        {
            return Value.GetPropertyRawText();
        }
    }

    /// <summary>
	/// Keeps both a List and Dictionary in sync to enable deterministic enumeration ordering of List
	/// and performance benefits of Dictionary once a threshold is hit.
	/// </summary>
	internal sealed class JsonPropertyDictionary<T> where T : class
    {
        private sealed class KeyCollection : IList<string>, ICollection<string>, IEnumerable<string>, IEnumerable
        {
            private readonly JsonPropertyDictionary<T> _parent;

            public int Count => _parent.Count;

            public bool IsReadOnly => true;

            public string this[int index]
            {
                get
                {
                    return _parent.List[index].Key;
                }
                set
                {
                    throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
                }
            }

            public KeyCollection(JsonPropertyDictionary<T> jsonObject)
            {
                _parent = jsonObject;
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                foreach (KeyValuePair<string, T> item in _parent)
                {
                    yield return item.Key;
                }
            }

            public void Add(string propertyName)
            {
                ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
            }

            public void Clear()
            {
                ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
            }

            public bool Contains(string propertyName)
            {
                return _parent.ContainsProperty(propertyName);
            }

            public void CopyTo(string[] propertyNameArray, int index)
            {
                if (index < 0)
                {
                    ThrowHelper.ThrowArgumentOutOfRangeException_ArrayIndexNegative("index");
                }
                foreach (KeyValuePair<string, T> item in _parent)
                {
                    if (index >= propertyNameArray.Length)
                    {
                        ThrowHelper.ThrowArgumentException_ArrayTooSmall("propertyNameArray");
                    }
                    propertyNameArray[index++] = item.Key;
                }
            }

            public IEnumerator<string> GetEnumerator()
            {
                foreach (KeyValuePair<string, T> item in _parent)
                {
                    yield return item.Key;
                }
            }

            bool ICollection<string>.Remove(string propertyName)
            {
                throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
            }

            public int IndexOf(string item)
            {
                throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
            }

            public void Insert(int index, string item)
            {
                throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
            }

            public void RemoveAt(int index)
            {
                throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
            }
        }

        private sealed class ValueCollection : IList<T>, ICollection<T>, IEnumerable<T>, IEnumerable
        {
            private readonly JsonPropertyDictionary<T> _parent;

            public int Count => _parent.Count;

            public bool IsReadOnly => true;

            public T this[int index]
            {
                get
                {
                    return _parent.List[index].Value;
                }
                set
                {
                    throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
                }
            }

            public ValueCollection(JsonPropertyDictionary<T> jsonObject)
            {
                _parent = jsonObject;
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                foreach (KeyValuePair<string, T> item in _parent)
                {
                    yield return item.Value;
                }
            }

            public void Add(T jsonNode)
            {
                ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
            }

            public void Clear()
            {
                ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
            }

            public bool Contains(T jsonNode)
            {
                return _parent.ContainsValue(jsonNode);
            }

            public void CopyTo(T[] nodeArray, int index)
            {
                if (index < 0)
                {
                    ThrowHelper.ThrowArgumentOutOfRangeException_ArrayIndexNegative("index");
                }
                foreach (KeyValuePair<string, T> item in _parent)
                {
                    if (index >= nodeArray.Length)
                    {
                        ThrowHelper.ThrowArgumentException_ArrayTooSmall("nodeArray");
                    }
                    nodeArray[index++] = item.Value;
                }
            }

            public IEnumerator<T> GetEnumerator()
            {
                foreach (KeyValuePair<string, T> item in _parent)
                {
                    yield return item.Value;
                }
            }

            bool ICollection<T>.Remove(T node)
            {
                throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
            }

            public int IndexOf(T item)
            {
                throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
            }

            public void Insert(int index, T item)
            {
                throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
            }

            public void RemoveAt(int index)
            {
                throw ThrowHelper.GetNotSupportedException_CollectionIsReadOnly();
            }
        }

        private const int ListToDictionaryThreshold = 9;

        private Dictionary<string, T> _propertyDictionary;

        private readonly List<KeyValuePair<string, T>> _propertyList;

        private readonly StringComparer _stringComparer;

        private KeyCollection _keyCollection;

        private ValueCollection _valueCollection;

        public List<KeyValuePair<string, T>> List => _propertyList;

        public int Count => _propertyList.Count;

        public IList<string> Keys => GetKeyCollection();

        public IList<T> Values => GetValueCollection();

        public bool IsReadOnly { get; set; }

        public T this[string propertyName]
        {
            get
            {
                if (TryGetPropertyValue(propertyName, out var value))
                {
                    return value;
                }
                return null;
            }
            [param: System.Diagnostics.CodeAnalysis.DisallowNull]
            set
            {
                SetValue(propertyName, value);
            }
        }

        public JsonPropertyDictionary(bool caseInsensitive)
        {
            _stringComparer = (caseInsensitive ? StringComparer.OrdinalIgnoreCase : StringComparer.Ordinal);
            _propertyList = new List<KeyValuePair<string, T>>();
        }

        public JsonPropertyDictionary(bool caseInsensitive, int capacity)
        {
            _stringComparer = (caseInsensitive ? StringComparer.OrdinalIgnoreCase : StringComparer.Ordinal);
            _propertyList = new List<KeyValuePair<string, T>>(capacity);
        }

        public void Add(string propertyName, T value)
        {
            if (IsReadOnly)
            {
                ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
            }
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            AddValue(propertyName, value);
        }

        public void Add(KeyValuePair<string, T> property)
        {
            if (IsReadOnly)
            {
                ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
            }
            Add(property.Key, property.Value);
        }

        public bool TryAdd(string propertyName, T value)
        {
            if (IsReadOnly)
            {
                ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
            }
            return TryAddValue(propertyName, value);
        }

        public void Clear()
        {
            if (IsReadOnly)
            {
                ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
            }
            _propertyList.Clear();
            _propertyDictionary?.Clear();
        }

        public bool ContainsKey(string propertyName)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            return ContainsProperty(propertyName);
        }

        public bool Remove(string propertyName)
        {
            if (IsReadOnly)
            {
                ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
            }
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            T existing;
            return TryRemoveProperty(propertyName, out existing);
        }

        public bool Contains(KeyValuePair<string, T> item)
        {
            using (IEnumerator<KeyValuePair<string, T>> enumerator = GetEnumerator())
            {
                while (enumerator.MoveNext())
                {
                    KeyValuePair<string, T> current = enumerator.Current;
                    if (item.Value == current.Value && _stringComparer.Equals(item.Key, current.Key))
                    {
                        return true;
                    }
                }
            }
            return false;
        }

        public void CopyTo(KeyValuePair<string, T>[] array, int index)
        {
            if (index < 0)
            {
                ThrowHelper.ThrowArgumentOutOfRangeException_ArrayIndexNegative("index");
            }
            foreach (KeyValuePair<string, T> property in _propertyList)
            {
                if (index >= array.Length)
                {
                    ThrowHelper.ThrowArgumentException_ArrayTooSmall("array");
                }
                array[index++] = property;
            }
        }

        public IEnumerator<KeyValuePair<string, T>> GetEnumerator()
        {
            foreach (KeyValuePair<string, T> property in _propertyList)
            {
                yield return property;
            }
        }

        public bool TryGetValue(string propertyName, [System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out T value)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            if (_propertyDictionary != null)
            {
                return _propertyDictionary.TryGetValue(propertyName, out value);
            }
            foreach (KeyValuePair<string, T> property in _propertyList)
            {
                if (_stringComparer.Equals(propertyName, property.Key))
                {
                    value = property.Value;
                    return true;
                }
            }
            value = null;
            return false;
        }

        public T SetValue(string propertyName, T value, Action assignParent = null)
        {
            if (IsReadOnly)
            {
                ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
            }
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            CreateDictionaryIfThresholdMet();
            T val = null;
            if (_propertyDictionary != null)
            {
                if (_propertyDictionary.TryAdd(in propertyName, in value))
                {
                    assignParent?.Invoke();
                    _propertyList.Add(new KeyValuePair<string, T>(propertyName, value));
                    return null;
                }
                val = _propertyDictionary[propertyName];
                if (val == value)
                {
                    return null;
                }
            }
            int num = FindValueIndex(propertyName);
            if (num >= 0)
            {
                if (_propertyDictionary != null)
                {
                    _propertyDictionary[propertyName] = value;
                }
                else
                {
                    KeyValuePair<string, T> keyValuePair = _propertyList[num];
                    if (keyValuePair.Value == value)
                    {
                        return null;
                    }
                    val = keyValuePair.Value;
                }
                assignParent?.Invoke();
                _propertyList[num] = new KeyValuePair<string, T>(propertyName, value);
            }
            else
            {
                assignParent?.Invoke();
                _propertyDictionary?.Add(propertyName, value);
                _propertyList.Add(new KeyValuePair<string, T>(propertyName, value));
            }
            return val;
        }

        private void AddValue(string propertyName, T value)
        {
            if (!TryAddValue(propertyName, value))
            {
                ThrowHelper.ThrowArgumentException_DuplicateKey("propertyName", propertyName);
            }
        }

        internal bool TryAddValue(string propertyName, T value)
        {
            if (IsReadOnly)
            {
                ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
            }
            CreateDictionaryIfThresholdMet();
            if (_propertyDictionary == null)
            {
                if (ContainsProperty(propertyName))
                {
                    return false;
                }
            }
            else if (!_propertyDictionary.TryAdd(in propertyName, in value))
            {
                return false;
            }
            _propertyList.Add(new KeyValuePair<string, T>(propertyName, value));
            return true;
        }

        private void CreateDictionaryIfThresholdMet()
        {
            if (_propertyDictionary == null && _propertyList.Count > 9)
            {
                _propertyDictionary = JsonHelpers.CreateDictionaryFromCollection(_propertyList, _stringComparer);
            }
        }

        internal bool ContainsValue(T value)
        {
            foreach (T item in GetValueCollection())
            {
                if (item == value)
                {
                    return true;
                }
            }
            return false;
        }

        public KeyValuePair<string, T>? FindValue(T value)
        {
            using (IEnumerator<KeyValuePair<string, T>> enumerator = GetEnumerator())
            {
                while (enumerator.MoveNext())
                {
                    KeyValuePair<string, T> current = enumerator.Current;
                    if (current.Value == value)
                    {
                        return current;
                    }
                }
            }
            return null;
        }

        private bool ContainsProperty(string propertyName)
        {
            if (_propertyDictionary != null)
            {
                return _propertyDictionary.ContainsKey(propertyName);
            }
            foreach (KeyValuePair<string, T> property in _propertyList)
            {
                if (_stringComparer.Equals(propertyName, property.Key))
                {
                    return true;
                }
            }
            return false;
        }

        private int FindValueIndex(string propertyName)
        {
            for (int i = 0; i < _propertyList.Count; i++)
            {
                KeyValuePair<string, T> keyValuePair = _propertyList[i];
                if (_stringComparer.Equals(propertyName, keyValuePair.Key))
                {
                    return i;
                }
            }
            return -1;
        }

        public bool TryGetPropertyValue(string propertyName, [System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out T value)
        {
            return TryGetValue(propertyName, out value);
        }

        public bool TryRemoveProperty(string propertyName, [System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out T existing)
        {
            if (IsReadOnly)
            {
                ThrowHelper.ThrowNotSupportedException_CollectionIsReadOnly();
            }
            if (_propertyDictionary != null)
            {
                if (!_propertyDictionary.TryGetValue(propertyName, out existing))
                {
                    return false;
                }
                bool flag = _propertyDictionary.Remove(propertyName);
            }
            for (int i = 0; i < _propertyList.Count; i++)
            {
                KeyValuePair<string, T> keyValuePair = _propertyList[i];
                if (_stringComparer.Equals(keyValuePair.Key, propertyName))
                {
                    _propertyList.RemoveAt(i);
                    existing = keyValuePair.Value;
                    return true;
                }
            }
            existing = null;
            return false;
        }

        public IList<string> GetKeyCollection()
        {
            return _keyCollection ?? (_keyCollection = new KeyCollection(this));
        }

        public IList<T> GetValueCollection()
        {
            return _valueCollection ?? (_valueCollection = new ValueCollection(this));
        }
    }

    [System.Serializable]
    internal sealed class JsonReaderException : JsonException
    {
        public JsonReaderException(string message, long lineNumber, long bytePositionInLine)
            : base(message, null, lineNumber, bytePositionInLine) { }

        private JsonReaderException(SerializationInfo info, StreamingContext context) : base(info, context) { }
    }

    internal static class JsonReaderHelper
    {
        private const ulong XorPowerOfTwoToHighByte = 283686952306184uL;

        public static readonly UTF8Encoding s_utf8Encoding = new UTF8Encoding(encoderShouldEmitUTF8Identifier: false, throwOnInvalidBytes: true);

        public static (int, int) CountNewLines(ReadOnlySpan<byte> data)
        {
            int item = -1;
            int num = 0;
            for (int i = 0; i < data.Length; i++)
            {
                if (data[i] == 10)
                {
                    item = i;
                    num++;
                }
            }
            return (num, item);
        }

        internal static JsonValueKind ToValueKind(this JsonTokenType tokenType)
        {
            switch (tokenType)
            {
                case JsonTokenType.None:
                    return JsonValueKind.Undefined;
                case JsonTokenType.StartArray:
                    return JsonValueKind.Array;
                case JsonTokenType.StartObject:
                    return JsonValueKind.Object;
                case JsonTokenType.String:
                case JsonTokenType.Number:
                case JsonTokenType.True:
                case JsonTokenType.False:
                case JsonTokenType.Null:
                    return (JsonValueKind)(tokenType - 4);
                default:
                    return JsonValueKind.Undefined;
            }
        }

        public static bool IsTokenTypePrimitive(JsonTokenType tokenType)
        {
            return (int)(tokenType - 7) <= 4;
        }

        public static bool IsHexDigit(byte nextByte)
        {
            return System.HexConverter.IsHexChar(nextByte);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int IndexOfQuoteOrAnyControlOrBackSlash(this ReadOnlySpan<byte> span)
        {
            return IndexOfOrLessThan(ref MemoryMarshal.GetReference(span), 34, 92, 32, span.Length);
        }

        private unsafe static int IndexOfOrLessThan(ref byte searchSpace, byte value0, byte value1, byte lessThan, int length)
        {
            IntPtr intPtr = (IntPtr)0;
            IntPtr intPtr2 = (IntPtr)length;
            if (Vector.IsHardwareAccelerated && length >= Vector<byte>.Count * 2)
            {
                int num = (int)System.Runtime.CompilerServices.Unsafe.AsPointer<byte>(ref searchSpace) & (Vector<byte>.Count - 1);
                intPtr2 = (IntPtr)((Vector<byte>.Count - num) & (Vector<byte>.Count - 1));
            }
            while (true)
            {
                if ((nuint)(void*)intPtr2 >= (nuint)8u)
                {
                    intPtr2 -= 8;
                    uint num2 = System.Runtime.CompilerServices.Unsafe.AddByteOffset<byte>(ref searchSpace, intPtr);
                    if (value0 == num2 || value1 == num2 || lessThan > num2)
                    {
                        goto IL_0393;
                    }
                    num2 = System.Runtime.CompilerServices.Unsafe.AddByteOffset<byte>(ref searchSpace, intPtr + 1);
                    if (value0 == num2 || value1 == num2 || lessThan > num2)
                    {
                        goto IL_039b;
                    }
                    num2 = System.Runtime.CompilerServices.Unsafe.AddByteOffset<byte>(ref searchSpace, intPtr + 2);
                    if (value0 == num2 || value1 == num2 || lessThan > num2)
                    {
                        goto IL_03a9;
                    }
                    num2 = System.Runtime.CompilerServices.Unsafe.AddByteOffset<byte>(ref searchSpace, intPtr + 3);
                    if (value0 != num2 && value1 != num2 && lessThan <= num2)
                    {
                        num2 = System.Runtime.CompilerServices.Unsafe.AddByteOffset<byte>(ref searchSpace, intPtr + 4);
                        if (value0 != num2 && value1 != num2 && lessThan <= num2)
                        {
                            num2 = System.Runtime.CompilerServices.Unsafe.AddByteOffset<byte>(ref searchSpace, intPtr + 5);
                            if (value0 != num2 && value1 != num2 && lessThan <= num2)
                            {
                                num2 = System.Runtime.CompilerServices.Unsafe.AddByteOffset<byte>(ref searchSpace, intPtr + 6);
                                if (value0 != num2 && value1 != num2 && lessThan <= num2)
                                {
                                    num2 = System.Runtime.CompilerServices.Unsafe.AddByteOffset<byte>(ref searchSpace, intPtr + 7);
                                    if (value0 == num2 || value1 == num2 || lessThan > num2)
                                    {
                                        break;
                                    }
                                    intPtr += 8;
                                    continue;
                                }
                                return (int)(void*)(intPtr + 6);
                            }
                            return (int)(void*)(intPtr + 5);
                        }
                        return (int)(void*)(intPtr + 4);
                    }
                    goto IL_03b7;
                }
                if ((nuint)(void*)intPtr2 >= (nuint)4u)
                {
                    intPtr2 -= 4;
                    uint num2 = System.Runtime.CompilerServices.Unsafe.AddByteOffset<byte>(ref searchSpace, intPtr);
                    if (value0 == num2 || value1 == num2 || lessThan > num2)
                    {
                        goto IL_0393;
                    }
                    num2 = System.Runtime.CompilerServices.Unsafe.AddByteOffset<byte>(ref searchSpace, intPtr + 1);
                    if (value0 == num2 || value1 == num2 || lessThan > num2)
                    {
                        goto IL_039b;
                    }
                    num2 = System.Runtime.CompilerServices.Unsafe.AddByteOffset<byte>(ref searchSpace, intPtr + 2);
                    if (value0 == num2 || value1 == num2 || lessThan > num2)
                    {
                        goto IL_03a9;
                    }
                    num2 = System.Runtime.CompilerServices.Unsafe.AddByteOffset<byte>(ref searchSpace, intPtr + 3);
                    if (value0 == num2 || value1 == num2 || lessThan > num2)
                    {
                        goto IL_03b7;
                    }
                    intPtr += 4;
                }
                while ((void*)intPtr2 != null)
                {
                    intPtr2 -= 1;
                    uint num2 = System.Runtime.CompilerServices.Unsafe.AddByteOffset<byte>(ref searchSpace, intPtr);
                    if (value0 != num2 && value1 != num2 && lessThan <= num2)
                    {
                        intPtr += 1;
                        continue;
                    }
                    goto IL_0393;
                }
                if (Vector.IsHardwareAccelerated && (int)(void*)intPtr < length)
                {
                    intPtr2 = (IntPtr)((length - (int)(void*)intPtr) & ~(Vector<byte>.Count - 1));
                    Vector<byte> right = new Vector<byte>(value0);
                    Vector<byte> right2 = new Vector<byte>(value1);
                    Vector<byte> right3 = new Vector<byte>(lessThan);
                    for (; (void*)intPtr2 > (void*)intPtr; intPtr += Vector<byte>.Count)
                    {
                        Vector<byte> left = System.Runtime.CompilerServices.Unsafe.ReadUnaligned<Vector<byte>>(ref System.Runtime.CompilerServices.Unsafe.AddByteOffset<byte>(ref searchSpace, intPtr));
                        Vector<byte> vector = Vector.BitwiseOr(Vector.BitwiseOr(Vector.Equals(left, right), Vector.Equals(left, right2)), Vector.LessThan(left, right3));
                        if (!Vector<byte>.Zero.Equals(vector))
                        {
                            return (int)(void*)intPtr + LocateFirstFoundByte(vector);
                        }
                    }
                    if ((int)(void*)intPtr < length)
                    {
                        intPtr2 = (IntPtr)(length - (int)(void*)intPtr);
                        continue;
                    }
                }
                return -1;
            IL_0393:
                return (int)(void*)intPtr;
            IL_039b:
                return (int)(void*)(intPtr + 1);
            IL_03b7:
                return (int)(void*)(intPtr + 3);
            IL_03a9:
                return (int)(void*)(intPtr + 2);
            }
            return (int)(void*)(intPtr + 7);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static int LocateFirstFoundByte(Vector<byte> match)
        {
            Vector<ulong> vector = Vector.AsVectorUInt64(match);
            ulong num = 0uL;
            int i;
            for (i = 0; i < Vector<ulong>.Count; i++)
            {
                num = vector[i];
                if (num != 0L)
                {
                    break;
                }
            }
            return i * 8 + LocateFirstFoundByte(num);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static int LocateFirstFoundByte(ulong match)
        {
            ulong num = match ^ (match - 1);
            return (int)(num * 283686952306184L >> 57);
        }

        public static bool TryGetEscapedDateTime(ReadOnlySpan<byte> source, out DateTime value)
        {
            Span<byte> span = stackalloc byte[252];
            Unescape(source, span, out var written);
            span = span.Slice(0, written);
            if (JsonHelpers.IsValidUnescapedDateTimeOffsetParseLength(span.Length) && JsonHelpers.TryParseAsISO((ReadOnlySpan<byte>)span, out DateTime value2))
            {
                value = value2;
                return true;
            }
            value = default(DateTime);
            return false;
        }

        public static bool TryGetEscapedDateTimeOffset(ReadOnlySpan<byte> source, out DateTimeOffset value)
        {
            Span<byte> span = stackalloc byte[252];
            Unescape(source, span, out var written);
            span = span.Slice(0, written);
            if (JsonHelpers.IsValidUnescapedDateTimeOffsetParseLength(span.Length) && JsonHelpers.TryParseAsISO((ReadOnlySpan<byte>)span, out DateTimeOffset value2))
            {
                value = value2;
                return true;
            }
            value = default(DateTimeOffset);
            return false;
        }

        public static bool TryGetEscapedGuid(ReadOnlySpan<byte> source, out Guid value)
        {
            Span<byte> span = stackalloc byte[216];
            Unescape(source, span, out var written);
            span = span.Slice(0, written);
            if (span.Length == 36 && Utf8Parser.TryParse((ReadOnlySpan<byte>)span, out Guid value2, out int _, 'D'))
            {
                value = value2;
                return true;
            }
            value = default(Guid);
            return false;
        }

        public static bool TryGetFloatingPointConstant(ReadOnlySpan<byte> span, out float value)
        {
            if (span.Length == 3)
            {
                if (span.SequenceEqual(JsonConstants.NaNValue))
                {
                    value = float.NaN;
                    return true;
                }
            }
            else if (span.Length == 8)
            {
                if (span.SequenceEqual(JsonConstants.PositiveInfinityValue))
                {
                    value = float.PositiveInfinity;
                    return true;
                }
            }
            else if (span.Length == 9 && span.SequenceEqual(JsonConstants.NegativeInfinityValue))
            {
                value = float.NegativeInfinity;
                return true;
            }
            value = 0f;
            return false;
        }

        public static bool TryGetFloatingPointConstant(ReadOnlySpan<byte> span, out double value)
        {
            if (span.Length == 3)
            {
                if (span.SequenceEqual(JsonConstants.NaNValue))
                {
                    value = double.NaN;
                    return true;
                }
            }
            else if (span.Length == 8)
            {
                if (span.SequenceEqual(JsonConstants.PositiveInfinityValue))
                {
                    value = double.PositiveInfinity;
                    return true;
                }
            }
            else if (span.Length == 9 && span.SequenceEqual(JsonConstants.NegativeInfinityValue))
            {
                value = double.NegativeInfinity;
                return true;
            }
            value = 0.0;
            return false;
        }

        public static bool TryGetUnescapedBase64Bytes(ReadOnlySpan<byte> utf8Source, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out byte[] bytes)
        {
            byte[] array = null;
            Span<byte> span = ((utf8Source.Length > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(utf8Source.Length))) : stackalloc byte[256]);
            Span<byte> span2 = span;
            Unescape(utf8Source, span2, out var written);
            span2 = span2.Slice(0, written);
            bool result = TryDecodeBase64InPlace(span2, out bytes);
            if (array != null)
            {
                span2.Clear();
                ArrayPool<byte>.Shared.Return(array);
            }
            return result;
        }

        public static string GetUnescapedString(ReadOnlySpan<byte> utf8Source)
        {
            int length = utf8Source.Length;
            byte[] array = null;
            Span<byte> span = ((length > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(length))) : stackalloc byte[256]);
            Span<byte> span2 = span;
            Unescape(utf8Source, span2, out var written);
            span2 = span2.Slice(0, written);
            string result = TranscodeHelper(span2);
            if (array != null)
            {
                span2.Clear();
                ArrayPool<byte>.Shared.Return(array);
            }
            return result;
        }

        public static ReadOnlySpan<byte> GetUnescapedSpan(ReadOnlySpan<byte> utf8Source)
        {
            int length = utf8Source.Length;
            byte[] array = null;
            Span<byte> span = ((length > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(length))) : stackalloc byte[256]);
            Span<byte> destination = span;
            Unescape(utf8Source, destination, out var written);
            ReadOnlySpan<byte> result = destination.Slice(0, written).ToArray();
            if (array != null)
            {
                new Span<byte>(array, 0, written).Clear();
                ArrayPool<byte>.Shared.Return(array);
            }
            return result;
        }

        public static bool UnescapeAndCompare(ReadOnlySpan<byte> utf8Source, ReadOnlySpan<byte> other)
        {
            byte[] array = null;
            Span<byte> span = ((utf8Source.Length > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(utf8Source.Length))) : stackalloc byte[256]);
            Span<byte> span2 = span;
            Unescape(utf8Source, span2, 0, out var written);
            span2 = span2.Slice(0, written);
            bool result = other.SequenceEqual(span2);
            if (array != null)
            {
                span2.Clear();
                ArrayPool<byte>.Shared.Return(array);
            }
            return result;
        }

        public static bool UnescapeAndCompare(ReadOnlySequence<byte> utf8Source, ReadOnlySpan<byte> other)
        {
            byte[] array = null;
            byte[] array2 = null;
            int num = checked((int)utf8Source.Length);
            Span<byte> span = ((num > 256) ? ((Span<byte>)(array2 = ArrayPool<byte>.Shared.Rent(num))) : stackalloc byte[256]);
            Span<byte> span2 = span;
            Span<byte> span3 = ((num > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(num))) : stackalloc byte[256]);
            Span<byte> span4 = span3;
            utf8Source.CopyTo(span4);
            span4 = span4.Slice(0, num);
            Unescape(span4, span2, 0, out var written);
            span2 = span2.Slice(0, written);
            bool result = other.SequenceEqual(span2);
            if (array2 != null)
            {
                span2.Clear();
                ArrayPool<byte>.Shared.Return(array2);
                span4.Clear();
                ArrayPool<byte>.Shared.Return(array);
            }
            return result;
        }

        public static bool TryDecodeBase64InPlace(Span<byte> utf8Unescaped, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out byte[] bytes)
        {
            if (Base64.DecodeFromUtf8InPlace(utf8Unescaped, out var bytesWritten) != 0)
            {
                bytes = null;
                return false;
            }
            bytes = utf8Unescaped.Slice(0, bytesWritten).ToArray();
            return true;
        }

        public static bool TryDecodeBase64(ReadOnlySpan<byte> utf8Unescaped, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out byte[] bytes)
        {
            byte[] array = null;
            Span<byte> span = ((utf8Unescaped.Length > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(utf8Unescaped.Length))) : stackalloc byte[256]);
            Span<byte> bytes2 = span;
            if (Base64.DecodeFromUtf8(utf8Unescaped, bytes2, out var _, out var bytesWritten) != 0)
            {
                bytes = null;
                if (array != null)
                {
                    bytes2.Clear();
                    ArrayPool<byte>.Shared.Return(array);
                }
                return false;
            }
            bytes = bytes2.Slice(0, bytesWritten).ToArray();
            if (array != null)
            {
                bytes2.Clear();
                ArrayPool<byte>.Shared.Return(array);
            }
            return true;
        }

        public unsafe static string TranscodeHelper(ReadOnlySpan<byte> utf8Unescaped)
        {
            try
            {
                if (utf8Unescaped.IsEmpty)
                {
                    return string.Empty;
                }
                fixed (byte* bytes = utf8Unescaped)
                {
                    return s_utf8Encoding.GetString(bytes, utf8Unescaped.Length);
                }
            }
            catch (DecoderFallbackException innerException)
            {
                throw ThrowHelper.GetInvalidOperationException_ReadInvalidUTF8(innerException);
            }
        }

        public unsafe static int TranscodeHelper(ReadOnlySpan<byte> utf8Unescaped, Span<char> destination)
        {
            try
            {
                if (utf8Unescaped.IsEmpty)
                {
                    return 0;
                }
                fixed (byte* bytes = utf8Unescaped)
                {
                    fixed (char* chars = destination)
                    {
                        return s_utf8Encoding.GetChars(bytes, utf8Unescaped.Length, chars, destination.Length);
                    }
                }
            }
            catch (DecoderFallbackException innerException)
            {
                throw ThrowHelper.GetInvalidOperationException_ReadInvalidUTF8(innerException);
            }
            catch (ArgumentException)
            {
                destination.Clear();
                throw;
            }
        }

        public unsafe static void ValidateUtf8(ReadOnlySpan<byte> utf8Buffer)
        {
            try
            {
                if (utf8Buffer.IsEmpty)
                {
                    return;
                }
                fixed (byte* bytes = utf8Buffer)
                {
                    s_utf8Encoding.GetCharCount(bytes, utf8Buffer.Length);
                }
            }
            catch (DecoderFallbackException innerException)
            {
                throw ThrowHelper.GetInvalidOperationException_ReadInvalidUTF8(innerException);
            }
        }

        internal unsafe static int GetUtf8ByteCount(ReadOnlySpan<char> text)
        {
            try
            {
                if (text.IsEmpty)
                {
                    return 0;
                }
                fixed (char* chars = text)
                {
                    return s_utf8Encoding.GetByteCount(chars, text.Length);
                }
            }
            catch (EncoderFallbackException innerException)
            {
                throw ThrowHelper.GetArgumentException_ReadInvalidUTF16(innerException);
            }
        }

        internal unsafe static int GetUtf8FromText(ReadOnlySpan<char> text, Span<byte> dest)
        {
            try
            {
                if (text.IsEmpty)
                {
                    return 0;
                }
                fixed (char* chars = text)
                {
                    fixed (byte* bytes = dest)
                    {
                        return s_utf8Encoding.GetBytes(chars, text.Length, bytes, dest.Length);
                    }
                }
            }
            catch (EncoderFallbackException innerException)
            {
                throw ThrowHelper.GetArgumentException_ReadInvalidUTF16(innerException);
            }
        }

        internal unsafe static string GetTextFromUtf8(ReadOnlySpan<byte> utf8Text)
        {
            if (utf8Text.IsEmpty)
            {
                return string.Empty;
            }
            fixed (byte* bytes = utf8Text)
            {
                return s_utf8Encoding.GetString(bytes, utf8Text.Length);
            }
        }

        internal static void Unescape(ReadOnlySpan<byte> source, Span<byte> destination, out int written)
        {
            int idx = source.IndexOf<byte>(92);
            bool flag = TryUnescape(source, destination, idx, out written);
        }

        internal static void Unescape(ReadOnlySpan<byte> source, Span<byte> destination, int idx, out int written)
        {
            bool flag = TryUnescape(source, destination, idx, out written);
        }

        /// <summary>
        /// Used when writing to buffers not guaranteed to fit the unescaped result.
        /// </summary>
        internal static bool TryUnescape(ReadOnlySpan<byte> source, Span<byte> destination, out int written)
        {
            int idx = source.IndexOf<byte>(92);
            return TryUnescape(source, destination, idx, out written);
        }

        /// <summary>
        /// Used when writing to buffers not guaranteed to fit the unescaped result.
        /// </summary>
        private static bool TryUnescape(ReadOnlySpan<byte> source, Span<byte> destination, int idx, out int written)
        {
            if (!source.Slice(0, idx).TryCopyTo(destination))
            {
                written = 0;
            }
            else
            {
                written = idx;
                while (written != destination.Length)
                {
                    byte b = source[++idx];
                    if ((uint)b <= 98u)
                    {
                        if ((uint)b <= 47u)
                        {
                            if (b != 34)
                            {
                                if (b != 47)
                                {
                                    goto IL_0179;
                                }
                                destination[written++] = 47;
                            }
                            else
                            {
                                destination[written++] = 34;
                            }
                        }
                        else if (b != 92)
                        {
                            if (b != 98)
                            {
                                goto IL_0179;
                            }
                            destination[written++] = 8;
                        }
                        else
                        {
                            destination[written++] = 92;
                        }
                    }
                    else if ((uint)b <= 110u)
                    {
                        if (b != 102)
                        {
                            if (b != 110)
                            {
                                goto IL_0179;
                            }
                            destination[written++] = 10;
                        }
                        else
                        {
                            destination[written++] = 12;
                        }
                    }
                    else if (b != 114)
                    {
                        if (b != 116)
                        {
                            goto IL_0179;
                        }
                        destination[written++] = 9;
                    }
                    else
                    {
                        destination[written++] = 13;
                    }
                    goto IL_025b;
                IL_025b:
                    if (++idx != source.Length)
                    {
                        if (source[idx] == 92)
                        {
                            continue;
                        }
                        ReadOnlySpan<byte> span = source.Slice(idx);
                        int num = span.IndexOf<byte>(92);
                        if (num < 0)
                        {
                            num = span.Length;
                        }
                        if ((uint)(written + num) >= (uint)destination.Length)
                        {
                            break;
                        }
                        switch (num)
                        {
                            case 1:
                                destination[written++] = source[idx++];
                                break;
                            case 2:
                                destination[written++] = source[idx++];
                                destination[written++] = source[idx++];
                                break;
                            case 3:
                                destination[written++] = source[idx++];
                                destination[written++] = source[idx++];
                                destination[written++] = source[idx++];
                                break;
                            default:
                                span.Slice(0, num).CopyTo(destination.Slice(written));
                                written += num;
                                idx += num;
                                break;
                        }
                        if (idx != source.Length)
                        {
                            continue;
                        }
                    }
                    return true;
                IL_0179:
                    bool flag = Utf8Parser.TryParse(source.Slice(idx + 1, 4), out int value, out int bytesConsumed, 'x');
                    idx += 4;
                    if (JsonHelpers.IsInRangeInclusive((uint)value, 55296u, 57343u))
                    {
                        if (value >= 56320)
                        {
                            ThrowHelper.ThrowInvalidOperationException_ReadInvalidUTF16(value);
                        }
                        if (source.Length < idx + 7 || source[idx + 1] != 92 || source[idx + 2] != 117)
                        {
                            ThrowHelper.ThrowInvalidOperationException_ReadIncompleteUTF16();
                        }
                        flag = Utf8Parser.TryParse(source.Slice(idx + 3, 4), out int value2, out bytesConsumed, 'x');
                        idx += 6;
                        if (!JsonHelpers.IsInRangeInclusive((uint)value2, 56320u, 57343u))
                        {
                            ThrowHelper.ThrowInvalidOperationException_ReadInvalidUTF16(value2);
                        }
                        value = 1024 * (value - 55296) + (value2 - 56320) + 65536;
                    }
                    if (!TryEncodeToUtf8Bytes((uint)value, destination.Slice(written), out var bytesWritten))
                    {
                        break;
                    }
                    written += bytesWritten;
                    goto IL_025b;
                }
            }
            return false;
        }

        /// <summary>
        /// Copies the UTF-8 code unit representation of this scalar to an output buffer.
        /// The buffer must be large enough to hold the required number of <see cref="T:System.Byte" />s.
        /// </summary>
        private static bool TryEncodeToUtf8Bytes(uint scalar, Span<byte> utf8Destination, out int bytesWritten)
        {
            if (scalar < 128)
            {
                if ((uint)utf8Destination.Length < 1u)
                {
                    bytesWritten = 0;
                    return false;
                }
                utf8Destination[0] = (byte)scalar;
                bytesWritten = 1;
            }
            else if (scalar < 2048)
            {
                if ((uint)utf8Destination.Length < 2u)
                {
                    bytesWritten = 0;
                    return false;
                }
                utf8Destination[0] = (byte)(0xC0u | (scalar >> 6));
                utf8Destination[1] = (byte)(0x80u | (scalar & 0x3Fu));
                bytesWritten = 2;
            }
            else if (scalar < 65536)
            {
                if ((uint)utf8Destination.Length < 3u)
                {
                    bytesWritten = 0;
                    return false;
                }
                utf8Destination[0] = (byte)(0xE0u | (scalar >> 12));
                utf8Destination[1] = (byte)(0x80u | ((scalar >> 6) & 0x3Fu));
                utf8Destination[2] = (byte)(0x80u | (scalar & 0x3Fu));
                bytesWritten = 3;
            }
            else
            {
                if ((uint)utf8Destination.Length < 4u)
                {
                    bytesWritten = 0;
                    return false;
                }
                utf8Destination[0] = (byte)(0xF0u | (scalar >> 18));
                utf8Destination[1] = (byte)(0x80u | ((scalar >> 12) & 0x3Fu));
                utf8Destination[2] = (byte)(0x80u | ((scalar >> 6) & 0x3Fu));
                utf8Destination[3] = (byte)(0x80u | (scalar & 0x3Fu));
                bytesWritten = 4;
            }
            return true;
        }
    }

    /// <summary>
	/// Provides the ability for the user to define custom behavior when reading JSON.
	/// </summary>
	public struct JsonReaderOptions
    {
        internal const int DefaultMaxDepth = 64;

        private int _maxDepth;

        private JsonCommentHandling _commentHandling;

        /// <summary>
        /// Defines how the <see cref="T:System.Text.Json.Utf8JsonReader" /> should handle comments when reading through the JSON.
        /// </summary>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        /// Thrown when the comment handling enum is set to a value that is not supported (i.e. not within the <see cref="T:System.Text.Json.JsonCommentHandling" /> enum range).
        /// </exception>
        /// <remarks>
        /// By default <exception cref="T:System.Text.Json.JsonException" /> is thrown if a comment is encountered.
        /// </remarks>
        public JsonCommentHandling CommentHandling
        {
            readonly get
            {
                return _commentHandling;
            }
            set
            {
                if ((int)value > 2)
                {
                    ThrowHelper.ThrowArgumentOutOfRangeException_CommentEnumMustBeInRange("value");
                }
                _commentHandling = value;
            }
        }

        /// <summary>
        /// Gets or sets the maximum depth allowed when reading JSON, with the default (i.e. 0) indicating a max depth of 64.
        /// </summary>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        /// Thrown when the max depth is set to a negative value.
        /// </exception>
        /// <remarks>
        /// Reading past this depth will throw a <exception cref="T:System.Text.Json.JsonException" />.
        /// </remarks>
        public int MaxDepth
        {
            readonly get
            {
                return _maxDepth;
            }
            set
            {
                if (value < 0)
                {
                    ThrowHelper.ThrowArgumentOutOfRangeException_MaxDepthMustBePositive("value");
                }
                _maxDepth = value;
            }
        }

        /// <summary>
        /// Defines whether an extra comma at the end of a list of JSON values in an object or array
        /// is allowed (and ignored) within the JSON payload being read.
        /// </summary>
        /// <remarks>
        /// By default, it's set to false, and <exception cref="T:System.Text.Json.JsonException" /> is thrown if a trailing comma is encountered.
        /// </remarks>
        public bool AllowTrailingCommas { get; set; }
    }

    /// <summary>
	/// Defines an opaque type that holds and saves all the relevant state information which must be provided
	/// to the <see cref="Utf8JsonReader" /> to continue reading after processing incomplete data.
	/// This type is required to support reentrancy when reading incomplete data, and to continue
	/// reading once more data is available. Unlike the <see cref="Utf8JsonReader" />, which is a ref struct,
	/// this type can survive across async/await boundaries and hence this type is required to provide
	/// support for reading in more data asynchronously before continuing with a new instance of the <see cref="T:System.Text.Json.Utf8JsonReader" />.
	/// </summary>
	public struct JsonReaderState
    {
        internal long _lineNumber;

        internal long _bytePositionInLine;

        internal bool _inObject;

        internal bool _isNotPrimitive;

        internal bool _valueIsEscaped;

        internal bool _trailingCommaBeforeComment;

        internal JsonTokenType _tokenType;

        internal JsonTokenType _previousTokenType;

        internal JsonReaderOptions _readerOptions;

        internal BitStack _bitStack;

        /// <summary>
        /// Gets the custom behavior when reading JSON using
        /// the <see cref="T:System.Text.Json.Utf8JsonReader" /> that may deviate from strict adherence
        /// to the JSON specification, which is the default behavior.
        /// </summary>
        public JsonReaderOptions Options => _readerOptions;

        /// <summary>
        /// Constructs a new <see cref="T:System.Text.Json.JsonReaderState" /> instance.
        /// </summary>
        /// <param name="options">Defines the customized behavior of the <see cref="T:System.Text.Json.Utf8JsonReader" />
        /// that is different from the JSON RFC (for example how to handle comments or maximum depth allowed when reading).
        /// By default, the <see cref="T:System.Text.Json.Utf8JsonReader" /> follows the JSON RFC strictly (i.e. comments within the JSON are invalid) and reads up to a maximum depth of 64.</param>
        /// <remarks>
        /// An instance of this state must be passed to the <see cref="T:System.Text.Json.Utf8JsonReader" /> ctor with the JSON data.
        /// Unlike the <see cref="T:System.Text.Json.Utf8JsonReader" />, which is a ref struct, the state can survive
        /// across async/await boundaries and hence this type is required to provide support for reading
        /// in more data asynchronously before continuing with a new instance of the <see cref="T:System.Text.Json.Utf8JsonReader" />.
        /// </remarks>
        public JsonReaderState(JsonReaderOptions options = default(JsonReaderOptions))
        {
            _lineNumber = 0L;
            _bytePositionInLine = 0L;
            _inObject = false;
            _isNotPrimitive = false;
            _valueIsEscaped = false;
            _trailingCommaBeforeComment = false;
            _tokenType = JsonTokenType.None;
            _previousTokenType = JsonTokenType.None;
            _readerOptions = options;
            _bitStack = default(BitStack);
        }
    }

    /// <summary>
	/// Provides functionality to serialize objects or value types to JSON and
	/// deserialize JSON into objects or value types.
	/// </summary>
	public static class JsonSerializer
    {
        internal const string SerializationUnreferencedCodeMessage = "JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.";

        internal const string SerializationRequiresDynamicCodeMessage = "JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.";

        internal const string IdPropertyName = "$id";

        internal const string RefPropertyName = "$ref";

        internal const string TypePropertyName = "$type";

        internal const string ValuesPropertyName = "$values";

        internal static readonly byte[] s_idPropertyName = Encoding.UTF8.GetBytes("$id");

        internal static readonly byte[] s_refPropertyName = Encoding.UTF8.GetBytes("$ref");

        internal static readonly byte[] s_typePropertyName = Encoding.UTF8.GetBytes("$type");

        internal static readonly byte[] s_valuesPropertyName = Encoding.UTF8.GetBytes("$values");

        internal static readonly JsonEncodedText s_metadataId = JsonEncodedText.Encode("$id");

        internal static readonly JsonEncodedText s_metadataRef = JsonEncodedText.Encode("$ref");

        internal static readonly JsonEncodedText s_metadataType = JsonEncodedText.Encode("$type");

        internal static readonly JsonEncodedText s_metadataValues = JsonEncodedText.Encode("$values");

        private const float FlushThreshold = 0.9f;

        /// <summary>
        /// Converts the <see cref="T:System.Text.Json.JsonDocument" /> representing a single JSON value into a <typeparamref name="TValue" />.
        /// </summary>
        /// <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        /// <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <param name="document">The <see cref="T:System.Text.Json.JsonDocument" /> to convert.</param>
        /// <param name="options">Options to control the behavior during parsing.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="document" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// <typeparamref name="TValue" /> is not compatible with the JSON.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static TValue? Deserialize<TValue>(this JsonDocument document, JsonSerializerOptions? options = null)
        {
            if (document == null)
            {
                ThrowHelper.ThrowArgumentNullException("document");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(options, typeof(TValue));
            return ReadDocument<TValue>(document, typeInfo);
        }

        /// <summary>
        /// Converts the <see cref="T:System.Text.Json.JsonDocument" /> representing a single JSON value into a <paramref name="returnType" />.
        /// </summary>
        /// <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        /// <param name="document">The <see cref="T:System.Text.Json.JsonDocument" /> to convert.</param>
        /// <param name="returnType">The type of the object to convert to and return.</param>
        /// <param name="options">Options to control the behavior during parsing.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="document" /> or <paramref name="returnType" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// <paramref name="returnType" /> is not compatible with the JSON.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="returnType" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static object? Deserialize(this JsonDocument document, Type returnType, JsonSerializerOptions? options = null)
        {
            if (document == null)
            {
                ThrowHelper.ThrowArgumentNullException("document");
            }
            if ((object)returnType == null)
            {
                ThrowHelper.ThrowArgumentNullException("returnType");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(options, returnType);
            return ReadDocument<object>(document, typeInfo);
        }

        /// <summary>
        /// Converts the <see cref="T:System.Text.Json.JsonDocument" /> representing a single JSON value into a <typeparamref name="TValue" />.
        /// </summary>
        /// <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        /// <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <param name="document">The <see cref="T:System.Text.Json.JsonDocument" /> to convert.</param>
        /// <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="document" /> is <see langword="null" />.
        ///
        /// -or-
        ///
        /// <paramref name="jsonTypeInfo" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// <typeparamref name="TValue" /> is not compatible with the JSON.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        public static TValue? Deserialize<TValue>(this JsonDocument document, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            if (document == null)
            {
                ThrowHelper.ThrowArgumentNullException("document");
            }
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
            }
            jsonTypeInfo.EnsureConfigured();
            return ReadDocument<TValue>(document, jsonTypeInfo);
        }

        /// <summary>
        /// Converts the <see cref="T:System.Text.Json.JsonDocument" /> representing a single JSON value into a <paramref name="returnType" />.
        /// </summary>
        /// <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        /// <param name="document">The <see cref="T:System.Text.Json.JsonDocument" /> to convert.</param>
        /// <param name="returnType">The type of the object to convert to and return.</param>
        /// <param name="context">A metadata provider for serializable types.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="document" /> is <see langword="null" />.
        ///
        /// -or-
        ///
        /// <paramref name="returnType" /> is <see langword="null" />.
        ///
        /// -or-
        ///
        /// <paramref name="context" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid.
        ///
        /// -or-
        ///
        /// <paramref name="returnType" /> is not compatible with the JSON.
        ///
        /// -or-
        ///
        /// There is remaining data in the string beyond a single JSON value.</exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="returnType" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided
        /// <paramref name="context" /> returns <see langword="null" /> for the type to convert.
        /// </exception>
        public static object? Deserialize(this JsonDocument document, Type returnType, JsonSerializerContext context)
        {
            if (document == null)
            {
                ThrowHelper.ThrowArgumentNullException("document");
            }
            if ((object)returnType == null)
            {
                ThrowHelper.ThrowArgumentNullException("returnType");
            }
            if (context == null)
            {
                ThrowHelper.ThrowArgumentNullException("context");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(context, returnType);
            return ReadDocument<object>(document, typeInfo);
        }

        private static TValue ReadDocument<TValue>(JsonDocument document, JsonTypeInfo jsonTypeInfo)
        {
            ReadOnlySpan<byte> span = document.GetRootRawValue().Span;
            return ReadFromSpan<TValue>(span, jsonTypeInfo);
        }

        /// <summary>
        /// Converts the <see cref="T:System.Text.Json.JsonElement" /> representing a single JSON value into a <typeparamref name="TValue" />.
        /// </summary>
        /// <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        /// <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <param name="element">The <see cref="T:System.Text.Json.JsonElement" /> to convert.</param>
        /// <param name="options">Options to control the behavior during parsing.</param>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// <typeparamref name="TValue" /> is not compatible with the JSON.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static TValue? Deserialize<TValue>(this JsonElement element, JsonSerializerOptions? options = null)
        {
            JsonTypeInfo typeInfo = GetTypeInfo(options, typeof(TValue));
            return ReadUsingMetadata<TValue>(element, typeInfo);
        }

        /// <summary>
        /// Converts the <see cref="T:System.Text.Json.JsonElement" /> representing a single JSON value into a <paramref name="returnType" />.
        /// </summary>
        /// <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        /// <param name="element">The <see cref="T:System.Text.Json.JsonElement" /> to convert.</param>
        /// <param name="returnType">The type of the object to convert to and return.</param>
        /// <param name="options">Options to control the behavior during parsing.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="returnType" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// <paramref name="returnType" /> is not compatible with the JSON.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="returnType" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static object? Deserialize(this JsonElement element, Type returnType, JsonSerializerOptions? options = null)
        {
            if ((object)returnType == null)
            {
                ThrowHelper.ThrowArgumentNullException("returnType");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(options, returnType);
            return ReadUsingMetadata<object>(element, typeInfo);
        }

        /// <summary>
        /// Converts the <see cref="T:System.Text.Json.JsonElement" /> representing a single JSON value into a <typeparamref name="TValue" />.
        /// </summary>
        /// <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        /// <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <param name="element">The <see cref="T:System.Text.Json.JsonElement" /> to convert.</param>
        /// <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="jsonTypeInfo" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// <typeparamref name="TValue" /> is not compatible with the JSON.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        public static TValue? Deserialize<TValue>(this JsonElement element, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
            }
            jsonTypeInfo.EnsureConfigured();
            return ReadUsingMetadata<TValue>(element, jsonTypeInfo);
        }

        /// <summary>
        /// Converts the <see cref="T:System.Text.Json.JsonElement" /> representing a single JSON value into a <paramref name="returnType" />.
        /// </summary>
        /// <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        /// <param name="element">The <see cref="T:System.Text.Json.JsonElement" /> to convert.</param>
        /// <param name="returnType">The type of the object to convert to and return.</param>
        /// <param name="context">A metadata provider for serializable types.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="returnType" /> is <see langword="null" />.
        ///
        /// -or-
        ///
        /// <paramref name="context" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid.
        ///
        /// -or-
        ///
        /// <paramref name="returnType" /> is not compatible with the JSON.
        ///
        /// -or-
        ///
        /// There is remaining data in the string beyond a single JSON value.</exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="returnType" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided
        /// <paramref name="context" /> returns <see langword="null" /> for the type to convert.
        /// </exception>
        public static object? Deserialize(this JsonElement element, Type returnType, JsonSerializerContext context)
        {
            if ((object)returnType == null)
            {
                ThrowHelper.ThrowArgumentNullException("returnType");
            }
            if (context == null)
            {
                ThrowHelper.ThrowArgumentNullException("context");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(context, returnType);
            return ReadUsingMetadata<object>(element, typeInfo);
        }

        private static TValue ReadUsingMetadata<TValue>(JsonElement element, JsonTypeInfo jsonTypeInfo)
        {
            ReadOnlySpan<byte> span = element.GetRawValue().Span;
            return ReadFromSpan<TValue>(span, jsonTypeInfo);
        }

        /// <summary>
        /// Converts the <see cref="T:System.Text.Json.Nodes.JsonNode" /> representing a single JSON value into a <typeparamref name="TValue" />.
        /// </summary>
        /// <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        /// <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <param name="node">The <see cref="T:System.Text.Json.Nodes.JsonNode" /> to convert.</param>
        /// <param name="options">Options to control the behavior during parsing.</param>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// <typeparamref name="TValue" /> is not compatible with the JSON.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static TValue? Deserialize<TValue>(this JsonNode? node, JsonSerializerOptions? options = null)
        {
            JsonTypeInfo typeInfo = GetTypeInfo(options, typeof(TValue));
            return ReadNode<TValue>(node, typeInfo);
        }

        /// <summary>
        /// Converts the <see cref="T:System.Text.Json.Nodes.JsonNode" /> representing a single JSON value into a <paramref name="returnType" />.
        /// </summary>
        /// <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        /// <param name="node">The <see cref="T:System.Text.Json.Nodes.JsonNode" /> to convert.</param>
        /// <param name="returnType">The type of the object to convert to and return.</param>
        /// <param name="options">Options to control the behavior during parsing.</param>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// <paramref name="returnType" /> is not compatible with the JSON.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="returnType" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static object? Deserialize(this JsonNode? node, Type returnType, JsonSerializerOptions? options = null)
        {
            if ((object)returnType == null)
            {
                ThrowHelper.ThrowArgumentNullException("returnType");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(options, returnType);
            return ReadNode<object>(node, typeInfo);
        }

        /// <summary>
        /// Converts the <see cref="T:System.Text.Json.Nodes.JsonNode" /> representing a single JSON value into a <typeparamref name="TValue" />.
        /// </summary>
        /// <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        /// <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <param name="node">The <see cref="T:System.Text.Json.Nodes.JsonNode" /> to convert.</param>
        /// <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="jsonTypeInfo" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// <typeparamref name="TValue" /> is not compatible with the JSON.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        public static TValue? Deserialize<TValue>(this JsonNode? node, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
            }
            jsonTypeInfo.EnsureConfigured();
            return ReadNode<TValue>(node, jsonTypeInfo);
        }

        /// <summary>
        /// Converts the <see cref="T:System.Text.Json.Nodes.JsonNode" /> representing a single JSON value into a <paramref name="returnType" />.
        /// </summary>
        /// <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        /// <param name="node">The <see cref="T:System.Text.Json.Nodes.JsonNode" /> to convert.</param>
        /// <param name="returnType">The type of the object to convert to and return.</param>
        /// <param name="context">A metadata provider for serializable types.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="returnType" /> is <see langword="null" />.
        ///
        /// -or-
        ///
        /// <paramref name="context" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid.
        ///
        /// -or-
        ///
        /// <paramref name="returnType" /> is not compatible with the JSON.
        ///
        /// -or-
        ///
        /// There is remaining data in the string beyond a single JSON value.</exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="returnType" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided
        /// <paramref name="context" /> returns <see langword="null" /> for the type to convert.
        /// </exception>
        public static object? Deserialize(this JsonNode? node, Type returnType, JsonSerializerContext context)
        {
            if ((object)returnType == null)
            {
                ThrowHelper.ThrowArgumentNullException("returnType");
            }
            if (context == null)
            {
                ThrowHelper.ThrowArgumentNullException("context");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(context, returnType);
            return ReadNode<object>(node, typeInfo);
        }

        private static TValue ReadNode<TValue>(JsonNode node, JsonTypeInfo jsonTypeInfo)
        {
            JsonSerializerOptions options = jsonTypeInfo.Options;
            using PooledByteBufferWriter pooledByteBufferWriter = new PooledByteBufferWriter(options.DefaultBufferSize);
            using (Utf8JsonWriter utf8JsonWriter = new Utf8JsonWriter(pooledByteBufferWriter, options.GetWriterOptions()))
            {
                if (node == null)
                {
                    utf8JsonWriter.WriteNullValue();
                }
                else
                {
                    node.WriteTo(utf8JsonWriter, options);
                }
            }
            return ReadFromSpan<TValue>(pooledByteBufferWriter.WrittenMemory.Span, jsonTypeInfo);
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.Text.Json.JsonDocument" />.
        /// </summary>
        /// <typeparam name="TValue">The type of the value to serialize.</typeparam>
        /// <returns>A <see cref="T:System.Text.Json.JsonDocument" /> representation of the JSON value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="options">Options to control the conversion behavior.</param>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static JsonDocument SerializeToDocument<TValue>(TValue value, JsonSerializerOptions? options = null)
        {
            JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
            return WriteDocument<TValue>(in value, typeInfo);
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.Text.Json.JsonDocument" />.
        /// </summary>
        /// <returns>A <see cref="T:System.Text.Json.JsonDocument" /> representation of the value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        /// <param name="options">Options to control the conversion behavior.</param>
        /// <exception cref="T:System.ArgumentException">
        /// <paramref name="inputType" /> is not compatible with <paramref name="value" />.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="inputType" /> is <see langword="null" />.
        /// </exception>
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="inputType" />  or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static JsonDocument SerializeToDocument(object? value, Type inputType, JsonSerializerOptions? options = null)
        {
            ValidateInputType(value, inputType);
            JsonTypeInfo typeInfo = GetTypeInfo(options, inputType);
            return WriteDocumentAsObject(value, typeInfo);
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.Text.Json.JsonDocument" />.
        /// </summary>
        /// <typeparam name="TValue">The type of the value to serialize.</typeparam>
        /// <returns>A <see cref="T:System.Text.Json.JsonDocument" /> representation of the value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="jsonTypeInfo" /> is <see langword="null" />.
        /// </exception>
        public static JsonDocument SerializeToDocument<TValue>(TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
            }
            jsonTypeInfo.EnsureConfigured();
            return WriteDocument(in value, jsonTypeInfo);
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.Text.Json.JsonDocument" />.
        /// </summary>
        /// <returns>A <see cref="T:System.Text.Json.JsonDocument" /> representation of the value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        /// <param name="context">A metadata provider for serializable types.</param>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="inputType" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided
        /// <paramref name="context" /> returns <see langword="null" /> for the type to convert.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="inputType" /> or <paramref name="context" /> is <see langword="null" />.
        /// </exception>
        public static JsonDocument SerializeToDocument(object? value, Type inputType, JsonSerializerContext context)
        {
            if (context == null)
            {
                ThrowHelper.ThrowArgumentNullException("context");
            }
            ValidateInputType(value, inputType);
            return WriteDocumentAsObject(value, GetTypeInfo(context, inputType));
        }

        private static JsonDocument WriteDocument<TValue>(in TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            JsonSerializerOptions options = jsonTypeInfo.Options;
            PooledByteBufferWriter pooledByteBufferWriter = new PooledByteBufferWriter(options.DefaultBufferSize);
            Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriter(options, pooledByteBufferWriter);
            try
            {
                WriteCore(writer, in value, jsonTypeInfo);
                return JsonDocument.ParseRented(pooledByteBufferWriter, options.GetDocumentOptions());
            }
            finally
            {
                Utf8JsonWriterCache.ReturnWriter(writer);
            }
        }

        private static JsonDocument WriteDocumentAsObject(object value, JsonTypeInfo jsonTypeInfo)
        {
            JsonSerializerOptions options = jsonTypeInfo.Options;
            PooledByteBufferWriter pooledByteBufferWriter = new PooledByteBufferWriter(options.DefaultBufferSize);
            Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriter(options, pooledByteBufferWriter);
            try
            {
                WriteCoreAsObject(writer, value, jsonTypeInfo);
                return JsonDocument.ParseRented(pooledByteBufferWriter, options.GetDocumentOptions());
            }
            finally
            {
                Utf8JsonWriterCache.ReturnWriter(writer);
            }
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.Text.Json.JsonElement" />.
        /// </summary>
        /// <typeparam name="TValue">The type of the value to serialize.</typeparam>
        /// <returns>A <see cref="T:System.Text.Json.JsonElement" /> representation of the JSON value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="options">Options to control the conversion behavior.</param>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static JsonElement SerializeToElement<TValue>(TValue value, JsonSerializerOptions? options = null)
        {
            JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
            return WriteElement<TValue>(in value, typeInfo);
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.Text.Json.JsonElement" />.
        /// </summary>
        /// <returns>A <see cref="T:System.Text.Json.JsonElement" /> representation of the value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        /// <param name="options">Options to control the conversion behavior.</param>
        /// <exception cref="T:System.ArgumentException">
        /// <paramref name="inputType" /> is not compatible with <paramref name="value" />.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="inputType" /> is <see langword="null" />.
        /// </exception>
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="inputType" />  or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static JsonElement SerializeToElement(object? value, Type inputType, JsonSerializerOptions? options = null)
        {
            ValidateInputType(value, inputType);
            JsonTypeInfo typeInfo = GetTypeInfo(options, inputType);
            return WriteElementAsObject(value, typeInfo);
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.Text.Json.JsonElement" />.
        /// </summary>
        /// <typeparam name="TValue">The type of the value to serialize.</typeparam>
        /// <returns>A <see cref="T:System.Text.Json.JsonElement" /> representation of the value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="jsonTypeInfo" /> is <see langword="null" />.
        /// </exception>
        public static JsonElement SerializeToElement<TValue>(TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
            }
            jsonTypeInfo.EnsureConfigured();
            return WriteElement(in value, jsonTypeInfo);
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.Text.Json.JsonElement" />.
        /// </summary>
        /// <returns>A <see cref="T:System.Text.Json.JsonElement" /> representation of the value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        /// <param name="context">A metadata provider for serializable types.</param>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="inputType" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided
        /// <paramref name="context" /> returns <see langword="null" /> for the type to convert.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="inputType" /> or <paramref name="context" /> is <see langword="null" />.
        /// </exception>
        public static JsonElement SerializeToElement(object? value, Type inputType, JsonSerializerContext context)
        {
            if (context == null)
            {
                ThrowHelper.ThrowArgumentNullException("context");
            }
            ValidateInputType(value, inputType);
            JsonTypeInfo typeInfo = GetTypeInfo(context, inputType);
            return WriteElementAsObject(value, typeInfo);
        }

        private static JsonElement WriteElement<TValue>(in TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            JsonSerializerOptions options = jsonTypeInfo.Options;
            PooledByteBufferWriter bufferWriter;
            Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriterAndBuffer(jsonTypeInfo.Options, out bufferWriter);
            try
            {
                WriteCore(writer, in value, jsonTypeInfo);
                return JsonElement.ParseValue(bufferWriter.WrittenMemory.Span, options.GetDocumentOptions());
            }
            finally
            {
                Utf8JsonWriterCache.ReturnWriterAndBuffer(writer, bufferWriter);
            }
        }

        private static JsonElement WriteElementAsObject(object value, JsonTypeInfo jsonTypeInfo)
        {
            JsonSerializerOptions options = jsonTypeInfo.Options;
            PooledByteBufferWriter bufferWriter;
            Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriterAndBuffer(jsonTypeInfo.Options, out bufferWriter);
            try
            {
                WriteCoreAsObject(writer, value, jsonTypeInfo);
                return JsonElement.ParseValue(bufferWriter.WrittenMemory.Span, options.GetDocumentOptions());
            }
            finally
            {
                Utf8JsonWriterCache.ReturnWriterAndBuffer(writer, bufferWriter);
            }
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
        /// </summary>
        /// <typeparam name="TValue">The type of the value to serialize.</typeparam>
        /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> representation of the JSON value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="options">Options to control the conversion behavior.</param>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static JsonNode? SerializeToNode<TValue>(TValue value, JsonSerializerOptions? options = null)
        {
            JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
            return WriteNode<TValue>(in value, typeInfo);
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
        /// </summary>
        /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> representation of the value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        /// <param name="options">Options to control the conversion behavior.</param>
        /// <exception cref="T:System.ArgumentException">
        /// <paramref name="inputType" /> is not compatible with <paramref name="value" />.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="inputType" /> is <see langword="null" />.
        /// </exception>
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="inputType" />  or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static JsonNode? SerializeToNode(object? value, Type inputType, JsonSerializerOptions? options = null)
        {
            ValidateInputType(value, inputType);
            JsonTypeInfo typeInfo = GetTypeInfo(options, inputType);
            return WriteNodeAsObject(value, typeInfo);
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
        /// </summary>
        /// <typeparam name="TValue">The type of the value to serialize.</typeparam>
        /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> representation of the value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="jsonTypeInfo" /> is <see langword="null" />.
        /// </exception>
        public static JsonNode? SerializeToNode<TValue>(TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
            }
            jsonTypeInfo.EnsureConfigured();
            return WriteNode(in value, jsonTypeInfo);
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
        /// </summary>
        /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> representation of the value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        /// <param name="context">A metadata provider for serializable types.</param>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="inputType" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided
        /// <paramref name="context" /> returns <see langword="null" /> for the type to convert.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="inputType" /> or <paramref name="context" /> is <see langword="null" />.
        /// </exception>
        public static JsonNode? SerializeToNode(object? value, Type inputType, JsonSerializerContext context)
        {
            if (context == null)
            {
                ThrowHelper.ThrowArgumentNullException("context");
            }
            ValidateInputType(value, inputType);
            JsonTypeInfo typeInfo = GetTypeInfo(context, inputType);
            return WriteNodeAsObject(value, typeInfo);
        }

        private static JsonNode WriteNode<TValue>(in TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            JsonSerializerOptions options = jsonTypeInfo.Options;
            PooledByteBufferWriter bufferWriter;
            Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriterAndBuffer(jsonTypeInfo.Options, out bufferWriter);
            try
            {
                WriteCore(writer, in value, jsonTypeInfo);
                return JsonNode.Parse(bufferWriter.WrittenMemory.Span, options.GetNodeOptions(), options.GetDocumentOptions());
            }
            finally
            {
                Utf8JsonWriterCache.ReturnWriterAndBuffer(writer, bufferWriter);
            }
        }

        private static JsonNode WriteNodeAsObject(object value, JsonTypeInfo jsonTypeInfo)
        {
            JsonSerializerOptions options = jsonTypeInfo.Options;
            PooledByteBufferWriter bufferWriter;
            Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriterAndBuffer(jsonTypeInfo.Options, out bufferWriter);
            try
            {
                WriteCoreAsObject(writer, value, jsonTypeInfo);
                return JsonNode.Parse(bufferWriter.WrittenMemory.Span, options.GetNodeOptions(), options.GetDocumentOptions());
            }
            finally
            {
                Utf8JsonWriterCache.ReturnWriterAndBuffer(writer, bufferWriter);
            }
        }

        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        private static JsonTypeInfo GetTypeInfo(JsonSerializerOptions options, Type inputType)
        {
            if (options == null)
            {
                options = JsonSerializerOptions.Default;
            }
            if (!options.IsInitializedForReflectionSerializer)
            {
                options.InitializeForReflectionSerializer();
            }
            if (!(inputType == JsonTypeInfo.ObjectType))
            {
                return options.GetTypeInfoForRootType(inputType);
            }
            return options.ObjectTypeInfo;
        }

        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        private static JsonTypeInfo<T> GetTypeInfo<T>(JsonSerializerOptions options)
        {
            return (JsonTypeInfo<T>)GetTypeInfo(options, typeof(T));
        }

        private static JsonTypeInfo GetTypeInfo(JsonSerializerContext context, Type inputType)
        {
            JsonTypeInfo typeInfo = context.GetTypeInfo(inputType);
            if (typeInfo == null)
            {
                ThrowHelper.ThrowInvalidOperationException_NoMetadataForType(inputType, context);
            }
            typeInfo.EnsureConfigured();
            return typeInfo;
        }

        internal static bool IsValidNumberHandlingValue(JsonNumberHandling handling)
        {
            return JsonHelpers.IsInRangeInclusive((int)handling, 0, 7);
        }

        internal static bool TryReadMetadata(JsonConverter converter, JsonTypeInfo jsonTypeInfo, ref Utf8JsonReader reader, scoped ref ReadStack state)
        {
            while (true)
            {
                if (state.Current.PropertyState == StackFramePropertyState.None)
                {
                    state.Current.PropertyState = StackFramePropertyState.ReadName;
                    if (!reader.Read())
                    {
                        return false;
                    }
                }
                if ((int)state.Current.PropertyState < 2)
                {
                    if (reader.TokenType == JsonTokenType.EndObject)
                    {
                        return true;
                    }
                    if (state.Current.MetadataPropertyNames.HasFlag(MetadataPropertyName.Ref))
                    {
                        ThrowHelper.ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties(reader.GetSpan(), ref state);
                    }
                    ReadOnlySpan<byte> span = reader.GetSpan();
                    switch (state.Current.LatestMetadataPropertyName = GetMetadataPropertyName(span, jsonTypeInfo.PolymorphicTypeResolver))
                    {
                        case MetadataPropertyName.Id:
                            state.Current.JsonPropertyName = s_idPropertyName;
                            if (state.ReferenceResolver == null)
                            {
                                ThrowHelper.ThrowJsonException_MetadataUnexpectedProperty(span, ref state);
                            }
                            if ((state.Current.MetadataPropertyNames & (MetadataPropertyName.Id | MetadataPropertyName.Ref)) != 0)
                            {
                                ThrowHelper.ThrowJsonException_MetadataIdIsNotFirstProperty(span, ref state);
                            }
                            if (!converter.CanHaveMetadata)
                            {
                                ThrowHelper.ThrowJsonException_MetadataCannotParsePreservedObjectIntoImmutable(converter.TypeToConvert);
                            }
                            break;
                        case MetadataPropertyName.Ref:
                            state.Current.JsonPropertyName = s_refPropertyName;
                            if (state.ReferenceResolver == null)
                            {
                                ThrowHelper.ThrowJsonException_MetadataUnexpectedProperty(span, ref state);
                            }
                            if (converter.IsValueType)
                            {
                                ThrowHelper.ThrowJsonException_MetadataInvalidReferenceToValueType(converter.TypeToConvert);
                            }
                            if (state.Current.MetadataPropertyNames != 0)
                            {
                                ThrowHelper.ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties(reader.GetSpan(), ref state);
                            }
                            break;
                        case MetadataPropertyName.Type:
                            state.Current.JsonPropertyName = jsonTypeInfo.PolymorphicTypeResolver?.TypeDiscriminatorPropertyNameUtf8 ?? s_typePropertyName;
                            if (jsonTypeInfo.PolymorphicTypeResolver == null)
                            {
                                ThrowHelper.ThrowJsonException_MetadataUnexpectedProperty(span, ref state);
                            }
                            if (state.PolymorphicTypeDiscriminator != null)
                            {
                                ThrowHelper.ThrowJsonException_MetadataDuplicateTypeProperty();
                            }
                            break;
                        case MetadataPropertyName.Values:
                            state.Current.JsonPropertyName = s_valuesPropertyName;
                            if (state.Current.MetadataPropertyNames == MetadataPropertyName.None)
                            {
                                ThrowHelper.ThrowJsonException_MetadataStandaloneValuesProperty(ref state, span);
                            }
                            break;
                        default:
                            return true;
                    }
                    state.Current.PropertyState = StackFramePropertyState.Name;
                }
                if ((int)state.Current.PropertyState < 3)
                {
                    state.Current.PropertyState = StackFramePropertyState.ReadValue;
                    if (!reader.Read())
                    {
                        break;
                    }
                }
                switch (state.Current.LatestMetadataPropertyName)
                {
                    case MetadataPropertyName.Id:
                        if (reader.TokenType != JsonTokenType.String)
                        {
                            ThrowHelper.ThrowJsonException_MetadataValueWasNotString(reader.TokenType);
                        }
                        if (state.ReferenceId != null)
                        {
                            ThrowHelper.ThrowNotSupportedException_ObjectWithParameterizedCtorRefMetadataNotSupported(s_refPropertyName, ref reader, ref state);
                        }
                        state.ReferenceId = reader.GetString();
                        break;
                    case MetadataPropertyName.Ref:
                        if (reader.TokenType != JsonTokenType.String)
                        {
                            ThrowHelper.ThrowJsonException_MetadataValueWasNotString(reader.TokenType);
                        }
                        if (state.ReferenceId != null)
                        {
                            ThrowHelper.ThrowNotSupportedException_ObjectWithParameterizedCtorRefMetadataNotSupported(s_refPropertyName, ref reader, ref state);
                        }
                        state.ReferenceId = reader.GetString();
                        break;
                    case MetadataPropertyName.Type:
                        switch (reader.TokenType)
                        {
                            case JsonTokenType.String:
                                state.PolymorphicTypeDiscriminator = reader.GetString();
                                break;
                            case JsonTokenType.Number:
                                state.PolymorphicTypeDiscriminator = reader.GetInt32();
                                break;
                            default:
                                ThrowHelper.ThrowJsonException_MetadataValueWasNotString(reader.TokenType);
                                break;
                        }
                        break;
                    case MetadataPropertyName.Values:
                        if (reader.TokenType != JsonTokenType.StartArray)
                        {
                            ThrowHelper.ThrowJsonException_MetadataValuesInvalidToken(reader.TokenType);
                        }
                        state.Current.PropertyState = StackFramePropertyState.None;
                        state.Current.MetadataPropertyNames |= state.Current.LatestMetadataPropertyName;
                        return true;
                }
                state.Current.MetadataPropertyNames |= state.Current.LatestMetadataPropertyName;
                state.Current.PropertyState = StackFramePropertyState.None;
                state.Current.JsonPropertyName = null;
            }
            return false;
        }

        internal static bool IsMetadataPropertyName(ReadOnlySpan<byte> propertyName, PolymorphicTypeResolver resolver)
        {
            if (propertyName.Length <= 0 || propertyName[0] != 36)
            {
                if (resolver == null)
                {
                    return false;
                }
                return resolver.TypeDiscriminatorPropertyNameUtf8?.AsSpan().SequenceEqual(propertyName) == true;
            }
            return true;
        }

        internal static MetadataPropertyName GetMetadataPropertyName(ReadOnlySpan<byte> propertyName, PolymorphicTypeResolver resolver)
        {
            if (propertyName.Length > 0 && propertyName[0] == 36)
            {
                switch (propertyName.Length)
                {
                    case 3:
                        if (propertyName[1] == 105 && propertyName[2] == 100)
                        {
                            return MetadataPropertyName.Id;
                        }
                        break;
                    case 4:
                        if (propertyName[1] == 114 && propertyName[2] == 101 && propertyName[3] == 102)
                        {
                            return MetadataPropertyName.Ref;
                        }
                        break;
                    case 5:
                        if (resolver?.TypeDiscriminatorPropertyNameUtf8 == null && propertyName[1] == 116 && propertyName[2] == 121 && propertyName[3] == 112 && propertyName[4] == 101)
                        {
                            return MetadataPropertyName.Type;
                        }
                        break;
                    case 7:
                        if (propertyName[1] == 118 && propertyName[2] == 97 && propertyName[3] == 108 && propertyName[4] == 117 && propertyName[5] == 101 && propertyName[6] == 115)
                        {
                            return MetadataPropertyName.Values;
                        }
                        break;
                }
            }
            byte[] array = resolver?.TypeDiscriminatorPropertyNameUtf8;
            if (array != null && propertyName.SequenceEqual(array))
            {
                return MetadataPropertyName.Type;
            }
            return MetadataPropertyName.None;
        }

        internal static bool TryHandleReferenceFromJsonElement(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonElement element, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out object referenceValue)
        {
            bool flag = false;
            referenceValue = null;
            if (element.ValueKind == JsonValueKind.Object)
            {
                int num = 0;
                foreach (JsonProperty item in element.EnumerateObject())
                {
                    num++;
                    if (flag)
                    {
                        ThrowHelper.ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties();
                        continue;
                    }
                    if (item.EscapedNameEquals(s_idPropertyName))
                    {
                        if (state.ReferenceId != null)
                        {
                            ThrowHelper.ThrowNotSupportedException_ObjectWithParameterizedCtorRefMetadataNotSupported(s_refPropertyName, ref reader, ref state);
                        }
                        if (item.Value.ValueKind != JsonValueKind.String)
                        {
                            ThrowHelper.ThrowJsonException_MetadataValueWasNotString(item.Value.ValueKind);
                        }
                        object obj = element;
                        state.ReferenceResolver.AddReference(item.Value.GetString(), obj);
                        referenceValue = obj;
                        return true;
                    }
                    if (item.EscapedNameEquals(s_refPropertyName))
                    {
                        if (state.ReferenceId != null)
                        {
                            ThrowHelper.ThrowNotSupportedException_ObjectWithParameterizedCtorRefMetadataNotSupported(s_refPropertyName, ref reader, ref state);
                        }
                        if (num > 1)
                        {
                            ThrowHelper.ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties();
                        }
                        if (item.Value.ValueKind != JsonValueKind.String)
                        {
                            ThrowHelper.ThrowJsonException_MetadataValueWasNotString(item.Value.ValueKind);
                        }
                        referenceValue = state.ReferenceResolver.ResolveReference(item.Value.GetString());
                        flag = true;
                    }
                }
            }
            return flag;
        }

        internal static bool TryHandleReferenceFromJsonNode(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonNode jsonNode, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out object referenceValue)
        {
            bool flag = false;
            referenceValue = null;
            if (jsonNode is JsonObject jsonObject)
            {
                int num = 0;
                foreach (KeyValuePair<string, JsonNode> item in jsonObject)
                {
                    num++;
                    if (flag)
                    {
                        ThrowHelper.ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties();
                        continue;
                    }
                    if (item.Key == "$id")
                    {
                        if (state.ReferenceId != null)
                        {
                            ThrowHelper.ThrowNotSupportedException_ObjectWithParameterizedCtorRefMetadataNotSupported(s_refPropertyName, ref reader, ref state);
                        }
                        string referenceId = ReadAsStringMetadataValue(item.Value);
                        state.ReferenceResolver.AddReference(referenceId, jsonNode);
                        referenceValue = jsonNode;
                        return true;
                    }
                    if (item.Key == "$ref")
                    {
                        if (state.ReferenceId != null)
                        {
                            ThrowHelper.ThrowNotSupportedException_ObjectWithParameterizedCtorRefMetadataNotSupported(s_refPropertyName, ref reader, ref state);
                        }
                        if (num > 1)
                        {
                            ThrowHelper.ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties();
                        }
                        string referenceId2 = ReadAsStringMetadataValue(item.Value);
                        referenceValue = state.ReferenceResolver.ResolveReference(referenceId2);
                        flag = true;
                    }
                }
            }
            return flag;
            static string ReadAsStringMetadataValue(JsonNode jsonNode)
            {
                if (jsonNode is JsonValue jsonValue && jsonValue.TryGetValue<string>(out string value) && value != null)
                {
                    return value;
                }
                JsonValueKind jsonValueKind = ((jsonNode == null) ? JsonValueKind.Null : ((jsonNode is JsonObject) ? JsonValueKind.Object : ((jsonNode is JsonArray) ? JsonValueKind.Array : ((jsonNode is JsonValue<JsonElement> jsonValue2) ? jsonValue2.Value.ValueKind : JsonValueKind.Undefined))));
                JsonValueKind valueKind = jsonValueKind;
                ThrowHelper.ThrowJsonException_MetadataValueWasNotString(valueKind);
                return null;
            }
        }

        internal static void ValidateMetadataForObjectConverter(JsonConverter converter, ref Utf8JsonReader reader, scoped ref ReadStack state)
        {
            if (state.Current.MetadataPropertyNames.HasFlag(MetadataPropertyName.Values))
            {
                ThrowHelper.ThrowJsonException_MetadataUnexpectedProperty(s_valuesPropertyName, ref state);
            }
        }

        internal static void ValidateMetadataForArrayConverter(JsonConverter converter, ref Utf8JsonReader reader, scoped ref ReadStack state)
        {
            switch (reader.TokenType)
            {
                case JsonTokenType.EndObject:
                    if (state.Current.MetadataPropertyNames != MetadataPropertyName.Ref)
                    {
                        ThrowHelper.ThrowJsonException_MetadataPreservedArrayValuesNotFound(ref state, converter.TypeToConvert);
                    }
                    break;
                default:
                    ThrowHelper.ThrowJsonException_MetadataInvalidPropertyInArrayMetadata(ref state, converter.TypeToConvert, in reader);
                    break;
                case JsonTokenType.StartArray:
                    break;
            }
        }

        internal static T ResolveReferenceId<T>(ref ReadStack state)
        {
            string referenceId = state.ReferenceId;
            object obj = state.ReferenceResolver.ResolveReference(referenceId);
            state.ReferenceId = null;
            try
            {
                return (T)obj;
            }
            catch (InvalidCastException)
            {
                ThrowHelper.ThrowInvalidOperationException_MetadataReferenceOfTypeCannotBeAssignedToType(referenceId, obj.GetType(), typeof(T));
                return default(T);
            }
        }

        /// <summary>
        /// Lookup the property given its name (obtained from the reader) and return it.
        /// Also sets state.Current.JsonPropertyInfo to a non-null value.
        /// </summary>
        internal static JsonPropertyInfo LookupProperty(object obj, ReadOnlySpan<byte> unescapedPropertyName, ref ReadStack state, JsonSerializerOptions options, out bool useExtensionProperty, bool createExtensionProperty = true)
        {
            useExtensionProperty = false;
            byte[] utf8PropertyName;
            JsonPropertyInfo jsonPropertyInfo = state.Current.JsonTypeInfo.GetProperty(unescapedPropertyName, ref state.Current, out utf8PropertyName);
            state.Current.PropertyIndex++;
            state.Current.JsonPropertyName = utf8PropertyName;
            if (jsonPropertyInfo == JsonPropertyInfo.s_missingProperty)
            {
                JsonPropertyInfo extensionDataProperty = state.Current.JsonTypeInfo.ExtensionDataProperty;
                if (extensionDataProperty != null && extensionDataProperty.HasGetter && extensionDataProperty.HasSetter)
                {
                    state.Current.JsonPropertyNameAsString = JsonHelpers.Utf8GetString(unescapedPropertyName);
                    if (createExtensionProperty)
                    {
                        CreateExtensionDataProperty(obj, extensionDataProperty, options);
                    }
                    jsonPropertyInfo = extensionDataProperty;
                    useExtensionProperty = true;
                }
            }
            state.Current.JsonPropertyInfo = jsonPropertyInfo;
            state.Current.NumberHandling = jsonPropertyInfo.EffectiveNumberHandling;
            return jsonPropertyInfo;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static ReadOnlySpan<byte> GetPropertyName(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonSerializerOptions options)
        {
            ReadOnlySpan<byte> span = reader.GetSpan();
            ReadOnlySpan<byte> result = ((!reader.ValueIsEscaped) ? span : JsonReaderHelper.GetUnescapedSpan(span));
            if (state.Current.CanContainMetadata && IsMetadataPropertyName(span, state.Current.BaseJsonTypeInfo.PolymorphicTypeResolver))
            {
                ThrowHelper.ThrowUnexpectedMetadataException(span, ref reader, ref state);
            }
            return result;
        }

        internal static void CreateExtensionDataProperty(object obj, JsonPropertyInfo jsonPropertyInfo, JsonSerializerOptions options)
        {
            object valueAsObject = jsonPropertyInfo.GetValueAsObject(obj);
            if (valueAsObject != null)
            {
                return;
            }
            Func<object> func = jsonPropertyInfo.JsonTypeInfo.CreateObject ?? jsonPropertyInfo.JsonTypeInfo.CreateObjectForExtensionDataProperty;
            if (func == null)
            {
                if (jsonPropertyInfo.PropertyType.FullName == "System.Text.Json.Nodes.JsonObject")
                {
                    ThrowHelper.ThrowInvalidOperationException_NodeJsonObjectCustomConverterNotAllowedOnExtensionProperty();
                }
                else
                {
                    ThrowHelper.ThrowNotSupportedException_SerializationNotSupported(jsonPropertyInfo.PropertyType);
                }
            }
            valueAsObject = func();
            jsonPropertyInfo.Set(obj, valueAsObject);
        }

        private static TValue ReadCore<TValue>(ref Utf8JsonReader reader, JsonTypeInfo jsonTypeInfo, scoped ref ReadStack state)
        {
            if (jsonTypeInfo is JsonTypeInfo<TValue> jsonTypeInfo2)
            {
                return jsonTypeInfo2.EffectiveConverter.ReadCore(ref reader, jsonTypeInfo2.Options, ref state);
            }
            object obj = jsonTypeInfo.Converter.ReadCoreAsObject(ref reader, jsonTypeInfo.Options, ref state);
            return (TValue)obj;
        }

        private static TValue ReadFromSpan<TValue>(ReadOnlySpan<byte> utf8Json, JsonTypeInfo jsonTypeInfo, int? actualByteCount = null)
        {
            JsonSerializerOptions options = jsonTypeInfo.Options;
            JsonReaderState state = new JsonReaderState(options.GetReaderOptions());
            Utf8JsonReader reader = new Utf8JsonReader(utf8Json, isFinalBlock: true, state);
            ReadStack state2 = default(ReadStack);
            state2.Initialize(jsonTypeInfo);
            if (jsonTypeInfo is JsonTypeInfo<TValue> jsonTypeInfo2)
            {
                return jsonTypeInfo2.EffectiveConverter.ReadCore(ref reader, options, ref state2);
            }
            object obj = jsonTypeInfo.Converter.ReadCoreAsObject(ref reader, options, ref state2);
            return (TValue)obj;
        }

        /// <summary>
        /// Parses the UTF-8 encoded text representing a single JSON value into a <typeparamref name="TValue" />.
        /// </summary>
        /// <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        /// <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <param name="utf8Json">JSON text to parse.</param>
        /// <param name="options">Options to control the behavior during parsing.</param>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid,
        /// <typeparamref name="TValue" /> is not compatible with the JSON,
        /// or when there is remaining data in the Stream.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static TValue? Deserialize<TValue>(ReadOnlySpan<byte> utf8Json, JsonSerializerOptions? options = null)
        {
            JsonTypeInfo typeInfo = GetTypeInfo(options, typeof(TValue));
            return ReadFromSpan<TValue>(utf8Json, typeInfo);
        }

        /// <summary>
        /// Parses the UTF-8 encoded text representing a single JSON value into a <paramref name="returnType" />.
        /// </summary>
        /// <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        /// <param name="utf8Json">JSON text to parse.</param>
        /// <param name="returnType">The type of the object to convert to and return.</param>
        /// <param name="options">Options to control the behavior during parsing.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="returnType" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid,
        /// <paramref name="returnType" /> is not compatible with the JSON,
        /// or when there is remaining data in the Stream.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="returnType" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static object? Deserialize(ReadOnlySpan<byte> utf8Json, Type returnType, JsonSerializerOptions? options = null)
        {
            if ((object)returnType == null)
            {
                ThrowHelper.ThrowArgumentNullException("returnType");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(options, returnType);
            return ReadFromSpan<object>(utf8Json, typeInfo);
        }

        /// <summary>
        /// Parses the UTF-8 encoded text representing a single JSON value into a <typeparamref name="TValue" />.
        /// </summary>
        /// <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        /// <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <param name="utf8Json">JSON text to parse.</param>
        /// <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid,
        /// <typeparamref name="TValue" /> is not compatible with the JSON,
        /// or when there is remaining data in the Stream.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        public static TValue? Deserialize<TValue>(ReadOnlySpan<byte> utf8Json, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
            }
            jsonTypeInfo.EnsureConfigured();
            return ReadFromSpan<TValue>(utf8Json, jsonTypeInfo);
        }

        /// <summary>
        /// Parses the UTF-8 encoded text representing a single JSON value into a <paramref name="returnType" />.
        /// </summary>
        /// <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        /// <param name="utf8Json">JSON text to parse.</param>
        /// <param name="returnType">The type of the object to convert to and return.</param>
        /// <param name="context">A metadata provider for serializable types.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="returnType" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid,
        /// <paramref name="returnType" /> is not compatible with the JSON,
        /// or when there is remaining data in the Stream.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="returnType" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method on the provided <paramref name="context" />
        /// did not return a compatible <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> for <paramref name="returnType" />.
        /// </exception>
        public static object? Deserialize(ReadOnlySpan<byte> utf8Json, Type returnType, JsonSerializerContext context)
        {
            if ((object)returnType == null)
            {
                ThrowHelper.ThrowArgumentNullException("returnType");
            }
            if (context == null)
            {
                ThrowHelper.ThrowArgumentNullException("context");
            }
            return ReadFromSpan<object>(utf8Json, GetTypeInfo(context, returnType));
        }

        /// <summary>
        /// Reads the UTF-8 encoded text representing a single JSON value into a <typeparamref name="TValue" />.
        /// The Stream will be read to completion.
        /// </summary>
        /// <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        /// <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <param name="utf8Json">JSON data to parse.</param>
        /// <param name="options">Options to control the behavior during reading.</param>
        /// <param name="cancellationToken">
        /// The <see cref="T:System.Threading.CancellationToken" /> that can be used to cancel the read operation.
        /// </param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="utf8Json" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid,
        /// <typeparamref name="TValue" /> is not compatible with the JSON,
        /// or when there is remaining data in the Stream.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static ValueTask<TValue?> DeserializeAsync<TValue>(Stream utf8Json, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(options, typeof(TValue));
            return ReadFromStreamAsync<TValue>(utf8Json, typeInfo, cancellationToken);
        }

        /// <summary>
        /// Reads the UTF-8 encoded text representing a single JSON value into a <typeparamref name="TValue" />.
        /// The Stream will be read to completion.
        /// </summary>
        /// <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        /// <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <param name="utf8Json">JSON data to parse.</param>
        /// <param name="options">Options to control the behavior during reading.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="utf8Json" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid,
        /// <typeparamref name="TValue" /> is not compatible with the JSON,
        /// or when there is remaining data in the Stream.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static TValue? Deserialize<TValue>(Stream utf8Json, JsonSerializerOptions? options = null)
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(options, typeof(TValue));
            return ReadFromStream<TValue>(utf8Json, typeInfo);
        }

        /// <summary>
        /// Reads the UTF-8 encoded text representing a single JSON value into a <paramref name="returnType" />.
        /// The Stream will be read to completion.
        /// </summary>
        /// <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        /// <param name="utf8Json">JSON data to parse.</param>
        /// <param name="returnType">The type of the object to convert to and return.</param>
        /// <param name="options">Options to control the behavior during reading.</param>
        /// <param name="cancellationToken">
        /// The <see cref="T:System.Threading.CancellationToken" /> that can be used to cancel the read operation.
        /// </param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="utf8Json" /> or <paramref name="returnType" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid,
        /// the <paramref name="returnType" /> is not compatible with the JSON,
        /// or when there is remaining data in the Stream.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="returnType" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static ValueTask<object?> DeserializeAsync(Stream utf8Json, Type returnType, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            if ((object)returnType == null)
            {
                ThrowHelper.ThrowArgumentNullException("returnType");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(options, returnType);
            return ReadFromStreamAsync<object>(utf8Json, typeInfo, cancellationToken);
        }

        /// <summary>
        /// Reads the UTF-8 encoded text representing a single JSON value into a <paramref name="returnType" />.
        /// The Stream will be read to completion.
        /// </summary>
        /// <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        /// <param name="utf8Json">JSON data to parse.</param>
        /// <param name="returnType">The type of the object to convert to and return.</param>
        /// <param name="options">Options to control the behavior during reading.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="utf8Json" /> or <paramref name="returnType" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid,
        /// the <paramref name="returnType" /> is not compatible with the JSON,
        /// or when there is remaining data in the Stream.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="returnType" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static object? Deserialize(Stream utf8Json, Type returnType, JsonSerializerOptions? options = null)
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            if ((object)returnType == null)
            {
                ThrowHelper.ThrowArgumentNullException("returnType");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(options, returnType);
            return ReadFromStream<object>(utf8Json, typeInfo);
        }

        /// <summary>
        /// Reads the UTF-8 encoded text representing a single JSON value into a <typeparamref name="TValue" />.
        /// The Stream will be read to completion.
        /// </summary>
        /// <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        /// <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <param name="utf8Json">JSON data to parse.</param>
        /// <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        /// <param name="cancellationToken">
        /// The <see cref="T:System.Threading.CancellationToken" /> that can be used to cancel the read operation.
        /// </param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="utf8Json" /> or <paramref name="jsonTypeInfo" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid,
        /// <typeparamref name="TValue" /> is not compatible with the JSON,
        /// or when there is remaining data in the Stream.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        public static ValueTask<TValue?> DeserializeAsync<TValue>(Stream utf8Json, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
            }
            jsonTypeInfo.EnsureConfigured();
            return ReadFromStreamAsync<TValue>(utf8Json, jsonTypeInfo, cancellationToken);
        }

        /// <summary>
        /// Reads the UTF-8 encoded text representing a single JSON value into a <typeparamref name="TValue" />.
        /// The Stream will be read to completion.
        /// </summary>
        /// <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        /// <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <param name="utf8Json">JSON data to parse.</param>
        /// <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="utf8Json" /> or <paramref name="jsonTypeInfo" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid,
        /// <typeparamref name="TValue" /> is not compatible with the JSON,
        /// or when there is remaining data in the Stream.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        public static TValue? Deserialize<TValue>(Stream utf8Json, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
            }
            jsonTypeInfo.EnsureConfigured();
            return ReadFromStream<TValue>(utf8Json, jsonTypeInfo);
        }

        /// <summary>
        /// Reads the UTF-8 encoded text representing a single JSON value into a <paramref name="returnType" />.
        /// The Stream will be read to completion.
        /// </summary>
        /// <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        /// <param name="utf8Json">JSON data to parse.</param>
        /// <param name="returnType">The type of the object to convert to and return.</param>
        /// <param name="context">A metadata provider for serializable types.</param>
        /// <param name="cancellationToken">
        /// The <see cref="T:System.Threading.CancellationToken" /> that can be used to cancel the read operation.
        /// </param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="utf8Json" />, <paramref name="returnType" />, or <paramref name="context" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid,
        /// the <paramref name="returnType" /> is not compatible with the JSON,
        /// or when there is remaining data in the Stream.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="returnType" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method on the provided <paramref name="context" />
        /// did not return a compatible <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> for <paramref name="returnType" />.
        /// </exception>
        public static ValueTask<object?> DeserializeAsync(Stream utf8Json, Type returnType, JsonSerializerContext context, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            if ((object)returnType == null)
            {
                ThrowHelper.ThrowArgumentNullException("returnType");
            }
            if (context == null)
            {
                ThrowHelper.ThrowArgumentNullException("context");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(context, returnType);
            return ReadFromStreamAsync<object>(utf8Json, typeInfo, cancellationToken);
        }

        /// <summary>
        /// Reads the UTF-8 encoded text representing a single JSON value into a <paramref name="returnType" />.
        /// The Stream will be read to completion.
        /// </summary>
        /// <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        /// <param name="utf8Json">JSON data to parse.</param>
        /// <param name="returnType">The type of the object to convert to and return.</param>
        /// <param name="context">A metadata provider for serializable types.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="utf8Json" />, <paramref name="returnType" />, or <paramref name="context" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid,
        /// the <paramref name="returnType" /> is not compatible with the JSON,
        /// or when there is remaining data in the Stream.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="returnType" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method on the provided <paramref name="context" />
        /// did not return a compatible <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> for <paramref name="returnType" />.
        /// </exception>
        public static object? Deserialize(Stream utf8Json, Type returnType, JsonSerializerContext context)
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            if ((object)returnType == null)
            {
                ThrowHelper.ThrowArgumentNullException("returnType");
            }
            if (context == null)
            {
                ThrowHelper.ThrowArgumentNullException("context");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(context, returnType);
            return ReadFromStream<object>(utf8Json, typeInfo);
        }

        /// <summary>
        /// Wraps the UTF-8 encoded text into an <see cref="T:System.Collections.Generic.IAsyncEnumerable`1" />
        /// that can be used to deserialize root-level JSON arrays in a streaming manner.
        /// </summary>
        /// <typeparam name="TValue">The element type to deserialize asynchronously.</typeparam>
        /// <returns>An <see cref="T:System.Collections.Generic.IAsyncEnumerable`1" /> representation of the provided JSON array.</returns>
        /// <param name="utf8Json">JSON data to parse.</param>
        /// <param name="options">Options to control the behavior during reading.</param>
        /// <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> that can be used to cancel the read operation.</param>
        /// <returns>An <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="utf8Json" /> is <see langword="null" />.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static IAsyncEnumerable<TValue?> DeserializeAsyncEnumerable<TValue>(Stream utf8Json, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(options, typeof(TValue));
            return CreateAsyncEnumerableDeserializer(utf8Json, CreateQueueTypeInfo<TValue>(typeInfo), cancellationToken);
        }

        /// <summary>
        /// Wraps the UTF-8 encoded text into an <see cref="T:System.Collections.Generic.IAsyncEnumerable`1" />
        /// that can be used to deserialize root-level JSON arrays in a streaming manner.
        /// </summary>
        /// <typeparam name="TValue">The element type to deserialize asynchronously.</typeparam>
        /// <returns>An <see cref="T:System.Collections.Generic.IAsyncEnumerable`1" /> representation of the provided JSON array.</returns>
        /// <param name="utf8Json">JSON data to parse.</param>
        /// <param name="jsonTypeInfo">Metadata about the element type to convert.</param>
        /// <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> that can be used to cancel the read operation.</param>
        /// <returns>An <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="utf8Json" /> or <paramref name="jsonTypeInfo" /> is <see langword="null" />.
        /// </exception>
        public static IAsyncEnumerable<TValue?> DeserializeAsyncEnumerable<TValue>(Stream utf8Json, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
            }
            return CreateAsyncEnumerableDeserializer(utf8Json, CreateQueueTypeInfo<TValue>(jsonTypeInfo), cancellationToken);
        }

        private static JsonTypeInfo<Queue<TValue>> CreateQueueTypeInfo<TValue>(JsonTypeInfo jsonTypeInfo)
        {
            JsonTypeInfo<Queue<TValue>> jsonTypeInfo2 = JsonMetadataServices.CreateQueueInfo<Queue<TValue>, TValue>(jsonTypeInfo.Options, new JsonCollectionInfoValues<Queue<TValue>>
            {
                ObjectCreator = () => new Queue<TValue>(),
                ElementInfo = jsonTypeInfo,
                NumberHandling = jsonTypeInfo.Options.NumberHandling
            });
            jsonTypeInfo2.EnsureConfigured();
            return jsonTypeInfo2;
        }

        private static async IAsyncEnumerable<TValue> CreateAsyncEnumerableDeserializer<TValue>(Stream utf8Json, JsonTypeInfo<Queue<TValue>> queueTypeInfo, [EnumeratorCancellation] CancellationToken cancellationToken)
        {
            JsonSerializerOptions options = queueTypeInfo.Options;
            ReadBufferState bufferState = new ReadBufferState(options.DefaultBufferSize);
            ReadStack readStack = default(ReadStack);
            readStack.Initialize(queueTypeInfo, supportContinuation: true);
            JsonReaderState jsonReaderState = new JsonReaderState(options.GetReaderOptions());
            try
            {
                do
                {
                    bufferState = await bufferState.ReadFromStreamAsync(utf8Json, cancellationToken, fillBuffer: false).ConfigureAwait(continueOnCapturedContext: false);
                    ContinueDeserialize<Queue<TValue>>(ref bufferState, ref jsonReaderState, ref readStack, queueTypeInfo);
                    object returnValue = readStack.Current.ReturnValue;
                    if (returnValue is Queue<TValue> queue)
                    {
                        while (queue.Count > 0)
                        {
                            yield return queue.Dequeue();
                        }
                    }
                }
                while (!bufferState.IsFinalBlock);
            }
            finally
            {
                bufferState.Dispose();
            }
        }

        internal static async ValueTask<TValue> ReadFromStreamAsync<TValue>(Stream utf8Json, JsonTypeInfo jsonTypeInfo, CancellationToken cancellationToken)
        {
            JsonSerializerOptions options = jsonTypeInfo.Options;
            ReadBufferState bufferState = new ReadBufferState(options.DefaultBufferSize);
            ReadStack readStack = default(ReadStack);
            readStack.Initialize(jsonTypeInfo, supportContinuation: true);
            JsonReaderState jsonReaderState = new JsonReaderState(options.GetReaderOptions());
            try
            {
                TValue result;
                do
                {
                    bufferState = await bufferState.ReadFromStreamAsync(utf8Json, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
                    result = ContinueDeserialize<TValue>(ref bufferState, ref jsonReaderState, ref readStack, jsonTypeInfo);
                }
                while (!bufferState.IsFinalBlock);
                return result;
            }
            finally
            {
                bufferState.Dispose();
            }
        }

        internal static TValue ReadFromStream<TValue>(Stream utf8Json, JsonTypeInfo jsonTypeInfo)
        {
            JsonSerializerOptions options = jsonTypeInfo.Options;
            ReadBufferState bufferState = new ReadBufferState(options.DefaultBufferSize);
            ReadStack readStack = default(ReadStack);
            readStack.Initialize(jsonTypeInfo, supportContinuation: true);
            JsonReaderState jsonReaderState = new JsonReaderState(options.GetReaderOptions());
            try
            {
                TValue result;
                do
                {
                    bufferState.ReadFromStream(utf8Json);
                    result = ContinueDeserialize<TValue>(ref bufferState, ref jsonReaderState, ref readStack, jsonTypeInfo);
                }
                while (!bufferState.IsFinalBlock);
                return result;
            }
            finally
            {
                bufferState.Dispose();
            }
        }

        internal static TValue ContinueDeserialize<TValue>(ref ReadBufferState bufferState, ref JsonReaderState jsonReaderState, ref ReadStack readStack, JsonTypeInfo jsonTypeInfo)
        {
            Utf8JsonReader reader = new Utf8JsonReader(bufferState.Bytes, bufferState.IsFinalBlock, jsonReaderState);
            readStack.ReadAhead = !bufferState.IsFinalBlock;
            readStack.BytesConsumed = 0L;
            TValue result = ReadCore<TValue>(ref reader, jsonTypeInfo, ref readStack);
            bufferState.AdvanceBuffer((int)readStack.BytesConsumed);
            jsonReaderState = reader.CurrentState;
            return result;
        }

        /// <summary>
        /// Parses the text representing a single JSON value into a <typeparamref name="TValue" />.
        /// </summary>
        /// <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        /// <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <param name="json">JSON text to parse.</param>
        /// <param name="options">Options to control the behavior during parsing.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="json" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid.
        ///
        /// -or-
        ///
        /// <typeparamref name="TValue" /> is not compatible with the JSON.
        ///
        /// -or-
        ///
        /// There is remaining data in the string beyond a single JSON value.</exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        /// <remarks>Using a <see cref="T:System.String" /> is not as efficient as using the
        /// UTF-8 methods since the implementation natively uses UTF-8.
        /// </remarks>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static TValue? Deserialize<TValue>([StringSyntax("Json")] string json, JsonSerializerOptions? options = null)
        {
            if (json == null)
            {
                ThrowHelper.ThrowArgumentNullException("json");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(options, typeof(TValue));
            return ReadFromSpan<TValue>(json.AsSpan(), typeInfo);
        }

        /// <summary>
        /// Parses the text representing a single JSON value into an instance of the type specified by a generic type parameter.
        /// </summary>
        /// <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        /// <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <param name="json">The JSON text to parse.</param>
        /// <param name="options">Options to control the behavior during parsing.</param>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid.
        ///
        /// -or-
        ///
        /// <typeparamref name="TValue" /> is not compatible with the JSON.
        ///
        /// -or-
        ///
        /// There is remaining data in the span beyond a single JSON value.</exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        /// <remarks>Using a UTF-16 span is not as efficient as using the
        /// UTF-8 methods since the implementation natively uses UTF-8.
        /// </remarks>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static TValue? Deserialize<TValue>([StringSyntax("Json")] ReadOnlySpan<char> json, JsonSerializerOptions? options = null)
        {
            JsonTypeInfo typeInfo = GetTypeInfo(options, typeof(TValue));
            return ReadFromSpan<TValue>(json, typeInfo);
        }

        /// <summary>
        /// Parses the text representing a single JSON value into a <paramref name="returnType" />.
        /// </summary>
        /// <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        /// <param name="json">JSON text to parse.</param>
        /// <param name="returnType">The type of the object to convert to and return.</param>
        /// <param name="options">Options to control the behavior during parsing.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="json" /> or <paramref name="returnType" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid.
        ///
        /// -or-
        ///
        /// <paramref name="returnType" /> is not compatible with the JSON.
        ///
        /// -or-
        ///
        /// There is remaining data in the string beyond a single JSON value.</exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="returnType" /> or its serializable members.
        /// </exception>
        /// <remarks>Using a <see cref="T:System.String" /> is not as efficient as using the
        /// UTF-8 methods since the implementation natively uses UTF-8.
        /// </remarks>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static object? Deserialize([StringSyntax("Json")] string json, Type returnType, JsonSerializerOptions? options = null)
        {
            if (json == null)
            {
                ThrowHelper.ThrowArgumentNullException("json");
            }
            if ((object)returnType == null)
            {
                ThrowHelper.ThrowArgumentNullException("returnType");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(options, returnType);
            return ReadFromSpan<object>(json.AsSpan(), typeInfo);
        }

        /// <summary>
        /// Parses the text representing a single JSON value into an instance of a specified type.
        /// </summary>
        /// <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        /// <param name="json">The JSON text to parse.</param>
        /// <param name="returnType">The type of the object to convert to and return.</param>
        /// <param name="options">Options to control the behavior during parsing.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="returnType" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid.
        ///
        /// -or-
        ///
        /// <paramref name="returnType" /> is not compatible with the JSON.
        ///
        /// -or-
        ///
        /// There is remaining data in the span beyond a single JSON value.</exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="returnType" /> or its serializable members.
        /// </exception>
        /// <remarks>Using a UTF-16 span is not as efficient as using the
        /// UTF-8 methods since the implementation natively uses UTF-8.
        /// </remarks>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static object? Deserialize([StringSyntax("Json")] ReadOnlySpan<char> json, Type returnType, JsonSerializerOptions? options = null)
        {
            if ((object)returnType == null)
            {
                ThrowHelper.ThrowArgumentNullException("returnType");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(options, returnType);
            return ReadFromSpan<object>(json, typeInfo);
        }

        /// <summary>
        /// Parses the text representing a single JSON value into a <typeparamref name="TValue" />.
        /// </summary>
        /// <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        /// <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <param name="json">JSON text to parse.</param>
        /// <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="json" /> is <see langword="null" />.
        ///
        /// -or-
        ///
        /// <paramref name="jsonTypeInfo" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid.
        ///
        /// -or-
        ///
        /// <typeparamref name="TValue" /> is not compatible with the JSON.
        ///
        /// -or-
        ///
        /// There is remaining data in the string beyond a single JSON value.</exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        /// <remarks>Using a <see cref="T:System.String" /> is not as efficient as using the
        /// UTF-8 methods since the implementation natively uses UTF-8.
        /// </remarks>
        public static TValue? Deserialize<TValue>([StringSyntax("Json")] string json, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            if (json == null)
            {
                ThrowHelper.ThrowArgumentNullException("json");
            }
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
            }
            jsonTypeInfo.EnsureConfigured();
            return ReadFromSpan<TValue>(json.AsSpan(), jsonTypeInfo);
        }

        /// <summary>
        /// Parses the text representing a single JSON value into a <typeparamref name="TValue" />.
        /// </summary>
        /// <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        /// <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <param name="json">JSON text to parse.</param>
        /// <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="json" /> is <see langword="null" />.
        ///
        /// -or-
        ///
        /// <paramref name="jsonTypeInfo" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid.
        ///
        /// -or-
        ///
        /// <typeparamref name="TValue" /> is not compatible with the JSON.
        ///
        /// -or-
        ///
        /// There is remaining data in the string beyond a single JSON value.</exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        /// <remarks>Using a <see cref="T:System.String" /> is not as efficient as using the
        /// UTF-8 methods since the implementation natively uses UTF-8.
        /// </remarks>
        public static TValue? Deserialize<TValue>([StringSyntax("Json")] ReadOnlySpan<char> json, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
            }
            jsonTypeInfo.EnsureConfigured();
            return ReadFromSpan<TValue>(json, jsonTypeInfo);
        }

        /// <summary>
        /// Parses the text representing a single JSON value into a <paramref name="returnType" />.
        /// </summary>
        /// <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        /// <param name="json">JSON text to parse.</param>
        /// <param name="returnType">The type of the object to convert to and return.</param>
        /// <param name="context">A metadata provider for serializable types.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="json" /> or <paramref name="returnType" /> is <see langword="null" />.
        ///
        /// -or-
        ///
        /// <paramref name="context" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid.
        ///
        /// -or-
        ///
        /// <paramref name="returnType" /> is not compatible with the JSON.
        ///
        /// -or-
        ///
        /// There is remaining data in the string beyond a single JSON value.</exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="returnType" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided
        /// <paramref name="context" /> returns <see langword="null" /> for the type to convert.
        /// </exception>
        /// <remarks>Using a <see cref="T:System.String" /> is not as efficient as using the
        /// UTF-8 methods since the implementation natively uses UTF-8.
        /// </remarks>
        public static object? Deserialize([StringSyntax("Json")] string json, Type returnType, JsonSerializerContext context)
        {
            if (json == null)
            {
                ThrowHelper.ThrowArgumentNullException("json");
            }
            if ((object)returnType == null)
            {
                ThrowHelper.ThrowArgumentNullException("returnType");
            }
            if (context == null)
            {
                ThrowHelper.ThrowArgumentNullException("context");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(context, returnType);
            return ReadFromSpan<object>(json.AsSpan(), typeInfo);
        }

        /// <summary>
        /// Parses the text representing a single JSON value into a <paramref name="returnType" />.
        /// </summary>
        /// <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        /// <param name="json">JSON text to parse.</param>
        /// <param name="returnType">The type of the object to convert to and return.</param>
        /// <param name="context">A metadata provider for serializable types.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="json" /> or <paramref name="returnType" /> is <see langword="null" />.
        ///
        /// -or-
        ///
        /// <paramref name="context" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid.
        ///
        /// -or-
        ///
        /// <paramref name="returnType" /> is not compatible with the JSON.
        ///
        /// -or-
        ///
        /// There is remaining data in the string beyond a single JSON value.</exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="returnType" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided
        /// <paramref name="context" /> returns <see langword="null" /> for the type to convert.
        /// </exception>
        /// <remarks>Using a <see cref="T:System.String" /> is not as efficient as using the
        /// UTF-8 methods since the implementation natively uses UTF-8.
        /// </remarks>
        public static object? Deserialize([StringSyntax("Json")] ReadOnlySpan<char> json, Type returnType, JsonSerializerContext context)
        {
            if ((object)returnType == null)
            {
                ThrowHelper.ThrowArgumentNullException("returnType");
            }
            if (context == null)
            {
                ThrowHelper.ThrowArgumentNullException("context");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(context, returnType);
            return ReadFromSpan<object>(json, typeInfo);
        }

        private static TValue ReadFromSpan<TValue>(ReadOnlySpan<char> json, JsonTypeInfo jsonTypeInfo)
        {
            byte[] array = null;
            Span<byte> span = (((long)json.Length > 349525L) ? new byte[JsonReaderHelper.GetUtf8ByteCount(json)] : (array = ArrayPool<byte>.Shared.Rent(json.Length * 3)));
            try
            {
                int utf8FromText = JsonReaderHelper.GetUtf8FromText(json, span);
                span = span.Slice(0, utf8FromText);
                return ReadFromSpan<TValue>(span, jsonTypeInfo, utf8FromText);
            }
            finally
            {
                if (array != null)
                {
                    span.Clear();
                    ArrayPool<byte>.Shared.Return(array);
                }
            }
        }

        /// <summary>
        /// Reads one JSON value (including objects or arrays) from the provided reader into a <typeparamref name="TValue" />.
        /// </summary>
        /// <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        /// <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <param name="reader">The reader to read.</param>
        /// <param name="options">Options to control the serializer behavior during reading.</param>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid,
        /// <typeparamref name="TValue" /> is not compatible with the JSON,
        /// or a value could not be read from the reader.
        /// </exception>
        /// <exception cref="T:System.ArgumentException">
        ///   <paramref name="reader" /> is using unsupported options.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        /// <remarks>
        ///   <para>
        ///     If the <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> property of <paramref name="reader" />
        ///     is <see cref="F:System.Text.Json.JsonTokenType.PropertyName" /> or <see cref="F:System.Text.Json.JsonTokenType.None" />, the
        ///     reader will be advanced by one call to <see cref="M:System.Text.Json.Utf8JsonReader.Read" /> to determine
        ///     the start of the value.
        ///   </para>
        ///
        ///   <para>
        ///     Upon completion of this method, <paramref name="reader" /> will be positioned at the
        ///     final token in the JSON value. If an exception is thrown, the reader is reset to
        ///     the state it was in when the method was called.
        ///   </para>
        ///
        ///   <para>
        ///     This method makes a copy of the data the reader acted on, so there is no caller
        ///     requirement to maintain data integrity beyond the return of this method.
        ///   </para>
        ///
        ///   <para>
        ///     The <see cref="T:System.Text.Json.JsonReaderOptions" /> used to create the instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> take precedence over the <see cref="T:System.Text.Json.JsonSerializerOptions" /> when they conflict.
        ///     Hence, <see cref="P:System.Text.Json.JsonReaderOptions.AllowTrailingCommas" />, <see cref="P:System.Text.Json.JsonReaderOptions.MaxDepth" />, and <see cref="P:System.Text.Json.JsonReaderOptions.CommentHandling" /> are used while reading.
        ///   </para>
        /// </remarks>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static TValue? Deserialize<TValue>(ref Utf8JsonReader reader, JsonSerializerOptions? options = null)
        {
            JsonTypeInfo typeInfo = GetTypeInfo(options, typeof(TValue));
            return Read<TValue>(ref reader, typeInfo);
        }

        /// <summary>
        /// Reads one JSON value (including objects or arrays) from the provided reader into a <paramref name="returnType" />.
        /// </summary>
        /// <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        /// <param name="reader">The reader to read.</param>
        /// <param name="returnType">The type of the object to convert to and return.</param>
        /// <param name="options">Options to control the serializer behavior during reading.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="returnType" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid,
        /// <paramref name="returnType" /> is not compatible with the JSON,
        /// or a value could not be read from the reader.
        /// </exception>
        /// <exception cref="T:System.ArgumentException">
        ///   <paramref name="reader" /> is using unsupported options.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="returnType" /> or its serializable members.
        /// </exception>
        /// <remarks>
        ///   <para>
        ///     If the <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> property of <paramref name="reader" />
        ///     is <see cref="F:System.Text.Json.JsonTokenType.PropertyName" /> or <see cref="F:System.Text.Json.JsonTokenType.None" />, the
        ///     reader will be advanced by one call to <see cref="M:System.Text.Json.Utf8JsonReader.Read" /> to determine
        ///     the start of the value.
        ///   </para>
        ///
        ///   <para>
        ///     Upon completion of this method, <paramref name="reader" /> will be positioned at the
        ///     final token in the JSON value. If an exception is thrown, the reader is reset to
        ///     the state it was in when the method was called.
        ///   </para>
        ///
        ///   <para>
        ///     This method makes a copy of the data the reader acted on, so there is no caller
        ///     requirement to maintain data integrity beyond the return of this method.
        ///   </para>
        ///   <para>
        ///     The <see cref="T:System.Text.Json.JsonReaderOptions" /> used to create the instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> take precedence over the <see cref="T:System.Text.Json.JsonSerializerOptions" /> when they conflict.
        ///     Hence, <see cref="P:System.Text.Json.JsonReaderOptions.AllowTrailingCommas" />, <see cref="P:System.Text.Json.JsonReaderOptions.MaxDepth" />, and <see cref="P:System.Text.Json.JsonReaderOptions.CommentHandling" /> are used while reading.
        ///   </para>
        /// </remarks>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static object? Deserialize(ref Utf8JsonReader reader, Type returnType, JsonSerializerOptions? options = null)
        {
            if ((object)returnType == null)
            {
                ThrowHelper.ThrowArgumentNullException("returnType");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(options, returnType);
            return Read<object>(ref reader, typeInfo);
        }

        /// <summary>
        /// Reads one JSON value (including objects or arrays) from the provided reader into a <typeparamref name="TValue" />.
        /// </summary>
        /// <typeparam name="TValue">The type to deserialize the JSON value into.</typeparam>
        /// <returns>A <typeparamref name="TValue" /> representation of the JSON value.</returns>
        /// <param name="reader">The reader to read.</param>
        /// <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid,
        /// <typeparamref name="TValue" /> is not compatible with the JSON,
        /// or a value could not be read from the reader.
        /// </exception>
        /// <exception cref="T:System.ArgumentException">
        ///   <paramref name="reader" /> is using unsupported options.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        /// <remarks>
        ///   <para>
        ///     If the <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> property of <paramref name="reader" />
        ///     is <see cref="F:System.Text.Json.JsonTokenType.PropertyName" /> or <see cref="F:System.Text.Json.JsonTokenType.None" />, the
        ///     reader will be advanced by one call to <see cref="M:System.Text.Json.Utf8JsonReader.Read" /> to determine
        ///     the start of the value.
        ///   </para>
        ///
        ///   <para>
        ///     Upon completion of this method, <paramref name="reader" /> will be positioned at the
        ///     final token in the JSON value. If an exception is thrown, the reader is reset to
        ///     the state it was in when the method was called.
        ///   </para>
        ///
        ///   <para>
        ///     This method makes a copy of the data the reader acted on, so there is no caller
        ///     requirement to maintain data integrity beyond the return of this method.
        ///   </para>
        ///
        ///   <para>
        ///     The <see cref="T:System.Text.Json.JsonReaderOptions" /> used to create the instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> take precedence over the <see cref="T:System.Text.Json.JsonSerializerOptions" /> when they conflict.
        ///     Hence, <see cref="P:System.Text.Json.JsonReaderOptions.AllowTrailingCommas" />, <see cref="P:System.Text.Json.JsonReaderOptions.MaxDepth" />, and <see cref="P:System.Text.Json.JsonReaderOptions.CommentHandling" /> are used while reading.
        ///   </para>
        /// </remarks>
        public static TValue? Deserialize<TValue>(ref Utf8JsonReader reader, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
            }
            jsonTypeInfo.EnsureConfigured();
            return Read<TValue>(ref reader, jsonTypeInfo);
        }

        /// <summary>
        /// Reads one JSON value (including objects or arrays) from the provided reader into a <paramref name="returnType" />.
        /// </summary>
        /// <returns>A <paramref name="returnType" /> representation of the JSON value.</returns>
        /// <param name="reader">The reader to read.</param>
        /// <param name="returnType">The type of the object to convert to and return.</param>
        /// <param name="context">A metadata provider for serializable types.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="returnType" /> or <paramref name="context" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// The JSON is invalid,
        /// <paramref name="returnType" /> is not compatible with the JSON,
        /// or a value could not be read from the reader.
        /// </exception>
        /// <exception cref="T:System.ArgumentException">
        ///   <paramref name="reader" /> is using unsupported options.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="returnType" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method on the provided <paramref name="context" />
        /// did not return a compatible <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> for <paramref name="returnType" />.
        /// </exception>
        /// <remarks>
        ///   <para>
        ///     If the <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> property of <paramref name="reader" />
        ///     is <see cref="F:System.Text.Json.JsonTokenType.PropertyName" /> or <see cref="F:System.Text.Json.JsonTokenType.None" />, the
        ///     reader will be advanced by one call to <see cref="M:System.Text.Json.Utf8JsonReader.Read" /> to determine
        ///     the start of the value.
        ///   </para>
        ///
        ///   <para>
        ///     Upon completion of this method, <paramref name="reader" /> will be positioned at the
        ///     final token in the JSON value. If an exception is thrown, the reader is reset to
        ///     the state it was in when the method was called.
        ///   </para>
        ///
        ///   <para>
        ///     This method makes a copy of the data the reader acted on, so there is no caller
        ///     requirement to maintain data integrity beyond the return of this method.
        ///   </para>
        ///   <para>
        ///     The <see cref="T:System.Text.Json.JsonReaderOptions" /> used to create the instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> take precedence over the <see cref="T:System.Text.Json.JsonSerializerOptions" /> when they conflict.
        ///     Hence, <see cref="P:System.Text.Json.JsonReaderOptions.AllowTrailingCommas" />, <see cref="P:System.Text.Json.JsonReaderOptions.MaxDepth" />, and <see cref="P:System.Text.Json.JsonReaderOptions.CommentHandling" /> are used while reading.
        ///   </para>
        /// </remarks>
        public static object? Deserialize(ref Utf8JsonReader reader, Type returnType, JsonSerializerContext context)
        {
            if ((object)returnType == null)
            {
                ThrowHelper.ThrowArgumentNullException("returnType");
            }
            if (context == null)
            {
                ThrowHelper.ThrowArgumentNullException("context");
            }
            return Read<object>(ref reader, GetTypeInfo(context, returnType));
        }

        private static TValue Read<TValue>(ref Utf8JsonReader reader, JsonTypeInfo jsonTypeInfo)
        {
            if (reader.CurrentState.Options.CommentHandling == JsonCommentHandling.Allow)
            {
                ThrowHelper.ThrowArgumentException_SerializerDoesNotSupportComments("reader");
            }
            ReadStack state = default(ReadStack);
            state.Initialize(jsonTypeInfo);
            Utf8JsonReader utf8JsonReader = reader;
            try
            {
                Utf8JsonReader reader2 = GetReaderScopedToNextValue(ref reader, ref state);
                return ReadCore<TValue>(ref reader2, jsonTypeInfo, ref state);
            }
            catch (JsonException)
            {
                reader = utf8JsonReader;
                throw;
            }
        }

        private static Utf8JsonReader GetReaderScopedToNextValue(ref Utf8JsonReader reader, scoped ref ReadStack state)
        {
            ReadOnlySpan<byte> jsonData = default(ReadOnlySpan<byte>);
            ReadOnlySequence<byte> jsonData2 = default(ReadOnlySequence<byte>);
            try
            {
                JsonTokenType tokenType = reader.TokenType;
                ReadOnlySpan<byte> bytes;
                if ((tokenType == JsonTokenType.None || tokenType == JsonTokenType.PropertyName) && !reader.Read())
                {
                    bytes = default(ReadOnlySpan<byte>);
                    ThrowHelper.ThrowJsonReaderException(ref reader, ExceptionResource.ExpectedOneCompleteToken, 0, bytes);
                }
                switch (reader.TokenType)
                {
                    case JsonTokenType.StartObject:
                    case JsonTokenType.StartArray:
                        {
                            long tokenStartIndex = reader.TokenStartIndex;
                            if (!reader.TrySkip())
                            {
                                bytes = default(ReadOnlySpan<byte>);
                                ThrowHelper.ThrowJsonReaderException(ref reader, ExceptionResource.NotEnoughData, 0, bytes);
                            }
                            long num2 = reader.BytesConsumed - tokenStartIndex;
                            ReadOnlySequence<byte> originalSequence = reader.OriginalSequence;
                            if (originalSequence.IsEmpty)
                            {
                                bytes = reader.OriginalSpan;
                                jsonData = checked(bytes.Slice((int)tokenStartIndex, (int)num2));
                            }
                            else
                            {
                                jsonData2 = originalSequence.Slice(tokenStartIndex, num2);
                            }
                            break;
                        }
                    case JsonTokenType.Number:
                    case JsonTokenType.True:
                    case JsonTokenType.False:
                    case JsonTokenType.Null:
                        if (reader.HasValueSequence)
                        {
                            jsonData2 = reader.ValueSequence;
                        }
                        else
                        {
                            jsonData = reader.ValueSpan;
                        }
                        break;
                    case JsonTokenType.String:
                        {
                            ReadOnlySequence<byte> originalSequence2 = reader.OriginalSequence;
                            if (originalSequence2.IsEmpty)
                            {
                                bytes = reader.ValueSpan;
                                int length = bytes.Length + 2;
                                jsonData = reader.OriginalSpan.Slice((int)reader.TokenStartIndex, length);
                                break;
                            }
                            long num3;
                            if (!reader.HasValueSequence)
                            {
                                bytes = reader.ValueSpan;
                                num3 = bytes.Length + 2;
                            }
                            else
                            {
                                num3 = reader.ValueSequence.Length + 2;
                            }
                            long length2 = num3;
                            jsonData2 = originalSequence2.Slice(reader.TokenStartIndex, length2);
                            break;
                        }
                    default:
                        {
                            byte num;
                            if (!reader.HasValueSequence)
                            {
                                bytes = reader.ValueSpan;
                                num = bytes[0];
                            }
                            else
                            {
                                bytes = reader.ValueSequence.First.Span;
                                num = bytes[0];
                            }
                            byte nextByte = num;
                            bytes = default(ReadOnlySpan<byte>);
                            ThrowHelper.ThrowJsonReaderException(ref reader, ExceptionResource.ExpectedStartOfValueNotFound, nextByte, bytes);
                            break;
                        }
                }
            }
            catch (JsonReaderException ex)
            {
                ThrowHelper.ReThrowWithPath(ref state, ex);
            }
            if (!jsonData.IsEmpty)
            {
                return new Utf8JsonReader(jsonData, reader.CurrentState.Options);
            }
            return new Utf8JsonReader(jsonData2, reader.CurrentState.Options);
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.Byte" /> array.
        /// </summary>
        /// <returns>A UTF-8 representation of the value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="options">Options to control the conversion behavior.</param>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static byte[] SerializeToUtf8Bytes<TValue>(TValue value, JsonSerializerOptions? options = null)
        {
            JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
            return WriteBytes<TValue>(in value, typeInfo);
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.Byte" /> array.
        /// </summary>
        /// <returns>A UTF-8 representation of the value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        /// <param name="options">Options to control the conversion behavior.</param>
        /// <exception cref="T:System.ArgumentException">
        /// <paramref name="inputType" /> is not compatible with <paramref name="value" />.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="inputType" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="inputType" />  or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static byte[] SerializeToUtf8Bytes(object? value, Type inputType, JsonSerializerOptions? options = null)
        {
            ValidateInputType(value, inputType);
            JsonTypeInfo typeInfo = GetTypeInfo(options, inputType);
            return WriteBytesAsObject(value, typeInfo);
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.Byte" /> array.
        /// </summary>
        /// <returns>A UTF-8 representation of the value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="jsonTypeInfo" /> is <see langword="null" />.
        /// </exception>
        public static byte[] SerializeToUtf8Bytes<TValue>(TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
            }
            jsonTypeInfo.EnsureConfigured();
            return WriteBytes(in value, jsonTypeInfo);
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.Byte" /> array.
        /// </summary>
        /// <returns>A UTF-8 representation of the value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        /// <param name="context">A metadata provider for serializable types.</param>
        /// <exception cref="T:System.ArgumentException">
        /// <paramref name="inputType" /> is not compatible with <paramref name="value" />.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="inputType" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="inputType" />  or its serializable members.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided
        /// <paramref name="context" /> returns <see langword="null" /> for the type to convert.
        /// </exception>
        public static byte[] SerializeToUtf8Bytes(object? value, Type inputType, JsonSerializerContext context)
        {
            if (context == null)
            {
                ThrowHelper.ThrowArgumentNullException("context");
            }
            ValidateInputType(value, inputType);
            JsonTypeInfo typeInfo = GetTypeInfo(context, inputType);
            return WriteBytesAsObject(value, typeInfo);
        }

        private static byte[] WriteBytes<TValue>(in TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            PooledByteBufferWriter bufferWriter;
            Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriterAndBuffer(jsonTypeInfo.Options, out bufferWriter);
            try
            {
                WriteCore(writer, in value, jsonTypeInfo);
                return bufferWriter.WrittenMemory.ToArray();
            }
            finally
            {
                Utf8JsonWriterCache.ReturnWriterAndBuffer(writer, bufferWriter);
            }
        }

        private static byte[] WriteBytesAsObject(object value, JsonTypeInfo jsonTypeInfo)
        {
            PooledByteBufferWriter bufferWriter;
            Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriterAndBuffer(jsonTypeInfo.Options, out bufferWriter);
            try
            {
                WriteCoreAsObject(writer, value, jsonTypeInfo);
                return bufferWriter.WrittenMemory.ToArray();
            }
            finally
            {
                Utf8JsonWriterCache.ReturnWriterAndBuffer(writer, bufferWriter);
            }
        }

        internal static MetadataPropertyName WriteMetadataForObject(JsonConverter jsonConverter, ref WriteStack state, Utf8JsonWriter writer)
        {
            MetadataPropertyName metadataPropertyName = MetadataPropertyName.None;
            if (state.NewReferenceId != null)
            {
                writer.WriteString(s_metadataId, state.NewReferenceId);
                metadataPropertyName |= MetadataPropertyName.Id;
                state.NewReferenceId = null;
            }
            object polymorphicTypeDiscriminator = state.PolymorphicTypeDiscriminator;
            if (polymorphicTypeDiscriminator != null)
            {
                JsonEncodedText? customTypeDiscriminatorPropertyNameJsonEncoded = state.Parent.JsonPropertyInfo.JsonTypeInfo.PolymorphicTypeResolver.CustomTypeDiscriminatorPropertyNameJsonEncoded;
                JsonEncodedText jsonEncodedText;
                if (customTypeDiscriminatorPropertyNameJsonEncoded.HasValue)
                {
                    JsonEncodedText valueOrDefault = customTypeDiscriminatorPropertyNameJsonEncoded.GetValueOrDefault();
                    jsonEncodedText = valueOrDefault;
                }
                else
                {
                    jsonEncodedText = s_metadataType;
                }
                JsonEncodedText propertyName = jsonEncodedText;
                if (polymorphicTypeDiscriminator is string value)
                {
                    writer.WriteString(propertyName, value);
                }
                else
                {
                    writer.WriteNumber(propertyName, (int)polymorphicTypeDiscriminator);
                }
                metadataPropertyName |= MetadataPropertyName.Type;
                state.PolymorphicTypeDiscriminator = null;
            }
            return metadataPropertyName;
        }

        internal static MetadataPropertyName WriteMetadataForCollection(JsonConverter jsonConverter, ref WriteStack state, Utf8JsonWriter writer)
        {
            writer.WriteStartObject();
            MetadataPropertyName result = WriteMetadataForObject(jsonConverter, ref state, writer);
            writer.WritePropertyName(s_metadataValues);
            return result;
        }

        /// <summary>
        /// Compute reference id for the next value to be serialized.
        /// </summary>
        internal static bool TryGetReferenceForValue(object currentValue, ref WriteStack state, Utf8JsonWriter writer)
        {
            bool alreadyExists;
            string reference = state.ReferenceResolver.GetReference(currentValue, out alreadyExists);
            if (alreadyExists)
            {
                writer.WriteStartObject();
                writer.WriteString(s_metadataRef, reference);
                writer.WriteEndObject();
                state.PolymorphicTypeDiscriminator = null;
            }
            else
            {
                state.NewReferenceId = reference;
            }
            return alreadyExists;
        }

        /// <summary>
        /// Sync, strongly typed root value serialization helper.
        /// </summary>
        private static void WriteCore<TValue>(Utf8JsonWriter writer, in TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            if (jsonTypeInfo.CanUseSerializeHandler)
            {
                jsonTypeInfo.SerializeHandler(writer, value);
            }
            else
            {
                WriteStack state = default(WriteStack);
                JsonTypeInfo jsonTypeInfo2 = ResolvePolymorphicTypeInfo(in value, jsonTypeInfo, out state.IsPolymorphicRootValue);
                state.Initialize(jsonTypeInfo2);
                bool flag = (state.IsPolymorphicRootValue ? jsonTypeInfo2.Converter.WriteCoreAsObject(writer, value, jsonTypeInfo.Options, ref state) : jsonTypeInfo.EffectiveConverter.WriteCore(writer, in value, jsonTypeInfo.Options, ref state));
            }
            writer.Flush();
        }

        /// <summary>
        /// Sync, untyped root value serialization helper.
        /// </summary>
        private static void WriteCoreAsObject(Utf8JsonWriter writer, object value, JsonTypeInfo jsonTypeInfo)
        {
            WriteStack state = default(WriteStack);
            JsonTypeInfo jsonTypeInfo2 = ResolvePolymorphicTypeInfo(in value, jsonTypeInfo, out state.IsPolymorphicRootValue);
            state.Initialize(jsonTypeInfo2);
            bool flag = jsonTypeInfo2.Converter.WriteCoreAsObject(writer, value, jsonTypeInfo.Options, ref state);
            writer.Flush();
        }

        /// <summary>
        /// Streaming root-level serialization helper.
        /// </summary>
        private static bool WriteCore<TValue>(Utf8JsonWriter writer, in TValue value, JsonTypeInfo jsonTypeInfo, ref WriteStack state)
        {
            bool result = ((!(jsonTypeInfo is JsonTypeInfo<TValue> jsonTypeInfo2)) ? jsonTypeInfo.Converter.WriteCoreAsObject(writer, value, jsonTypeInfo.Options, ref state) : jsonTypeInfo2.EffectiveConverter.WriteCore(writer, in value, jsonTypeInfo.Options, ref state));
            writer.Flush();
            return result;
        }

        private static JsonTypeInfo ResolvePolymorphicTypeInfo<TValue>(in TValue value, JsonTypeInfo jsonTypeInfo, out bool isPolymorphicType)
        {
            if (jsonTypeInfo.Converter.CanBePolymorphic && value != null)
            {
                TValue val = value;
                Type type = val.GetType();
                if (type != jsonTypeInfo.Type)
                {
                    isPolymorphicType = true;
                    return jsonTypeInfo.Options.GetTypeInfoForRootType(type);
                }
            }
            isPolymorphicType = false;
            return jsonTypeInfo;
        }

        private static void ValidateInputType(object value, Type inputType)
        {
            if ((object)inputType == null)
            {
                ThrowHelper.ThrowArgumentNullException("inputType");
            }
            if (value != null)
            {
                Type type = value.GetType();
                if (!inputType.IsAssignableFrom(type))
                {
                    ThrowHelper.ThrowArgumentException_DeserializeWrongType(inputType, value);
                }
            }
        }

        /// <summary>
        /// Converts the provided value to UTF-8 encoded JSON text and write it to the <see cref="T:System.IO.Stream" />.
        /// </summary>
        /// <typeparam name="TValue">The type of the value to serialize.</typeparam>
        /// <returns>A task that represents the asynchronous write operation.</returns>
        /// <param name="utf8Json">The UTF-8 <see cref="T:System.IO.Stream" /> to write to.</param>
        /// <param name="value">The value to convert.</param>
        /// <param name="options">Options to control the conversion behavior.</param>
        /// <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> that can be used to cancel the write operation.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="utf8Json" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static Task SerializeAsync<TValue>(Stream utf8Json, TValue value, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(options, typeof(TValue));
            return WriteStreamAsync(utf8Json, value, typeInfo, cancellationToken);
        }

        /// <summary>
        /// Converts the provided value to UTF-8 encoded JSON text and write it to the <see cref="T:System.IO.Stream" />.
        /// </summary>
        /// <typeparam name="TValue">The type of the value to serialize.</typeparam>
        /// <param name="utf8Json">The UTF-8 <see cref="T:System.IO.Stream" /> to write to.</param>
        /// <param name="value">The value to convert.</param>
        /// <param name="options">Options to control the conversion behavior.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="utf8Json" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static void Serialize<TValue>(Stream utf8Json, TValue value, JsonSerializerOptions? options = null)
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            JsonTypeInfo typeInfo = GetTypeInfo(options, typeof(TValue));
            WriteStream(utf8Json, in value, typeInfo);
        }

        /// <summary>
        /// Converts the provided value to UTF-8 encoded JSON text and write it to the <see cref="T:System.IO.Stream" />.
        /// </summary>
        /// <returns>A task that represents the asynchronous write operation.</returns>
        /// <param name="utf8Json">The UTF-8 <see cref="T:System.IO.Stream" /> to write to.</param>
        /// <param name="value">The value to convert.</param>
        /// <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        /// <param name="options">Options to control the conversion behavior.</param>
        /// <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> that can be used to cancel the write operation.</param>
        /// <exception cref="T:System.ArgumentException">
        /// <paramref name="inputType" /> is not compatible with <paramref name="value" />.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="utf8Json" /> or <paramref name="inputType" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="inputType" />  or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static Task SerializeAsync(Stream utf8Json, object? value, Type inputType, JsonSerializerOptions? options = null, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            ValidateInputType(value, inputType);
            JsonTypeInfo typeInfo = GetTypeInfo(options, inputType);
            return WriteStreamAsync(utf8Json, value, typeInfo, cancellationToken);
        }

        /// <summary>
        /// Converts the provided value to UTF-8 encoded JSON text and write it to the <see cref="T:System.IO.Stream" />.
        /// </summary>
        /// <param name="utf8Json">The UTF-8 <see cref="T:System.IO.Stream" /> to write to.</param>
        /// <param name="value">The value to convert.</param>
        /// <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        /// <param name="options">Options to control the conversion behavior.</param>
        /// <exception cref="T:System.ArgumentException">
        /// <paramref name="inputType" /> is not compatible with <paramref name="value" />.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="utf8Json" /> or <paramref name="inputType" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="inputType" />  or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static void Serialize(Stream utf8Json, object? value, Type inputType, JsonSerializerOptions? options = null)
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            ValidateInputType(value, inputType);
            JsonTypeInfo typeInfo = GetTypeInfo(options, inputType);
            WriteStream(utf8Json, in value, typeInfo);
        }

        /// <summary>
        /// Converts the provided value to UTF-8 encoded JSON text and write it to the <see cref="T:System.IO.Stream" />.
        /// </summary>
        /// <typeparam name="TValue">The type of the value to serialize.</typeparam>
        /// <returns>A task that represents the asynchronous write operation.</returns>
        /// <param name="utf8Json">The UTF-8 <see cref="T:System.IO.Stream" /> to write to.</param>
        /// <param name="value">The value to convert.</param>
        /// <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        /// <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> that can be used to cancel the write operation.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="utf8Json" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        public static Task SerializeAsync<TValue>(Stream utf8Json, TValue value, JsonTypeInfo<TValue> jsonTypeInfo, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
            }
            return WriteStreamAsync(utf8Json, value, jsonTypeInfo, cancellationToken);
        }

        /// <summary>
        /// Converts the provided value to UTF-8 encoded JSON text and write it to the <see cref="T:System.IO.Stream" />.
        /// </summary>
        /// <typeparam name="TValue">The type of the value to serialize.</typeparam>
        /// <param name="utf8Json">The UTF-8 <see cref="T:System.IO.Stream" /> to write to.</param>
        /// <param name="value">The value to convert.</param>
        /// <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="utf8Json" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        public static void Serialize<TValue>(Stream utf8Json, TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
            }
            WriteStream(utf8Json, in value, jsonTypeInfo);
        }

        /// <summary>
        /// Converts the provided value to UTF-8 encoded JSON text and write it to the <see cref="T:System.IO.Stream" />.
        /// </summary>
        /// <returns>A task that represents the asynchronous write operation.</returns>
        /// <param name="utf8Json">The UTF-8 <see cref="T:System.IO.Stream" /> to write to.</param>
        /// <param name="value">The value to convert.</param>
        /// <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        /// <param name="context">A metadata provider for serializable types.</param>
        /// <param name="cancellationToken">The <see cref="T:System.Threading.CancellationToken" /> that can be used to cancel the write operation.</param>
        /// <exception cref="T:System.ArgumentException">
        /// <paramref name="inputType" /> is not compatible with <paramref name="value" />.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="utf8Json" />, <paramref name="inputType" />, or <paramref name="context" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="inputType" />  or its serializable members.
        /// </exception>
        public static Task SerializeAsync(Stream utf8Json, object? value, Type inputType, JsonSerializerContext context, CancellationToken cancellationToken = default(CancellationToken))
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            if (context == null)
            {
                ThrowHelper.ThrowArgumentNullException("context");
            }
            ValidateInputType(value, inputType);
            return WriteStreamAsync(utf8Json, value, GetTypeInfo(context, inputType), cancellationToken);
        }

        /// <summary>
        /// Converts the provided value to UTF-8 encoded JSON text and write it to the <see cref="T:System.IO.Stream" />.
        /// </summary>
        /// <param name="utf8Json">The UTF-8 <see cref="T:System.IO.Stream" /> to write to.</param>
        /// <param name="value">The value to convert.</param>
        /// <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        /// <param name="context">A metadata provider for serializable types.</param>
        /// <exception cref="T:System.ArgumentException">
        /// <paramref name="inputType" /> is not compatible with <paramref name="value" />.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="utf8Json" />, <paramref name="inputType" />, or <paramref name="context" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="inputType" />  or its serializable members.
        /// </exception>
        public static void Serialize(Stream utf8Json, object? value, Type inputType, JsonSerializerContext context)
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            if (context == null)
            {
                ThrowHelper.ThrowArgumentNullException("context");
            }
            ValidateInputType(value, inputType);
            WriteStream(utf8Json, in value, GetTypeInfo(context, inputType));
        }

        private static async Task WriteStreamAsync<TValue>(Stream utf8Json, TValue value, JsonTypeInfo jsonTypeInfo, CancellationToken cancellationToken)
        {
            jsonTypeInfo.EnsureConfigured();
            JsonSerializerOptions options = jsonTypeInfo.Options;
            JsonWriterOptions writerOptions = options.GetWriterOptions();
            using PooledByteBufferWriter bufferWriter = new PooledByteBufferWriter(options.DefaultBufferSize);
            using Utf8JsonWriter writer = new Utf8JsonWriter(bufferWriter, writerOptions);
            WriteStack state = default(WriteStack);
            jsonTypeInfo = ResolvePolymorphicTypeInfo(in value, jsonTypeInfo, out state.IsPolymorphicRootValue);
            state.Initialize(jsonTypeInfo, supportContinuation: true, supportAsync: true);
            state.CancellationToken = cancellationToken;
            try
            {
                bool isFinalBlock;
                do
                {
                    state.FlushThreshold = (int)((float)bufferWriter.Capacity * 0.9f);
                    try
                    {
                        isFinalBlock = WriteCore(writer, in value, jsonTypeInfo, ref state);
                        if (state.SuppressFlush)
                        {
                            state.SuppressFlush = false;
                            continue;
                        }
                        await bufferWriter.WriteToStreamAsync(utf8Json, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
                        bufferWriter.Clear();
                    }
                    finally
                    {
                        if (state.PendingTask != null)
                        {
                            try
                            {
                                await state.PendingTask.ConfigureAwait(continueOnCapturedContext: false);
                            }
                            catch
                            {
                            }
                        }
                        List<IAsyncDisposable> completedAsyncDisposables = state.CompletedAsyncDisposables;
                        if (completedAsyncDisposables != null && completedAsyncDisposables.Count > 0)
                        {
                            await state.DisposeCompletedAsyncDisposables().ConfigureAwait(continueOnCapturedContext: false);
                        }
                    }
                }
                while (!isFinalBlock);
            }
            catch
            {
                await state.DisposePendingDisposablesOnExceptionAsync().ConfigureAwait(continueOnCapturedContext: false);
                throw;
            }
        }

        private static void WriteStream<TValue>(Stream utf8Json, in TValue value, JsonTypeInfo jsonTypeInfo)
        {
            jsonTypeInfo.EnsureConfigured();
            JsonSerializerOptions options = jsonTypeInfo.Options;
            JsonWriterOptions writerOptions = options.GetWriterOptions();
            using PooledByteBufferWriter pooledByteBufferWriter = new PooledByteBufferWriter(options.DefaultBufferSize);
            using Utf8JsonWriter writer = new Utf8JsonWriter(pooledByteBufferWriter, writerOptions);
            WriteStack state = default(WriteStack);
            jsonTypeInfo = ResolvePolymorphicTypeInfo(in value, jsonTypeInfo, out state.IsPolymorphicRootValue);
            state.Initialize(jsonTypeInfo, supportContinuation: true);
            bool flag;
            do
            {
                state.FlushThreshold = (int)((float)pooledByteBufferWriter.Capacity * 0.9f);
                flag = WriteCore(writer, in value, jsonTypeInfo, ref state);
                pooledByteBufferWriter.WriteToStream(utf8Json);
                pooledByteBufferWriter.Clear();
            }
            while (!flag);
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.String" />.
        /// </summary>
        /// <typeparam name="TValue">The type of the value to serialize.</typeparam>
        /// <returns>A <see cref="T:System.String" /> representation of the value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="options">Options to control the conversion behavior.</param>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        /// <remarks>Using a <see cref="T:System.String" /> is not as efficient as using UTF-8
        /// encoding since the implementation internally uses UTF-8. See also <see cref="M:System.Text.Json.JsonSerializer.SerializeToUtf8Bytes``1(``0,System.Text.Json.JsonSerializerOptions)" />
        /// and <see cref="M:System.Text.Json.JsonSerializer.SerializeAsync``1(System.IO.Stream,``0,System.Text.Json.JsonSerializerOptions,System.Threading.CancellationToken)" />.
        /// </remarks>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static string Serialize<TValue>(TValue value, JsonSerializerOptions? options = null)
        {
            JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
            return WriteString<TValue>(in value, typeInfo);
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.String" />.
        /// </summary>
        /// <returns>A <see cref="T:System.String" /> representation of the value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        /// <param name="options">Options to control the conversion behavior.</param>
        /// <exception cref="T:System.ArgumentException">
        /// <paramref name="inputType" /> is not compatible with <paramref name="value" />.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="inputType" />  or its serializable members.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="inputType" /> is <see langword="null" />.
        /// </exception>
        /// <remarks>Using a <see cref="T:System.String" /> is not as efficient as using UTF-8
        /// encoding since the implementation internally uses UTF-8. See also <see cref="M:System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(System.Object,System.Type,System.Text.Json.JsonSerializerOptions)" />
        /// and <see cref="M:System.Text.Json.JsonSerializer.SerializeAsync(System.IO.Stream,System.Object,System.Type,System.Text.Json.JsonSerializerOptions,System.Threading.CancellationToken)" />.
        /// </remarks>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static string Serialize(object? value, Type inputType, JsonSerializerOptions? options = null)
        {
            ValidateInputType(value, inputType);
            JsonTypeInfo typeInfo = GetTypeInfo(options, inputType);
            return WriteStringAsObject(value, typeInfo);
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.String" />.
        /// </summary>
        /// <typeparam name="TValue">The type of the value to serialize.</typeparam>
        /// <returns>A <see cref="T:System.String" /> representation of the value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="jsonTypeInfo" /> is <see langword="null" />.
        /// </exception>
        /// <remarks>Using a <see cref="T:System.String" /> is not as efficient as using UTF-8
        /// encoding since the implementation internally uses UTF-8. See also <see cref="M:System.Text.Json.JsonSerializer.SerializeToUtf8Bytes``1(``0,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0})" />
        /// and <see cref="M:System.Text.Json.JsonSerializer.SerializeAsync``1(System.IO.Stream,``0,System.Text.Json.Serialization.Metadata.JsonTypeInfo{``0},System.Threading.CancellationToken)" />.
        /// </remarks>
        public static string Serialize<TValue>(TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
            }
            jsonTypeInfo.EnsureConfigured();
            return WriteString(in value, jsonTypeInfo);
        }

        /// <summary>
        /// Converts the provided value into a <see cref="T:System.String" />.
        /// </summary>
        /// <returns>A <see cref="T:System.String" /> representation of the value.</returns>
        /// <param name="value">The value to convert.</param>
        /// <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        /// <param name="context">A metadata provider for serializable types.</param>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="inputType" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided
        /// <paramref name="context" /> returns <see langword="null" /> for the type to convert.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="inputType" /> or <paramref name="context" /> is <see langword="null" />.
        /// </exception>
        /// <remarks>Using a <see cref="T:System.String" /> is not as efficient as using UTF-8
        /// encoding since the implementation internally uses UTF-8. See also <see cref="M:System.Text.Json.JsonSerializer.SerializeToUtf8Bytes(System.Object,System.Type,System.Text.Json.Serialization.JsonSerializerContext)" />
        /// and <see cref="M:System.Text.Json.JsonSerializer.SerializeAsync(System.IO.Stream,System.Object,System.Type,System.Text.Json.Serialization.JsonSerializerContext,System.Threading.CancellationToken)" />.
        /// </remarks>
        public static string Serialize(object? value, Type inputType, JsonSerializerContext context)
        {
            if (context == null)
            {
                ThrowHelper.ThrowArgumentNullException("context");
            }
            ValidateInputType(value, inputType);
            JsonTypeInfo typeInfo = GetTypeInfo(context, inputType);
            return WriteStringAsObject(value, typeInfo);
        }

        private static string WriteString<TValue>(in TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            PooledByteBufferWriter bufferWriter;
            Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriterAndBuffer(jsonTypeInfo.Options, out bufferWriter);
            try
            {
                WriteCore(writer, in value, jsonTypeInfo);
                return JsonReaderHelper.TranscodeHelper(bufferWriter.WrittenMemory.Span);
            }
            finally
            {
                Utf8JsonWriterCache.ReturnWriterAndBuffer(writer, bufferWriter);
            }
        }

        private static string WriteStringAsObject(object value, JsonTypeInfo jsonTypeInfo)
        {
            PooledByteBufferWriter bufferWriter;
            Utf8JsonWriter writer = Utf8JsonWriterCache.RentWriterAndBuffer(jsonTypeInfo.Options, out bufferWriter);
            try
            {
                WriteCoreAsObject(writer, value, jsonTypeInfo);
                return JsonReaderHelper.TranscodeHelper(bufferWriter.WrittenMemory.Span);
            }
            finally
            {
                Utf8JsonWriterCache.ReturnWriterAndBuffer(writer, bufferWriter);
            }
        }

        /// <summary>
        /// Writes one JSON value (including objects or arrays) to the provided writer.
        /// </summary>
        /// <typeparam name="TValue">The type of the value to serialize.</typeparam>
        /// <param name="writer">The writer to write.</param>
        /// <param name="value">The value to convert and write.</param>
        /// <param name="options">Options to control the behavior.</param>
        /// <exception cref="T:System.ArgumentNullException">
        ///   <paramref name="writer" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static void Serialize<TValue>(Utf8JsonWriter writer, TValue value, JsonSerializerOptions? options = null)
        {
            if (writer == null)
            {
                ThrowHelper.ThrowArgumentNullException("writer");
            }
            JsonTypeInfo<TValue> typeInfo = GetTypeInfo<TValue>(options);
            WriteCore<TValue>(writer, in value, typeInfo);
        }

        /// <summary>
        /// Writes one JSON value (including objects or arrays) to the provided writer.
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="value">The value to convert and write.</param>
        /// <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        /// <param name="options">Options to control the behavior.</param>
        /// <exception cref="T:System.ArgumentException">
        /// <paramref name="inputType" /> is not compatible with <paramref name="value" />.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="writer" /> or <paramref name="inputType" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="inputType" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        public static void Serialize(Utf8JsonWriter writer, object? value, Type inputType, JsonSerializerOptions? options = null)
        {
            if (writer == null)
            {
                ThrowHelper.ThrowArgumentNullException("writer");
            }
            ValidateInputType(value, inputType);
            JsonTypeInfo typeInfo = GetTypeInfo(options, inputType);
            WriteCoreAsObject(writer, value, typeInfo);
        }

        /// <summary>
        /// Writes one JSON value (including objects or arrays) to the provided writer.
        /// </summary>
        /// <typeparam name="TValue">The type of the value to serialize.</typeparam>
        /// <param name="writer">The writer to write.</param>
        /// <param name="value">The value to convert and write.</param>
        /// <param name="jsonTypeInfo">Metadata about the type to convert.</param>
        /// <exception cref="T:System.ArgumentNullException">
        ///   <paramref name="writer" /> or <paramref name="jsonTypeInfo" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <typeparamref name="TValue" /> or its serializable members.
        /// </exception>
        public static void Serialize<TValue>(Utf8JsonWriter writer, TValue value, JsonTypeInfo<TValue> jsonTypeInfo)
        {
            if (writer == null)
            {
                ThrowHelper.ThrowArgumentNullException("writer");
            }
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
            }
            jsonTypeInfo.EnsureConfigured();
            WriteCore(writer, in value, jsonTypeInfo);
        }

        /// <summary>
        /// Writes one JSON value (including objects or arrays) to the provided writer.
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="value">The value to convert and write.</param>
        /// <param name="inputType">The type of the <paramref name="value" /> to convert.</param>
        /// <param name="context">A metadata provider for serializable types.</param>
        /// <exception cref="T:System.ArgumentException">
        /// <paramref name="inputType" /> is not compatible with <paramref name="value" />.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="writer" /> or <paramref name="inputType" /> is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="inputType" /> or its serializable members.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// The <see cref="M:System.Text.Json.Serialization.JsonSerializerContext.GetTypeInfo(System.Type)" /> method of the provided
        /// <paramref name="context" /> returns <see langword="null" /> for the type to convert.
        /// </exception>
        public static void Serialize(Utf8JsonWriter writer, object? value, Type inputType, JsonSerializerContext context)
        {
            if (writer == null)
            {
                ThrowHelper.ThrowArgumentNullException("writer");
            }
            if (context == null)
            {
                ThrowHelper.ThrowArgumentNullException("context");
            }
            ValidateInputType(value, inputType);
            JsonTypeInfo typeInfo = GetTypeInfo(context, inputType);
            WriteCoreAsObject(writer, value, typeInfo);
        }
    }

    /// <summary>
	/// Signifies what default options are used by <see cref="JsonSerializerOptions" />.
	/// </summary>
	public enum JsonSerializerDefaults
    {
        /// <summary>
        /// Specifies that general-purpose values should be used. These are the same settings applied if a <see cref="T:System.Text.Json.JsonSerializerDefaults" /> isn't specified.
        /// </summary>
        /// <remarks>
        /// This option implies that property names are treated as case-sensitive and that "PascalCase" name formatting should be employed.
        /// </remarks>
        General,
        /// <summary>
        /// Specifies that values should be used more appropriate to web-based scenarios.
        /// </summary>
        /// <remarks>
        /// This option implies that property names are treated as case-insensitive and that "camelCase" name formatting should be employed.
        /// </remarks>
        Web
    }

    /// <summary>
	/// Provides options to be used with <see cref="T:System.Text.Json.JsonSerializer" />.
	/// </summary>
	/// <summary>
	/// Provides options to be used with <see cref="T:System.Text.Json.JsonSerializer" />.
	/// </summary>
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
    public sealed class JsonSerializerOptions
    {
        /// <summary>
        /// Stores and manages all reflection caches for one or more <see cref="T:System.Text.Json.JsonSerializerOptions" /> instances.
        /// NB the type encapsulates the original options instance and only consults that one when building new types;
        /// this is to prevent multiple options instances from leaking into the object graphs of converters which
        /// could break user invariants.
        /// </summary>
        internal sealed class CachingContext
        {
            private readonly ConcurrentDictionary<Type, JsonTypeInfo> _jsonTypeInfoCache = new ConcurrentDictionary<Type, JsonTypeInfo>();

            private readonly Func<Type, JsonTypeInfo> _jsonTypeInfoFactory;

            public JsonSerializerOptions Options { get; }

            public int HashCode { get; }

            public int Count => _jsonTypeInfoCache.Count;

            public CachingContext(JsonSerializerOptions options, int hashCode)
            {
                Options = options;
                HashCode = hashCode;
                _jsonTypeInfoFactory = Options.GetTypeInfoNoCaching;
            }

            public JsonTypeInfo GetOrAddJsonTypeInfo(Type type)
            {
                return _jsonTypeInfoCache.GetOrAdd(type, _jsonTypeInfoFactory);
            }

            public bool TryGetJsonTypeInfo(Type type, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out JsonTypeInfo typeInfo)
            {
                return _jsonTypeInfoCache.TryGetValue(type, out typeInfo);
            }

            public void Clear()
            {
                _jsonTypeInfoCache.Clear();
            }
        }

        /// <summary>
        /// Defines a cache of CachingContexts; instead of using a ConditionalWeakTable which can be slow to traverse
        /// this approach uses a fixed-size array of weak references of <see cref="T:System.Text.Json.JsonSerializerOptions.CachingContext" /> that can be looked up lock-free.
        /// Relevant caching contexts are looked up by linear traversal using the equality comparison defined by <see cref="T:System.Text.Json.JsonSerializerOptions.EqualityComparer" />.
        /// </summary>
        internal static class TrackedCachingContexts
        {
            private const int MaxTrackedContexts = 64;

            private static readonly WeakReference<CachingContext>[] s_trackedContexts = new WeakReference<CachingContext>[64];

            private static readonly EqualityComparer s_optionsComparer = new EqualityComparer();

            public static CachingContext GetOrCreate(JsonSerializerOptions options)
            {
                int hashCode = s_optionsComparer.GetHashCode(options);
                if (TryGetContext(options, hashCode, out var firstUnpopulatedIndex, out var result))
                {
                    return result;
                }
                if (firstUnpopulatedIndex < 0)
                {
                    return new CachingContext(options, hashCode);
                }
                lock (s_trackedContexts)
                {
                    if (TryGetContext(options, hashCode, out firstUnpopulatedIndex, out result))
                    {
                        return result;
                    }
                    CachingContext cachingContext = new CachingContext(options, hashCode);
                    if (firstUnpopulatedIndex >= 0)
                    {
                        ref WeakReference<CachingContext> reference = ref s_trackedContexts[firstUnpopulatedIndex];
                        if (reference == null)
                        {
                            reference = new WeakReference<CachingContext>(cachingContext);
                        }
                        else
                        {
                            reference.SetTarget(cachingContext);
                        }
                    }
                    return cachingContext;
                }
            }

            private static bool TryGetContext(JsonSerializerOptions options, int hashCode, out int firstUnpopulatedIndex, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out CachingContext result)
            {
                WeakReference<CachingContext>[] array = s_trackedContexts;
                firstUnpopulatedIndex = -1;
                for (int i = 0; i < array.Length; i++)
                {
                    WeakReference<CachingContext> weakReference = array[i];
                    if (weakReference == null || !weakReference.TryGetTarget(out var target))
                    {
                        if (firstUnpopulatedIndex < 0)
                        {
                            firstUnpopulatedIndex = i;
                        }
                    }
                    else if (hashCode == target.HashCode && s_optionsComparer.Equals(options, target.Options))
                    {
                        result = target;
                        return true;
                    }
                }
                result = null;
                return false;
            }
        }

        /// <summary>
        /// Provides a conservative equality comparison for JsonSerializerOptions instances.
        /// If two instances are equivalent, they should generate identical metadata caches;
        /// the converse however does not necessarily hold.
        /// </summary>
        private sealed class EqualityComparer : IEqualityComparer<JsonSerializerOptions>
        {
            /// <summary>
            /// Polyfill for System.HashCode.
            /// </summary>
            private struct HashCode
            {
                private int _hashCode;

                public void Add<T>(T value)
                {
                    _hashCode = (_hashCode, value).GetHashCode();
                }

                public int ToHashCode()
                {
                    return _hashCode;
                }
            }

            public bool Equals(JsonSerializerOptions left, JsonSerializerOptions right)
            {
                if (left._dictionaryKeyPolicy == right._dictionaryKeyPolicy && left._jsonPropertyNamingPolicy == right._jsonPropertyNamingPolicy && left._readCommentHandling == right._readCommentHandling && left._referenceHandler == right._referenceHandler && left._encoder == right._encoder && left._defaultIgnoreCondition == right._defaultIgnoreCondition && left._numberHandling == right._numberHandling && left._unknownTypeHandling == right._unknownTypeHandling && left._defaultBufferSize == right._defaultBufferSize && left._maxDepth == right._maxDepth && left._allowTrailingCommas == right._allowTrailingCommas && left._ignoreNullValues == right._ignoreNullValues && left._ignoreReadOnlyProperties == right._ignoreReadOnlyProperties && left._ignoreReadonlyFields == right._ignoreReadonlyFields && left._includeFields == right._includeFields && left._propertyNameCaseInsensitive == right._propertyNameCaseInsensitive && left._writeIndented == right._writeIndented && left._typeInfoResolver == right._typeInfoResolver)
                {
                    return CompareLists<JsonConverter>(left._converters, right._converters);
                }
                return false;
                static bool CompareLists<TValue>(ConfigurationList<TValue> left, ConfigurationList<TValue> right) where TValue : class
                {
                    int count;
                    if ((count = left.Count) != right.Count)
                    {
                        return false;
                    }
                    for (int i = 0; i < count; i++)
                    {
                        if (left[i] != right[i])
                        {
                            return false;
                        }
                    }
                    return true;
                }
            }

            public int GetHashCode(JsonSerializerOptions options)
            {
                HashCode hc2 = default(HashCode);
                AddHashCode<JsonNamingPolicy>(ref hc2, options._dictionaryKeyPolicy);
                AddHashCode<JsonNamingPolicy>(ref hc2, options._jsonPropertyNamingPolicy);
                AddHashCode<JsonCommentHandling>(ref hc2, options._readCommentHandling);
                AddHashCode<ReferenceHandler>(ref hc2, options._referenceHandler);
                AddHashCode<JavaScriptEncoder>(ref hc2, options._encoder);
                AddHashCode<JsonIgnoreCondition>(ref hc2, options._defaultIgnoreCondition);
                AddHashCode<JsonNumberHandling>(ref hc2, options._numberHandling);
                AddHashCode<JsonUnknownTypeHandling>(ref hc2, options._unknownTypeHandling);
                AddHashCode<int>(ref hc2, options._defaultBufferSize);
                AddHashCode<int>(ref hc2, options._maxDepth);
                AddHashCode<bool>(ref hc2, options._allowTrailingCommas);
                AddHashCode<bool>(ref hc2, options._ignoreNullValues);
                AddHashCode<bool>(ref hc2, options._ignoreReadOnlyProperties);
                AddHashCode<bool>(ref hc2, options._ignoreReadonlyFields);
                AddHashCode<bool>(ref hc2, options._includeFields);
                AddHashCode<bool>(ref hc2, options._propertyNameCaseInsensitive);
                AddHashCode<bool>(ref hc2, options._writeIndented);
                AddHashCode<IJsonTypeInfoResolver>(ref hc2, options._typeInfoResolver);
                AddListHashCode<JsonConverter>(ref hc2, options._converters);
                return hc2.ToHashCode();
                static void AddHashCode<TValue>(ref HashCode hc, TValue value)
                {
                    if (typeof(TValue).IsValueType)
                    {
                        hc.Add(value);
                    }
                    else
                    {
                        hc.Add(RuntimeHelpers.GetHashCode(value));
                    }
                }
                static void AddListHashCode<TValue>(ref HashCode hc, ConfigurationList<TValue> list)
                {
                    int count = list.Count;
                    for (int i = 0; i < count; i++)
                    {
                        AddHashCode<TValue>(ref hc, list[i]);
                    }
                }
            }
        }

        internal static class TrackedOptionsInstances
        {
            /// <summary>Tracks all live JsonSerializerOptions instances.</summary>
            /// <remarks>Instances are added to the table in their constructor.</remarks>
            public static ConditionalWeakTable<JsonSerializerOptions, object> All { get; } = new ConditionalWeakTable<JsonSerializerOptions, object>();
        }

        private sealed class ConverterList : ConfigurationList<JsonConverter>
        {
            private readonly JsonSerializerOptions _options;

            protected override bool IsImmutable => _options.IsImmutable;

            public ConverterList(JsonSerializerOptions options, IList<JsonConverter> source = null)
                : base(source)
            {
                _options = options;
            }

            protected override void VerifyMutable()
            {
                _options.VerifyMutable();
            }
        }

        /// <summary>
        /// Encapsulates all cached metadata referenced by the current <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance.
        /// Context can be shared across multiple equivalent options instances.
        /// </summary>
        private CachingContext _cachingContext;

        private volatile JsonTypeInfo _lastTypeInfo;

        private JsonTypeInfo _objectTypeInfo;

        internal const int BufferSizeDefault = 16384;

        internal const int DefaultMaxDepth = 64;

        private static JsonSerializerOptions s_defaultOptions;

        private IJsonTypeInfoResolver _typeInfoResolver;

        private MemberAccessor _memberAccessorStrategy;

        private JsonNamingPolicy _dictionaryKeyPolicy;

        private JsonNamingPolicy _jsonPropertyNamingPolicy;

        private JsonCommentHandling _readCommentHandling;

        private ReferenceHandler _referenceHandler;

        private JavaScriptEncoder _encoder;

        private ConfigurationList<JsonConverter> _converters;

        private JsonIgnoreCondition _defaultIgnoreCondition;

        private JsonNumberHandling _numberHandling;

        private JsonUnknownTypeHandling _unknownTypeHandling;

        private int _defaultBufferSize = 16384;

        private int _maxDepth;

        private bool _allowTrailingCommas;

        private bool _ignoreNullValues;

        private bool _ignoreReadOnlyProperties;

        private bool _ignoreReadonlyFields;

        private bool _includeFields;

        private bool _propertyNameCaseInsensitive;

        private bool _writeIndented;

        private volatile bool _isImmutable;

        internal ReferenceHandlingStrategy ReferenceHandlingStrategy;

        private volatile bool _isInitializedForReflectionSerializer;

        private IJsonTypeInfoResolver _effectiveJsonTypeInfoResolver;

        internal JsonTypeInfo ObjectTypeInfo => _objectTypeInfo ?? (_objectTypeInfo = GetTypeInfoInternal(JsonTypeInfo.ObjectType));

        /// <summary>
        /// The list of custom converters.
        /// </summary>
        /// <remarks>
        /// Once serialization or deserialization occurs, the list cannot be modified.
        /// </remarks>
        public IList<JsonConverter> Converters => _converters;

        /// <summary>
        /// Gets a read-only, singleton instance of <see cref="T:System.Text.Json.JsonSerializerOptions" /> that uses the default configuration.
        /// </summary>
        /// <remarks>
        /// Each <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance encapsulates its own serialization metadata caches,
        /// so using fresh default instances every time one is needed can result in redundant recomputation of converters.
        /// This property provides a shared instance that can be consumed by any number of components without necessitating any converter recomputation.
        /// </remarks>
        public static JsonSerializerOptions Default
        {
            [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
            [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
            get
            {
                JsonSerializerOptions orCreateDefaultOptionsInstance = s_defaultOptions;
                if (orCreateDefaultOptionsInstance == null)
                {
                    orCreateDefaultOptionsInstance = GetOrCreateDefaultOptionsInstance();
                }
                return orCreateDefaultOptionsInstance;
            }
        }

        /// <summary>
        /// Gets or sets the <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> contract resolver used by this instance.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this property is set after serialization or deserialization has occurred.
        /// </exception>
        /// <remarks>
        /// A <see langword="null" /> setting is equivalent to using the reflection-based <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" />.
        /// The property will be populated automatically once used with one of the <see cref="T:System.Text.Json.JsonSerializer" /> methods.
        /// </remarks>
        public IJsonTypeInfoResolver? TypeInfoResolver
        {
            get
            {
                return _typeInfoResolver;
            }
            set
            {
                VerifyMutable();
                _typeInfoResolver = value;
            }
        }

        /// <summary>
        /// Defines whether an extra comma at the end of a list of JSON values in an object or array
        /// is allowed (and ignored) within the JSON payload being deserialized.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this property is set after serialization or deserialization has occurred.
        /// </exception>
        /// <remarks>
        /// By default, it's set to false, and <exception cref="T:System.Text.Json.JsonException" /> is thrown if a trailing comma is encountered.
        /// </remarks>
        public bool AllowTrailingCommas
        {
            get
            {
                return _allowTrailingCommas;
            }
            set
            {
                VerifyMutable();
                _allowTrailingCommas = value;
            }
        }

        /// <summary>
        /// The default buffer size in bytes used when creating temporary buffers.
        /// </summary>
        /// <remarks>The default size is 16K.</remarks>
        /// <exception cref="T:System.ArgumentException">Thrown when the buffer size is less than 1.</exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this property is set after serialization or deserialization has occurred.
        /// </exception>
        public int DefaultBufferSize
        {
            get
            {
                return _defaultBufferSize;
            }
            set
            {
                VerifyMutable();
                if (value < 1)
                {
                    throw new ArgumentException(MDCFR.Properties.Resources.SerializationInvalidBufferSize);
                }
                _defaultBufferSize = value;
            }
        }

        /// <summary>
        /// The encoder to use when escaping strings, or <see langword="null" /> to use the default encoder.
        /// </summary>
        public JavaScriptEncoder? Encoder
        {
            get
            {
                return _encoder;
            }
            set
            {
                VerifyMutable();
                _encoder = value;
            }
        }

        /// <summary>
        /// Specifies the policy used to convert a <see cref="T:System.Collections.IDictionary" /> key's name to another format, such as camel-casing.
        /// </summary>
        /// <remarks>
        /// This property can be set to <see cref="P:System.Text.Json.JsonNamingPolicy.CamelCase" /> to specify a camel-casing policy.
        /// It is not used when deserializing.
        /// </remarks>
        public JsonNamingPolicy? DictionaryKeyPolicy
        {
            get
            {
                return _dictionaryKeyPolicy;
            }
            set
            {
                VerifyMutable();
                _dictionaryKeyPolicy = value;
            }
        }

        /// <summary>
        /// Determines whether null values are ignored during serialization and deserialization.
        /// The default value is false.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this property is set after serialization or deserialization has occurred.
        /// or <see cref="P:System.Text.Json.JsonSerializerOptions.DefaultIgnoreCondition" /> has been set to a non-default value. These properties cannot be used together.
        /// </exception>
        [Obsolete("JsonSerializerOptions.IgnoreNullValues is obsolete. To ignore null values when serializing, set DefaultIgnoreCondition to JsonIgnoreCondition.WhenWritingNull.", DiagnosticId = "SYSLIB0020", UrlFormat = "https://aka.ms/dotnet-warnings/{0}")]
        [EditorBrowsable(EditorBrowsableState.Never)]
        public bool IgnoreNullValues
        {
            get
            {
                return _ignoreNullValues;
            }
            set
            {
                VerifyMutable();
                if (value && _defaultIgnoreCondition != 0)
                {
                    throw new InvalidOperationException(MDCFR.Properties.Resources.DefaultIgnoreConditionAlreadySpecified);
                }
                _ignoreNullValues = value;
            }
        }

        /// <summary>
        /// Specifies a condition to determine when properties with default values are ignored during serialization or deserialization.
        /// The default value is <see cref="F:System.Text.Json.Serialization.JsonIgnoreCondition.Never" />.
        /// </summary>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown if this property is set to <see cref="F:System.Text.Json.Serialization.JsonIgnoreCondition.Always" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this property is set after serialization or deserialization has occurred,
        /// or <see cref="P:System.Text.Json.JsonSerializerOptions.IgnoreNullValues" /> has been set to <see langword="true" />. These properties cannot be used together.
        /// </exception>
        public JsonIgnoreCondition DefaultIgnoreCondition
        {
            get
            {
                return _defaultIgnoreCondition;
            }
            set
            {
                VerifyMutable();
                switch (value)
                {
                    case JsonIgnoreCondition.Always:
                        throw new ArgumentException(MDCFR.Properties.Resources.DefaultIgnoreConditionInvalid);
                    default:
                        if (_ignoreNullValues)
                        {
                            throw new InvalidOperationException(MDCFR.Properties.Resources.DefaultIgnoreConditionAlreadySpecified);
                        }
                        break;
                    case JsonIgnoreCondition.Never:
                        break;
                }
                _defaultIgnoreCondition = value;
            }
        }

        /// <summary>
        /// Specifies how number types should be handled when serializing or deserializing.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this property is set after serialization or deserialization has occurred.
        /// </exception>
        public JsonNumberHandling NumberHandling
        {
            get
            {
                return _numberHandling;
            }
            set
            {
                VerifyMutable();
                if (!JsonSerializer.IsValidNumberHandlingValue(value))
                {
                    throw new ArgumentOutOfRangeException("value");
                }
                _numberHandling = value;
            }
        }

        /// <summary>
        /// Determines whether read-only properties are ignored during serialization.
        /// A property is read-only if it contains a public getter but not a public setter.
        /// The default value is false.
        /// </summary>
        /// <remarks>
        /// Read-only properties are not deserialized regardless of this setting.
        /// </remarks>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this property is set after serialization or deserialization has occurred.
        /// </exception>
        public bool IgnoreReadOnlyProperties
        {
            get
            {
                return _ignoreReadOnlyProperties;
            }
            set
            {
                VerifyMutable();
                _ignoreReadOnlyProperties = value;
            }
        }

        /// <summary>
        /// Determines whether read-only fields are ignored during serialization.
        /// A field is read-only if it is marked with the <c>readonly</c> keyword.
        /// The default value is false.
        /// </summary>
        /// <remarks>
        /// Read-only fields are not deserialized regardless of this setting.
        /// </remarks>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this property is set after serialization or deserialization has occurred.
        /// </exception>
        public bool IgnoreReadOnlyFields
        {
            get
            {
                return _ignoreReadonlyFields;
            }
            set
            {
                VerifyMutable();
                _ignoreReadonlyFields = value;
            }
        }

        /// <summary>
        /// Determines whether fields are handled on serialization and deserialization.
        /// The default value is false.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this property is set after serialization or deserialization has occurred.
        /// </exception>
        public bool IncludeFields
        {
            get
            {
                return _includeFields;
            }
            set
            {
                VerifyMutable();
                _includeFields = value;
            }
        }

        /// <summary>
        /// Gets or sets the maximum depth allowed when serializing or deserializing JSON, with the default (i.e. 0) indicating a max depth of 64.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this property is set after serialization or deserialization has occurred.
        /// </exception>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        /// Thrown when the max depth is set to a negative value.
        /// </exception>
        /// <remarks>
        /// Going past this depth will throw a <exception cref="T:System.Text.Json.JsonException" />.
        /// </remarks>
        public int MaxDepth
        {
            get
            {
                return _maxDepth;
            }
            set
            {
                VerifyMutable();
                if (value < 0)
                {
                    ThrowHelper.ThrowArgumentOutOfRangeException_MaxDepthMustBePositive("value");
                }
                _maxDepth = value;
                EffectiveMaxDepth = ((value == 0) ? 64 : value);
            }
        }

        internal int EffectiveMaxDepth { get; private set; } = 64;


        /// <summary>
        /// Specifies the policy used to convert a property's name on an object to another format, such as camel-casing.
        /// The resulting property name is expected to match the JSON payload during deserialization, and
        /// will be used when writing the property name during serialization.
        /// </summary>
        /// <remarks>
        /// The policy is not used for properties that have a <see cref="T:System.Text.Json.Serialization.JsonPropertyNameAttribute" /> applied.
        /// This property can be set to <see cref="P:System.Text.Json.JsonNamingPolicy.CamelCase" /> to specify a camel-casing policy.
        /// </remarks>
        public JsonNamingPolicy? PropertyNamingPolicy
        {
            get
            {
                return _jsonPropertyNamingPolicy;
            }
            set
            {
                VerifyMutable();
                _jsonPropertyNamingPolicy = value;
            }
        }

        /// <summary>
        /// Determines whether a property's name uses a case-insensitive comparison during deserialization.
        /// The default value is false.
        /// </summary>
        /// <remarks>There is a performance cost associated when the value is true.</remarks>
        public bool PropertyNameCaseInsensitive
        {
            get
            {
                return _propertyNameCaseInsensitive;
            }
            set
            {
                VerifyMutable();
                _propertyNameCaseInsensitive = value;
            }
        }

        /// <summary>
        /// Defines how the comments are handled during deserialization.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this property is set after serialization or deserialization has occurred.
        /// </exception>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        /// Thrown when the comment handling enum is set to a value that is not supported (or not within the <see cref="T:System.Text.Json.JsonCommentHandling" /> enum range).
        /// </exception>
        /// <remarks>
        /// By default <exception cref="T:System.Text.Json.JsonException" /> is thrown if a comment is encountered.
        /// </remarks>
        public JsonCommentHandling ReadCommentHandling
        {
            get
            {
                return _readCommentHandling;
            }
            set
            {
                VerifyMutable();
                if ((int)value > 1)
                {
                    throw new ArgumentOutOfRangeException("value", MDCFR.Properties.Resources.JsonSerializerDoesNotSupportComments);
                }
                _readCommentHandling = value;
            }
        }

        /// <summary>
        /// Defines how deserializing a type declared as an <see cref="T:System.Object" /> is handled during deserialization.
        /// </summary>
        public JsonUnknownTypeHandling UnknownTypeHandling
        {
            get
            {
                return _unknownTypeHandling;
            }
            set
            {
                VerifyMutable();
                _unknownTypeHandling = value;
            }
        }

        /// <summary>
        /// Defines whether JSON should pretty print which includes:
        /// indenting nested JSON tokens, adding new lines, and adding white space between property names and values.
        /// By default, the JSON is serialized without any extra white space.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this property is set after serialization or deserialization has occurred.
        /// </exception>
        public bool WriteIndented
        {
            get
            {
                return _writeIndented;
            }
            set
            {
                VerifyMutable();
                _writeIndented = value;
            }
        }

        /// <summary>
        /// Configures how object references are handled when reading and writing JSON.
        /// </summary>
        public ReferenceHandler? ReferenceHandler
        {
            get
            {
                return _referenceHandler;
            }
            set
            {
                VerifyMutable();
                _referenceHandler = value;
                ReferenceHandlingStrategy = value?.HandlingStrategy ?? ReferenceHandlingStrategy.None;
            }
        }

        internal JsonSerializerContext? SerializerContext => _typeInfoResolver as JsonSerializerContext;

        [UnconditionalSuppressMessage("AotAnalysis", "IL3050:RequiresDynamicCode", Justification = "Dynamic path is guarded by the runtime feature switch.")]
        internal MemberAccessor MemberAccessorStrategy => _memberAccessorStrategy ?? (_memberAccessorStrategy = new ReflectionEmitCachingMemberAccessor());

        internal bool IsImmutable
        {
            get
            {
                return _isImmutable;
            }
            set
            {
                _isImmutable = true;
            }
        }

        internal bool IsInitializedForReflectionSerializer => _isInitializedForReflectionSerializer;

        private string DebuggerDisplay => $"TypeInfoResolver = {TypeInfoResolver?.GetType()?.Name}, IsImmutable = {IsImmutable}";

        /// <summary>
        /// Gets the <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> contract metadata resolved by the current <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance.
        /// </summary>
        /// <param name="type">The type to resolve contract metadata for.</param>
        /// <returns>The contract metadata resolved for <paramref name="type" />.</returns>
        /// <exception cref="T:System.ArgumentNullException"><paramref name="type" /> is <see langword="null" />.</exception>
        /// <exception cref="T:System.ArgumentException"><paramref name="type" /> is not valid for serialization.</exception>
        /// <remarks>
        /// Returned metadata can be downcast to <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo`1" /> and used with the relevant <see cref="T:System.Text.Json.JsonSerializer" /> overloads.
        ///
        /// If the <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance is locked for modification, the method will return a cached instance for the metadata.
        /// </remarks>
        public JsonTypeInfo GetTypeInfo(Type type)
        {
            if ((object)type == null)
            {
                ThrowHelper.ThrowArgumentNullException("type");
            }
            if (JsonTypeInfo.IsInvalidForSerialization(type))
            {
                ThrowHelper.ThrowArgumentException_CannotSerializeInvalidType("type", type, null, null);
            }
            return GetTypeInfoInternal(type, ensureConfigured: true, resolveIfMutable: true);
        }

        /// <summary>
        /// Same as GetTypeInfo but without validation and additional knobs.
        /// </summary>
        internal JsonTypeInfo GetTypeInfoInternal(Type type, bool ensureConfigured = true, bool resolveIfMutable = false)
        {
            JsonTypeInfo jsonTypeInfo = null;
            if (IsImmutable)
            {
                jsonTypeInfo = GetCachingContext()?.GetOrAddJsonTypeInfo(type);
                if (ensureConfigured)
                {
                    jsonTypeInfo?.EnsureConfigured();
                }
            }
            else if (resolveIfMutable)
            {
                jsonTypeInfo = GetTypeInfoNoCaching(type);
            }
            if (jsonTypeInfo == null)
            {
                ThrowHelper.ThrowNotSupportedException_NoMetadataForType(type, TypeInfoResolver);
            }
            return jsonTypeInfo;
        }

        internal bool TryGetTypeInfoCached(Type type, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out JsonTypeInfo typeInfo)
        {
            if (_cachingContext == null)
            {
                typeInfo = null;
                return false;
            }
            return _cachingContext.TryGetJsonTypeInfo(type, out typeInfo);
        }

        /// <summary>
        /// Return the TypeInfo for root API calls.
        /// This has an LRU cache that is intended only for public API calls that specify the root type.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal JsonTypeInfo GetTypeInfoForRootType(Type type)
        {
            JsonTypeInfo jsonTypeInfo = _lastTypeInfo;
            if (jsonTypeInfo?.Type != type)
            {
                jsonTypeInfo = (_lastTypeInfo = GetTypeInfoInternal(type));
            }
            return jsonTypeInfo;
        }

        internal void ClearCaches()
        {
            _cachingContext?.Clear();
            _lastTypeInfo = null;
            _objectTypeInfo = null;
        }

        private CachingContext GetCachingContext()
        {
            return _cachingContext ?? (_cachingContext = TrackedCachingContexts.GetOrCreate(this));
        }

        /// <summary>
        /// Returns the converter for the specified type.
        /// </summary>
        /// <param name="typeToConvert">The type to return a converter for.</param>
        /// <returns>
        /// The converter for the given type.
        /// </returns>
        /// <exception cref="T:System.InvalidOperationException">
        /// The configured <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for <paramref name="typeToConvert" /> returned an invalid converter.
        /// </exception>
        /// <exception cref="T:System.NotSupportedException">
        /// There is no compatible <see cref="T:System.Text.Json.Serialization.JsonConverter" />
        /// for <paramref name="typeToConvert" /> or its serializable members.
        /// </exception>
        [RequiresUnreferencedCode("Getting a converter for a type may require reflection which depends on unreferenced code.")]
        [RequiresDynamicCode("Getting a converter for a type may require reflection which depends on runtime code generation.")]
        public JsonConverter GetConverter(Type typeToConvert)
        {
            if ((object)typeToConvert == null)
            {
                ThrowHelper.ThrowArgumentNullException("typeToConvert");
            }
            if (_typeInfoResolver == null)
            {
                return DefaultJsonTypeInfoResolver.GetConverterForType(typeToConvert, this);
            }
            return GetConverterInternal(typeToConvert);
        }

        /// <summary>
        /// Same as GetConverter but without defaulting to reflection converters.
        /// </summary>
        internal JsonConverter GetConverterInternal(Type typeToConvert)
        {
            JsonTypeInfo typeInfoInternal = GetTypeInfoInternal(typeToConvert, ensureConfigured: false, resolveIfMutable: true);
            return typeInfoInternal.Converter;
        }

        internal JsonConverter GetConverterFromList(Type typeToConvert)
        {
            foreach (JsonConverter converter in _converters)
            {
                if (converter.CanConvert(typeToConvert))
                {
                    return converter;
                }
            }
            return null;
        }

        [return: System.Diagnostics.CodeAnalysis.NotNullIfNotNull("converter")]
        internal JsonConverter ExpandConverterFactory(JsonConverter converter, Type typeToConvert)
        {
            if (converter is JsonConverterFactory jsonConverterFactory)
            {
                converter = jsonConverterFactory.GetConverterInternal(typeToConvert, this);
            }
            return converter;
        }

        internal static void CheckConverterNullabilityIsSameAsPropertyType(JsonConverter converter, Type propertyType)
        {
            if (propertyType.IsValueType && converter.IsValueType && (propertyType.IsNullableOfT() ^ converter.TypeToConvert.IsNullableOfT()))
            {
                ThrowHelper.ThrowInvalidOperationException_ConverterCanConvertMultipleTypes(propertyType, converter);
            }
        }

        /// <summary>
        /// Constructs a new <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance.
        /// </summary>
        public JsonSerializerOptions()
        {
            _converters = new ConverterList(this);
            TrackOptionsInstance(this);
        }

        /// <summary>
        /// Copies the options from a <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance to a new instance.
        /// </summary>
        /// <param name="options">The <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance to copy options from.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// <paramref name="options" /> is <see langword="null" />.
        /// </exception>
        public JsonSerializerOptions(JsonSerializerOptions options)
        {
            if (options == null)
            {
                ThrowHelper.ThrowArgumentNullException("options");
            }
            _memberAccessorStrategy = options._memberAccessorStrategy;
            _dictionaryKeyPolicy = options._dictionaryKeyPolicy;
            _jsonPropertyNamingPolicy = options._jsonPropertyNamingPolicy;
            _readCommentHandling = options._readCommentHandling;
            _referenceHandler = options._referenceHandler;
            _converters = new ConverterList(this, options._converters);
            _encoder = options._encoder;
            _defaultIgnoreCondition = options._defaultIgnoreCondition;
            _numberHandling = options._numberHandling;
            _unknownTypeHandling = options._unknownTypeHandling;
            _defaultBufferSize = options._defaultBufferSize;
            _maxDepth = options._maxDepth;
            _allowTrailingCommas = options._allowTrailingCommas;
            _ignoreNullValues = options._ignoreNullValues;
            _ignoreReadOnlyProperties = options._ignoreReadOnlyProperties;
            _ignoreReadonlyFields = options._ignoreReadonlyFields;
            _includeFields = options._includeFields;
            _propertyNameCaseInsensitive = options._propertyNameCaseInsensitive;
            _writeIndented = options._writeIndented;
            _typeInfoResolver = options._typeInfoResolver;
            EffectiveMaxDepth = options.EffectiveMaxDepth;
            ReferenceHandlingStrategy = options.ReferenceHandlingStrategy;
            TrackOptionsInstance(this);
        }

        /// <summary>Tracks the options instance to enable all instances to be enumerated.</summary>
        private static void TrackOptionsInstance(JsonSerializerOptions options)
        {
            TrackedOptionsInstances.All.Add(options, null);
        }

        /// <summary>
        /// Constructs a new <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance with a predefined set of options determined by the specified <see cref="T:System.Text.Json.JsonSerializerDefaults" />.
        /// </summary>
        /// <param name="defaults"> The <see cref="T:System.Text.Json.JsonSerializerDefaults" /> to reason about.</param>
        public JsonSerializerOptions(JsonSerializerDefaults defaults)
            : this()
        {
            switch (defaults)
            {
                case JsonSerializerDefaults.Web:
                    _propertyNameCaseInsensitive = true;
                    _jsonPropertyNamingPolicy = JsonNamingPolicy.CamelCase;
                    _numberHandling = JsonNumberHandling.AllowReadingFromString;
                    break;
                default:
                    throw new ArgumentOutOfRangeException("defaults");
                case JsonSerializerDefaults.General:
                    break;
            }
        }

        /// <summary>
        /// Binds current <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance with a new instance of the specified <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" /> type.
        /// </summary>
        /// <typeparam name="TContext">The generic definition of the specified context type.</typeparam>
        /// <remarks>
        /// When serializing and deserializing types using the options
        /// instance, metadata for the types will be fetched from the context instance.
        /// </remarks>
        public void AddContext<TContext>() where TContext : JsonSerializerContext, new()
        {
            VerifyMutable();
            TContext val = new TContext
            {
                Options = this
            };
        }

        /// <summary>
        /// Initializes the converters for the reflection-based serializer.
        /// </summary>
        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        internal void InitializeForReflectionSerializer()
        {
            DefaultJsonTypeInfoResolver defaultJsonTypeInfoResolver = DefaultJsonTypeInfoResolver.RootDefaultInstance();
            IJsonTypeInfoResolver typeInfoResolver = _typeInfoResolver;
            if (typeInfoResolver != null)
            {
                if (typeInfoResolver is JsonSerializerContext jsonSerializerContext && AppContextSwitchHelper.IsSourceGenReflectionFallbackEnabled)
                {
                    _effectiveJsonTypeInfoResolver = JsonTypeInfoResolver.Combine(jsonSerializerContext, defaultJsonTypeInfoResolver);
                }
            }
            else
            {
                _typeInfoResolver = defaultJsonTypeInfoResolver;
            }
            IsImmutable = true;
            _isInitializedForReflectionSerializer = true;
        }

        internal void InitializeForMetadataGeneration()
        {
            if (_typeInfoResolver == null)
            {
                ThrowHelper.ThrowInvalidOperationException_JsonTypeInfoUsedButTypeInfoResolverNotSet();
            }
            IsImmutable = true;
        }

        private JsonTypeInfo GetTypeInfoNoCaching(Type type)
        {
            JsonTypeInfo jsonTypeInfo = (_effectiveJsonTypeInfoResolver ?? _typeInfoResolver)?.GetTypeInfo(type, this);
            if (jsonTypeInfo != null)
            {
                if (jsonTypeInfo.Type != type)
                {
                    ThrowHelper.ThrowInvalidOperationException_ResolverTypeNotCompatible(type, jsonTypeInfo.Type);
                }
                if (jsonTypeInfo.Options != this)
                {
                    ThrowHelper.ThrowInvalidOperationException_ResolverTypeInfoOptionsNotCompatible();
                }
            }
            return jsonTypeInfo;
        }

        internal JsonDocumentOptions GetDocumentOptions()
        {
            JsonDocumentOptions result = default(JsonDocumentOptions);
            result.AllowTrailingCommas = AllowTrailingCommas;
            result.CommentHandling = ReadCommentHandling;
            result.MaxDepth = MaxDepth;
            return result;
        }

        internal JsonNodeOptions GetNodeOptions()
        {
            JsonNodeOptions result = default(JsonNodeOptions);
            result.PropertyNameCaseInsensitive = PropertyNameCaseInsensitive;
            return result;
        }

        internal JsonReaderOptions GetReaderOptions()
        {
            JsonReaderOptions result = default(JsonReaderOptions);
            result.AllowTrailingCommas = AllowTrailingCommas;
            result.CommentHandling = ReadCommentHandling;
            result.MaxDepth = EffectiveMaxDepth;
            return result;
        }

        internal JsonWriterOptions GetWriterOptions()
        {
            JsonWriterOptions result = default(JsonWriterOptions);
            result.Encoder = Encoder;
            result.Indented = WriteIndented;
            result.MaxDepth = EffectiveMaxDepth;
            result.SkipValidation = true;
            return result;
        }

        internal void VerifyMutable()
        {
            if (_isImmutable)
            {
                ThrowHelper.ThrowInvalidOperationException_SerializerOptionsImmutable(_typeInfoResolver as JsonSerializerContext);
            }
        }

        [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        private static JsonSerializerOptions GetOrCreateDefaultOptionsInstance()
        {
            JsonSerializerOptions jsonSerializerOptions = new JsonSerializerOptions
            {
                TypeInfoResolver = DefaultJsonTypeInfoResolver.RootDefaultInstance(),
                IsImmutable = true
            };
            return Interlocked.CompareExchange(ref s_defaultOptions, jsonSerializerOptions, null) ?? jsonSerializerOptions;
        }
    }

    /// <summary>
	/// This enum defines the various JSON tokens that make up a JSON text and is used by
	/// the <see cref="T:System.Text.Json.Utf8JsonReader" /> when moving from one token to the next.
	/// The <see cref="T:System.Text.Json.Utf8JsonReader" /> starts at 'None' by default. The 'Comment' enum value
	/// is only ever reached in a specific <see cref="T:System.Text.Json.Utf8JsonReader" /> mode and is not
	/// reachable by default.
	/// </summary>
	public enum JsonTokenType : byte
    {
        /// <summary>
        ///   Indicates that there is no value (as distinct from <see cref="F:System.Text.Json.JsonTokenType.Null" />).
        /// </summary>
        /// <remarks>
        ///   This is the default token type if no data has been read by the <see cref="T:System.Text.Json.Utf8JsonReader" />.
        /// </remarks>
        None,
        /// <summary>
        ///   Indicates that the token type is the start of a JSON object.
        /// </summary>
        StartObject,
        /// <summary>
        ///   Indicates that the token type is the end of a JSON object.
        /// </summary>
        EndObject,
        /// <summary>
        ///   Indicates that the token type is the start of a JSON array.
        /// </summary>
        StartArray,
        /// <summary>
        ///   Indicates that the token type is the end of a JSON array.
        /// </summary>
        EndArray,
        /// <summary>
        ///   Indicates that the token type is a JSON property name.
        /// </summary>
        PropertyName,
        /// <summary>
        ///   Indicates that the token type is the comment string.
        /// </summary>
        Comment,
        /// <summary>
        ///   Indicates that the token type is a JSON string.
        /// </summary>
        String,
        /// <summary>
        ///   Indicates that the token type is a JSON number.
        /// </summary>
        Number,
        /// <summary>
        ///   Indicates that the token type is the JSON literal <c>true</c>.
        /// </summary>
        True,
        /// <summary>
        ///   Indicates that the token type is the JSON literal <c>false</c>.
        /// </summary>
        False,
        /// <summary>
        ///   Indicates that the token type is the JSON literal <c>null</c>.
        /// </summary>
        Null
    }

    /// <summary>
	///   Specifies the data type of a JSON value.
	/// </summary>
	public enum JsonValueKind : byte
    {
        /// <summary>
        ///   Indicates that there is no value (as distinct from <see cref="F:System.Text.Json.JsonValueKind.Null" />).
        /// </summary>
        Undefined,
        /// <summary>
        ///   Indicates that a value is a JSON object.
        /// </summary>
        Object,
        /// <summary>
        ///   Indicates that a value is a JSON array.
        /// </summary>
        Array,
        /// <summary>
        ///   Indicates that a value is a JSON string.
        /// </summary>
        String,
        /// <summary>
        ///   Indicates that a value is a JSON number.
        /// </summary>
        Number,
        /// <summary>
        ///   Indicates that a value is the JSON value <c>true</c>.
        /// </summary>
        True,
        /// <summary>
        ///   Indicates that a value is the JSON value <c>false</c>.
        /// </summary>
        False,
        /// <summary>
        ///   Indicates that a value is the JSON value <c>null</c>.
        /// </summary>
        Null
    }

    internal static class JsonWriterHelper
    {
        private static readonly StandardFormat s_dateTimeStandardFormat = new StandardFormat('O');

        public const int LastAsciiCharacter = 127;

        private static readonly StandardFormat s_hexStandardFormat = new StandardFormat('X', 4);

        private static ReadOnlySpan<byte> AllowList => new byte[256]
        {
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        };

        public static void WriteIndentation(Span<byte> buffer, int indent)
        {
            if (indent < 8)
            {
                int num = 0;
                while (num < indent)
                {
                    buffer[num++] = 32;
                    buffer[num++] = 32;
                }
            }
            else
            {
                buffer.Slice(0, indent).Fill(32);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ValidateProperty(ReadOnlySpan<byte> propertyName)
        {
            if (propertyName.Length > 166666666)
            {
                ThrowHelper.ThrowArgumentException_PropertyNameTooLarge(propertyName.Length);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ValidateValue(ReadOnlySpan<byte> value)
        {
            if (value.Length > 166666666)
            {
                ThrowHelper.ThrowArgumentException_ValueTooLarge(value.Length);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ValidateBytes(ReadOnlySpan<byte> bytes)
        {
            if (bytes.Length > 125000000)
            {
                ThrowHelper.ThrowArgumentException_ValueTooLarge(bytes.Length);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ValidateDouble(double value)
        {
            if (!JsonHelpers.IsFinite(value))
            {
                ThrowHelper.ThrowArgumentException_ValueNotSupported();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ValidateSingle(float value)
        {
            if (!JsonHelpers.IsFinite(value))
            {
                ThrowHelper.ThrowArgumentException_ValueNotSupported();
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ValidateProperty(ReadOnlySpan<char> propertyName)
        {
            if (propertyName.Length > 166666666)
            {
                ThrowHelper.ThrowArgumentException_PropertyNameTooLarge(propertyName.Length);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ValidateValue(ReadOnlySpan<char> value)
        {
            if (value.Length > 166666666)
            {
                ThrowHelper.ThrowArgumentException_ValueTooLarge(value.Length);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ValidatePropertyAndValue(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> value)
        {
            if (propertyName.Length > 166666666 || value.Length > 166666666)
            {
                ThrowHelper.ThrowArgumentException(propertyName, value);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ValidatePropertyAndValue(ReadOnlySpan<byte> propertyName, ReadOnlySpan<char> value)
        {
            if (propertyName.Length > 166666666 || value.Length > 166666666)
            {
                ThrowHelper.ThrowArgumentException(propertyName, value);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ValidatePropertyAndValue(ReadOnlySpan<byte> propertyName, ReadOnlySpan<byte> value)
        {
            if (propertyName.Length > 166666666 || value.Length > 166666666)
            {
                ThrowHelper.ThrowArgumentException(propertyName, value);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ValidatePropertyAndValue(ReadOnlySpan<char> propertyName, ReadOnlySpan<char> value)
        {
            if (propertyName.Length > 166666666 || value.Length > 166666666)
            {
                ThrowHelper.ThrowArgumentException(propertyName, value);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ValidatePropertyAndBytes(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> bytes)
        {
            if (propertyName.Length > 166666666 || bytes.Length > 125000000)
            {
                ThrowHelper.ThrowArgumentException(propertyName, bytes);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void ValidatePropertyAndBytes(ReadOnlySpan<byte> propertyName, ReadOnlySpan<byte> bytes)
        {
            if (propertyName.Length > 166666666 || bytes.Length > 125000000)
            {
                ThrowHelper.ThrowArgumentException(propertyName, bytes);
            }
        }

        internal static void ValidateNumber(ReadOnlySpan<byte> utf8FormattedNumber)
        {
            int i = 0;
            if (utf8FormattedNumber[i] == 45)
            {
                i++;
                if (utf8FormattedNumber.Length <= i)
                {
                    throw new ArgumentException(MDCFR.Properties.Resources.RequiredDigitNotFoundEndOfData, "utf8FormattedNumber");
                }
            }
            if (utf8FormattedNumber[i] == 48)
            {
                i++;
            }
            else
            {
                for (; i < utf8FormattedNumber.Length && JsonHelpers.IsDigit(utf8FormattedNumber[i]); i++)
                {
                }
            }
            if (i == utf8FormattedNumber.Length)
            {
                return;
            }
            byte b = utf8FormattedNumber[i];
            if (b == 46)
            {
                i++;
                if (utf8FormattedNumber.Length <= i)
                {
                    throw new ArgumentException(MDCFR.Properties.Resources.RequiredDigitNotFoundEndOfData, "utf8FormattedNumber");
                }
                for (; i < utf8FormattedNumber.Length && JsonHelpers.IsDigit(utf8FormattedNumber[i]); i++)
                {
                }
                if (i == utf8FormattedNumber.Length)
                {
                    return;
                }
                b = utf8FormattedNumber[i];
            }
            if (b == 101 || b == 69)
            {
                i++;
                if (utf8FormattedNumber.Length <= i)
                {
                    throw new ArgumentException(MDCFR.Properties.Resources.RequiredDigitNotFoundEndOfData, "utf8FormattedNumber");
                }
                b = utf8FormattedNumber[i];
                if (b == 43 || b == 45)
                {
                    i++;
                }
                if (utf8FormattedNumber.Length <= i)
                {
                    throw new ArgumentException(MDCFR.Properties.Resources.RequiredDigitNotFoundEndOfData, "utf8FormattedNumber");
                }
                for (; i < utf8FormattedNumber.Length && JsonHelpers.IsDigit(utf8FormattedNumber[i]); i++)
                {
                }
                if (i == utf8FormattedNumber.Length)
                {
                    return;
                }
                throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.ExpectedEndOfDigitNotFound, ThrowHelper.GetPrintableString(utf8FormattedNumber[i])), "utf8FormattedNumber");
            }
            throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.ExpectedEndOfDigitNotFound, ThrowHelper.GetPrintableString(b)), "utf8FormattedNumber");
        }

        public static void WriteDateTimeTrimmed(Span<byte> buffer, DateTime value, out int bytesWritten)
        {
            Span<byte> destination = stackalloc byte[33];
            bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten, s_dateTimeStandardFormat);
            TrimDateTimeOffset(destination.Slice(0, bytesWritten), out bytesWritten);
            destination.Slice(0, bytesWritten).CopyTo(buffer);
        }

        public static void WriteDateTimeOffsetTrimmed(Span<byte> buffer, DateTimeOffset value, out int bytesWritten)
        {
            Span<byte> destination = stackalloc byte[33];
            bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten, s_dateTimeStandardFormat);
            TrimDateTimeOffset(destination.Slice(0, bytesWritten), out bytesWritten);
            destination.Slice(0, bytesWritten).CopyTo(buffer);
        }

        public static void TrimDateTimeOffset(Span<byte> buffer, out int bytesWritten)
        {
            if (buffer[26] != 48)
            {
                bytesWritten = buffer.Length;
                return;
            }
            int num = ((buffer[25] != 48) ? 26 : ((buffer[24] != 48) ? 25 : ((buffer[23] != 48) ? 24 : ((buffer[22] != 48) ? 23 : ((buffer[21] != 48) ? 22 : ((buffer[20] != 48) ? 21 : 19))))));
            if (buffer.Length == 27)
            {
                bytesWritten = num;
            }
            else if (buffer.Length == 33)
            {
                buffer[num] = buffer[27];
                buffer[num + 1] = buffer[28];
                buffer[num + 2] = buffer[29];
                buffer[num + 3] = buffer[30];
                buffer[num + 4] = buffer[31];
                buffer[num + 5] = buffer[32];
                bytesWritten = num + 6;
            }
            else
            {
                buffer[num] = 90;
                bytesWritten = num + 1;
            }
        }

        private static bool NeedsEscaping(byte value)
        {
            return AllowList[value] == 0;
        }

        private static bool NeedsEscapingNoBoundsCheck(char value)
        {
            return AllowList[value] == 0;
        }

        public static int NeedsEscaping(ReadOnlySpan<byte> value, JavaScriptEncoder encoder)
        {
            return (encoder ?? JavaScriptEncoder.Default).FindFirstCharacterToEncodeUtf8(value);
        }

        public unsafe static int NeedsEscaping(ReadOnlySpan<char> value, JavaScriptEncoder encoder)
        {
            if (value.IsEmpty)
            {
                return -1;
            }
            fixed (char* text = value)
            {
                return (encoder ?? JavaScriptEncoder.Default).FindFirstCharacterToEncode(text, value.Length);
            }
        }

        public static int GetMaxEscapedLength(int textLength, int firstIndexToEscape)
        {
            return firstIndexToEscape + 6 * (textLength - firstIndexToEscape);
        }

        private static void EscapeString(ReadOnlySpan<byte> value, Span<byte> destination, JavaScriptEncoder encoder, ref int written)
        {
            if (encoder.EncodeUtf8(value, destination, out var _, out var bytesWritten) != 0)
            {
                ThrowHelper.ThrowArgumentException_InvalidUTF8(value.Slice(bytesWritten));
            }
            written += bytesWritten;
        }

        public static void EscapeString(ReadOnlySpan<byte> value, Span<byte> destination, int indexOfFirstByteToEscape, JavaScriptEncoder encoder, out int written)
        {
            value.Slice(0, indexOfFirstByteToEscape).CopyTo(destination);
            written = indexOfFirstByteToEscape;
            if (encoder != null)
            {
                destination = destination.Slice(indexOfFirstByteToEscape);
                value = value.Slice(indexOfFirstByteToEscape);
                EscapeString(value, destination, encoder, ref written);
                return;
            }
            while (indexOfFirstByteToEscape < value.Length)
            {
                byte b = value[indexOfFirstByteToEscape];
                if (IsAsciiValue(b))
                {
                    if (NeedsEscaping(b))
                    {
                        EscapeNextBytes(b, destination, ref written);
                        indexOfFirstByteToEscape++;
                    }
                    else
                    {
                        destination[written] = b;
                        written++;
                        indexOfFirstByteToEscape++;
                    }
                    continue;
                }
                destination = destination.Slice(written);
                value = value.Slice(indexOfFirstByteToEscape);
                EscapeString(value, destination, JavaScriptEncoder.Default, ref written);
                break;
            }
        }

        private static void EscapeNextBytes(byte value, Span<byte> destination, ref int written)
        {
            destination[written++] = 92;
            switch (value)
            {
                case 34:
                    destination[written++] = 117;
                    destination[written++] = 48;
                    destination[written++] = 48;
                    destination[written++] = 50;
                    destination[written++] = 50;
                    break;
                case 10:
                    destination[written++] = 110;
                    break;
                case 13:
                    destination[written++] = 114;
                    break;
                case 9:
                    destination[written++] = 116;
                    break;
                case 92:
                    destination[written++] = 92;
                    break;
                case 8:
                    destination[written++] = 98;
                    break;
                case 12:
                    destination[written++] = 102;
                    break;
                default:
                    {
                        destination[written++] = 117;
                        int bytesWritten;
                        bool flag = Utf8Formatter.TryFormat(value, destination.Slice(written), out bytesWritten, s_hexStandardFormat);
                        written += bytesWritten;
                        break;
                    }
            }
        }

        private static bool IsAsciiValue(byte value)
        {
            return value <= 127;
        }

        private static bool IsAsciiValue(char value)
        {
            return value <= '\u007f';
        }

        private static void EscapeString(ReadOnlySpan<char> value, Span<char> destination, JavaScriptEncoder encoder, ref int written)
        {
            if (encoder.Encode(value, destination, out var _, out var charsWritten) != 0)
            {
                ThrowHelper.ThrowArgumentException_InvalidUTF16(value[charsWritten]);
            }
            written += charsWritten;
        }

        public static void EscapeString(ReadOnlySpan<char> value, Span<char> destination, int indexOfFirstByteToEscape, JavaScriptEncoder encoder, out int written)
        {
            value.Slice(0, indexOfFirstByteToEscape).CopyTo(destination);
            written = indexOfFirstByteToEscape;
            if (encoder != null)
            {
                destination = destination.Slice(indexOfFirstByteToEscape);
                value = value.Slice(indexOfFirstByteToEscape);
                EscapeString(value, destination, encoder, ref written);
                return;
            }
            while (indexOfFirstByteToEscape < value.Length)
            {
                char c = value[indexOfFirstByteToEscape];
                if (IsAsciiValue(c))
                {
                    if (NeedsEscapingNoBoundsCheck(c))
                    {
                        EscapeNextChars(c, destination, ref written);
                        indexOfFirstByteToEscape++;
                    }
                    else
                    {
                        destination[written] = c;
                        written++;
                        indexOfFirstByteToEscape++;
                    }
                    continue;
                }
                destination = destination.Slice(written);
                value = value.Slice(indexOfFirstByteToEscape);
                EscapeString(value, destination, JavaScriptEncoder.Default, ref written);
                break;
            }
        }

        private static void EscapeNextChars(char value, Span<char> destination, ref int written)
        {
            destination[written++] = '\\';
            switch ((byte)value)
            {
                case 34:
                    destination[written++] = 'u';
                    destination[written++] = '0';
                    destination[written++] = '0';
                    destination[written++] = '2';
                    destination[written++] = '2';
                    break;
                case 10:
                    destination[written++] = 'n';
                    break;
                case 13:
                    destination[written++] = 'r';
                    break;
                case 9:
                    destination[written++] = 't';
                    break;
                case 92:
                    destination[written++] = '\\';
                    break;
                case 8:
                    destination[written++] = 'b';
                    break;
                case 12:
                    destination[written++] = 'f';
                    break;
                default:
                    destination[written++] = 'u';
                    written = WriteHex(value, destination, written);
                    break;
            }
        }

        private static int WriteHex(int value, Span<char> destination, int written)
        {
            destination[written++] = System.HexConverter.ToCharUpper(value >> 12);
            destination[written++] = System.HexConverter.ToCharUpper(value >> 8);
            destination[written++] = System.HexConverter.ToCharUpper(value >> 4);
            destination[written++] = System.HexConverter.ToCharUpper(value);
            return written;
        }

        /// <summary>
        /// Converts a span containing a sequence of UTF-16 bytes into UTF-8 bytes.
        ///
        /// This method will consume as many of the input bytes as possible.
        ///
        /// On successful exit, the entire input was consumed and encoded successfully. In this case, <paramref name="bytesConsumed" /> will be
        /// equal to the length of the <paramref name="utf16Source" /> and <paramref name="bytesWritten" /> will equal the total number of bytes written to
        /// the <paramref name="utf8Destination" />.
        /// </summary>
        /// <param name="utf16Source">A span containing a sequence of UTF-16 bytes.</param>
        /// <param name="utf8Destination">A span to write the UTF-8 bytes into.</param>
        /// <param name="bytesConsumed">On exit, contains the number of bytes that were consumed from the <paramref name="utf16Source" />.</param>
        /// <param name="bytesWritten">On exit, contains the number of bytes written to <paramref name="utf8Destination" /></param>
        /// <returns>A <see cref="T:System.Buffers.OperationStatus" /> value representing the state of the conversion.</returns>
        public unsafe static OperationStatus ToUtf8(ReadOnlySpan<byte> utf16Source, Span<byte> utf8Destination, out int bytesConsumed, out int bytesWritten)
        {
            fixed (byte* ptr = &MemoryMarshal.GetReference(utf16Source))
            {
                fixed (byte* ptr3 = &MemoryMarshal.GetReference(utf8Destination))
                {
                    char* ptr2 = (char*)ptr;
                    byte* ptr4 = ptr3;
                    char* ptr5 = (char*)(ptr + utf16Source.Length);
                    byte* ptr6 = ptr4 + utf8Destination.Length;
                    while (true)
                    {
                    IL_025a:
                        if (ptr5 - ptr2 > 13)
                        {
                            int num = Math.Min(PtrDiff(ptr5, ptr2), PtrDiff(ptr6, ptr4));
                            char* ptr7 = ptr2 + num - 5;
                            if (ptr2 < ptr7)
                            {
                                while (true)
                                {
                                    int num2 = *ptr2;
                                    ptr2++;
                                    if (num2 > 127)
                                    {
                                        goto IL_0181;
                                    }
                                    *ptr4 = (byte)num2;
                                    ptr4++;
                                    if (((uint)(int)ptr2 & 2u) != 0)
                                    {
                                        num2 = *ptr2;
                                        ptr2++;
                                        if (num2 > 127)
                                        {
                                            goto IL_0181;
                                        }
                                        *ptr4 = (byte)num2;
                                        ptr4++;
                                    }
                                    while (ptr2 < ptr7)
                                    {
                                        num2 = *(int*)ptr2;
                                        int num3 = *(int*)(ptr2 + 2);
                                        if (((num2 | num3) & -8323200) == 0)
                                        {
                                            if (!BitConverter.IsLittleEndian)
                                            {
                                                *ptr4 = (byte)(num2 >> 16);
                                                ptr4[1] = (byte)num2;
                                                ptr2 += 4;
                                                ptr4[2] = (byte)(num3 >> 16);
                                                ptr4[3] = (byte)num3;
                                                ptr4 += 4;
                                            }
                                            else
                                            {
                                                *ptr4 = (byte)num2;
                                                ptr4[1] = (byte)(num2 >> 16);
                                                ptr2 += 4;
                                                ptr4[2] = (byte)num3;
                                                ptr4[3] = (byte)(num3 >> 16);
                                                ptr4 += 4;
                                            }
                                            continue;
                                        }
                                        goto IL_014f;
                                    }
                                    goto IL_0251;
                                IL_014f:
                                    num2 = (int)(BitConverter.IsLittleEndian ? ((ushort)num2) : ((uint)num2 >> 16));
                                    ptr2++;
                                    if (num2 > 127)
                                    {
                                        goto IL_0181;
                                    }
                                    *ptr4 = (byte)num2;
                                    ptr4++;
                                    goto IL_0251;
                                IL_0251:
                                    if (ptr2 < ptr7)
                                    {
                                        continue;
                                    }
                                    goto IL_025a;
                                IL_0181:
                                    int num4;
                                    if (num2 <= 2047)
                                    {
                                        num4 = -64 | (num2 >> 6);
                                    }
                                    else
                                    {
                                        if (!JsonHelpers.IsInRangeInclusive(num2, 55296, 57343))
                                        {
                                            num4 = -32 | (num2 >> 12);
                                        }
                                        else
                                        {
                                            if (num2 > 56319)
                                            {
                                                break;
                                            }
                                            num4 = *ptr2;
                                            if (!JsonHelpers.IsInRangeInclusive(num4, 56320, 57343))
                                            {
                                                break;
                                            }
                                            ptr2++;
                                            num2 = num4 + (num2 << 10) + -56613888;
                                            *ptr4 = (byte)(0xFFFFFFF0u | (uint)(num2 >> 18));
                                            ptr4++;
                                            num4 = -128 | ((num2 >> 12) & 0x3F);
                                        }
                                        *ptr4 = (byte)num4;
                                        ptr7--;
                                        ptr4++;
                                        num4 = -128 | ((num2 >> 6) & 0x3F);
                                    }
                                    *ptr4 = (byte)num4;
                                    ptr7--;
                                    ptr4[1] = (byte)(0xFFFFFF80u | ((uint)num2 & 0x3Fu));
                                    ptr4 += 2;
                                    goto IL_0251;
                                }
                                break;
                            }
                        }
                        while (true)
                        {
                            int num5;
                            int num6;
                            if (ptr2 < ptr5)
                            {
                                num5 = *ptr2;
                                ptr2++;
                                if (num5 <= 127)
                                {
                                    if (ptr6 - ptr4 > 0)
                                    {
                                        *ptr4 = (byte)num5;
                                        ptr4++;
                                        continue;
                                    }
                                }
                                else if (num5 <= 2047)
                                {
                                    if (ptr6 - ptr4 > 1)
                                    {
                                        num6 = -64 | (num5 >> 6);
                                        goto IL_0380;
                                    }
                                }
                                else if (!JsonHelpers.IsInRangeInclusive(num5, 55296, 57343))
                                {
                                    if (ptr6 - ptr4 > 2)
                                    {
                                        num6 = -32 | (num5 >> 12);
                                        goto IL_0368;
                                    }
                                }
                                else if (ptr6 - ptr4 > 3)
                                {
                                    if (num5 > 56319)
                                    {
                                        break;
                                    }
                                    if (ptr2 < ptr5)
                                    {
                                        num6 = *ptr2;
                                        if (!JsonHelpers.IsInRangeInclusive(num6, 56320, 57343))
                                        {
                                            break;
                                        }
                                        ptr2++;
                                        num5 = num6 + (num5 << 10) + -56613888;
                                        *ptr4 = (byte)(0xFFFFFFF0u | (uint)(num5 >> 18));
                                        ptr4++;
                                        num6 = -128 | ((num5 >> 12) & 0x3F);
                                        goto IL_0368;
                                    }
                                    bytesConsumed = (int)((byte*)(ptr2 - 1) - ptr);
                                    bytesWritten = (int)(ptr4 - ptr3);
                                    return OperationStatus.NeedMoreData;
                                }
                                bytesConsumed = (int)((byte*)(ptr2 - 1) - ptr);
                                bytesWritten = (int)(ptr4 - ptr3);
                                return OperationStatus.DestinationTooSmall;
                            }
                            bytesConsumed = (int)((byte*)ptr2 - ptr);
                            bytesWritten = (int)(ptr4 - ptr3);
                            return OperationStatus.Done;
                        IL_0368:
                            *ptr4 = (byte)num6;
                            ptr4++;
                            num6 = -128 | ((num5 >> 6) & 0x3F);
                            goto IL_0380;
                        IL_0380:
                            *ptr4 = (byte)num6;
                            ptr4[1] = (byte)(0xFFFFFF80u | ((uint)num5 & 0x3Fu));
                            ptr4 += 2;
                        }
                        break;
                    }
                    bytesConsumed = (int)((byte*)(ptr2 - 1) - ptr);
                    bytesWritten = (int)(ptr4 - ptr3);
                    return OperationStatus.InvalidData;
                }
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private unsafe static int PtrDiff(char* a, char* b)
        {
            return (int)((uint)((byte*)a - (byte*)b) >> 1);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private unsafe static int PtrDiff(byte* a, byte* b)
        {
            return (int)(a - b);
        }
    }

    /// <summary>
	/// Provides the ability for the user to define custom behavior when writing JSON
	/// using the <see cref="T:System.Text.Json.Utf8JsonWriter" />. By default, the JSON is written without
	/// any indentation or extra white space. Also, the <see cref="T:System.Text.Json.Utf8JsonWriter" /> will
	/// throw an exception if the user attempts to write structurally invalid JSON.
	/// </summary>
	public struct JsonWriterOptions
    {
        internal const int DefaultMaxDepth = 1000;

        private int _maxDepth;

        private int _optionsMask;

        private const int IndentBit = 1;

        private const int SkipValidationBit = 2;

        /// <summary>
        /// The encoder to use when escaping strings, or <see langword="null" /> to use the default encoder.
        /// </summary>
        public JavaScriptEncoder? Encoder { get; set; }

        /// <summary>
        /// Defines whether the <see cref="T:System.Text.Json.Utf8JsonWriter" /> should pretty print the JSON which includes:
        /// indenting nested JSON tokens, adding new lines, and adding white space between property names and values.
        /// By default, the JSON is written without any extra white space.
        /// </summary>
        public bool Indented
        {
            get
            {
                return (_optionsMask & 1) != 0;
            }
            set
            {
                if (value)
                {
                    _optionsMask |= 1;
                }
                else
                {
                    _optionsMask &= -2;
                }
            }
        }

        /// <summary>
        /// Gets or sets the maximum depth allowed when writing JSON, with the default (i.e. 0) indicating a max depth of 1000.
        /// </summary>
        /// <exception cref="T:System.ArgumentOutOfRangeException">
        /// Thrown when the max depth is set to a negative value.
        /// </exception>
        /// <remarks>
        /// Reading past this depth will throw a <exception cref="T:System.Text.Json.JsonException" />.
        /// </remarks>
        public int MaxDepth
        {
            readonly get
            {
                return _maxDepth;
            }
            set
            {
                if (value < 0)
                {
                    ThrowHelper.ThrowArgumentOutOfRangeException_MaxDepthMustBePositive("value");
                }
                _maxDepth = value;
            }
        }

        /// <summary>
        /// Defines whether the <see cref="T:System.Text.Json.Utf8JsonWriter" /> should skip structural validation and allow
        /// the user to write invalid JSON, when set to true. If set to false, any attempts to write invalid JSON will result in
        /// a <exception cref="T:System.InvalidOperationException" /> to be thrown.
        /// </summary>
        /// <remarks>
        /// If the JSON being written is known to be correct,
        /// then skipping validation (by setting it to true) could improve performance.
        /// An example of invalid JSON where the writer will throw (when SkipValidation
        /// is set to false) is when you write a value within a JSON object
        /// without a property name.
        /// </remarks>
        public bool SkipValidation
        {
            get
            {
                return (_optionsMask & 2) != 0;
            }
            set
            {
                if (value)
                {
                    _optionsMask |= 2;
                }
                else
                {
                    _optionsMask &= -3;
                }
            }
        }

        internal bool IndentedOrNotSkipValidation => _optionsMask != 2;
    }

    [Flags]
    internal enum MetadataPropertyName : byte
    {
        None = 0,
        Values = 1,
        Id = 2,
        Ref = 4,
        Type = 8
    }

    internal enum NumericType
    {
        Byte,
        SByte,
        Int16,
        Int32,
        Int64,
        UInt16,
        UInt32,
        UInt64,
        Single,
        Double,
        Decimal
    }

    internal enum PolymorphicSerializationState : byte
    {
        None,
        /// <summary>
        /// Dispatch to a derived converter has been initiated.
        /// </summary>
        PolymorphicReEntryStarted,
        /// <summary>
        /// Current frame is a continuation using a suspended derived converter.
        /// </summary>
        PolymorphicReEntrySuspended,
        /// <summary>
        /// Current frame is a polymorphic converter that couldn't resolve a derived converter.
        /// (E.g. because the runtime type matches the declared type).
        /// </summary>
        PolymorphicReEntryNotFound
    }

    internal sealed class PooledByteBufferWriter : IBufferWriter<byte>, IDisposable
    {
        private byte[] _rentedBuffer;

        private int _index;

        private const int MinimumBufferSize = 256;

        public ReadOnlyMemory<byte> WrittenMemory => _rentedBuffer.AsMemory(0, _index);

        public int WrittenCount => _index;

        public int Capacity => _rentedBuffer.Length;

        public int FreeCapacity => _rentedBuffer.Length - _index;

        private PooledByteBufferWriter()
        {
        }

        public PooledByteBufferWriter(int initialCapacity)
        {
            _rentedBuffer = ArrayPool<byte>.Shared.Rent(initialCapacity);
            _index = 0;
        }

        public void Clear()
        {
            ClearHelper();
        }

        public void ClearAndReturnBuffers()
        {
            ClearHelper();
            byte[] rentedBuffer = _rentedBuffer;
            _rentedBuffer = null;
            ArrayPool<byte>.Shared.Return(rentedBuffer);
        }

        private void ClearHelper()
        {
            _rentedBuffer.AsSpan(0, _index).Clear();
            _index = 0;
        }

        public void Dispose()
        {
            if (_rentedBuffer != null)
            {
                ClearHelper();
                byte[] rentedBuffer = _rentedBuffer;
                _rentedBuffer = null;
                ArrayPool<byte>.Shared.Return(rentedBuffer);
            }
        }

        public void InitializeEmptyInstance(int initialCapacity)
        {
            _rentedBuffer = ArrayPool<byte>.Shared.Rent(initialCapacity);
            _index = 0;
        }

        public static PooledByteBufferWriter CreateEmptyInstanceForCaching()
        {
            return new PooledByteBufferWriter();
        }

        public void Advance(int count)
        {
            _index += count;
        }

        public Memory<byte> GetMemory(int sizeHint = 0)
        {
            CheckAndResizeBuffer(sizeHint);
            return _rentedBuffer.AsMemory(_index);
        }

        public Span<byte> GetSpan(int sizeHint = 0)
        {
            CheckAndResizeBuffer(sizeHint);
            return _rentedBuffer.AsSpan(_index);
        }

        internal Task WriteToStreamAsync(Stream destination, CancellationToken cancellationToken)
        {
            return destination.WriteAsync(_rentedBuffer, 0, _index, cancellationToken);
        }

        internal void WriteToStream(Stream destination)
        {
            destination.Write(_rentedBuffer, 0, _index);
        }

        private void CheckAndResizeBuffer(int sizeHint)
        {
            if (sizeHint == 0)
            {
                sizeHint = 256;
            }
            int num = _rentedBuffer.Length - _index;
            if (sizeHint <= num)
            {
                return;
            }
            int num2 = _rentedBuffer.Length;
            int num3 = Math.Max(sizeHint, num2);
            int num4 = num2 + num3;
            if ((uint)num4 > 2147483647u)
            {
                num4 = num2 + sizeHint;
                if ((uint)num4 > 2147483647u)
                {
                    ThrowHelper.ThrowOutOfMemoryException_BufferMaximumSizeExceeded((uint)num4);
                }
            }
            byte[] rentedBuffer = _rentedBuffer;
            _rentedBuffer = ArrayPool<byte>.Shared.Rent(num4);
            Span<byte> span = rentedBuffer.AsSpan(0, _index);
            span.CopyTo(_rentedBuffer);
            span.Clear();
            ArrayPool<byte>.Shared.Return(rentedBuffer);
        }
    }

    [StructLayout(LayoutKind.Auto)]
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    internal struct ReadStack
    {
        internal static readonly char[] SpecialCharacters = new char[18]
        {
            '.', ' ', '\'', '/', '"', '[', ']', '(', ')', '\t',
            '\n', '\r', '\f', '\b', '\\', '\u0085', '\u2028', '\u2029'
        };

        /// <summary>
        /// Exposes the stackframe that is currently active.
        /// </summary>
        public ReadStackFrame Current;

        /// <summary>
        /// Buffer containing all frames in the stack. For performance it is only populated for serialization depths &gt; 1.
        /// </summary>
        private ReadStackFrame[] _stack;

        /// <summary>
        /// Tracks the current depth of the stack.
        /// </summary>
        private int _count;

        /// <summary>
        /// If not zero, indicates that the stack is part of a re-entrant continuation of given depth.
        /// </summary>
        private int _continuationCount;

        private List<ArgumentState> _ctorArgStateCache;

        /// <summary>
        /// Bytes consumed in the current loop.
        /// </summary>
        public long BytesConsumed;

        /// <summary>
        /// Internal flag to let us know that we need to read ahead in the inner read loop.
        /// </summary>
        public bool ReadAhead;

        public ReferenceResolver ReferenceResolver;

        /// <summary>
        /// Whether we need to read ahead in the inner read loop.
        /// </summary>
        public bool SupportContinuation;

        /// <summary>
        /// Holds the value of $id or $ref of the currently read object
        /// </summary>
        public string ReferenceId;

        /// <summary>
        /// Holds the value of $type of the currently read object
        /// </summary>
        public object PolymorphicTypeDiscriminator;

        /// <summary>
        /// Global flag indicating whether we can read preserved references.
        /// </summary>
        public bool PreserveReferences;

        /// <summary>
        /// Indicates that the state still contains suspended frames waiting re-entry.
        /// </summary>
        public bool IsContinuation => _continuationCount != 0;

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private string DebuggerDisplay => $"Path:{JsonPath()} Current: ConverterStrategy.{Current.JsonTypeInfo?.PropertyInfoForTypeInfo.ConverterStrategy}, {Current.JsonTypeInfo?.Type.Name}";

        /// <summary>
        /// Ensures that the stack buffer has sufficient capacity to hold an additional frame.
        /// </summary>
        private void EnsurePushCapacity()
        {
            if (_stack == null)
            {
                _stack = new ReadStackFrame[4];
            }
            else if (_count - 1 == _stack.Length)
            {
                Array.Resize(ref _stack, 2 * _stack.Length);
            }
        }

        internal void Initialize(JsonTypeInfo jsonTypeInfo, bool supportContinuation = false)
        {
            JsonSerializerOptions options = jsonTypeInfo.Options;
            if (options.ReferenceHandlingStrategy == ReferenceHandlingStrategy.Preserve)
            {
                ReferenceResolver = options.ReferenceHandler.CreateResolver(writing: false);
                PreserveReferences = true;
            }
            Current.JsonTypeInfo = jsonTypeInfo;
            Current.JsonPropertyInfo = jsonTypeInfo.PropertyInfoForTypeInfo;
            Current.NumberHandling = Current.JsonPropertyInfo.EffectiveNumberHandling;
            Current.CanContainMetadata = PreserveReferences || (jsonTypeInfo.PolymorphicTypeResolver?.UsesTypeDiscriminators ?? false);
            SupportContinuation = supportContinuation;
        }

        public void Push()
        {
            if (_continuationCount == 0)
            {
                if (_count == 0)
                {
                    _count = 1;
                }
                else
                {
                    JsonTypeInfo jsonTypeInfo = Current.JsonPropertyInfo?.JsonTypeInfo ?? Current.CtorArgumentState.JsonParameterInfo.JsonTypeInfo;
                    JsonNumberHandling? numberHandling = Current.NumberHandling;
                    EnsurePushCapacity();
                    _stack[_count - 1] = Current;
                    Current = default(ReadStackFrame);
                    _count++;
                    Current.JsonTypeInfo = jsonTypeInfo;
                    Current.JsonPropertyInfo = jsonTypeInfo.PropertyInfoForTypeInfo;
                    Current.NumberHandling = numberHandling ?? Current.JsonPropertyInfo.EffectiveNumberHandling;
                    Current.CanContainMetadata = PreserveReferences || (jsonTypeInfo.PolymorphicTypeResolver?.UsesTypeDiscriminators ?? false);
                }
            }
            else
            {
                if (_count++ > 0)
                {
                    _stack[_count - 2] = Current;
                    Current = _stack[_count - 1];
                }
                if (_continuationCount == _count)
                {
                    _continuationCount = 0;
                }
            }
            SetConstructorArgumentState();
        }

        public void Pop(bool success)
        {
            if (!success)
            {
                if (_continuationCount == 0)
                {
                    if (_count == 1)
                    {
                        _continuationCount = 1;
                        _count = 0;
                        return;
                    }
                    EnsurePushCapacity();
                    _continuationCount = _count--;
                }
                else if (--_count == 0)
                {
                    return;
                }
                _stack[_count] = Current;
                Current = _stack[_count - 1];
            }
            else if (--_count > 0)
            {
                Current = _stack[_count - 1];
            }
            SetConstructorArgumentState();
        }

        /// <summary>
        /// Configures the current stack frame for a polymorphic converter.
        /// </summary>
        public JsonConverter InitializePolymorphicReEntry(JsonTypeInfo derivedJsonTypeInfo)
        {
            Current.PolymorphicJsonTypeInfo = Current.JsonTypeInfo;
            Current.JsonTypeInfo = derivedJsonTypeInfo.PropertyInfoForTypeInfo.JsonTypeInfo;
            Current.JsonPropertyInfo = Current.JsonTypeInfo.PropertyInfoForTypeInfo;
            ref JsonNumberHandling? numberHandling = ref Current.NumberHandling;
            JsonNumberHandling? jsonNumberHandling = numberHandling;
            if (!jsonNumberHandling.HasValue)
            {
                numberHandling = Current.JsonPropertyInfo.NumberHandling;
            }
            Current.PolymorphicSerializationState = PolymorphicSerializationState.PolymorphicReEntryStarted;
            SetConstructorArgumentState();
            return derivedJsonTypeInfo.Converter;
        }

        /// <summary>
        /// Configures the current frame for a continuation of a polymorphic converter.
        /// </summary>
        public JsonConverter ResumePolymorphicReEntry()
        {
            ref JsonTypeInfo jsonTypeInfo = ref Current.JsonTypeInfo;
            ref JsonTypeInfo polymorphicJsonTypeInfo = ref Current.PolymorphicJsonTypeInfo;
            JsonTypeInfo polymorphicJsonTypeInfo2 = Current.PolymorphicJsonTypeInfo;
            JsonTypeInfo jsonTypeInfo2 = Current.JsonTypeInfo;
            jsonTypeInfo = polymorphicJsonTypeInfo2;
            polymorphicJsonTypeInfo = jsonTypeInfo2;
            Current.PolymorphicSerializationState = PolymorphicSerializationState.PolymorphicReEntryStarted;
            return Current.JsonTypeInfo.Converter;
        }

        /// <summary>
        /// Updates frame state after a polymorphic converter has returned.
        /// </summary>
        public void ExitPolymorphicConverter(bool success)
        {
            ref JsonTypeInfo jsonTypeInfo = ref Current.JsonTypeInfo;
            ref JsonTypeInfo polymorphicJsonTypeInfo = ref Current.PolymorphicJsonTypeInfo;
            JsonTypeInfo polymorphicJsonTypeInfo2 = Current.PolymorphicJsonTypeInfo;
            JsonTypeInfo jsonTypeInfo2 = Current.JsonTypeInfo;
            jsonTypeInfo = polymorphicJsonTypeInfo2;
            polymorphicJsonTypeInfo = jsonTypeInfo2;
            Current.PolymorphicSerializationState = ((!success) ? PolymorphicSerializationState.PolymorphicReEntrySuspended : PolymorphicSerializationState.None);
        }

        public string JsonPath()
        {
            StringBuilder stringBuilder = new StringBuilder("$");
            int continuationCount = _continuationCount;
            (int, bool) tuple = continuationCount switch
            {
                0 => (_count - 1, true),
                1 => (0, true),
                _ => (continuationCount, false),
            };
            int item = tuple.Item1;
            bool item2 = tuple.Item2;
            for (int i = 0; i < item; i++)
            {
                AppendStackFrame(stringBuilder, ref _stack[i]);
            }
            if (item2)
            {
                AppendStackFrame(stringBuilder, ref Current);
            }
            return stringBuilder.ToString();
            static void AppendPropertyName(StringBuilder sb, string propertyName)
            {
                if (propertyName != null)
                {
                    if (propertyName.IndexOfAny(SpecialCharacters) != -1)
                    {
                        sb.Append("['");
                        sb.Append(propertyName);
                        sb.Append("']");
                    }
                    else
                    {
                        sb.Append('.');
                        sb.Append(propertyName);
                    }
                }
            }
            static void AppendStackFrame(StringBuilder sb, ref ReadStackFrame frame)
            {
                string propertyName2 = GetPropertyName(ref frame);
                AppendPropertyName(sb, propertyName2);
                if (frame.JsonTypeInfo != null && frame.IsProcessingEnumerable() && frame.ReturnValue is IEnumerable enumerable2 && (frame.ObjectState == StackFrameObjectState.None || frame.ObjectState == StackFrameObjectState.CreatedObject || frame.ObjectState == StackFrameObjectState.ReadElements))
                {
                    sb.Append('[');
                    sb.Append(GetCount(enumerable2));
                    sb.Append(']');
                }
            }
            static int GetCount(IEnumerable enumerable)
            {
                if (enumerable is ICollection collection)
                {
                    return collection.Count;
                }
                int num = 0;
                IEnumerator enumerator = enumerable.GetEnumerator();
                while (enumerator.MoveNext())
                {
                    num++;
                }
                return num;
            }
            static string GetPropertyName(ref ReadStackFrame frame)
            {
                string result = null;
                byte[] array = frame.JsonPropertyName;
                if (array == null)
                {
                    if (frame.JsonPropertyNameAsString != null)
                    {
                        result = frame.JsonPropertyNameAsString;
                    }
                    else
                    {
                        array = frame.JsonPropertyInfo?.NameAsUtf8Bytes ?? frame.CtorArgumentState?.JsonParameterInfo?.NameAsUtf8Bytes;
                    }
                }
                if (array != null)
                {
                    result = JsonHelpers.Utf8GetString(array);
                }
                return result;
            }
        }

        public JsonTypeInfo GetTopJsonTypeInfoWithParameterizedConstructor()
        {
            for (int i = 0; i < _count - 1; i++)
            {
                if (_stack[i].JsonTypeInfo.Converter.ConstructorIsParameterized)
                {
                    return _stack[i].JsonTypeInfo;
                }
            }
            return Current.JsonTypeInfo;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void SetConstructorArgumentState()
        {
            if (!Current.JsonTypeInfo.Converter.ConstructorIsParameterized)
            {
                return;
            }
            if (Current.CtorArgumentStateIndex == 0)
            {
                if (_ctorArgStateCache == null)
                {
                    _ctorArgStateCache = new List<ArgumentState>();
                }
                ArgumentState argumentState = new ArgumentState();
                _ctorArgStateCache.Add(argumentState);
                ref int ctorArgumentStateIndex = ref Current.CtorArgumentStateIndex;
                ref ArgumentState ctorArgumentState = ref Current.CtorArgumentState;
                int count = _ctorArgStateCache.Count;
                ArgumentState argumentState2 = argumentState;
                ctorArgumentStateIndex = count;
                ctorArgumentState = argumentState2;
            }
            else
            {
                Current.CtorArgumentState = _ctorArgStateCache[Current.CtorArgumentStateIndex - 1];
            }
        }
    }

    [StructLayout(LayoutKind.Auto)]
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    internal struct ReadStackFrame
    {
        public JsonPropertyInfo JsonPropertyInfo;

        public StackFramePropertyState PropertyState;

        public bool UseExtensionProperty;

        public byte[] JsonPropertyName;

        public string JsonPropertyNameAsString;

        public object DictionaryKey;

        public object ReturnValue;

        public JsonTypeInfo JsonTypeInfo;

        public StackFrameObjectState ObjectState;

        public bool CanContainMetadata;

        public MetadataPropertyName LatestMetadataPropertyName;

        public MetadataPropertyName MetadataPropertyNames;

        public PolymorphicSerializationState PolymorphicSerializationState;

        public JsonTypeInfo PolymorphicJsonTypeInfo;
        public int PropertyIndex;

        public List<PropertyRef> PropertyRefCache;

        public int CtorArgumentStateIndex;

        public ArgumentState CtorArgumentState;

        public JsonNumberHandling? NumberHandling;

        public BitArray RequiredPropertiesSet;

        public JsonTypeInfo BaseJsonTypeInfo
        {
            get
            {
                if (PolymorphicSerializationState != PolymorphicSerializationState.PolymorphicReEntryStarted)
                {
                    return JsonTypeInfo;
                }
                return PolymorphicJsonTypeInfo;
            }
        }

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private string DebuggerDisplay => $"ConverterStrategy.{JsonTypeInfo?.PropertyInfoForTypeInfo.ConverterStrategy}, {JsonTypeInfo?.Type.Name}";

        public void EndConstructorParameter()
        {
            CtorArgumentState.JsonParameterInfo = null;
            JsonPropertyName = null;
            PropertyState = StackFramePropertyState.None;
        }

        public void EndProperty()
        {
            JsonPropertyInfo = null;
            JsonPropertyName = null;
            JsonPropertyNameAsString = null;
            PropertyState = StackFramePropertyState.None;
        }

        public void EndElement()
        {
            JsonPropertyNameAsString = null;
            PropertyState = StackFramePropertyState.None;
        }

        /// <summary>
        /// Is the current object a Dictionary.
        /// </summary>
        public bool IsProcessingDictionary()
        {
            return (JsonTypeInfo.PropertyInfoForTypeInfo.ConverterStrategy & ConverterStrategy.Dictionary) != 0;
        }

        /// <summary>
        /// Is the current object an Enumerable.
        /// </summary>
        public bool IsProcessingEnumerable()
        {
            return (JsonTypeInfo.PropertyInfoForTypeInfo.ConverterStrategy & ConverterStrategy.Enumerable) != 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void MarkRequiredPropertyAsRead(JsonPropertyInfo propertyInfo)
        {
            if (propertyInfo.IsRequired)
            {
                RequiredPropertiesSet[propertyInfo.RequiredPropertyIndex] = true;
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void InitializeRequiredPropertiesValidationState(JsonTypeInfo typeInfo)
        {
            if (typeInfo.NumberOfRequiredProperties > 0)
            {
                RequiredPropertiesSet = new BitArray(typeInfo.NumberOfRequiredProperties);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal void ValidateAllRequiredPropertiesAreRead(JsonTypeInfo typeInfo)
        {
            if (typeInfo.NumberOfRequiredProperties > 0 && !RequiredPropertiesSet.AllBitsEqual(value: true))
            {
                ThrowHelper.ThrowJsonException_JsonRequiredPropertyMissing(typeInfo, RequiredPropertiesSet);
            }
        }
    }

    /// <summary>
	/// The current state of an object or collection that supports continuation.
	/// The values are typically compared with the less-than operator so the ordering is important.
	/// </summary>
	internal enum StackFrameObjectState : byte
    {
        None,
        StartToken,
        ReadMetadata,
        ConstructorArguments,
        CreatedObject,
        ReadElements,
        EndToken,
        EndTokenValidation
    }

    /// <summary>
	/// The current state of a property that supports continuation.
	/// The values are typically compared with the less-than operator so the ordering is important.
	/// </summary>
	internal enum StackFramePropertyState : byte
    {
        None,
        ReadName,
        Name,
        ReadValue,
        ReadValueIsEnd,
        TryRead
    }

    internal static class ThrowHelper
    {
        public const string ExceptionSourceValueToRethrowAsJsonException = "System.Text.Json.Rethrowable";

        [MethodImpl(MethodImplOptions.NoInlining)]
        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowOutOfMemoryException_BufferMaximumSizeExceeded(uint capacity)
        {
            throw new OutOfMemoryException(System.SR.Format(MDCFR.Properties.Resources.BufferMaximumSizeExceeded, capacity));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentNullException(string parameterName)
        {
            throw new ArgumentNullException(parameterName);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentOutOfRangeException_MaxDepthMustBePositive(string parameterName)
        {
            throw GetArgumentOutOfRangeException(parameterName, MDCFR.Properties.Resources.MaxDepthMustBePositive);
        }

        private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(string parameterName, string message)
        {
            return new ArgumentOutOfRangeException(parameterName, message);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentOutOfRangeException_CommentEnumMustBeInRange(string parameterName)
        {
            throw GetArgumentOutOfRangeException(parameterName, MDCFR.Properties.Resources.CommentHandlingMustBeValid);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentOutOfRangeException_ArrayIndexNegative(string paramName)
        {
            throw new ArgumentOutOfRangeException(paramName, MDCFR.Properties.Resources.ArrayIndexNegative);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException_ArrayTooSmall(string paramName)
        {
            throw new ArgumentException(MDCFR.Properties.Resources.ArrayTooSmall, paramName);
        }

        private static ArgumentException GetArgumentException(string message)
        {
            return new ArgumentException(message);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException(string message)
        {
            throw GetArgumentException(message);
        }

        public static InvalidOperationException GetInvalidOperationException_CallFlushFirst(int _buffered)
        {
            return GetInvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.CallFlushToAvoidDataLoss, _buffered));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException_DestinationTooShort()
        {
            throw GetArgumentException(MDCFR.Properties.Resources.DestinationTooShort);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException_PropertyNameTooLarge(int tokenLength)
        {
            throw GetArgumentException(System.SR.Format(MDCFR.Properties.Resources.PropertyNameTooLarge, tokenLength));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException_ValueTooLarge(int tokenLength)
        {
            throw GetArgumentException(System.SR.Format(MDCFR.Properties.Resources.ValueTooLarge, tokenLength));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException_ValueNotSupported()
        {
            throw GetArgumentException(MDCFR.Properties.Resources.SpecialNumberValuesNotSupported);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_NeedLargerSpan()
        {
            throw GetInvalidOperationException(MDCFR.Properties.Resources.FailedToGetLargerSpan);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException(ReadOnlySpan<byte> propertyName, ReadOnlySpan<byte> value)
        {
            if (propertyName.Length > 166666666)
            {
                ThrowArgumentException(System.SR.Format(MDCFR.Properties.Resources.PropertyNameTooLarge, propertyName.Length));
            }
            else
            {
                ThrowArgumentException(System.SR.Format(MDCFR.Properties.Resources.ValueTooLarge, value.Length));
            }
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException(ReadOnlySpan<byte> propertyName, ReadOnlySpan<char> value)
        {
            if (propertyName.Length > 166666666)
            {
                ThrowArgumentException(System.SR.Format(MDCFR.Properties.Resources.PropertyNameTooLarge, propertyName.Length));
            }
            else
            {
                ThrowArgumentException(System.SR.Format(MDCFR.Properties.Resources.ValueTooLarge, value.Length));
            }
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> value)
        {
            if (propertyName.Length > 166666666)
            {
                ThrowArgumentException(System.SR.Format(MDCFR.Properties.Resources.PropertyNameTooLarge, propertyName.Length));
            }
            else
            {
                ThrowArgumentException(System.SR.Format(MDCFR.Properties.Resources.ValueTooLarge, value.Length));
            }
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException(ReadOnlySpan<char> propertyName, ReadOnlySpan<char> value)
        {
            if (propertyName.Length > 166666666)
            {
                ThrowArgumentException(System.SR.Format(MDCFR.Properties.Resources.PropertyNameTooLarge, propertyName.Length));
            }
            else
            {
                ThrowArgumentException(System.SR.Format(MDCFR.Properties.Resources.ValueTooLarge, value.Length));
            }
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationOrArgumentException(ReadOnlySpan<byte> propertyName, int currentDepth, int maxDepth)
        {
            currentDepth &= 0x7FFFFFFF;
            if (currentDepth >= maxDepth)
            {
                ThrowInvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.DepthTooLarge, currentDepth, maxDepth));
            }
            else
            {
                ThrowArgumentException(System.SR.Format(MDCFR.Properties.Resources.PropertyNameTooLarge, propertyName.Length));
            }
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException(int currentDepth, int maxDepth)
        {
            currentDepth &= 0x7FFFFFFF;
            ThrowInvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.DepthTooLarge, currentDepth, maxDepth));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException(string message)
        {
            throw GetInvalidOperationException(message);
        }

        private static InvalidOperationException GetInvalidOperationException(string message)
        {
            return new InvalidOperationException(message)
            {
                Source = "System.Text.Json.Rethrowable"
            };
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_DepthNonZeroOrEmptyJson(int currentDepth)
        {
            throw GetInvalidOperationException(currentDepth);
        }

        private static InvalidOperationException GetInvalidOperationException(int currentDepth)
        {
            currentDepth &= 0x7FFFFFFF;
            if (currentDepth != 0)
            {
                return GetInvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.ZeroDepthAtEnd, currentDepth));
            }
            return GetInvalidOperationException(MDCFR.Properties.Resources.EmptyJsonIsInvalid);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationOrArgumentException(ReadOnlySpan<char> propertyName, int currentDepth, int maxDepth)
        {
            currentDepth &= 0x7FFFFFFF;
            if (currentDepth >= maxDepth)
            {
                ThrowInvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.DepthTooLarge, currentDepth, maxDepth));
            }
            else
            {
                ThrowArgumentException(System.SR.Format(MDCFR.Properties.Resources.PropertyNameTooLarge, propertyName.Length));
            }
        }

        public static InvalidOperationException GetInvalidOperationException_ExpectedArray(JsonTokenType tokenType)
        {
            return GetInvalidOperationException("array", tokenType);
        }

        public static InvalidOperationException GetInvalidOperationException_ExpectedObject(JsonTokenType tokenType)
        {
            return GetInvalidOperationException("object", tokenType);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_ExpectedNumber(JsonTokenType tokenType)
        {
            throw GetInvalidOperationException("number", tokenType);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_ExpectedBoolean(JsonTokenType tokenType)
        {
            throw GetInvalidOperationException("boolean", tokenType);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_ExpectedString(JsonTokenType tokenType)
        {
            throw GetInvalidOperationException("string", tokenType);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_ExpectedStringComparison(JsonTokenType tokenType)
        {
            throw GetInvalidOperationException(tokenType);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_ExpectedComment(JsonTokenType tokenType)
        {
            throw GetInvalidOperationException("comment", tokenType);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_CannotSkipOnPartial()
        {
            throw GetInvalidOperationException(MDCFR.Properties.Resources.CannotSkip);
        }

        private static InvalidOperationException GetInvalidOperationException(string message, JsonTokenType tokenType)
        {
            return GetInvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.InvalidCast, tokenType, message));
        }

        private static InvalidOperationException GetInvalidOperationException(JsonTokenType tokenType)
        {
            return GetInvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.InvalidComparison, tokenType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        internal static void ThrowJsonElementWrongTypeException(JsonTokenType expectedType, JsonTokenType actualType)
        {
            throw GetJsonElementWrongTypeException(expectedType.ToValueKind(), actualType.ToValueKind());
        }

        internal static InvalidOperationException GetJsonElementWrongTypeException(JsonValueKind expectedType, JsonValueKind actualType)
        {
            return GetInvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.JsonElementHasWrongType, expectedType, actualType));
        }

        internal static InvalidOperationException GetJsonElementWrongTypeException(string expectedTypeName, JsonValueKind actualType)
        {
            return GetInvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.JsonElementHasWrongType, expectedTypeName, actualType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonReaderException(ref Utf8JsonReader json, ExceptionResource resource, byte nextByte = 0, ReadOnlySpan<byte> bytes = default(ReadOnlySpan<byte>))
        {
            throw GetJsonReaderException(ref json, resource, nextByte, bytes);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static JsonException GetJsonReaderException(ref Utf8JsonReader json, ExceptionResource resource, byte nextByte, ReadOnlySpan<byte> bytes)
        {
            string resourceString = GetResourceString(ref json, resource, nextByte, JsonHelpers.Utf8GetString(bytes));
            long lineNumber = json.CurrentState._lineNumber;
            long bytePositionInLine = json.CurrentState._bytePositionInLine;
            resourceString += $" LineNumber: {lineNumber} | BytePositionInLine: {bytePositionInLine}.";
            return new JsonReaderException(resourceString, lineNumber, bytePositionInLine);
        }

        private static bool IsPrintable(byte value)
        {
            if (value >= 32)
            {
                return value < 127;
            }
            return false;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static string GetPrintableString(byte value)
        {
            if (!IsPrintable(value))
            {
                return $"0x{value:X2}";
            }
            char c = (char)value;
            return c.ToString();
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private static string GetResourceString(ref Utf8JsonReader json, ExceptionResource resource, byte nextByte, string characters)
        {
            string printableString = GetPrintableString(nextByte);
            string result = "";
            switch (resource)
            {
                case ExceptionResource.ArrayDepthTooLarge:
                    result = System.SR.Format(MDCFR.Properties.Resources.ArrayDepthTooLarge, json.CurrentState.Options.MaxDepth);
                    break;
                case ExceptionResource.MismatchedObjectArray:
                    result = System.SR.Format(MDCFR.Properties.Resources.MismatchedObjectArray, printableString);
                    break;
                case ExceptionResource.TrailingCommaNotAllowedBeforeArrayEnd:
                    result = MDCFR.Properties.Resources.TrailingCommaNotAllowedBeforeArrayEnd;
                    break;
                case ExceptionResource.TrailingCommaNotAllowedBeforeObjectEnd:
                    result = MDCFR.Properties.Resources.TrailingCommaNotAllowedBeforeObjectEnd;
                    break;
                case ExceptionResource.EndOfStringNotFound:
                    result = MDCFR.Properties.Resources.EndOfStringNotFound;
                    break;
                case ExceptionResource.RequiredDigitNotFoundAfterSign:
                    result = System.SR.Format(MDCFR.Properties.Resources.RequiredDigitNotFoundAfterSign, printableString);
                    break;
                case ExceptionResource.RequiredDigitNotFoundAfterDecimal:
                    result = System.SR.Format(MDCFR.Properties.Resources.RequiredDigitNotFoundAfterDecimal, printableString);
                    break;
                case ExceptionResource.RequiredDigitNotFoundEndOfData:
                    result = MDCFR.Properties.Resources.RequiredDigitNotFoundEndOfData;
                    break;
                case ExceptionResource.ExpectedEndAfterSingleJson:
                    result = System.SR.Format(MDCFR.Properties.Resources.ExpectedEndAfterSingleJson, printableString);
                    break;
                case ExceptionResource.ExpectedEndOfDigitNotFound:
                    result = System.SR.Format(MDCFR.Properties.Resources.ExpectedEndOfDigitNotFound, printableString);
                    break;
                case ExceptionResource.ExpectedNextDigitEValueNotFound:
                    result = System.SR.Format(MDCFR.Properties.Resources.ExpectedNextDigitEValueNotFound, printableString);
                    break;
                case ExceptionResource.ExpectedSeparatorAfterPropertyNameNotFound:
                    result = System.SR.Format(MDCFR.Properties.Resources.ExpectedSeparatorAfterPropertyNameNotFound, printableString);
                    break;
                case ExceptionResource.ExpectedStartOfPropertyNotFound:
                    result = System.SR.Format(MDCFR.Properties.Resources.ExpectedStartOfPropertyNotFound, printableString);
                    break;
                case ExceptionResource.ExpectedStartOfPropertyOrValueNotFound:
                    result = MDCFR.Properties.Resources.ExpectedStartOfPropertyOrValueNotFound;
                    break;
                case ExceptionResource.ExpectedStartOfPropertyOrValueAfterComment:
                    result = System.SR.Format(MDCFR.Properties.Resources.ExpectedStartOfPropertyOrValueAfterComment, printableString);
                    break;
                case ExceptionResource.ExpectedStartOfValueNotFound:
                    result = System.SR.Format(MDCFR.Properties.Resources.ExpectedStartOfValueNotFound, printableString);
                    break;
                case ExceptionResource.ExpectedValueAfterPropertyNameNotFound:
                    result = MDCFR.Properties.Resources.ExpectedValueAfterPropertyNameNotFound;
                    break;
                case ExceptionResource.FoundInvalidCharacter:
                    result = System.SR.Format(MDCFR.Properties.Resources.FoundInvalidCharacter, printableString);
                    break;
                case ExceptionResource.InvalidEndOfJsonNonPrimitive:
                    result = System.SR.Format(MDCFR.Properties.Resources.InvalidEndOfJsonNonPrimitive, json.TokenType);
                    break;
                case ExceptionResource.ObjectDepthTooLarge:
                    result = System.SR.Format(MDCFR.Properties.Resources.ObjectDepthTooLarge, json.CurrentState.Options.MaxDepth);
                    break;
                case ExceptionResource.ExpectedFalse:
                    result = System.SR.Format(MDCFR.Properties.Resources.ExpectedFalse, characters);
                    break;
                case ExceptionResource.ExpectedNull:
                    result = System.SR.Format(MDCFR.Properties.Resources.ExpectedNull, characters);
                    break;
                case ExceptionResource.ExpectedTrue:
                    result = System.SR.Format(MDCFR.Properties.Resources.ExpectedTrue, characters);
                    break;
                case ExceptionResource.InvalidCharacterWithinString:
                    result = System.SR.Format(MDCFR.Properties.Resources.InvalidCharacterWithinString, printableString);
                    break;
                case ExceptionResource.InvalidCharacterAfterEscapeWithinString:
                    result = System.SR.Format(MDCFR.Properties.Resources.InvalidCharacterAfterEscapeWithinString, printableString);
                    break;
                case ExceptionResource.InvalidHexCharacterWithinString:
                    result = System.SR.Format(MDCFR.Properties.Resources.InvalidHexCharacterWithinString, printableString);
                    break;
                case ExceptionResource.EndOfCommentNotFound:
                    result = MDCFR.Properties.Resources.EndOfCommentNotFound;
                    break;
                case ExceptionResource.ZeroDepthAtEnd:
                    result = System.SR.Format(MDCFR.Properties.Resources.ZeroDepthAtEnd);
                    break;
                case ExceptionResource.ExpectedJsonTokens:
                    result = MDCFR.Properties.Resources.ExpectedJsonTokens;
                    break;
                case ExceptionResource.NotEnoughData:
                    result = MDCFR.Properties.Resources.NotEnoughData;
                    break;
                case ExceptionResource.ExpectedOneCompleteToken:
                    result = MDCFR.Properties.Resources.ExpectedOneCompleteToken;
                    break;
                case ExceptionResource.InvalidCharacterAtStartOfComment:
                    result = System.SR.Format(MDCFR.Properties.Resources.InvalidCharacterAtStartOfComment, printableString);
                    break;
                case ExceptionResource.UnexpectedEndOfDataWhileReadingComment:
                    result = System.SR.Format(MDCFR.Properties.Resources.UnexpectedEndOfDataWhileReadingComment);
                    break;
                case ExceptionResource.UnexpectedEndOfLineSeparator:
                    result = System.SR.Format(MDCFR.Properties.Resources.UnexpectedEndOfLineSeparator);
                    break;
                case ExceptionResource.InvalidLeadingZeroInNumber:
                    result = System.SR.Format(MDCFR.Properties.Resources.InvalidLeadingZeroInNumber, printableString);
                    break;
            }
            return result;
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException(ExceptionResource resource, int currentDepth, int maxDepth, byte token, JsonTokenType tokenType)
        {
            throw GetInvalidOperationException(resource, currentDepth, maxDepth, token, tokenType);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException_InvalidCommentValue()
        {
            throw new ArgumentException(MDCFR.Properties.Resources.CannotWriteCommentWithEmbeddedDelimiter);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException_InvalidUTF8(ReadOnlySpan<byte> value)
        {
            StringBuilder stringBuilder = new StringBuilder();
            int num = Math.Min(value.Length, 10);
            for (int i = 0; i < num; i++)
            {
                byte b = value[i];
                if (IsPrintable(b))
                {
                    stringBuilder.Append((char)b);
                }
                else
                {
                    stringBuilder.Append($"0x{b:X2}");
                }
            }
            if (num < value.Length)
            {
                stringBuilder.Append("...");
            }
            throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.CannotEncodeInvalidUTF8, stringBuilder));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException_InvalidUTF16(int charAsInt)
        {
            throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.CannotEncodeInvalidUTF16, $"0x{charAsInt:X2}"));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_ReadInvalidUTF16(int charAsInt)
        {
            throw GetInvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.CannotReadInvalidUTF16, $"0x{charAsInt:X2}"));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_ReadIncompleteUTF16()
        {
            throw GetInvalidOperationException(MDCFR.Properties.Resources.CannotReadIncompleteUTF16);
        }

        public static InvalidOperationException GetInvalidOperationException_ReadInvalidUTF8(DecoderFallbackException innerException)
        {
            return GetInvalidOperationException(MDCFR.Properties.Resources.CannotTranscodeInvalidUtf8, innerException);
        }

        public static ArgumentException GetArgumentException_ReadInvalidUTF16(EncoderFallbackException innerException)
        {
            return new ArgumentException(MDCFR.Properties.Resources.CannotTranscodeInvalidUtf16, innerException);
        }

        public static InvalidOperationException GetInvalidOperationException(string message, Exception innerException)
        {
            InvalidOperationException ex = new InvalidOperationException(message, innerException);
            ex.Source = "System.Text.Json.Rethrowable";
            return ex;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        public static InvalidOperationException GetInvalidOperationException(ExceptionResource resource, int currentDepth, int maxDepth, byte token, JsonTokenType tokenType)
        {
            string resourceString = GetResourceString(resource, currentDepth, maxDepth, token, tokenType);
            InvalidOperationException invalidOperationException = GetInvalidOperationException(resourceString);
            invalidOperationException.Source = "System.Text.Json.Rethrowable";
            return invalidOperationException;
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowOutOfMemoryException(uint capacity)
        {
            throw new OutOfMemoryException(System.SR.Format(MDCFR.Properties.Resources.BufferMaximumSizeExceeded, capacity));
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private static string GetResourceString(ExceptionResource resource, int currentDepth, int maxDepth, byte token, JsonTokenType tokenType)
        {
            string result = "";
            switch (resource)
            {
                case ExceptionResource.MismatchedObjectArray:
                    result = ((tokenType == JsonTokenType.PropertyName) ? System.SR.Format(MDCFR.Properties.Resources.CannotWriteEndAfterProperty, (char)token) : System.SR.Format(MDCFR.Properties.Resources.MismatchedObjectArray, (char)token));
                    break;
                case ExceptionResource.DepthTooLarge:
                    result = System.SR.Format(MDCFR.Properties.Resources.DepthTooLarge, currentDepth & 0x7FFFFFFF, maxDepth);
                    break;
                case ExceptionResource.CannotStartObjectArrayWithoutProperty:
                    result = System.SR.Format(MDCFR.Properties.Resources.CannotStartObjectArrayWithoutProperty, tokenType);
                    break;
                case ExceptionResource.CannotStartObjectArrayAfterPrimitiveOrClose:
                    result = System.SR.Format(MDCFR.Properties.Resources.CannotStartObjectArrayAfterPrimitiveOrClose, tokenType);
                    break;
                case ExceptionResource.CannotWriteValueWithinObject:
                    result = System.SR.Format(MDCFR.Properties.Resources.CannotWriteValueWithinObject, tokenType);
                    break;
                case ExceptionResource.CannotWritePropertyWithinArray:
                    result = ((tokenType == JsonTokenType.PropertyName) ? System.SR.Format(MDCFR.Properties.Resources.CannotWritePropertyAfterProperty) : System.SR.Format(MDCFR.Properties.Resources.CannotWritePropertyWithinArray, tokenType));
                    break;
                case ExceptionResource.CannotWriteValueAfterPrimitiveOrClose:
                    result = System.SR.Format(MDCFR.Properties.Resources.CannotWriteValueAfterPrimitiveOrClose, tokenType);
                    break;
            }
            return result;
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowFormatException()
        {
            throw new FormatException
            {
                Source = "System.Text.Json.Rethrowable"
            };
        }

        public static void ThrowFormatException(NumericType numericType)
        {
            string message = "";
            switch (numericType)
            {
                case NumericType.Byte:
                    message = MDCFR.Properties.Resources.FormatByte;
                    break;
                case NumericType.SByte:
                    message = MDCFR.Properties.Resources.FormatSByte;
                    break;
                case NumericType.Int16:
                    message = MDCFR.Properties.Resources.FormatInt16;
                    break;
                case NumericType.Int32:
                    message = MDCFR.Properties.Resources.FormatInt32;
                    break;
                case NumericType.Int64:
                    message = MDCFR.Properties.Resources.FormatInt64;
                    break;
                case NumericType.UInt16:
                    message = MDCFR.Properties.Resources.FormatUInt16;
                    break;
                case NumericType.UInt32:
                    message = MDCFR.Properties.Resources.FormatUInt32;
                    break;
                case NumericType.UInt64:
                    message = MDCFR.Properties.Resources.FormatUInt64;
                    break;
                case NumericType.Single:
                    message = MDCFR.Properties.Resources.FormatSingle;
                    break;
                case NumericType.Double:
                    message = MDCFR.Properties.Resources.FormatDouble;
                    break;
                case NumericType.Decimal:
                    message = MDCFR.Properties.Resources.FormatDecimal;
                    break;
            }
            throw new FormatException(message)
            {
                Source = "System.Text.Json.Rethrowable"
            };
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowFormatException(DataType dataType)
        {
            string message = "";
            switch (dataType)
            {
                case DataType.Boolean:
                case DataType.DateOnly:
                case DataType.DateTime:
                case DataType.DateTimeOffset:
                case DataType.TimeOnly:
                case DataType.TimeSpan:
                case DataType.Guid:
                case DataType.Version:
                    message = System.SR.Format(MDCFR.Properties.Resources.UnsupportedFormat, dataType);
                    break;
                case DataType.Base64String:
                    message = MDCFR.Properties.Resources.CannotDecodeInvalidBase64;
                    break;
            }
            throw new FormatException(message)
            {
                Source = "System.Text.Json.Rethrowable"
            };
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_ExpectedChar(JsonTokenType tokenType)
        {
            throw GetInvalidOperationException("char", tokenType);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowObjectDisposedException_Utf8JsonWriter()
        {
            throw new ObjectDisposedException("Utf8JsonWriter");
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowObjectDisposedException_JsonDocument()
        {
            throw new ObjectDisposedException("JsonDocument");
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException_NodeValueNotAllowed(string paramName)
        {
            throw new ArgumentException(MDCFR.Properties.Resources.NodeValueNotAllowed, paramName);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException_DuplicateKey(string paramName, string propertyName)
        {
            throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.NodeDuplicateKey, propertyName), paramName);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_NodeAlreadyHasParent()
        {
            throw new InvalidOperationException(MDCFR.Properties.Resources.NodeAlreadyHasParent);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_NodeCycleDetected()
        {
            throw new InvalidOperationException(MDCFR.Properties.Resources.NodeCycleDetected);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_NodeElementCannotBeObjectOrArray()
        {
            throw new InvalidOperationException(MDCFR.Properties.Resources.NodeElementCannotBeObjectOrArray);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowNotSupportedException_CollectionIsReadOnly()
        {
            throw GetNotSupportedException_CollectionIsReadOnly();
        }

        public static NotSupportedException GetNotSupportedException_CollectionIsReadOnly()
        {
            return new NotSupportedException(MDCFR.Properties.Resources.CollectionIsReadOnly);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException_DeserializeWrongType(Type type, object value)
        {
            throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.DeserializeWrongType, type, value.GetType()));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException_SerializerDoesNotSupportComments(string paramName)
        {
            throw new ArgumentException(MDCFR.Properties.Resources.JsonSerializerDoesNotSupportComments, paramName);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowNotSupportedException_SerializationNotSupported(Type propertyType)
        {
            throw new NotSupportedException(System.SR.Format(MDCFR.Properties.Resources.SerializationNotSupportedType, propertyType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowNotSupportedException_TypeRequiresAsyncSerialization(Type propertyType)
        {
            throw new NotSupportedException(System.SR.Format(MDCFR.Properties.Resources.TypeRequiresAsyncSerialization, propertyType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowNotSupportedException_ConstructorMaxOf64Parameters(Type type)
        {
            throw new NotSupportedException(System.SR.Format(MDCFR.Properties.Resources.ConstructorMaxOf64Parameters, type));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowNotSupportedException_DictionaryKeyTypeNotSupported(Type keyType, JsonConverter converter)
        {
            throw new NotSupportedException(System.SR.Format(MDCFR.Properties.Resources.DictionaryKeyTypeNotSupported, keyType, converter.GetType()));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_DeserializeUnableToConvertValue(Type propertyType)
        {
            throw new JsonException(System.SR.Format(MDCFR.Properties.Resources.DeserializeUnableToConvertValue, propertyType))
            {
                AppendPathInformation = true
            };
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidCastException_DeserializeUnableToAssignValue(Type typeOfValue, Type declaredType)
        {
            throw new InvalidCastException(System.SR.Format(MDCFR.Properties.Resources.DeserializeUnableToAssignValue, typeOfValue, declaredType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_DeserializeUnableToAssignNull(Type declaredType)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.DeserializeUnableToAssignNull, declaredType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_SerializationConverterRead(JsonConverter converter)
        {
            throw new JsonException(System.SR.Format(MDCFR.Properties.Resources.SerializationConverterRead, converter))
            {
                AppendPathInformation = true
            };
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_SerializationConverterWrite(JsonConverter converter)
        {
            throw new JsonException(System.SR.Format(MDCFR.Properties.Resources.SerializationConverterWrite, converter))
            {
                AppendPathInformation = true
            };
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_SerializerCycleDetected(int maxDepth)
        {
            throw new JsonException(System.SR.Format(MDCFR.Properties.Resources.SerializerCycleDetected, maxDepth))
            {
                AppendPathInformation = true
            };
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException(string message = null)
        {
            throw new JsonException(message)
            {
                AppendPathInformation = true
            };
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException_CannotSerializeInvalidType(string paramName, Type typeToConvert, Type declaringType, string propertyName)
        {
            if (declaringType == null)
            {
                throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.CannotSerializeInvalidType, typeToConvert), paramName);
            }
            throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.CannotSerializeInvalidMember, typeToConvert, propertyName, declaringType), paramName);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_CannotSerializeInvalidType(Type typeToConvert, Type declaringType, MemberInfo memberInfo)
        {
            if (declaringType == null)
            {
                throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.CannotSerializeInvalidType, typeToConvert));
            }
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.CannotSerializeInvalidMember, typeToConvert, memberInfo.Name, declaringType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_SerializationConverterNotCompatible(Type converterType, Type type)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.SerializationConverterNotCompatible, converterType, type));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_ResolverTypeNotCompatible(Type requestedType, Type actualType)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.ResolverTypeNotCompatible, actualType, requestedType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_ResolverTypeInfoOptionsNotCompatible()
        {
            throw new InvalidOperationException(MDCFR.Properties.Resources.ResolverTypeInfoOptionsNotCompatible);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_JsonTypeInfoUsedButTypeInfoResolverNotSet()
        {
            throw new InvalidOperationException(MDCFR.Properties.Resources.JsonTypeInfoUsedButTypeInfoResolverNotSet);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_SerializationConverterOnAttributeInvalid(Type classType, MemberInfo memberInfo)
        {
            string text = classType.ToString();
            if (memberInfo != null)
            {
                text = text + "." + memberInfo.Name;
            }
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.SerializationConverterOnAttributeInvalid, text));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_SerializationConverterOnAttributeNotCompatible(Type classTypeAttributeIsOn, MemberInfo memberInfo, Type typeToConvert)
        {
            string text = classTypeAttributeIsOn.ToString();
            if (memberInfo != null)
            {
                text = text + "." + memberInfo.Name;
            }
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.SerializationConverterOnAttributeNotCompatible, text, typeToConvert));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_SerializerOptionsImmutable(JsonSerializerContext context)
        {
            string message = ((context == null) ? MDCFR.Properties.Resources.SerializerOptionsImmutable : MDCFR.Properties.Resources.SerializerContextOptionsImmutable);
            throw new InvalidOperationException(message);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_TypeInfoResolverImmutable()
        {
            throw new InvalidOperationException(MDCFR.Properties.Resources.TypeInfoResolverImmutable);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_TypeInfoImmutable()
        {
            throw new InvalidOperationException(MDCFR.Properties.Resources.TypeInfoImmutable);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_PropertyInfoImmutable()
        {
            throw new InvalidOperationException(MDCFR.Properties.Resources.PropertyInfoImmutable);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_SerializerPropertyNameConflict(Type type, string propertyName)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.SerializerPropertyNameConflict, type, propertyName));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_SerializerPropertyNameNull(JsonPropertyInfo jsonPropertyInfo)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.SerializerPropertyNameNull, jsonPropertyInfo.DeclaringType, jsonPropertyInfo.MemberName));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_JsonPropertyRequiredAndNotDeserializable(JsonPropertyInfo jsonPropertyInfo)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.JsonPropertyRequiredAndNotDeserializable, jsonPropertyInfo.Name, jsonPropertyInfo.DeclaringType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_JsonPropertyRequiredAndExtensionData(JsonPropertyInfo jsonPropertyInfo)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.JsonPropertyRequiredAndExtensionData, jsonPropertyInfo.Name, jsonPropertyInfo.DeclaringType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_JsonRequiredPropertyMissing(JsonTypeInfo parent, BitArray requiredPropertiesSet)
        {
            StringBuilder stringBuilder = new StringBuilder();
            bool flag = true;
            for (int i = 0; i < parent.PropertyCache.List.Count; i++)
            {
                JsonPropertyInfo value = parent.PropertyCache.List[i].Value;
                if (value.IsRequired && !requiredPropertiesSet[value.RequiredPropertyIndex])
                {
                    if (!flag)
                    {
                        stringBuilder.Append(CultureInfo.CurrentUICulture.TextInfo.ListSeparator);
                        stringBuilder.Append(' ');
                    }
                    stringBuilder.Append(value.Name);
                    flag = false;
                    if (stringBuilder.Length >= 50)
                    {
                        break;
                    }
                }
            }
            throw new JsonException(System.SR.Format(MDCFR.Properties.Resources.JsonRequiredPropertiesMissing, parent.Type, stringBuilder.ToString()));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_NamingPolicyReturnNull(JsonNamingPolicy namingPolicy)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.NamingPolicyReturnNull, namingPolicy));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_SerializerConverterFactoryReturnsNull(Type converterType)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.SerializerConverterFactoryReturnsNull, converterType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_SerializerConverterFactoryReturnsJsonConverterFactorty(Type converterType)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.SerializerConverterFactoryReturnsJsonConverterFactory, converterType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_MultiplePropertiesBindToConstructorParameters(Type parentType, string parameterName, string firstMatchName, string secondMatchName)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.MultipleMembersBindWithConstructorParameter, firstMatchName, secondMatchName, parentType, parameterName));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_ConstructorParameterIncompleteBinding(Type parentType)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.ConstructorParamIncompleteBinding, parentType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_ExtensionDataCannotBindToCtorParam(string propertyName, JsonPropertyInfo jsonPropertyInfo)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.ExtensionDataCannotBindToCtorParam, propertyName, jsonPropertyInfo.DeclaringType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_JsonIncludeOnNonPublicInvalid(string memberName, Type declaringType)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.JsonIncludeOnNonPublicInvalid, memberName, declaringType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_IgnoreConditionOnValueTypeInvalid(string clrPropertyName, Type propertyDeclaringType)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.IgnoreConditionOnValueTypeInvalid, clrPropertyName, propertyDeclaringType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_NumberHandlingOnPropertyInvalid(JsonPropertyInfo jsonPropertyInfo)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.NumberHandlingOnPropertyInvalid, jsonPropertyInfo.MemberName, jsonPropertyInfo.DeclaringType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_ConverterCanConvertMultipleTypes(Type runtimePropertyType, JsonConverter jsonConverter)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.ConverterCanConvertMultipleTypes, jsonConverter.GetType(), jsonConverter.TypeToConvert, runtimePropertyType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowNotSupportedException_ObjectWithParameterizedCtorRefMetadataNotSupported(ReadOnlySpan<byte> propertyName, ref Utf8JsonReader reader, scoped ref ReadStack state)
        {
            JsonTypeInfo topJsonTypeInfoWithParameterizedConstructor = state.GetTopJsonTypeInfoWithParameterizedConstructor();
            state.Current.JsonPropertyName = propertyName.ToArray();
            NotSupportedException ex = new NotSupportedException(System.SR.Format(MDCFR.Properties.Resources.ObjectWithParameterizedCtorRefMetadataNotSupported, topJsonTypeInfoWithParameterizedConstructor.Type));
            ThrowNotSupportedException(ref state, in reader, ex);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(JsonTypeInfoKind kind)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.InvalidJsonTypeInfoOperationForKind, kind));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_CreateObjectConverterNotCompatible(Type type)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.CreateObjectConverterNotCompatible, type));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ReThrowWithPath(scoped ref ReadStack state, JsonReaderException ex)
        {
            string text = state.JsonPath();
            string message = ex.Message;
            int num = message.LastIndexOf(" LineNumber: ", StringComparison.InvariantCulture);
            message = ((num < 0) ? (message + " Path: " + text + ".") : (message.Substring(0, num) + " Path: " + text + " |" + message.Substring(num)));
            throw new JsonException(message, text, ex.LineNumber, ex.BytePositionInLine, ex);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ReThrowWithPath(scoped ref ReadStack state, in Utf8JsonReader reader, Exception ex)
        {
            JsonException ex2 = new JsonException(null, ex);
            AddJsonExceptionInformation(ref state, in reader, ex2);
            throw ex2;
        }

        public static void AddJsonExceptionInformation(scoped ref ReadStack state, in Utf8JsonReader reader, JsonException ex)
        {
            long lineNumber = reader.CurrentState._lineNumber;
            ex.LineNumber = lineNumber;
            long bytePositionInLine = reader.CurrentState._bytePositionInLine;
            ex.BytePositionInLine = bytePositionInLine;
            string arg = (ex.Path = state.JsonPath());
            string text2 = ex._message;
            if (string.IsNullOrEmpty(text2))
            {
                Type p = state.Current.JsonPropertyInfo?.PropertyType ?? state.Current.JsonTypeInfo.Type;
                text2 = System.SR.Format(MDCFR.Properties.Resources.DeserializeUnableToConvertValue, p);
                ex.AppendPathInformation = true;
            }
            if (ex.AppendPathInformation)
            {
                text2 += $" Path: {arg} | LineNumber: {lineNumber} | BytePositionInLine: {bytePositionInLine}.";
                ex.SetMessage(text2);
            }
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ReThrowWithPath(ref WriteStack state, Exception ex)
        {
            JsonException ex2 = new JsonException(null, ex);
            AddJsonExceptionInformation(ref state, ex2);
            throw ex2;
        }

        public static void AddJsonExceptionInformation(ref WriteStack state, JsonException ex)
        {
            string text2 = (ex.Path = state.PropertyPath());
            string text3 = ex._message;
            if (string.IsNullOrEmpty(text3))
            {
                text3 = System.SR.Format(MDCFR.Properties.Resources.SerializeUnableToSerialize);
                ex.AppendPathInformation = true;
            }
            if (ex.AppendPathInformation)
            {
                text3 = text3 + " Path: " + text2 + ".";
                ex.SetMessage(text3);
            }
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_SerializationDuplicateAttribute(Type attribute, MemberInfo memberInfo)
        {
            string p = ((memberInfo is Type type) ? type.ToString() : $"{memberInfo.DeclaringType}.{memberInfo.Name}");
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.SerializationDuplicateAttribute, attribute, p));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_SerializationDuplicateTypeAttribute(Type classType, Type attribute)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.SerializationDuplicateTypeAttribute, classType, attribute));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_SerializationDuplicateTypeAttribute<TAttribute>(Type classType)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.SerializationDuplicateTypeAttribute, classType, typeof(TAttribute)));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_SerializationDataExtensionPropertyInvalid(JsonPropertyInfo jsonPropertyInfo)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.SerializationDataExtensionPropertyInvalid, jsonPropertyInfo.PropertyType, jsonPropertyInfo.MemberName));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_NodeJsonObjectCustomConverterNotAllowedOnExtensionProperty()
        {
            throw new InvalidOperationException(MDCFR.Properties.Resources.NodeJsonObjectCustomConverterNotAllowedOnExtensionProperty);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowNotSupportedException(scoped ref ReadStack state, in Utf8JsonReader reader, NotSupportedException ex)
        {
            string text = ex.Message;
            Type type = state.Current.JsonPropertyInfo?.PropertyType ?? state.Current.JsonTypeInfo.Type;
            if (!text.Contains(type.ToString()))
            {
                if (text.Length > 0)
                {
                    text += " ";
                }
                text += System.SR.Format(MDCFR.Properties.Resources.SerializationNotSupportedParentType, type);
            }
            long lineNumber = reader.CurrentState._lineNumber;
            long bytePositionInLine = reader.CurrentState._bytePositionInLine;
            text += $" Path: {state.JsonPath()} | LineNumber: {lineNumber} | BytePositionInLine: {bytePositionInLine}.";
            throw new NotSupportedException(text, ex);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowNotSupportedException(ref WriteStack state, NotSupportedException ex)
        {
            string text = ex.Message;
            Type type = state.Current.JsonPropertyInfo?.PropertyType ?? state.Current.JsonTypeInfo.Type;
            if (!text.Contains(type.ToString()))
            {
                if (text.Length > 0)
                {
                    text += " ";
                }
                text += System.SR.Format(MDCFR.Properties.Resources.SerializationNotSupportedParentType, type);
            }
            text = text + " Path: " + state.PropertyPath() + ".";
            throw new NotSupportedException(text, ex);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowNotSupportedException_DeserializeNoConstructor(Type type, ref Utf8JsonReader reader, scoped ref ReadStack state)
        {
            string message = ((!type.IsInterface) ? System.SR.Format(MDCFR.Properties.Resources.DeserializeNoConstructor, "JsonConstructorAttribute", type) : System.SR.Format(MDCFR.Properties.Resources.DeserializePolymorphicInterface, type));
            ThrowNotSupportedException(ref state, in reader, new NotSupportedException(message));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowNotSupportedException_CannotPopulateCollection(Type type, ref Utf8JsonReader reader, scoped ref ReadStack state)
        {
            ThrowNotSupportedException(ref state, in reader, new NotSupportedException(System.SR.Format(MDCFR.Properties.Resources.CannotPopulateCollection, type)));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_MetadataValuesInvalidToken(JsonTokenType tokenType)
        {
            ThrowJsonException(System.SR.Format(MDCFR.Properties.Resources.MetadataInvalidTokenAfterValues, tokenType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_MetadataReferenceNotFound(string id)
        {
            ThrowJsonException(System.SR.Format(MDCFR.Properties.Resources.MetadataReferenceNotFound, id));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_MetadataValueWasNotString(JsonTokenType tokenType)
        {
            ThrowJsonException(System.SR.Format(MDCFR.Properties.Resources.MetadataValueWasNotString, tokenType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_MetadataValueWasNotString(JsonValueKind valueKind)
        {
            ThrowJsonException(System.SR.Format(MDCFR.Properties.Resources.MetadataValueWasNotString, valueKind));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties(ReadOnlySpan<byte> propertyName, scoped ref ReadStack state)
        {
            state.Current.JsonPropertyName = propertyName.ToArray();
            ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties();
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_MetadataUnexpectedProperty(ReadOnlySpan<byte> propertyName, scoped ref ReadStack state)
        {
            state.Current.JsonPropertyName = propertyName.ToArray();
            ThrowJsonException(System.SR.Format(MDCFR.Properties.Resources.MetadataUnexpectedProperty));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_MetadataReferenceObjectCannotContainOtherProperties()
        {
            ThrowJsonException(MDCFR.Properties.Resources.MetadataReferenceCannotContainOtherProperties);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_MetadataIdIsNotFirstProperty(ReadOnlySpan<byte> propertyName, scoped ref ReadStack state)
        {
            state.Current.JsonPropertyName = propertyName.ToArray();
            ThrowJsonException(MDCFR.Properties.Resources.MetadataIdIsNotFirstProperty);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_MetadataStandaloneValuesProperty(scoped ref ReadStack state, ReadOnlySpan<byte> propertyName)
        {
            state.Current.JsonPropertyName = propertyName.ToArray();
            ThrowJsonException(MDCFR.Properties.Resources.MetadataStandaloneValuesProperty);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_MetadataInvalidPropertyWithLeadingDollarSign(ReadOnlySpan<byte> propertyName, scoped ref ReadStack state, in Utf8JsonReader reader)
        {
            if (state.Current.IsProcessingDictionary())
            {
                state.Current.JsonPropertyNameAsString = reader.GetString();
            }
            else
            {
                state.Current.JsonPropertyName = propertyName.ToArray();
            }
            ThrowJsonException(MDCFR.Properties.Resources.MetadataInvalidPropertyWithLeadingDollarSign);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_MetadataDuplicateIdFound(string id)
        {
            ThrowJsonException(System.SR.Format(MDCFR.Properties.Resources.MetadataDuplicateIdFound, id));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_MetadataDuplicateTypeProperty()
        {
            ThrowJsonException(MDCFR.Properties.Resources.MetadataDuplicateTypeProperty);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_MetadataInvalidReferenceToValueType(Type propertyType)
        {
            ThrowJsonException(System.SR.Format(MDCFR.Properties.Resources.MetadataInvalidReferenceToValueType, propertyType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_MetadataInvalidPropertyInArrayMetadata(scoped ref ReadStack state, Type propertyType, in Utf8JsonReader reader)
        {
            ref ReadStackFrame current = ref state.Current;
            byte[] jsonPropertyName;
            if (!reader.HasValueSequence)
            {
                jsonPropertyName = reader.ValueSpan.ToArray();
            }
            else
            {
                ReadOnlySequence<byte> sequence = reader.ValueSequence;
                jsonPropertyName = BuffersExtensions.ToArray(in sequence);
            }
            current.JsonPropertyName = jsonPropertyName;
            string @string = reader.GetString();
            ThrowJsonException(System.SR.Format(MDCFR.Properties.Resources.MetadataPreservedArrayFailed, System.SR.Format(MDCFR.Properties.Resources.MetadataInvalidPropertyInArrayMetadata, @string), System.SR.Format(MDCFR.Properties.Resources.DeserializeUnableToConvertValue, propertyType)));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_MetadataPreservedArrayValuesNotFound(scoped ref ReadStack state, Type propertyType)
        {
            state.Current.JsonPropertyName = null;
            ThrowJsonException(System.SR.Format(MDCFR.Properties.Resources.MetadataPreservedArrayFailed, MDCFR.Properties.Resources.MetadataStandaloneValuesProperty, System.SR.Format(MDCFR.Properties.Resources.DeserializeUnableToConvertValue, propertyType)));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_MetadataCannotParsePreservedObjectIntoImmutable(Type propertyType)
        {
            ThrowJsonException(System.SR.Format(MDCFR.Properties.Resources.MetadataCannotParsePreservedObjectToImmutable, propertyType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_MetadataReferenceOfTypeCannotBeAssignedToType(string referenceId, Type currentType, Type typeToConvert)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.MetadataReferenceOfTypeCannotBeAssignedToType, referenceId, currentType, typeToConvert));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_JsonPropertyInfoIsBoundToDifferentJsonTypeInfo(JsonPropertyInfo propertyInfo)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.JsonPropertyInfoBoundToDifferentParent, propertyInfo.Name, propertyInfo.ParentTypeInfo.Type.FullName));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        internal static void ThrowUnexpectedMetadataException(scoped ReadOnlySpan<byte> propertyName, ref Utf8JsonReader reader, scoped ref ReadStack state)
        {
            if (JsonSerializer.GetMetadataPropertyName(propertyName, state.Current.BaseJsonTypeInfo.PolymorphicTypeResolver) != 0)
            {
                ThrowJsonException_MetadataUnexpectedProperty(propertyName, ref state);
            }
            else
            {
                ThrowJsonException_MetadataInvalidPropertyWithLeadingDollarSign(propertyName, ref state, in reader);
            }
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowNotSupportedException_NoMetadataForType(Type type, IJsonTypeInfoResolver resolver)
        {
            throw new NotSupportedException(System.SR.Format(MDCFR.Properties.Resources.NoMetadataForType, type, resolver?.GetType().FullName ?? "<null>"));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowNotSupportedException_ConstructorContainsNullParameterNames(Type declaringType)
        {
            throw new NotSupportedException(System.SR.Format(MDCFR.Properties.Resources.ConstructorContainsNullParameterNames, declaringType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_NoMetadataForType(Type type, IJsonTypeInfoResolver resolver)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.NoMetadataForType, type, resolver?.GetType().FullName ?? "<null>"));
        }

        public static Exception GetInvalidOperationException_NoMetadataForTypeProperties(IJsonTypeInfoResolver resolver, Type type)
        {
            return new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.NoMetadataForTypeProperties, resolver?.GetType().FullName ?? "<null>", type));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_NoMetadataForTypeProperties(IJsonTypeInfoResolver resolver, Type type)
        {
            throw GetInvalidOperationException_NoMetadataForTypeProperties(resolver, type);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_NoMetadataForTypeCtorParams(IJsonTypeInfoResolver resolver, Type type)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.NoMetadataForTypeCtorParams, resolver?.GetType().FullName ?? "<null>", type));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowMissingMemberException_MissingFSharpCoreMember(string missingFsharpCoreMember)
        {
            throw new MissingMemberException(System.SR.Format(MDCFR.Properties.Resources.MissingFSharpCoreMember, missingFsharpCoreMember));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowNotSupportedException_BaseConverterDoesNotSupportMetadata(Type derivedType)
        {
            throw new NotSupportedException(System.SR.Format(MDCFR.Properties.Resources.Polymorphism_DerivedConverterDoesNotSupportMetadata, derivedType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowNotSupportedException_DerivedConverterDoesNotSupportMetadata(Type derivedType)
        {
            throw new NotSupportedException(System.SR.Format(MDCFR.Properties.Resources.Polymorphism_DerivedConverterDoesNotSupportMetadata, derivedType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowNotSupportedException_RuntimeTypeNotSupported(Type baseType, Type runtimeType)
        {
            throw new NotSupportedException(System.SR.Format(MDCFR.Properties.Resources.Polymorphism_RuntimeTypeNotSupported, runtimeType, baseType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowNotSupportedException_RuntimeTypeDiamondAmbiguity(Type baseType, Type runtimeType, Type derivedType1, Type derivedType2)
        {
            throw new NotSupportedException(System.SR.Format(MDCFR.Properties.Resources.Polymorphism_RuntimeTypeDiamondAmbiguity, runtimeType, derivedType1, derivedType2, baseType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_TypeDoesNotSupportPolymorphism(Type baseType)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.Polymorphism_TypeDoesNotSupportPolymorphism, baseType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_DerivedTypeNotSupported(Type baseType, Type derivedType)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.Polymorphism_DerivedTypeIsNotSupported, derivedType, baseType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_DerivedTypeIsAlreadySpecified(Type baseType, Type derivedType)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.Polymorphism_DerivedTypeIsAlreadySpecified, baseType, derivedType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_TypeDicriminatorIdIsAlreadySpecified(Type baseType, object typeDiscriminator)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.Polymorphism_TypeDicriminatorIdIsAlreadySpecified, baseType, typeDiscriminator));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_InvalidCustomTypeDiscriminatorPropertyName()
        {
            throw new InvalidOperationException(MDCFR.Properties.Resources.Polymorphism_InvalidCustomTypeDiscriminatorPropertyName);
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowInvalidOperationException_PolymorphicTypeConfigurationDoesNotSpecifyDerivedTypes(Type baseType)
        {
            throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.Polymorphism_ConfigurationDoesNotSpecifyDerivedTypes, baseType));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowJsonException_UnrecognizedTypeDiscriminator(object typeDiscriminator)
        {
            ThrowJsonException(System.SR.Format(MDCFR.Properties.Resources.Polymorphism_UnrecognizedTypeDiscriminator, typeDiscriminator));
        }

        [System.Diagnostics.CodeAnalysis.DoesNotReturn]
        public static void ThrowArgumentException_JsonPolymorphismOptionsAssociatedWithDifferentJsonTypeInfo(string parameterName)
        {
            throw new ArgumentException(MDCFR.Properties.Resources.JsonPolymorphismOptionsAssociatedWithDifferentJsonTypeInfo, parameterName);
        }
    }

    /// <summary>
	/// Provides a high-performance API for forward-only, read-only access to the UTF-8 encoded JSON text.
	/// It processes the text sequentially with no caching and adheres strictly to the JSON RFC
	/// by default (https://tools.ietf.org/html/rfc8259). When it encounters invalid JSON, it throws
	/// a JsonException with basic error information like line number and byte position on the line.
	/// Since this type is a ref struct, it does not directly support async. However, it does provide
	/// support for reentrancy to read incomplete data, and continue reading once more data is presented.
	/// To be able to set max depth while reading OR allow skipping comments, create an instance of
	/// <see cref="T:System.Text.Json.JsonReaderState" /> and pass that in to the reader.
	/// </summary>
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
    public ref struct Utf8JsonReader
    {
        private readonly struct PartialStateForRollback
        {
            public readonly long _prevTotalConsumed;

            public readonly long _prevBytePositionInLine;

            public readonly int _prevConsumed;

            public readonly SequencePosition _prevCurrentPosition;

            public PartialStateForRollback(long totalConsumed, long bytePositionInLine, int consumed, SequencePosition currentPosition)
            {
                _prevTotalConsumed = totalConsumed;
                _prevBytePositionInLine = bytePositionInLine;
                _prevConsumed = consumed;
                _prevCurrentPosition = currentPosition;
            }

            public SequencePosition GetStartPosition(int offset = 0)
            {
                return new SequencePosition(_prevCurrentPosition.GetObject(), _prevCurrentPosition.GetInteger() + _prevConsumed + offset);
            }
        }

        private ReadOnlySpan<byte> _buffer;

        private readonly bool _isFinalBlock;

        private readonly bool _isInputSequence;

        private long _lineNumber;

        private long _bytePositionInLine;

        private int _consumed;

        private bool _inObject;

        private bool _isNotPrimitive;

        private JsonTokenType _tokenType;

        private JsonTokenType _previousTokenType;

        private JsonReaderOptions _readerOptions;

        private BitStack _bitStack;

        private long _totalConsumed;

        private bool _isLastSegment;

        private readonly bool _isMultiSegment;

        private bool _trailingCommaBeforeComment;

        private SequencePosition _nextPosition;

        private SequencePosition _currentPosition;

        private readonly ReadOnlySequence<byte> _sequence;

        private bool IsLastSpan
        {
            get
            {
                if (_isFinalBlock)
                {
                    if (_isMultiSegment)
                    {
                        return _isLastSegment;
                    }
                    return true;
                }
                return false;
            }
        }

        internal ReadOnlySequence<byte> OriginalSequence => _sequence;

        internal ReadOnlySpan<byte> OriginalSpan
        {
            get
            {
                if (!_sequence.IsEmpty)
                {
                    return default(ReadOnlySpan<byte>);
                }
                return _buffer;
            }
        }

        internal readonly int ValueLength
        {
            get
            {
                if (!HasValueSequence)
                {
                    return ValueSpan.Length;
                }
                return checked((int)ValueSequence.Length);
            }
        }

        /// <summary>
        /// Gets the value of the last processed token as a ReadOnlySpan&lt;byte&gt; slice
        /// of the input payload. If the JSON is provided within a ReadOnlySequence&lt;byte&gt;
        /// and the slice that represents the token value fits in a single segment, then
        /// <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> will contain the sliced value since it can be represented as a span.
        /// Otherwise, the <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> will contain the token value.
        /// </summary>
        /// <remarks>
        /// If <see cref="P:System.Text.Json.Utf8JsonReader.HasValueSequence" /> is true, <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> contains useless data, likely for
        /// a previous single-segment token. Therefore, only access <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> if <see cref="P:System.Text.Json.Utf8JsonReader.HasValueSequence" /> is false.
        /// Otherwise, the token value must be accessed from <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" />.
        /// </remarks>
        public ReadOnlySpan<byte> ValueSpan { get; private set; }

        /// <summary>
        /// Returns the total amount of bytes consumed by the <see cref="T:System.Text.Json.Utf8JsonReader" /> so far
        /// for the current instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> with the given UTF-8 encoded input text.
        /// </summary>
        public readonly long BytesConsumed => _totalConsumed + _consumed;

        /// <summary>
        /// Returns the index that the last processed JSON token starts at
        /// within the given UTF-8 encoded input text, skipping any white space.
        /// </summary>
        /// <remarks>
        /// For JSON strings (including property names), this points to before the start quote.
        /// For comments, this points to before the first comment delimiter (i.e. '/').
        /// </remarks>
        public long TokenStartIndex { get; private set; }

        /// <summary>
        /// Tracks the recursive depth of the nested objects / arrays within the JSON text
        /// processed so far. This provides the depth of the current token.
        /// </summary>
        public readonly int CurrentDepth
        {
            get
            {
                int num = _bitStack.CurrentDepth;
                if (TokenType == JsonTokenType.StartArray || TokenType == JsonTokenType.StartObject)
                {
                    num--;
                }
                return num;
            }
        }

        internal bool IsInArray => !_inObject;

        /// <summary>
        /// Gets the type of the last processed JSON token in the UTF-8 encoded JSON text.
        /// </summary>
        public readonly JsonTokenType TokenType => _tokenType;

        /// <summary>
        /// Lets the caller know which of the two 'Value' properties to read to get the
        /// token value. For input data within a ReadOnlySpan&lt;byte&gt; this will
        /// always return false. For input data within a ReadOnlySequence&lt;byte&gt;, this
        /// will only return true if the token value straddles more than a single segment and
        /// hence couldn't be represented as a span.
        /// </summary>
        public bool HasValueSequence { get; private set; }

        /// <summary>
        /// Lets the caller know whether the current <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> or <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> properties
        /// contain escape sequences per RFC 8259 section 7, and therefore require unescaping before being consumed.
        /// </summary>
        public bool ValueIsEscaped { get; private set; }

        /// <summary>
        /// Returns the mode of this instance of the <see cref="T:System.Text.Json.Utf8JsonReader" />.
        /// True when the reader was constructed with the input span containing the entire data to process.
        /// False when the reader was constructed knowing that the input span may contain partial data with more data to follow.
        /// </summary>
        public readonly bool IsFinalBlock => _isFinalBlock;

        /// <summary>
        /// Gets the value of the last processed token as a ReadOnlySpan&lt;byte&gt; slice
        /// of the input payload. If the JSON is provided within a ReadOnlySequence&lt;byte&gt;
        /// and the slice that represents the token value fits in a single segment, then
        /// <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> will contain the sliced value since it can be represented as a span.
        /// Otherwise, the <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> will contain the token value.
        /// </summary>
        /// <remarks>
        /// If <see cref="P:System.Text.Json.Utf8JsonReader.HasValueSequence" /> is false, <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> contains useless data, likely for
        /// a previous multi-segment token. Therefore, only access <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" /> if <see cref="P:System.Text.Json.Utf8JsonReader.HasValueSequence" /> is true.
        /// Otherwise, the token value must be accessed from <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" />.
        /// </remarks>
        public ReadOnlySequence<byte> ValueSequence { get; private set; }

        /// <summary>
        /// Returns the current <see cref="T:System.SequencePosition" /> within the provided UTF-8 encoded
        /// input ReadOnlySequence&lt;byte&gt;. If the <see cref="T:System.Text.Json.Utf8JsonReader" /> was constructed
        /// with a ReadOnlySpan&lt;byte&gt; instead, this will always return a default <see cref="T:System.SequencePosition" />.
        /// </summary>
        public readonly SequencePosition Position
        {
            get
            {
                if (_isInputSequence)
                {
                    return _sequence.GetPosition(_consumed, _currentPosition);
                }
                return default(SequencePosition);
            }
        }

        /// <summary>
        /// Returns the current snapshot of the <see cref="T:System.Text.Json.Utf8JsonReader" /> state which must
        /// be captured by the caller and passed back in to the <see cref="T:System.Text.Json.Utf8JsonReader" /> ctor with more data.
        /// Unlike the <see cref="T:System.Text.Json.Utf8JsonReader" />, which is a ref struct, the state can survive
        /// across async/await boundaries and hence this type is required to provide support for reading
        /// in more data asynchronously before continuing with a new instance of the <see cref="T:System.Text.Json.Utf8JsonReader" />.
        /// </summary>
        public readonly JsonReaderState CurrentState
        {
            get
            {
                JsonReaderState result = default(JsonReaderState);
                result._lineNumber = _lineNumber;
                result._bytePositionInLine = _bytePositionInLine;
                result._inObject = _inObject;
                result._isNotPrimitive = _isNotPrimitive;
                result._valueIsEscaped = ValueIsEscaped;
                result._trailingCommaBeforeComment = _trailingCommaBeforeComment;
                result._tokenType = _tokenType;
                result._previousTokenType = _previousTokenType;
                result._readerOptions = _readerOptions;
                result._bitStack = _bitStack;
                return result;
            }
        }

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private string DebuggerDisplay => $"TokenType = {DebugTokenType} (TokenStartIndex = {TokenStartIndex}) Consumed = {BytesConsumed}";

        private string DebugTokenType => TokenType switch
        {
            JsonTokenType.Comment => "Comment",
            JsonTokenType.EndArray => "EndArray",
            JsonTokenType.EndObject => "EndObject",
            JsonTokenType.False => "False",
            JsonTokenType.None => "None",
            JsonTokenType.Null => "Null",
            JsonTokenType.Number => "Number",
            JsonTokenType.PropertyName => "PropertyName",
            JsonTokenType.StartArray => "StartArray",
            JsonTokenType.StartObject => "StartObject",
            JsonTokenType.String => "String",
            JsonTokenType.True => "True",
            _ => ((byte)TokenType).ToString(),
        };

        /// <summary>
        /// Constructs a new <see cref="T:System.Text.Json.Utf8JsonReader" /> instance.
        /// </summary>
        /// <param name="jsonData">The ReadOnlySpan&lt;byte&gt; containing the UTF-8 encoded JSON text to process.</param>
        /// <param name="isFinalBlock">True when the input span contains the entire data to process.
        /// Set to false only if it is known that the input span contains partial data with more data to follow.</param>
        /// <param name="state">If this is the first call to the ctor, pass in a default state. Otherwise,
        /// capture the state from the previous instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> and pass that back.</param>
        /// <remarks>
        /// Since this type is a ref struct, it is a stack-only type and all the limitations of ref structs apply to it.
        /// This is the reason why the ctor accepts a <see cref="T:System.Text.Json.JsonReaderState" />.
        /// </remarks>
        public Utf8JsonReader(ReadOnlySpan<byte> jsonData, bool isFinalBlock, JsonReaderState state)
        {
            _buffer = jsonData;
            _isFinalBlock = isFinalBlock;
            _isInputSequence = false;
            _lineNumber = state._lineNumber;
            _bytePositionInLine = state._bytePositionInLine;
            _inObject = state._inObject;
            _isNotPrimitive = state._isNotPrimitive;
            ValueIsEscaped = state._valueIsEscaped;
            _trailingCommaBeforeComment = state._trailingCommaBeforeComment;
            _tokenType = state._tokenType;
            _previousTokenType = state._previousTokenType;
            _readerOptions = state._readerOptions;
            if (_readerOptions.MaxDepth == 0)
            {
                _readerOptions.MaxDepth = 64;
            }
            _bitStack = state._bitStack;
            _consumed = 0;
            TokenStartIndex = 0L;
            _totalConsumed = 0L;
            _isLastSegment = _isFinalBlock;
            _isMultiSegment = false;
            ValueSpan = ReadOnlySpan<byte>.Empty;
            _currentPosition = default(SequencePosition);
            _nextPosition = default(SequencePosition);
            _sequence = default(ReadOnlySequence<byte>);
            HasValueSequence = false;
            ValueSequence = ReadOnlySequence<byte>.Empty;
        }

        /// <summary>
        /// Constructs a new <see cref="T:System.Text.Json.Utf8JsonReader" /> instance.
        /// </summary>
        /// <param name="jsonData">The ReadOnlySpan&lt;byte&gt; containing the UTF-8 encoded JSON text to process.</param>
        /// <param name="options">Defines the customized behavior of the <see cref="T:System.Text.Json.Utf8JsonReader" />
        /// that is different from the JSON RFC (for example how to handle comments or maximum depth allowed when reading).
        /// By default, the <see cref="T:System.Text.Json.Utf8JsonReader" /> follows the JSON RFC strictly (i.e. comments within the JSON are invalid) and reads up to a maximum depth of 64.</param>
        /// <remarks>
        ///   <para>
        ///     Since this type is a ref struct, it is a stack-only type and all the limitations of ref structs apply to it.
        ///   </para>
        ///   <para>
        ///     This assumes that the entire JSON payload is passed in (equivalent to <see cref="P:System.Text.Json.Utf8JsonReader.IsFinalBlock" /> = true)
        ///   </para>
        /// </remarks>
        public Utf8JsonReader(ReadOnlySpan<byte> jsonData, JsonReaderOptions options = default(JsonReaderOptions))
            : this(jsonData, isFinalBlock: true, new JsonReaderState(options))
        {
        }

        /// <summary>
        /// Read the next JSON token from input source.
        /// </summary>
        /// <returns>True if the token was read successfully, else false.</returns>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// Thrown when an invalid JSON token is encountered according to the JSON RFC
        /// or if the current depth exceeds the recursive limit set by the max depth.
        /// </exception>
        public bool Read()
        {
            bool flag = (_isMultiSegment ? ReadMultiSegment() : ReadSingleSegment());
            if (!flag && _isFinalBlock && TokenType == JsonTokenType.None)
            {
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedJsonTokens, 0);
            }
            return flag;
        }

        /// <summary>
        /// Skips the children of the current JSON token.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown when the reader was given partial data with more data to follow (i.e. <see cref="P:System.Text.Json.Utf8JsonReader.IsFinalBlock" /> is false).
        /// </exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// Thrown when an invalid JSON token is encountered while skipping, according to the JSON RFC,
        /// or if the current depth exceeds the recursive limit set by the max depth.
        /// </exception>
        /// <remarks>
        /// When <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> is <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />, the reader first moves to the property value.
        /// When <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> (originally, or after advancing) is <see cref="F:System.Text.Json.JsonTokenType.StartObject" /> or
        /// <see cref="F:System.Text.Json.JsonTokenType.StartArray" />, the reader advances to the matching
        /// <see cref="F:System.Text.Json.JsonTokenType.EndObject" /> or <see cref="F:System.Text.Json.JsonTokenType.EndArray" />.
        ///
        /// For all other token types, the reader does not move. After the next call to <see cref="M:System.Text.Json.Utf8JsonReader.Read" />, the reader will be at
        /// the next value (when in an array), the next property name (when in an object), or the end array/object token.
        /// </remarks>
        public void Skip()
        {
            if (!_isFinalBlock)
            {
                ThrowHelper.ThrowInvalidOperationException_CannotSkipOnPartial();
            }
            SkipHelper();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void SkipHelper()
        {
            if (TokenType == JsonTokenType.PropertyName)
            {
                bool flag = Read();
            }
            if (TokenType == JsonTokenType.StartObject || TokenType == JsonTokenType.StartArray)
            {
                int currentDepth = CurrentDepth;
                do
                {
                    bool flag2 = Read();
                }
                while (currentDepth < CurrentDepth);
            }
        }

        /// <summary>
        /// Tries to skip the children of the current JSON token.
        /// </summary>
        /// <returns>True if there was enough data for the children to be skipped successfully, else false.</returns>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// Thrown when an invalid JSON token is encountered while skipping, according to the JSON RFC,
        /// or if the current depth exceeds the recursive limit set by the max depth.
        /// </exception>
        /// <remarks>
        ///   <para>
        ///     If the reader did not have enough data to completely skip the children of the current token,
        ///     it will be reset to the state it was in before the method was called.
        ///   </para>
        ///   <para>
        ///     When <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> is <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />, the reader first moves to the property value.
        ///     When <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> (originally, or after advancing) is <see cref="F:System.Text.Json.JsonTokenType.StartObject" /> or
        ///     <see cref="F:System.Text.Json.JsonTokenType.StartArray" />, the reader advances to the matching
        ///     <see cref="F:System.Text.Json.JsonTokenType.EndObject" /> or <see cref="F:System.Text.Json.JsonTokenType.EndArray" />.
        ///
        ///     For all other token types, the reader does not move. After the next call to <see cref="M:System.Text.Json.Utf8JsonReader.Read" />, the reader will be at
        ///     the next value (when in an array), the next property name (when in an object), or the end array/object token.
        ///   </para>
        /// </remarks>
        public bool TrySkip()
        {
            if (_isFinalBlock)
            {
                SkipHelper();
                return true;
            }
            return TrySkipHelper();
        }

        private bool TrySkipHelper()
        {
            Utf8JsonReader utf8JsonReader = this;
            if (TokenType != JsonTokenType.PropertyName || Read())
            {
                if (TokenType != JsonTokenType.StartObject && TokenType != JsonTokenType.StartArray)
                {
                    goto IL_0042;
                }
                int currentDepth = CurrentDepth;
                while (Read())
                {
                    if (currentDepth < CurrentDepth)
                    {
                        continue;
                    }
                    goto IL_0042;
                }
            }
            this = utf8JsonReader;
            return false;
        IL_0042:
            return true;
        }

        /// <summary>
        /// Compares the UTF-8 encoded text to the unescaped JSON token value in the source and returns true if they match.
        /// </summary>
        /// <param name="utf8Text">The UTF-8 encoded text to compare against.</param>
        /// <returns>True if the JSON token value in the source matches the UTF-8 encoded look up text.</returns>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to find a text match on a JSON token that is not a string
        /// (i.e. other than <see cref="F:System.Text.Json.JsonTokenType.String" /> or <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        /// <remarks>
        ///   <para>
        ///     If the look up text is invalid UTF-8 text, the method will return false since you cannot have
        ///     invalid UTF-8 within the JSON payload.
        ///   </para>
        ///   <para>
        ///     The comparison of the JSON token value in the source and the look up text is done by first unescaping the JSON value in source,
        ///     if required. The look up text is matched as is, without any modifications to it.
        ///   </para>
        /// </remarks>
        public readonly bool ValueTextEquals(ReadOnlySpan<byte> utf8Text)
        {
            if (!IsTokenTypeString(TokenType))
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedStringComparison(TokenType);
            }
            return TextEqualsHelper(utf8Text);
        }

        /// <summary>
        /// Compares the string text to the unescaped JSON token value in the source and returns true if they match.
        /// </summary>
        /// <param name="text">The text to compare against.</param>
        /// <returns>True if the JSON token value in the source matches the look up text.</returns>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to find a text match on a JSON token that is not a string
        /// (i.e. other than <see cref="F:System.Text.Json.JsonTokenType.String" /> or <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        /// <remarks>
        ///   <para>
        ///     If the look up text is invalid UTF-8 text, the method will return false since you cannot have
        ///     invalid UTF-8 within the JSON payload.
        ///   </para>
        ///   <para>
        ///     The comparison of the JSON token value in the source and the look up text is done by first unescaping the JSON value in source,
        ///     if required. The look up text is matched as is, without any modifications to it.
        ///   </para>
        /// </remarks>
        public readonly bool ValueTextEquals(string? text)
        {
            return ValueTextEquals(text.AsSpan());
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private readonly bool TextEqualsHelper(ReadOnlySpan<byte> otherUtf8Text)
        {
            if (HasValueSequence)
            {
                return CompareToSequence(otherUtf8Text);
            }
            if (ValueIsEscaped)
            {
                return UnescapeAndCompare(otherUtf8Text);
            }
            return otherUtf8Text.SequenceEqual(ValueSpan);
        }

        /// <summary>
        /// Compares the text to the unescaped JSON token value in the source and returns true if they match.
        /// </summary>
        /// <param name="text">The text to compare against.</param>
        /// <returns>True if the JSON token value in the source matches the look up text.</returns>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to find a text match on a JSON token that is not a string
        /// (i.e. other than <see cref="F:System.Text.Json.JsonTokenType.String" /> or <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />).
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        /// <remarks>
        ///   <para>
        ///     If the look up text is invalid or incomplete UTF-16 text (i.e. unpaired surrogates), the method will return false
        ///     since you cannot have invalid UTF-16 within the JSON payload.
        ///   </para>
        ///   <para>
        ///     The comparison of the JSON token value in the source and the look up text is done by first unescaping the JSON value in source,
        ///     if required. The look up text is matched as is, without any modifications to it.
        ///   </para>
        /// </remarks>
        public readonly bool ValueTextEquals(ReadOnlySpan<char> text)
        {
            if (!IsTokenTypeString(TokenType))
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedStringComparison(TokenType);
            }

            if (MatchNotPossible(text.Length))
            {
                return false;
            }

            byte[]? otherUtf8TextArray = null;

            Span<byte> otherUtf8Text;

            int length = checked(text.Length * JsonConstants.MaxExpansionFactorWhileTranscoding);

            if (length > JsonConstants.StackallocByteThreshold)
            {
                otherUtf8TextArray = ArrayPool<byte>.Shared.Rent(length);
                otherUtf8Text = otherUtf8TextArray;
            }
            else
            {
                // Cannot create a span directly since it gets passed to instance methods on a ref struct.
                unsafe
                {
                    byte* ptr = stackalloc byte[JsonConstants.StackallocByteThreshold];
                    otherUtf8Text = new Span<byte>(ptr, JsonConstants.StackallocByteThreshold);
                }
            }

            ReadOnlySpan<byte> utf16Text = MemoryMarshal.AsBytes(text);
            OperationStatus status = JsonWriterHelper.ToUtf8(utf16Text, otherUtf8Text, out int consumed, out int written);
            Debug.Assert(status != OperationStatus.DestinationTooSmall);
            bool result;
            if (status > OperationStatus.DestinationTooSmall)   // Equivalent to: (status == NeedMoreData || status == InvalidData)
            {
                result = false;
            }
            else
            {
                Debug.Assert(status == OperationStatus.Done);
                Debug.Assert(consumed == utf16Text.Length);

                result = TextEqualsHelper(otherUtf8Text.Slice(0, written));
            }

            if (otherUtf8TextArray != null)
            {
                otherUtf8Text.Slice(0, written).Clear();
                ArrayPool<byte>.Shared.Return(otherUtf8TextArray);
            }

            return result;
        }

        private readonly bool CompareToSequence(ReadOnlySpan<byte> other)
        {
            if (ValueIsEscaped)
            {
                return UnescapeSequenceAndCompare(other);
            }
            ReadOnlySequence<byte> valueSequence = ValueSequence;
            if (valueSequence.Length != other.Length)
            {
                return false;
            }
            int num = 0;
            ReadOnlySequence<byte>.Enumerator enumerator = valueSequence.GetEnumerator();
            while (enumerator.MoveNext())
            {
                ReadOnlySpan<byte> span = enumerator.Current.Span;
                if (other.Slice(num).StartsWith(span))
                {
                    num += span.Length;
                    continue;
                }
                return false;
            }
            return true;
        }

        private readonly bool UnescapeAndCompare(ReadOnlySpan<byte> other)
        {
            ReadOnlySpan<byte> valueSpan = ValueSpan;
            if (valueSpan.Length < other.Length || valueSpan.Length / 6 > other.Length)
            {
                return false;
            }
            int num = valueSpan.IndexOf<byte>(92);
            if (!other.StartsWith(valueSpan.Slice(0, num)))
            {
                return false;
            }
            return JsonReaderHelper.UnescapeAndCompare(valueSpan.Slice(num), other.Slice(num));
        }

        private readonly bool UnescapeSequenceAndCompare(ReadOnlySpan<byte> other)
        {
            ReadOnlySequence<byte> valueSequence = ValueSequence;
            long length = valueSequence.Length;
            if (length < other.Length || length / 6 > other.Length)
            {
                return false;
            }
            int num = 0;
            bool result = false;
            ReadOnlySequence<byte>.Enumerator enumerator = valueSequence.GetEnumerator();
            while (enumerator.MoveNext())
            {
                ReadOnlySpan<byte> span = enumerator.Current.Span;
                int num2 = span.IndexOf<byte>(92);
                if (num2 != -1)
                {
                    if (other.Slice(num).StartsWith(span.Slice(0, num2)))
                    {
                        num += num2;
                        other = other.Slice(num);
                        valueSequence = valueSequence.Slice(num);
                        result = ((!valueSequence.IsSingleSegment) ? JsonReaderHelper.UnescapeAndCompare(valueSequence, other) : JsonReaderHelper.UnescapeAndCompare(valueSequence.First.Span, other));
                    }
                    break;
                }
                if (!other.Slice(num).StartsWith(span))
                {
                    break;
                }
                num += span.Length;
            }
            return result;
        }

        private static bool IsTokenTypeString(JsonTokenType tokenType)
        {
            if (tokenType != JsonTokenType.PropertyName)
            {
                return tokenType == JsonTokenType.String;
            }
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private readonly bool MatchNotPossible(int charTextLength)
        {
            if (HasValueSequence)
            {
                return MatchNotPossibleSequence(charTextLength);
            }
            int length = ValueSpan.Length;
            if (length < charTextLength || length / (ValueIsEscaped ? 6 : 3) > charTextLength)
            {
                return true;
            }
            return false;
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private readonly bool MatchNotPossibleSequence(int charTextLength)
        {
            long length = ValueSequence.Length;
            if (length < charTextLength || length / (ValueIsEscaped ? 6 : 3) > charTextLength)
            {
                return true;
            }
            return false;
        }

        private void StartObject()
        {
            if (_bitStack.CurrentDepth >= _readerOptions.MaxDepth)
            {
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ObjectDepthTooLarge, 0);
            }
            _bitStack.PushTrue();
            ValueSpan = _buffer.Slice(_consumed, 1);
            _consumed++;
            _bytePositionInLine++;
            _tokenType = JsonTokenType.StartObject;
            _inObject = true;
        }

        private void EndObject()
        {
            if (!_inObject || _bitStack.CurrentDepth <= 0)
            {
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.MismatchedObjectArray, 125);
            }
            if (_trailingCommaBeforeComment)
            {
                if (!_readerOptions.AllowTrailingCommas)
                {
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeObjectEnd, 0);
                }
                _trailingCommaBeforeComment = false;
            }
            _tokenType = JsonTokenType.EndObject;
            ValueSpan = _buffer.Slice(_consumed, 1);
            UpdateBitStackOnEndToken();
        }

        private void StartArray()
        {
            if (_bitStack.CurrentDepth >= _readerOptions.MaxDepth)
            {
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ArrayDepthTooLarge, 0);
            }
            _bitStack.PushFalse();
            ValueSpan = _buffer.Slice(_consumed, 1);
            _consumed++;
            _bytePositionInLine++;
            _tokenType = JsonTokenType.StartArray;
            _inObject = false;
        }

        private void EndArray()
        {
            if (_inObject || _bitStack.CurrentDepth <= 0)
            {
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.MismatchedObjectArray, 93);
            }
            if (_trailingCommaBeforeComment)
            {
                if (!_readerOptions.AllowTrailingCommas)
                {
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeArrayEnd, 0);
                }
                _trailingCommaBeforeComment = false;
            }
            _tokenType = JsonTokenType.EndArray;
            ValueSpan = _buffer.Slice(_consumed, 1);
            UpdateBitStackOnEndToken();
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void UpdateBitStackOnEndToken()
        {
            _consumed++;
            _bytePositionInLine++;
            _inObject = _bitStack.Pop();
        }

        private bool ReadSingleSegment()
        {
            bool flag = false;
            ValueSpan = default(ReadOnlySpan<byte>);
            ValueIsEscaped = false;
            if (HasMoreData())
            {
                byte b = _buffer[_consumed];
                if (b <= 32)
                {
                    SkipWhiteSpace();
                    if (!HasMoreData())
                    {
                        goto IL_0139;
                    }
                    b = _buffer[_consumed];
                }
                TokenStartIndex = _consumed;
                if (_tokenType != 0)
                {
                    if (b == 47)
                    {
                        flag = ConsumeNextTokenOrRollback(b);
                    }
                    else if (_tokenType == JsonTokenType.StartObject)
                    {
                        if (b == 125)
                        {
                            EndObject();
                            goto IL_0137;
                        }
                        if (b != 34)
                        {
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
                        }
                        int consumed = _consumed;
                        long bytePositionInLine = _bytePositionInLine;
                        long lineNumber = _lineNumber;
                        flag = ConsumePropertyName();
                        if (!flag)
                        {
                            _consumed = consumed;
                            _tokenType = JsonTokenType.StartObject;
                            _bytePositionInLine = bytePositionInLine;
                            _lineNumber = lineNumber;
                        }
                    }
                    else if (_tokenType != JsonTokenType.StartArray)
                    {
                        flag = ((_tokenType != JsonTokenType.PropertyName) ? ConsumeNextTokenOrRollback(b) : ConsumeValue(b));
                    }
                    else
                    {
                        if (b == 93)
                        {
                            EndArray();
                            goto IL_0137;
                        }
                        flag = ConsumeValue(b);
                    }
                }
                else
                {
                    flag = ReadFirstToken(b);
                }
            }
            goto IL_0139;
        IL_0137:
            flag = true;
            goto IL_0139;
        IL_0139:
            return flag;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool HasMoreData()
        {
            if (_consumed >= (uint)_buffer.Length)
            {
                if (_isNotPrimitive && IsLastSpan)
                {
                    if (_bitStack.CurrentDepth != 0)
                    {
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ZeroDepthAtEnd, 0);
                    }
                    if (_readerOptions.CommentHandling == JsonCommentHandling.Allow && _tokenType == JsonTokenType.Comment)
                    {
                        return false;
                    }
                    if (_tokenType != JsonTokenType.EndArray && _tokenType != JsonTokenType.EndObject)
                    {
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidEndOfJsonNonPrimitive, 0);
                    }
                }
                return false;
            }
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool HasMoreData(ExceptionResource resource)
        {
            if (_consumed >= (uint)_buffer.Length)
            {
                if (IsLastSpan)
                {
                    ThrowHelper.ThrowJsonReaderException(ref this, resource, 0);
                }
                return false;
            }
            return true;
        }

        private bool ReadFirstToken(byte first)
        {
            switch (first)
            {
                case 123:
                    _bitStack.SetFirstBit();
                    _tokenType = JsonTokenType.StartObject;
                    ValueSpan = _buffer.Slice(_consumed, 1);
                    _consumed++;
                    _bytePositionInLine++;
                    _inObject = true;
                    _isNotPrimitive = true;
                    break;
                case 91:
                    _bitStack.ResetFirstBit();
                    _tokenType = JsonTokenType.StartArray;
                    ValueSpan = _buffer.Slice(_consumed, 1);
                    _consumed++;
                    _bytePositionInLine++;
                    _isNotPrimitive = true;
                    break;
                default:
                    {
                        ReadOnlySpan<byte> buffer = _buffer;
                        if (JsonHelpers.IsDigit(first) || first == 45)
                        {
                            if (!TryGetNumber(buffer.Slice(_consumed), out var consumed))
                            {
                                return false;
                            }
                            _tokenType = JsonTokenType.Number;
                            _consumed += consumed;
                            _bytePositionInLine += consumed;
                            return true;
                        }
                        if (!ConsumeValue(first))
                        {
                            return false;
                        }
                        if (_tokenType == JsonTokenType.StartObject || _tokenType == JsonTokenType.StartArray)
                        {
                            _isNotPrimitive = true;
                        }
                        break;
                    }
            }
            return true;
        }

        private void SkipWhiteSpace()
        {
            ReadOnlySpan<byte> buffer = _buffer;
            while (_consumed < buffer.Length)
            {
                byte b = buffer[_consumed];
                if (b == 32 || b == 13 || b == 10 || b == 9)
                {
                    if (b == 10)
                    {
                        _lineNumber++;
                        _bytePositionInLine = 0L;
                    }
                    else
                    {
                        _bytePositionInLine++;
                    }
                    _consumed++;
                    continue;
                }
                break;
            }
        }

        /// <summary>
        /// This method contains the logic for processing the next value token and determining
        /// what type of data it is.
        /// </summary>
        private bool ConsumeValue(byte marker)
        {
            while (true)
            {
                _trailingCommaBeforeComment = false;
                switch (marker)
                {
                    case 34:
                        return ConsumeString();
                    case 123:
                        StartObject();
                        break;
                    case 91:
                        StartArray();
                        break;
                    default:
                        if (JsonHelpers.IsDigit(marker) || marker == 45)
                        {
                            return ConsumeNumber();
                        }
                        switch (marker)
                        {
                            case 102:
                                return ConsumeLiteral(JsonConstants.FalseValue, JsonTokenType.False);
                            case 116:
                                return ConsumeLiteral(JsonConstants.TrueValue, JsonTokenType.True);
                            case 110:
                                return ConsumeLiteral(JsonConstants.NullValue, JsonTokenType.Null);
                        }
                        switch (_readerOptions.CommentHandling)
                        {
                            case JsonCommentHandling.Allow:
                                if (marker == 47)
                                {
                                    return ConsumeComment();
                                }
                                break;
                            default:
                                if (marker != 47)
                                {
                                    break;
                                }
                                if (SkipComment())
                                {
                                    if (_consumed >= (uint)_buffer.Length)
                                    {
                                        if (_isNotPrimitive && IsLastSpan && _tokenType != JsonTokenType.EndArray && _tokenType != JsonTokenType.EndObject)
                                        {
                                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidEndOfJsonNonPrimitive, 0);
                                        }
                                        return false;
                                    }
                                    marker = _buffer[_consumed];
                                    if (marker <= 32)
                                    {
                                        SkipWhiteSpace();
                                        if (!HasMoreData())
                                        {
                                            return false;
                                        }
                                        marker = _buffer[_consumed];
                                    }
                                    goto IL_0140;
                                }
                                return false;
                            case JsonCommentHandling.Disallow:
                                break;
                        }
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfValueNotFound, marker);
                        break;
                }
                break;
            IL_0140:
                TokenStartIndex = _consumed;
            }
            return true;
        }

        private bool ConsumeLiteral(ReadOnlySpan<byte> literal, JsonTokenType tokenType)
        {
            ReadOnlySpan<byte> span = _buffer.Slice(_consumed);
            if (!span.StartsWith(literal))
            {
                return CheckLiteral(span, literal);
            }
            ValueSpan = span.Slice(0, literal.Length);
            _tokenType = tokenType;
            _consumed += literal.Length;
            _bytePositionInLine += literal.Length;
            return true;
        }

        private bool CheckLiteral(ReadOnlySpan<byte> span, ReadOnlySpan<byte> literal)
        {
            int num = 0;
            for (int i = 1; i < literal.Length; i++)
            {
                if (span.Length > i)
                {
                    if (span[i] != literal[i])
                    {
                        _bytePositionInLine += i;
                        ThrowInvalidLiteral(span);
                    }
                    continue;
                }
                num = i;
                break;
            }
            if (IsLastSpan)
            {
                _bytePositionInLine += num;
                ThrowInvalidLiteral(span);
            }
            return false;
        }

        private void ThrowInvalidLiteral(ReadOnlySpan<byte> span)
        {
            ThrowHelper.ThrowJsonReaderException(ref this, span[0] switch
            {
                116 => ExceptionResource.ExpectedTrue,
                102 => ExceptionResource.ExpectedFalse,
                _ => ExceptionResource.ExpectedNull,
            }, 0, span);
        }

        private bool ConsumeNumber()
        {
            if (!TryGetNumber(_buffer.Slice(_consumed), out var consumed))
            {
                return false;
            }
            _tokenType = JsonTokenType.Number;
            _consumed += consumed;
            _bytePositionInLine += consumed;
            if (_consumed >= (uint)_buffer.Length && _isNotPrimitive)
            {
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndOfDigitNotFound, _buffer[_consumed - 1]);
            }
            return true;
        }

        private bool ConsumePropertyName()
        {
            _trailingCommaBeforeComment = false;
            if (!ConsumeString())
            {
                return false;
            }
            if (!HasMoreData(ExceptionResource.ExpectedValueAfterPropertyNameNotFound))
            {
                return false;
            }
            byte b = _buffer[_consumed];
            if (b <= 32)
            {
                SkipWhiteSpace();
                if (!HasMoreData(ExceptionResource.ExpectedValueAfterPropertyNameNotFound))
                {
                    return false;
                }
                b = _buffer[_consumed];
            }
            if (b != 58)
            {
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedSeparatorAfterPropertyNameNotFound, b);
            }
            _consumed++;
            _bytePositionInLine++;
            _tokenType = JsonTokenType.PropertyName;
            return true;
        }

        private bool ConsumeString()
        {
            ReadOnlySpan<byte> readOnlySpan = _buffer.Slice(_consumed + 1);
            int num = readOnlySpan.IndexOfQuoteOrAnyControlOrBackSlash();
            if (num >= 0)
            {
                byte b = readOnlySpan[num];
                if (b == 34)
                {
                    _bytePositionInLine += num + 2;
                    ValueSpan = readOnlySpan.Slice(0, num);
                    ValueIsEscaped = false;
                    _tokenType = JsonTokenType.String;
                    _consumed += num + 2;
                    return true;
                }
                return ConsumeStringAndValidate(readOnlySpan, num);
            }
            if (IsLastSpan)
            {
                _bytePositionInLine += readOnlySpan.Length + 1;
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.EndOfStringNotFound, 0);
            }
            return false;
        }

        private bool ConsumeStringAndValidate(ReadOnlySpan<byte> data, int idx)
        {
            long bytePositionInLine = _bytePositionInLine;
            long lineNumber = _lineNumber;
            _bytePositionInLine += idx + 1;
            bool flag = false;
            while (true)
            {
                if (idx < data.Length)
                {
                    byte b = data[idx];
                    if (b == 34)
                    {
                        if (!flag)
                        {
                            break;
                        }
                        flag = false;
                    }
                    else if (b == 92)
                    {
                        flag = !flag;
                    }
                    else if (flag)
                    {
                        int num = JsonConstants.EscapableChars.IndexOf(b);
                        if (num == -1)
                        {
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidCharacterAfterEscapeWithinString, b);
                        }
                        if (b == 117)
                        {
                            _bytePositionInLine++;
                            if (!ValidateHexDigits(data, idx + 1))
                            {
                                idx = data.Length;
                                goto IL_00e5;
                            }
                            idx += 4;
                        }
                        flag = false;
                    }
                    else if (b < 32)
                    {
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidCharacterWithinString, b);
                    }
                    _bytePositionInLine++;
                    idx++;
                    continue;
                }
                goto IL_00e5;
            IL_00e5:
                if (idx < data.Length)
                {
                    break;
                }
                if (IsLastSpan)
                {
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.EndOfStringNotFound, 0);
                }
                _lineNumber = lineNumber;
                _bytePositionInLine = bytePositionInLine;
                return false;
            }
            _bytePositionInLine++;
            ValueSpan = data.Slice(0, idx);
            ValueIsEscaped = true;
            _tokenType = JsonTokenType.String;
            _consumed += idx + 2;
            return true;
        }

        private bool ValidateHexDigits(ReadOnlySpan<byte> data, int idx)
        {
            for (int i = idx; i < data.Length; i++)
            {
                byte nextByte = data[i];
                if (!JsonReaderHelper.IsHexDigit(nextByte))
                {
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidHexCharacterWithinString, nextByte);
                }
                if (i - idx >= 3)
                {
                    return true;
                }
                _bytePositionInLine++;
            }
            return false;
        }

        private bool TryGetNumber(ReadOnlySpan<byte> data, out int consumed)
        {
            consumed = 0;
            int i = 0;
            ConsumeNumberResult consumeNumberResult = ConsumeNegativeSign(ref data, ref i);
            if (consumeNumberResult == ConsumeNumberResult.NeedMoreData)
            {
                return false;
            }
            byte b = data[i];
            if (b == 48)
            {
                ConsumeNumberResult consumeNumberResult2 = ConsumeZero(ref data, ref i);
                if (consumeNumberResult2 == ConsumeNumberResult.NeedMoreData)
                {
                    return false;
                }
                if (consumeNumberResult2 != 0)
                {
                    b = data[i];
                    goto IL_00a3;
                }
            }
            else
            {
                i++;
                ConsumeNumberResult consumeNumberResult3 = ConsumeIntegerDigits(ref data, ref i);
                if (consumeNumberResult3 == ConsumeNumberResult.NeedMoreData)
                {
                    return false;
                }
                if (consumeNumberResult3 != 0)
                {
                    b = data[i];
                    if (b != 46 && b != 69 && b != 101)
                    {
                        _bytePositionInLine += i;
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndOfDigitNotFound, b);
                    }
                    goto IL_00a3;
                }
            }
            goto IL_0152;
        IL_00a3:
            if (b == 46)
            {
                i++;
                ConsumeNumberResult consumeNumberResult4 = ConsumeDecimalDigits(ref data, ref i);
                if (consumeNumberResult4 == ConsumeNumberResult.NeedMoreData)
                {
                    return false;
                }
                if (consumeNumberResult4 == ConsumeNumberResult.Success)
                {
                    goto IL_0152;
                }
                b = data[i];
                if (b != 69 && b != 101)
                {
                    _bytePositionInLine += i;
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedNextDigitEValueNotFound, b);
                }
            }
            i++;
            consumeNumberResult = ConsumeSign(ref data, ref i);
            if (consumeNumberResult == ConsumeNumberResult.NeedMoreData)
            {
                return false;
            }
            i++;
            switch (ConsumeIntegerDigits(ref data, ref i))
            {
                case ConsumeNumberResult.NeedMoreData:
                    return false;
                default:
                    _bytePositionInLine += i;
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndOfDigitNotFound, data[i]);
                    break;
                case ConsumeNumberResult.Success:
                    break;
            }
            goto IL_0152;
        IL_0152:
            ValueSpan = data.Slice(0, i);
            consumed = i;
            return true;
        }

        private ConsumeNumberResult ConsumeNegativeSign(ref ReadOnlySpan<byte> data, scoped ref int i)
        {
            byte b = data[i];
            if (b == 45)
            {
                i++;
                if (i >= data.Length)
                {
                    if (IsLastSpan)
                    {
                        _bytePositionInLine += i;
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
                    }
                    return ConsumeNumberResult.NeedMoreData;
                }
                b = data[i];
                if (!JsonHelpers.IsDigit(b))
                {
                    _bytePositionInLine += i;
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundAfterSign, b);
                }
            }
            return ConsumeNumberResult.OperationIncomplete;
        }

        private ConsumeNumberResult ConsumeZero(ref ReadOnlySpan<byte> data, scoped ref int i)
        {
            i++;
            if (i < data.Length)
            {
                byte value = data[i];
                if (JsonConstants.Delimiters.IndexOf(value) >= 0)
                {
                    return ConsumeNumberResult.Success;
                }
                value = data[i];
                if (value != 46 && value != 69 && value != 101)
                {
                    _bytePositionInLine += i;
                    ThrowHelper.ThrowJsonReaderException(ref this, JsonHelpers.IsInRangeInclusive(value, 48, 57) ? ExceptionResource.InvalidLeadingZeroInNumber : ExceptionResource.ExpectedEndOfDigitNotFound, value);
                }
                return ConsumeNumberResult.OperationIncomplete;
            }
            if (IsLastSpan)
            {
                return ConsumeNumberResult.Success;
            }
            return ConsumeNumberResult.NeedMoreData;
        }

        private ConsumeNumberResult ConsumeIntegerDigits(ref ReadOnlySpan<byte> data, scoped ref int i)
        {
            byte value = 0;
            while (i < data.Length)
            {
                value = data[i];
                if (!JsonHelpers.IsDigit(value))
                {
                    break;
                }
                i++;
            }
            if (i >= data.Length)
            {
                if (IsLastSpan)
                {
                    return ConsumeNumberResult.Success;
                }
                return ConsumeNumberResult.NeedMoreData;
            }
            if (JsonConstants.Delimiters.IndexOf(value) >= 0)
            {
                return ConsumeNumberResult.Success;
            }
            return ConsumeNumberResult.OperationIncomplete;
        }

        private ConsumeNumberResult ConsumeDecimalDigits(ref ReadOnlySpan<byte> data, scoped ref int i)
        {
            if (i >= data.Length)
            {
                if (IsLastSpan)
                {
                    _bytePositionInLine += i;
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
                }
                return ConsumeNumberResult.NeedMoreData;
            }
            byte b = data[i];
            if (!JsonHelpers.IsDigit(b))
            {
                _bytePositionInLine += i;
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundAfterDecimal, b);
            }
            i++;
            return ConsumeIntegerDigits(ref data, ref i);
        }

        private ConsumeNumberResult ConsumeSign(ref ReadOnlySpan<byte> data, scoped ref int i)
        {
            if (i >= data.Length)
            {
                if (IsLastSpan)
                {
                    _bytePositionInLine += i;
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
                }
                return ConsumeNumberResult.NeedMoreData;
            }
            byte b = data[i];
            if (b == 43 || b == 45)
            {
                i++;
                if (i >= data.Length)
                {
                    if (IsLastSpan)
                    {
                        _bytePositionInLine += i;
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
                    }
                    return ConsumeNumberResult.NeedMoreData;
                }
                b = data[i];
            }
            if (!JsonHelpers.IsDigit(b))
            {
                _bytePositionInLine += i;
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundAfterSign, b);
            }
            return ConsumeNumberResult.OperationIncomplete;
        }

        private bool ConsumeNextTokenOrRollback(byte marker)
        {
            int consumed = _consumed;
            long bytePositionInLine = _bytePositionInLine;
            long lineNumber = _lineNumber;
            JsonTokenType tokenType = _tokenType;
            bool trailingCommaBeforeComment = _trailingCommaBeforeComment;
            switch (ConsumeNextToken(marker))
            {
                case ConsumeTokenResult.Success:
                    return true;
                case ConsumeTokenResult.NotEnoughDataRollBackState:
                    _consumed = consumed;
                    _tokenType = tokenType;
                    _bytePositionInLine = bytePositionInLine;
                    _lineNumber = lineNumber;
                    _trailingCommaBeforeComment = trailingCommaBeforeComment;
                    break;
            }
            return false;
        }

        /// <summary>
        /// This method consumes the next token regardless of whether we are inside an object or an array.
        /// For an object, it reads the next property name token. For an array, it just reads the next value.
        /// </summary>
        private ConsumeTokenResult ConsumeNextToken(byte marker)
        {
            if (_readerOptions.CommentHandling != 0)
            {
                if (_readerOptions.CommentHandling != JsonCommentHandling.Allow)
                {
                    return ConsumeNextTokenUntilAfterAllCommentsAreSkipped(marker);
                }
                if (marker == 47)
                {
                    if (!ConsumeComment())
                    {
                        return ConsumeTokenResult.NotEnoughDataRollBackState;
                    }
                    return ConsumeTokenResult.Success;
                }
                if (_tokenType == JsonTokenType.Comment)
                {
                    return ConsumeNextTokenFromLastNonCommentToken();
                }
            }
            if (_bitStack.CurrentDepth == 0)
            {
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndAfterSingleJson, marker);
            }
            switch (marker)
            {
                case 44:
                    {
                        _consumed++;
                        _bytePositionInLine++;
                        if (_consumed >= (uint)_buffer.Length)
                        {
                            if (IsLastSpan)
                            {
                                _consumed--;
                                _bytePositionInLine--;
                                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound, 0);
                            }
                            return ConsumeTokenResult.NotEnoughDataRollBackState;
                        }
                        byte b = _buffer[_consumed];
                        if (b <= 32)
                        {
                            SkipWhiteSpace();
                            if (!HasMoreData(ExceptionResource.ExpectedStartOfPropertyOrValueNotFound))
                            {
                                return ConsumeTokenResult.NotEnoughDataRollBackState;
                            }
                            b = _buffer[_consumed];
                        }
                        TokenStartIndex = _consumed;
                        if (_readerOptions.CommentHandling == JsonCommentHandling.Allow && b == 47)
                        {
                            _trailingCommaBeforeComment = true;
                            if (!ConsumeComment())
                            {
                                return ConsumeTokenResult.NotEnoughDataRollBackState;
                            }
                            return ConsumeTokenResult.Success;
                        }
                        if (_inObject)
                        {
                            if (b != 34)
                            {
                                if (b == 125)
                                {
                                    if (_readerOptions.AllowTrailingCommas)
                                    {
                                        EndObject();
                                        return ConsumeTokenResult.Success;
                                    }
                                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeObjectEnd, 0);
                                }
                                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
                            }
                            if (!ConsumePropertyName())
                            {
                                return ConsumeTokenResult.NotEnoughDataRollBackState;
                            }
                            return ConsumeTokenResult.Success;
                        }
                        if (b == 93)
                        {
                            if (_readerOptions.AllowTrailingCommas)
                            {
                                EndArray();
                                return ConsumeTokenResult.Success;
                            }
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeArrayEnd, 0);
                        }
                        if (!ConsumeValue(b))
                        {
                            return ConsumeTokenResult.NotEnoughDataRollBackState;
                        }
                        return ConsumeTokenResult.Success;
                    }
                case 125:
                    EndObject();
                    break;
                case 93:
                    EndArray();
                    break;
                default:
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.FoundInvalidCharacter, marker);
                    break;
            }
            return ConsumeTokenResult.Success;
        }

        private ConsumeTokenResult ConsumeNextTokenFromLastNonCommentToken()
        {
            if (JsonReaderHelper.IsTokenTypePrimitive(_previousTokenType))
            {
                _tokenType = (_inObject ? JsonTokenType.StartObject : JsonTokenType.StartArray);
            }
            else
            {
                _tokenType = _previousTokenType;
            }
            if (HasMoreData())
            {
                byte b = _buffer[_consumed];
                if (b <= 32)
                {
                    SkipWhiteSpace();
                    if (!HasMoreData())
                    {
                        goto IL_0343;
                    }
                    b = _buffer[_consumed];
                }
                if (_bitStack.CurrentDepth == 0 && _tokenType != 0)
                {
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndAfterSingleJson, b);
                }
                TokenStartIndex = _consumed;
                if (b != 44)
                {
                    if (b == 125)
                    {
                        EndObject();
                    }
                    else
                    {
                        if (b != 93)
                        {
                            if (_tokenType == JsonTokenType.None)
                            {
                                if (ReadFirstToken(b))
                                {
                                    goto IL_0341;
                                }
                            }
                            else if (_tokenType == JsonTokenType.StartObject)
                            {
                                if (b != 34)
                                {
                                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
                                }
                                int consumed = _consumed;
                                long bytePositionInLine = _bytePositionInLine;
                                long lineNumber = _lineNumber;
                                if (ConsumePropertyName())
                                {
                                    goto IL_0341;
                                }
                                _consumed = consumed;
                                _tokenType = JsonTokenType.StartObject;
                                _bytePositionInLine = bytePositionInLine;
                                _lineNumber = lineNumber;
                            }
                            else if (_tokenType == JsonTokenType.StartArray)
                            {
                                if (ConsumeValue(b))
                                {
                                    goto IL_0341;
                                }
                            }
                            else if (_tokenType == JsonTokenType.PropertyName)
                            {
                                if (ConsumeValue(b))
                                {
                                    goto IL_0341;
                                }
                            }
                            else if (_inObject)
                            {
                                if (b != 34)
                                {
                                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
                                }
                                if (ConsumePropertyName())
                                {
                                    goto IL_0341;
                                }
                            }
                            else if (ConsumeValue(b))
                            {
                                goto IL_0341;
                            }
                            goto IL_0343;
                        }
                        EndArray();
                    }
                    goto IL_0341;
                }
                if ((int)_previousTokenType <= 1 || _previousTokenType == JsonTokenType.StartArray || _trailingCommaBeforeComment)
                {
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueAfterComment, b);
                }
                _consumed++;
                _bytePositionInLine++;
                if (_consumed >= (uint)_buffer.Length)
                {
                    if (IsLastSpan)
                    {
                        _consumed--;
                        _bytePositionInLine--;
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound, 0);
                    }
                }
                else
                {
                    b = _buffer[_consumed];
                    if (b <= 32)
                    {
                        SkipWhiteSpace();
                        if (!HasMoreData(ExceptionResource.ExpectedStartOfPropertyOrValueNotFound))
                        {
                            goto IL_0343;
                        }
                        b = _buffer[_consumed];
                    }
                    TokenStartIndex = _consumed;
                    if (b == 47)
                    {
                        _trailingCommaBeforeComment = true;
                        if (ConsumeComment())
                        {
                            goto IL_0341;
                        }
                    }
                    else if (_inObject)
                    {
                        if (b != 34)
                        {
                            if (b == 125)
                            {
                                if (_readerOptions.AllowTrailingCommas)
                                {
                                    EndObject();
                                    goto IL_0341;
                                }
                                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeObjectEnd, 0);
                            }
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
                        }
                        if (ConsumePropertyName())
                        {
                            goto IL_0341;
                        }
                    }
                    else
                    {
                        if (b == 93)
                        {
                            if (_readerOptions.AllowTrailingCommas)
                            {
                                EndArray();
                                goto IL_0341;
                            }
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeArrayEnd, 0);
                        }
                        if (ConsumeValue(b))
                        {
                            goto IL_0341;
                        }
                    }
                }
            }
            goto IL_0343;
        IL_0343:
            return ConsumeTokenResult.NotEnoughDataRollBackState;
        IL_0341:
            return ConsumeTokenResult.Success;
        }

        private bool SkipAllComments(scoped ref byte marker)
        {
            while (true)
            {
                if (marker == 47)
                {
                    if (!SkipComment() || !HasMoreData())
                    {
                        break;
                    }
                    marker = _buffer[_consumed];
                    if (marker <= 32)
                    {
                        SkipWhiteSpace();
                        if (!HasMoreData())
                        {
                            break;
                        }
                        marker = _buffer[_consumed];
                    }
                    continue;
                }
                return true;
            }
            return false;
        }

        private bool SkipAllComments(scoped ref byte marker, ExceptionResource resource)
        {
            while (true)
            {
                if (marker == 47)
                {
                    if (!SkipComment() || !HasMoreData(resource))
                    {
                        break;
                    }
                    marker = _buffer[_consumed];
                    if (marker <= 32)
                    {
                        SkipWhiteSpace();
                        if (!HasMoreData(resource))
                        {
                            break;
                        }
                        marker = _buffer[_consumed];
                    }
                    continue;
                }
                return true;
            }
            return false;
        }

        private ConsumeTokenResult ConsumeNextTokenUntilAfterAllCommentsAreSkipped(byte marker)
        {
            if (SkipAllComments(ref marker))
            {
                TokenStartIndex = _consumed;
                if (_tokenType == JsonTokenType.StartObject)
                {
                    if (marker == 125)
                    {
                        EndObject();
                    }
                    else
                    {
                        if (marker != 34)
                        {
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, marker);
                        }
                        int consumed = _consumed;
                        long bytePositionInLine = _bytePositionInLine;
                        long lineNumber = _lineNumber;
                        if (!ConsumePropertyName())
                        {
                            _consumed = consumed;
                            _tokenType = JsonTokenType.StartObject;
                            _bytePositionInLine = bytePositionInLine;
                            _lineNumber = lineNumber;
                            goto IL_0281;
                        }
                    }
                }
                else if (_tokenType == JsonTokenType.StartArray)
                {
                    if (marker == 93)
                    {
                        EndArray();
                    }
                    else if (!ConsumeValue(marker))
                    {
                        goto IL_0281;
                    }
                }
                else if (_tokenType == JsonTokenType.PropertyName)
                {
                    if (!ConsumeValue(marker))
                    {
                        goto IL_0281;
                    }
                }
                else if (_bitStack.CurrentDepth == 0)
                {
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndAfterSingleJson, marker);
                }
                else
                {
                    switch (marker)
                    {
                        case 44:
                            _consumed++;
                            _bytePositionInLine++;
                            if (_consumed >= (uint)_buffer.Length)
                            {
                                if (IsLastSpan)
                                {
                                    _consumed--;
                                    _bytePositionInLine--;
                                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound, 0);
                                }
                                return ConsumeTokenResult.NotEnoughDataRollBackState;
                            }
                            marker = _buffer[_consumed];
                            if (marker <= 32)
                            {
                                SkipWhiteSpace();
                                if (!HasMoreData(ExceptionResource.ExpectedStartOfPropertyOrValueNotFound))
                                {
                                    return ConsumeTokenResult.NotEnoughDataRollBackState;
                                }
                                marker = _buffer[_consumed];
                            }
                            if (SkipAllComments(ref marker, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound))
                            {
                                TokenStartIndex = _consumed;
                                if (_inObject)
                                {
                                    if (marker != 34)
                                    {
                                        if (marker == 125)
                                        {
                                            if (_readerOptions.AllowTrailingCommas)
                                            {
                                                EndObject();
                                                break;
                                            }
                                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeObjectEnd, 0);
                                        }
                                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, marker);
                                    }
                                    if (!ConsumePropertyName())
                                    {
                                        return ConsumeTokenResult.NotEnoughDataRollBackState;
                                    }
                                    return ConsumeTokenResult.Success;
                                }
                                if (marker == 93)
                                {
                                    if (_readerOptions.AllowTrailingCommas)
                                    {
                                        EndArray();
                                        break;
                                    }
                                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeArrayEnd, 0);
                                }
                                if (!ConsumeValue(marker))
                                {
                                    return ConsumeTokenResult.NotEnoughDataRollBackState;
                                }
                                return ConsumeTokenResult.Success;
                            }
                            return ConsumeTokenResult.NotEnoughDataRollBackState;
                        case 125:
                            EndObject();
                            break;
                        case 93:
                            EndArray();
                            break;
                        default:
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.FoundInvalidCharacter, marker);
                            break;
                    }
                }
                return ConsumeTokenResult.Success;
            }
            goto IL_0281;
        IL_0281:
            return ConsumeTokenResult.IncompleteNoRollBackNecessary;
        }

        private bool SkipComment()
        {
            ReadOnlySpan<byte> readOnlySpan = _buffer.Slice(_consumed + 1);
            if (readOnlySpan.Length > 0)
            {
                int idx;
                switch (readOnlySpan[0])
                {
                    case 47:
                        return SkipSingleLineComment(readOnlySpan.Slice(1), out idx);
                    case 42:
                        return SkipMultiLineComment(readOnlySpan.Slice(1), out idx);
                }
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfValueNotFound, 47);
            }
            if (IsLastSpan)
            {
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfValueNotFound, 47);
            }
            return false;
        }

        private bool SkipSingleLineComment(ReadOnlySpan<byte> localBuffer, out int idx)
        {
            idx = FindLineSeparator(localBuffer);
            int num;
            if (idx != -1)
            {
                num = idx;
                if (localBuffer[idx] != 10)
                {
                    if (idx < localBuffer.Length - 1)
                    {
                        if (localBuffer[idx + 1] == 10)
                        {
                            num++;
                        }
                    }
                    else if (!IsLastSpan)
                    {
                        return false;
                    }
                }
                num++;
                _bytePositionInLine = 0L;
                _lineNumber++;
            }
            else
            {
                if (!IsLastSpan)
                {
                    return false;
                }
                idx = localBuffer.Length;
                num = idx;
                _bytePositionInLine += 2 + localBuffer.Length;
            }
            _consumed += 2 + num;
            return true;
        }

        private int FindLineSeparator(ReadOnlySpan<byte> localBuffer)
        {
            int num = 0;
            while (true)
            {
                int num2 = localBuffer.IndexOfAny<byte>(10, 13, 226);
                if (num2 == -1)
                {
                    return -1;
                }
                num += num2;
                if (localBuffer[num2] != 226)
                {
                    break;
                }
                num++;
                localBuffer = localBuffer.Slice(num2 + 1);
                ThrowOnDangerousLineSeparator(localBuffer);
            }
            return num;
        }

        private void ThrowOnDangerousLineSeparator(ReadOnlySpan<byte> localBuffer)
        {
            if (localBuffer.Length >= 2)
            {
                byte b = localBuffer[1];
                if (localBuffer[0] == 128 && (b == 168 || b == 169))
                {
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.UnexpectedEndOfLineSeparator, 0);
                }
            }
        }

        private bool SkipMultiLineComment(ReadOnlySpan<byte> localBuffer, out int idx)
        {
            idx = 0;
            while (true)
            {
                int num = localBuffer.Slice(idx).IndexOf<byte>(47);
                switch (num)
                {
                    case -1:
                        if (IsLastSpan)
                        {
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.EndOfCommentNotFound, 0);
                        }
                        return false;
                    default:
                        if (localBuffer[num + idx - 1] == 42)
                        {
                            idx += num - 1;
                            _consumed += 4 + idx;
                            var (num2, num3) = JsonReaderHelper.CountNewLines(localBuffer.Slice(0, idx));
                            _lineNumber += num2;
                            if (num3 != -1)
                            {
                                _bytePositionInLine = idx - num3 + 1;
                            }
                            else
                            {
                                _bytePositionInLine += 4 + idx;
                            }
                            return true;
                        }
                        break;
                    case 0:
                        break;
                }
                idx += num + 1;
            }
        }

        private bool ConsumeComment()
        {
            ReadOnlySpan<byte> readOnlySpan = _buffer.Slice(_consumed + 1);
            if (readOnlySpan.Length > 0)
            {
                byte b = readOnlySpan[0];
                switch (b)
                {
                    case 47:
                        return ConsumeSingleLineComment(readOnlySpan.Slice(1), _consumed);
                    case 42:
                        return ConsumeMultiLineComment(readOnlySpan.Slice(1), _consumed);
                }
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidCharacterAtStartOfComment, b);
            }
            if (IsLastSpan)
            {
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.UnexpectedEndOfDataWhileReadingComment, 0);
            }
            return false;
        }

        private bool ConsumeSingleLineComment(ReadOnlySpan<byte> localBuffer, int previousConsumed)
        {
            if (!SkipSingleLineComment(localBuffer, out var idx))
            {
                return false;
            }
            ValueSpan = _buffer.Slice(previousConsumed + 2, idx);
            if (_tokenType != JsonTokenType.Comment)
            {
                _previousTokenType = _tokenType;
            }
            _tokenType = JsonTokenType.Comment;
            return true;
        }

        private bool ConsumeMultiLineComment(ReadOnlySpan<byte> localBuffer, int previousConsumed)
        {
            if (!SkipMultiLineComment(localBuffer, out var idx))
            {
                return false;
            }
            ValueSpan = _buffer.Slice(previousConsumed + 2, idx);
            if (_tokenType != JsonTokenType.Comment)
            {
                _previousTokenType = _tokenType;
            }
            _tokenType = JsonTokenType.Comment;
            return true;
        }

        private ReadOnlySpan<byte> GetUnescapedSpan()
        {
            ReadOnlySpan<byte> readOnlySpan;
            if (!HasValueSequence)
            {
                readOnlySpan = ValueSpan;
            }
            else
            {
                ReadOnlySequence<byte> sequence = ValueSequence;
                readOnlySpan = BuffersExtensions.ToArray(in sequence);
            }
            ReadOnlySpan<byte> readOnlySpan2 = readOnlySpan;
            if (ValueIsEscaped)
            {
                readOnlySpan2 = JsonReaderHelper.GetUnescapedSpan(readOnlySpan2);
            }
            return readOnlySpan2;
        }

        /// <summary>
        /// Constructs a new <see cref="T:System.Text.Json.Utf8JsonReader" /> instance.
        /// </summary>
        /// <param name="jsonData">The ReadOnlySequence&lt;byte&gt; containing the UTF-8 encoded JSON text to process.</param>
        /// <param name="isFinalBlock">True when the input span contains the entire data to process.
        /// Set to false only if it is known that the input span contains partial data with more data to follow.</param>
        /// <param name="state">If this is the first call to the ctor, pass in a default state. Otherwise,
        /// capture the state from the previous instance of the <see cref="T:System.Text.Json.Utf8JsonReader" /> and pass that back.</param>
        /// <remarks>
        /// Since this type is a ref struct, it is a stack-only type and all the limitations of ref structs apply to it.
        /// This is the reason why the ctor accepts a <see cref="T:System.Text.Json.JsonReaderState" />.
        /// </remarks>
        public Utf8JsonReader(ReadOnlySequence<byte> jsonData, bool isFinalBlock, JsonReaderState state)
        {
            ReadOnlyMemory<byte> memory = jsonData.First;
            _buffer = memory.Span;
            _isFinalBlock = isFinalBlock;
            _isInputSequence = true;
            _lineNumber = state._lineNumber;
            _bytePositionInLine = state._bytePositionInLine;
            _inObject = state._inObject;
            _isNotPrimitive = state._isNotPrimitive;
            ValueIsEscaped = state._valueIsEscaped;
            _trailingCommaBeforeComment = state._trailingCommaBeforeComment;
            _tokenType = state._tokenType;
            _previousTokenType = state._previousTokenType;
            _readerOptions = state._readerOptions;
            if (_readerOptions.MaxDepth == 0)
            {
                _readerOptions.MaxDepth = 64;
            }
            _bitStack = state._bitStack;
            _consumed = 0;
            TokenStartIndex = 0L;
            _totalConsumed = 0L;
            ValueSpan = ReadOnlySpan<byte>.Empty;
            _sequence = jsonData;
            HasValueSequence = false;
            ValueSequence = ReadOnlySequence<byte>.Empty;
            if (jsonData.IsSingleSegment)
            {
                _nextPosition = default(SequencePosition);
                _currentPosition = jsonData.Start;
                _isLastSegment = isFinalBlock;
                _isMultiSegment = false;
                return;
            }
            _currentPosition = jsonData.Start;
            _nextPosition = _currentPosition;
            bool flag = _buffer.Length == 0;
            if (flag)
            {
                SequencePosition nextPosition = _nextPosition;
                ReadOnlyMemory<byte> memory2;
                while (jsonData.TryGet(ref _nextPosition, out memory2))
                {
                    _currentPosition = nextPosition;
                    if (memory2.Length != 0)
                    {
                        _buffer = memory2.Span;
                        break;
                    }
                    nextPosition = _nextPosition;
                }
            }
            _isLastSegment = !jsonData.TryGet(ref _nextPosition, out memory, !flag) && isFinalBlock;
            _isMultiSegment = true;
        }

        /// <summary>
        /// Constructs a new <see cref="T:System.Text.Json.Utf8JsonReader" /> instance.
        /// </summary>
        /// <param name="jsonData">The ReadOnlySequence&lt;byte&gt; containing the UTF-8 encoded JSON text to process.</param>
        /// <param name="options">Defines the customized behavior of the <see cref="T:System.Text.Json.Utf8JsonReader" />
        /// that is different from the JSON RFC (for example how to handle comments or maximum depth allowed when reading).
        /// By default, the <see cref="T:System.Text.Json.Utf8JsonReader" /> follows the JSON RFC strictly (i.e. comments within the JSON are invalid) and reads up to a maximum depth of 64.</param>
        /// <remarks>
        ///   <para>
        ///     Since this type is a ref struct, it is a stack-only type and all the limitations of ref structs apply to it.
        ///   </para>
        ///   <para>
        ///     This assumes that the entire JSON payload is passed in (equivalent to <see cref="P:System.Text.Json.Utf8JsonReader.IsFinalBlock" /> = true)
        ///   </para>
        /// </remarks>
        public Utf8JsonReader(ReadOnlySequence<byte> jsonData, JsonReaderOptions options = default(JsonReaderOptions))
            : this(jsonData, isFinalBlock: true, new JsonReaderState(options))
        {
        }

        private bool ReadMultiSegment()
        {
            bool flag = false;
            HasValueSequence = false;
            ValueIsEscaped = false;
            ValueSpan = default(ReadOnlySpan<byte>);
            ValueSequence = default(ReadOnlySequence<byte>);
            if (HasMoreDataMultiSegment())
            {
                byte b = _buffer[_consumed];
                if (b <= 32)
                {
                    SkipWhiteSpaceMultiSegment();
                    if (!HasMoreDataMultiSegment())
                    {
                        goto IL_0173;
                    }
                    b = _buffer[_consumed];
                }
                TokenStartIndex = BytesConsumed;
                if (_tokenType != 0)
                {
                    if (b == 47)
                    {
                        flag = ConsumeNextTokenOrRollbackMultiSegment(b);
                    }
                    else if (_tokenType == JsonTokenType.StartObject)
                    {
                        if (b == 125)
                        {
                            EndObject();
                            goto IL_0171;
                        }
                        if (b != 34)
                        {
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
                        }
                        long totalConsumed = _totalConsumed;
                        int consumed = _consumed;
                        long bytePositionInLine = _bytePositionInLine;
                        long lineNumber = _lineNumber;
                        SequencePosition currentPosition = _currentPosition;
                        flag = ConsumePropertyNameMultiSegment();
                        if (!flag)
                        {
                            _consumed = consumed;
                            _tokenType = JsonTokenType.StartObject;
                            _bytePositionInLine = bytePositionInLine;
                            _lineNumber = lineNumber;
                            _totalConsumed = totalConsumed;
                            _currentPosition = currentPosition;
                        }
                    }
                    else if (_tokenType != JsonTokenType.StartArray)
                    {
                        flag = ((_tokenType != JsonTokenType.PropertyName) ? ConsumeNextTokenOrRollbackMultiSegment(b) : ConsumeValueMultiSegment(b));
                    }
                    else
                    {
                        if (b == 93)
                        {
                            EndArray();
                            goto IL_0171;
                        }
                        flag = ConsumeValueMultiSegment(b);
                    }
                }
                else
                {
                    flag = ReadFirstTokenMultiSegment(b);
                }
            }
            goto IL_0173;
        IL_0171:
            flag = true;
            goto IL_0173;
        IL_0173:
            return flag;
        }

        private bool ValidateStateAtEndOfData()
        {
            if (_bitStack.CurrentDepth != 0)
            {
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ZeroDepthAtEnd, 0);
            }
            if (_readerOptions.CommentHandling == JsonCommentHandling.Allow && _tokenType == JsonTokenType.Comment)
            {
                return false;
            }
            if (_tokenType != JsonTokenType.EndArray && _tokenType != JsonTokenType.EndObject)
            {
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidEndOfJsonNonPrimitive, 0);
            }
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool HasMoreDataMultiSegment()
        {
            if (_consumed >= (uint)_buffer.Length)
            {
                if (_isNotPrimitive && IsLastSpan && !ValidateStateAtEndOfData())
                {
                    return false;
                }
                if (!GetNextSpan())
                {
                    if (_isNotPrimitive && IsLastSpan)
                    {
                        ValidateStateAtEndOfData();
                    }
                    return false;
                }
            }
            return true;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private bool HasMoreDataMultiSegment(ExceptionResource resource)
        {
            if (_consumed >= (uint)_buffer.Length)
            {
                if (IsLastSpan)
                {
                    ThrowHelper.ThrowJsonReaderException(ref this, resource, 0);
                }
                if (!GetNextSpan())
                {
                    if (IsLastSpan)
                    {
                        ThrowHelper.ThrowJsonReaderException(ref this, resource, 0);
                    }
                    return false;
                }
            }
            return true;
        }

        private bool GetNextSpan()
        {
            ReadOnlyMemory<byte> memory;
            while (true)
            {
                SequencePosition currentPosition = _currentPosition;
                _currentPosition = _nextPosition;
                if (!_sequence.TryGet(ref _nextPosition, out memory))
                {
                    _currentPosition = currentPosition;
                    _isLastSegment = true;
                    return false;
                }
                if (memory.Length != 0)
                {
                    break;
                }
                _currentPosition = currentPosition;
            }
            if (_isFinalBlock)
            {
                _isLastSegment = !_sequence.TryGet(ref _nextPosition, out var _, advance: false);
            }
            _buffer = memory.Span;
            _totalConsumed += _consumed;
            _consumed = 0;
            return true;
        }

        private bool ReadFirstTokenMultiSegment(byte first)
        {
            switch (first)
            {
                case 123:
                    _bitStack.SetFirstBit();
                    _tokenType = JsonTokenType.StartObject;
                    ValueSpan = _buffer.Slice(_consumed, 1);
                    _consumed++;
                    _bytePositionInLine++;
                    _inObject = true;
                    _isNotPrimitive = true;
                    break;
                case 91:
                    _bitStack.ResetFirstBit();
                    _tokenType = JsonTokenType.StartArray;
                    ValueSpan = _buffer.Slice(_consumed, 1);
                    _consumed++;
                    _bytePositionInLine++;
                    _isNotPrimitive = true;
                    break;
                default:
                    if (JsonHelpers.IsDigit(first) || first == 45)
                    {
                        if (!TryGetNumberMultiSegment(_buffer.Slice(_consumed), out var consumed))
                        {
                            return false;
                        }
                        _tokenType = JsonTokenType.Number;
                        _consumed += consumed;
                        return true;
                    }
                    if (!ConsumeValueMultiSegment(first))
                    {
                        return false;
                    }
                    if (_tokenType == JsonTokenType.StartObject || _tokenType == JsonTokenType.StartArray)
                    {
                        _isNotPrimitive = true;
                    }
                    break;
            }
            return true;
        }

        private void SkipWhiteSpaceMultiSegment()
        {
            do
            {
                SkipWhiteSpace();
            }
            while (_consumed >= _buffer.Length && GetNextSpan());
        }

        /// <summary>
        /// This method contains the logic for processing the next value token and determining
        /// what type of data it is.
        /// </summary>
        private bool ConsumeValueMultiSegment(byte marker)
        {
            while (true)
            {
                _trailingCommaBeforeComment = false;
                switch (marker)
                {
                    case 34:
                        return ConsumeStringMultiSegment();
                    case 123:
                        StartObject();
                        break;
                    case 91:
                        StartArray();
                        break;
                    default:
                        if (JsonHelpers.IsDigit(marker) || marker == 45)
                        {
                            return ConsumeNumberMultiSegment();
                        }
                        switch (marker)
                        {
                            case 102:
                                return ConsumeLiteralMultiSegment(JsonConstants.FalseValue, JsonTokenType.False);
                            case 116:
                                return ConsumeLiteralMultiSegment(JsonConstants.TrueValue, JsonTokenType.True);
                            case 110:
                                return ConsumeLiteralMultiSegment(JsonConstants.NullValue, JsonTokenType.Null);
                        }
                        switch (_readerOptions.CommentHandling)
                        {
                            case JsonCommentHandling.Allow:
                                if (marker == 47)
                                {
                                    SequencePosition currentPosition2 = _currentPosition;
                                    if (!SkipOrConsumeCommentMultiSegmentWithRollback())
                                    {
                                        _currentPosition = currentPosition2;
                                        return false;
                                    }
                                    return true;
                                }
                                break;
                            default:
                                {
                                    if (marker != 47)
                                    {
                                        break;
                                    }
                                    SequencePosition currentPosition = _currentPosition;
                                    if (SkipCommentMultiSegment(out var _))
                                    {
                                        if (_consumed >= (uint)_buffer.Length)
                                        {
                                            if (_isNotPrimitive && IsLastSpan && _tokenType != JsonTokenType.EndArray && _tokenType != JsonTokenType.EndObject)
                                            {
                                                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidEndOfJsonNonPrimitive, 0);
                                            }
                                            if (!GetNextSpan())
                                            {
                                                if (_isNotPrimitive && IsLastSpan && _tokenType != JsonTokenType.EndArray && _tokenType != JsonTokenType.EndObject)
                                                {
                                                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidEndOfJsonNonPrimitive, 0);
                                                }
                                                _currentPosition = currentPosition;
                                                return false;
                                            }
                                        }
                                        marker = _buffer[_consumed];
                                        if (marker <= 32)
                                        {
                                            SkipWhiteSpaceMultiSegment();
                                            if (!HasMoreDataMultiSegment())
                                            {
                                                _currentPosition = currentPosition;
                                                return false;
                                            }
                                            marker = _buffer[_consumed];
                                        }
                                        goto IL_01a8;
                                    }
                                    _currentPosition = currentPosition;
                                    return false;
                                }
                            case JsonCommentHandling.Disallow:
                                break;
                        }
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfValueNotFound, marker);
                        break;
                }
                break;
            IL_01a8:
                TokenStartIndex = BytesConsumed;
            }
            return true;
        }

        private bool ConsumeLiteralMultiSegment(ReadOnlySpan<byte> literal, JsonTokenType tokenType)
        {
            ReadOnlySpan<byte> span = _buffer.Slice(_consumed);
            int consumed = literal.Length;
            if (!span.StartsWith(literal))
            {
                int consumed2 = _consumed;
                if (!CheckLiteralMultiSegment(span, literal, out consumed))
                {
                    _consumed = consumed2;
                    return false;
                }
            }
            else
            {
                ValueSpan = span.Slice(0, literal.Length);
                HasValueSequence = false;
            }
            _tokenType = tokenType;
            _consumed += consumed;
            _bytePositionInLine += consumed;
            return true;
        }

        private bool CheckLiteralMultiSegment(ReadOnlySpan<byte> span, ReadOnlySpan<byte> literal, out int consumed)
        {
            Span<byte> destination = stackalloc byte[5];
            int num = 0;
            long totalConsumed = _totalConsumed;
            SequencePosition currentPosition = _currentPosition;
            if (span.Length >= literal.Length || IsLastSpan)
            {
                _bytePositionInLine += FindMismatch(span, literal);
                int num2 = Math.Min(span.Length, (int)_bytePositionInLine + 1);
                span.Slice(0, num2).CopyTo(destination);
                num += num2;
            }
            else if (!literal.StartsWith(span))
            {
                _bytePositionInLine += FindMismatch(span, literal);
                int num3 = Math.Min(span.Length, (int)_bytePositionInLine + 1);
                span.Slice(0, num3).CopyTo(destination);
                num += num3;
            }
            else
            {
                ReadOnlySpan<byte> readOnlySpan = literal.Slice(span.Length);
                SequencePosition currentPosition2 = _currentPosition;
                int consumed2 = _consumed;
                int num4 = literal.Length - readOnlySpan.Length;
                while (true)
                {
                    _totalConsumed += num4;
                    _bytePositionInLine += num4;
                    if (!GetNextSpan())
                    {
                        _totalConsumed = totalConsumed;
                        consumed = 0;
                        _currentPosition = currentPosition;
                        if (IsLastSpan)
                        {
                            break;
                        }
                        return false;
                    }
                    int num5 = Math.Min(span.Length, destination.Length - num);
                    span.Slice(0, num5).CopyTo(destination.Slice(num));
                    num += num5;
                    span = _buffer;
                    if (span.StartsWith(readOnlySpan))
                    {
                        HasValueSequence = true;
                        SequencePosition start = new SequencePosition(currentPosition2.GetObject(), currentPosition2.GetInteger() + consumed2);
                        SequencePosition end = new SequencePosition(_currentPosition.GetObject(), _currentPosition.GetInteger() + readOnlySpan.Length);
                        ValueSequence = _sequence.Slice(start, end);
                        consumed = readOnlySpan.Length;
                        return true;
                    }
                    if (!readOnlySpan.StartsWith(span))
                    {
                        _bytePositionInLine += FindMismatch(span, readOnlySpan);
                        num5 = Math.Min(span.Length, (int)_bytePositionInLine + 1);
                        span.Slice(0, num5).CopyTo(destination.Slice(num));
                        num += num5;
                        break;
                    }
                    readOnlySpan = readOnlySpan.Slice(span.Length);
                    num4 = span.Length;
                }
            }
            _totalConsumed = totalConsumed;
            consumed = 0;
            _currentPosition = currentPosition;
            throw GetInvalidLiteralMultiSegment(destination.Slice(0, num).ToArray());
        }

        private static int FindMismatch(ReadOnlySpan<byte> span, ReadOnlySpan<byte> literal)
        {
            int num = Math.Min(span.Length, literal.Length);
            int i;
            for (i = 0; i < num && span[i] == literal[i]; i++)
            {
            }
            return i;
        }

        private JsonException GetInvalidLiteralMultiSegment(ReadOnlySpan<byte> span)
        {
            return ThrowHelper.GetJsonReaderException(ref this, span[0] switch
            {
                116 => ExceptionResource.ExpectedTrue,
                102 => ExceptionResource.ExpectedFalse,
                _ => ExceptionResource.ExpectedNull,
            }, 0, span);
        }

        private bool ConsumeNumberMultiSegment()
        {
            if (!TryGetNumberMultiSegment(_buffer.Slice(_consumed), out var consumed))
            {
                return false;
            }
            _tokenType = JsonTokenType.Number;
            _consumed += consumed;
            if (_consumed >= (uint)_buffer.Length && _isNotPrimitive)
            {
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndOfDigitNotFound, _buffer[_consumed - 1]);
            }
            return true;
        }

        private bool ConsumePropertyNameMultiSegment()
        {
            _trailingCommaBeforeComment = false;
            if (!ConsumeStringMultiSegment())
            {
                return false;
            }
            if (!HasMoreDataMultiSegment(ExceptionResource.ExpectedValueAfterPropertyNameNotFound))
            {
                return false;
            }
            byte b = _buffer[_consumed];
            if (b <= 32)
            {
                SkipWhiteSpaceMultiSegment();
                if (!HasMoreDataMultiSegment(ExceptionResource.ExpectedValueAfterPropertyNameNotFound))
                {
                    return false;
                }
                b = _buffer[_consumed];
            }
            if (b != 58)
            {
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedSeparatorAfterPropertyNameNotFound, b);
            }
            _consumed++;
            _bytePositionInLine++;
            _tokenType = JsonTokenType.PropertyName;
            return true;
        }

        private bool ConsumeStringMultiSegment()
        {
            ReadOnlySpan<byte> readOnlySpan = _buffer.Slice(_consumed + 1);
            int num = readOnlySpan.IndexOfQuoteOrAnyControlOrBackSlash();
            if (num >= 0)
            {
                byte b = readOnlySpan[num];
                if (b == 34)
                {
                    _bytePositionInLine += num + 2;
                    ValueSpan = readOnlySpan.Slice(0, num);
                    HasValueSequence = false;
                    ValueIsEscaped = false;
                    _tokenType = JsonTokenType.String;
                    _consumed += num + 2;
                    return true;
                }
                return ConsumeStringAndValidateMultiSegment(readOnlySpan, num);
            }
            if (IsLastSpan)
            {
                _bytePositionInLine += readOnlySpan.Length + 1;
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.EndOfStringNotFound, 0);
            }
            return ConsumeStringNextSegment();
        }

        private bool ConsumeStringNextSegment()
        {
            PartialStateForRollback state = CaptureState();
            HasValueSequence = true;
            int num = _buffer.Length - _consumed;
            ReadOnlySpan<byte> buffer;
            int num2;
            while (true)
            {
                if (!GetNextSpan())
                {
                    if (IsLastSpan)
                    {
                        _bytePositionInLine += num;
                        RollBackState(in state, isError: true);
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.EndOfStringNotFound, 0);
                    }
                    RollBackState(in state);
                    return false;
                }
                buffer = _buffer;
                num2 = buffer.IndexOfQuoteOrAnyControlOrBackSlash();
                if (num2 >= 0)
                {
                    break;
                }
                _totalConsumed += buffer.Length;
                _bytePositionInLine += buffer.Length;
            }
            byte b = buffer[num2];
            SequencePosition end;
            if (b == 34)
            {
                end = new SequencePosition(_currentPosition.GetObject(), _currentPosition.GetInteger() + num2);
                _bytePositionInLine += num + num2 + 1;
                _totalConsumed += num;
                _consumed = num2 + 1;
                ValueIsEscaped = false;
            }
            else
            {
                _bytePositionInLine += num + num2;
                ValueIsEscaped = true;
                bool flag = false;
                while (true)
                {
                    if (num2 < buffer.Length)
                    {
                        byte b2 = buffer[num2];
                        if (b2 == 34)
                        {
                            if (!flag)
                            {
                                break;
                            }
                            flag = false;
                        }
                        else if (b2 == 92)
                        {
                            flag = !flag;
                        }
                        else if (flag)
                        {
                            int num3 = JsonConstants.EscapableChars.IndexOf(b2);
                            if (num3 == -1)
                            {
                                RollBackState(in state, isError: true);
                                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidCharacterAfterEscapeWithinString, b2);
                            }
                            if (b2 == 117)
                            {
                                _bytePositionInLine++;
                                int num4 = 0;
                                int num5 = num2 + 1;
                                while (true)
                                {
                                    if (num5 < buffer.Length)
                                    {
                                        byte nextByte = buffer[num5];
                                        if (!JsonReaderHelper.IsHexDigit(nextByte))
                                        {
                                            RollBackState(in state, isError: true);
                                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidHexCharacterWithinString, nextByte);
                                        }
                                        num4++;
                                        _bytePositionInLine++;
                                        if (num4 >= 4)
                                        {
                                            break;
                                        }
                                        num5++;
                                        continue;
                                    }
                                    if (!GetNextSpan())
                                    {
                                        if (IsLastSpan)
                                        {
                                            RollBackState(in state, isError: true);
                                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.EndOfStringNotFound, 0);
                                        }
                                        RollBackState(in state);
                                        return false;
                                    }
                                    _totalConsumed += buffer.Length;
                                    buffer = _buffer;
                                    num5 = 0;
                                }
                                flag = false;
                                num2 = num5 + 1;
                                continue;
                            }
                            flag = false;
                        }
                        else if (b2 < 32)
                        {
                            RollBackState(in state, isError: true);
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidCharacterWithinString, b2);
                        }
                        _bytePositionInLine++;
                        num2++;
                        continue;
                    }
                    if (!GetNextSpan())
                    {
                        if (IsLastSpan)
                        {
                            RollBackState(in state, isError: true);
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.EndOfStringNotFound, 0);
                        }
                        RollBackState(in state);
                        return false;
                    }
                    _totalConsumed += buffer.Length;
                    buffer = _buffer;
                    num2 = 0;
                }
                _bytePositionInLine++;
                _consumed = num2 + 1;
                _totalConsumed += num;
                end = new SequencePosition(_currentPosition.GetObject(), _currentPosition.GetInteger() + num2);
            }
            SequencePosition startPosition = state.GetStartPosition(1);
            ValueSequence = _sequence.Slice(startPosition, end);
            _tokenType = JsonTokenType.String;
            return true;
        }

        private bool ConsumeStringAndValidateMultiSegment(ReadOnlySpan<byte> data, int idx)
        {
            PartialStateForRollback state = CaptureState();
            HasValueSequence = false;
            int num = _buffer.Length - _consumed;
            _bytePositionInLine += idx + 1;
            bool flag = false;
            while (true)
            {
                if (idx < data.Length)
                {
                    byte b = data[idx];
                    switch (b)
                    {
                        case 34:
                            if (flag)
                            {
                                flag = false;
                                goto IL_01b7;
                            }
                            if (HasValueSequence)
                            {
                                _bytePositionInLine++;
                                _consumed = idx + 1;
                                _totalConsumed += num;
                                SequencePosition end = new SequencePosition(_currentPosition.GetObject(), _currentPosition.GetInteger() + idx);
                                SequencePosition startPosition = state.GetStartPosition(1);
                                ValueSequence = _sequence.Slice(startPosition, end);
                            }
                            else
                            {
                                _bytePositionInLine++;
                                _consumed += idx + 2;
                                ValueSpan = data.Slice(0, idx);
                            }
                            ValueIsEscaped = true;
                            _tokenType = JsonTokenType.String;
                            return true;
                        case 92:
                            flag = !flag;
                            goto IL_01b7;
                        default:
                            {
                                if (flag)
                                {
                                    int num2 = JsonConstants.EscapableChars.IndexOf(b);
                                    if (num2 == -1)
                                    {
                                        RollBackState(in state, isError: true);
                                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidCharacterAfterEscapeWithinString, b);
                                    }
                                    if (b == 117)
                                    {
                                        _bytePositionInLine++;
                                        int num3 = 0;
                                        int num4 = idx + 1;
                                        while (true)
                                        {
                                            if (num4 < data.Length)
                                            {
                                                byte nextByte = data[num4];
                                                if (!JsonReaderHelper.IsHexDigit(nextByte))
                                                {
                                                    RollBackState(in state, isError: true);
                                                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidHexCharacterWithinString, nextByte);
                                                }
                                                num3++;
                                                _bytePositionInLine++;
                                                if (num3 >= 4)
                                                {
                                                    break;
                                                }
                                                num4++;
                                                continue;
                                            }
                                            if (!GetNextSpan())
                                            {
                                                if (IsLastSpan)
                                                {
                                                    RollBackState(in state, isError: true);
                                                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.EndOfStringNotFound, 0);
                                                }
                                                RollBackState(in state);
                                                return false;
                                            }
                                            if (HasValueSequence)
                                            {
                                                _totalConsumed += data.Length;
                                            }
                                            data = _buffer;
                                            num4 = 0;
                                            HasValueSequence = true;
                                        }
                                        flag = false;
                                        idx = num4 + 1;
                                        break;
                                    }
                                    flag = false;
                                }
                                else if (b < 32)
                                {
                                    RollBackState(in state, isError: true);
                                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidCharacterWithinString, b);
                                }
                                goto IL_01b7;
                            }
                        IL_01b7:
                            _bytePositionInLine++;
                            idx++;
                            break;
                    }
                }
                else
                {
                    if (!GetNextSpan())
                    {
                        break;
                    }
                    if (HasValueSequence)
                    {
                        _totalConsumed += data.Length;
                    }
                    data = _buffer;
                    idx = 0;
                    HasValueSequence = true;
                }
            }
            if (IsLastSpan)
            {
                RollBackState(in state, isError: true);
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.EndOfStringNotFound, 0);
            }
            RollBackState(in state);
            return false;
        }

        private void RollBackState(scoped in PartialStateForRollback state, bool isError = false)
        {
            _totalConsumed = state._prevTotalConsumed;
            if (!isError)
            {
                _bytePositionInLine = state._prevBytePositionInLine;
            }
            _consumed = state._prevConsumed;
            _currentPosition = state._prevCurrentPosition;
        }

        private bool TryGetNumberMultiSegment(ReadOnlySpan<byte> data, out int consumed)
        {
            PartialStateForRollback rollBackState = CaptureState();
            consumed = 0;
            int i = 0;
            ConsumeNumberResult consumeNumberResult = ConsumeNegativeSignMultiSegment(ref data, ref i, in rollBackState);
            if (consumeNumberResult == ConsumeNumberResult.NeedMoreData)
            {
                RollBackState(in rollBackState);
                return false;
            }
            byte b = data[i];
            if (b == 48)
            {
                ConsumeNumberResult consumeNumberResult2 = ConsumeZeroMultiSegment(ref data, ref i, in rollBackState);
                if (consumeNumberResult2 == ConsumeNumberResult.NeedMoreData)
                {
                    RollBackState(in rollBackState);
                    return false;
                }
                if (consumeNumberResult2 != 0)
                {
                    b = data[i];
                    goto IL_00bf;
                }
            }
            else
            {
                ConsumeNumberResult consumeNumberResult3 = ConsumeIntegerDigitsMultiSegment(ref data, ref i);
                if (consumeNumberResult3 == ConsumeNumberResult.NeedMoreData)
                {
                    RollBackState(in rollBackState);
                    return false;
                }
                if (consumeNumberResult3 != 0)
                {
                    b = data[i];
                    if (b != 46 && b != 69 && b != 101)
                    {
                        RollBackState(in rollBackState, isError: true);
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndOfDigitNotFound, b);
                    }
                    goto IL_00bf;
                }
            }
            goto IL_01b1;
        IL_00bf:
            if (b == 46)
            {
                i++;
                _bytePositionInLine++;
                ConsumeNumberResult consumeNumberResult4 = ConsumeDecimalDigitsMultiSegment(ref data, ref i, in rollBackState);
                if (consumeNumberResult4 == ConsumeNumberResult.NeedMoreData)
                {
                    RollBackState(in rollBackState);
                    return false;
                }
                if (consumeNumberResult4 == ConsumeNumberResult.Success)
                {
                    goto IL_01b1;
                }
                b = data[i];
                if (b != 69 && b != 101)
                {
                    RollBackState(in rollBackState, isError: true);
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedNextDigitEValueNotFound, b);
                }
            }
            i++;
            _bytePositionInLine++;
            consumeNumberResult = ConsumeSignMultiSegment(ref data, ref i, in rollBackState);
            if (consumeNumberResult == ConsumeNumberResult.NeedMoreData)
            {
                RollBackState(in rollBackState);
                return false;
            }
            i++;
            _bytePositionInLine++;
            switch (ConsumeIntegerDigitsMultiSegment(ref data, ref i))
            {
                case ConsumeNumberResult.NeedMoreData:
                    RollBackState(in rollBackState);
                    return false;
                default:
                    RollBackState(in rollBackState, isError: true);
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndOfDigitNotFound, data[i]);
                    break;
                case ConsumeNumberResult.Success:
                    break;
            }
            goto IL_01b1;
        IL_01b1:
            if (HasValueSequence)
            {
                SequencePosition startPosition = rollBackState.GetStartPosition();
                SequencePosition end = new SequencePosition(_currentPosition.GetObject(), _currentPosition.GetInteger() + i);
                ValueSequence = _sequence.Slice(startPosition, end);
                consumed = i;
            }
            else
            {
                ValueSpan = data.Slice(0, i);
                consumed = i;
            }
            return true;
        }

        private ConsumeNumberResult ConsumeNegativeSignMultiSegment(ref ReadOnlySpan<byte> data, scoped ref int i, scoped in PartialStateForRollback rollBackState)
        {
            byte b = data[i];
            if (b == 45)
            {
                i++;
                _bytePositionInLine++;
                if (i >= data.Length)
                {
                    if (IsLastSpan)
                    {
                        RollBackState(in rollBackState, isError: true);
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
                    }
                    if (!GetNextSpan())
                    {
                        if (IsLastSpan)
                        {
                            RollBackState(in rollBackState, isError: true);
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
                        }
                        return ConsumeNumberResult.NeedMoreData;
                    }
                    _totalConsumed += i;
                    HasValueSequence = true;
                    i = 0;
                    data = _buffer;
                }
                b = data[i];
                if (!JsonHelpers.IsDigit(b))
                {
                    RollBackState(in rollBackState, isError: true);
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundAfterSign, b);
                }
            }
            return ConsumeNumberResult.OperationIncomplete;
        }

        private ConsumeNumberResult ConsumeZeroMultiSegment(ref ReadOnlySpan<byte> data, scoped ref int i, scoped in PartialStateForRollback rollBackState)
        {
            i++;
            _bytePositionInLine++;
            byte value;
            if (i < data.Length)
            {
                value = data[i];
                if (JsonConstants.Delimiters.IndexOf(value) >= 0)
                {
                    return ConsumeNumberResult.Success;
                }
            }
            else
            {
                if (IsLastSpan)
                {
                    return ConsumeNumberResult.Success;
                }
                if (!GetNextSpan())
                {
                    if (IsLastSpan)
                    {
                        return ConsumeNumberResult.Success;
                    }
                    return ConsumeNumberResult.NeedMoreData;
                }
                _totalConsumed += i;
                HasValueSequence = true;
                i = 0;
                data = _buffer;
                value = data[i];
                if (JsonConstants.Delimiters.IndexOf(value) >= 0)
                {
                    return ConsumeNumberResult.Success;
                }
            }
            value = data[i];
            if (value != 46 && value != 69 && value != 101)
            {
                RollBackState(in rollBackState, isError: true);
                ThrowHelper.ThrowJsonReaderException(ref this, JsonHelpers.IsInRangeInclusive(value, 48, 57) ? ExceptionResource.InvalidLeadingZeroInNumber : ExceptionResource.ExpectedEndOfDigitNotFound, value);
            }
            return ConsumeNumberResult.OperationIncomplete;
        }

        private ConsumeNumberResult ConsumeIntegerDigitsMultiSegment(ref ReadOnlySpan<byte> data, scoped ref int i)
        {
            byte value = 0;
            int num = 0;
            while (i < data.Length)
            {
                value = data[i];
                if (!JsonHelpers.IsDigit(value))
                {
                    break;
                }
                num++;
                i++;
            }
            if (i >= data.Length)
            {
                if (IsLastSpan)
                {
                    _bytePositionInLine += num;
                    return ConsumeNumberResult.Success;
                }
                while (true)
                {
                    if (!GetNextSpan())
                    {
                        if (IsLastSpan)
                        {
                            _bytePositionInLine += num;
                            return ConsumeNumberResult.Success;
                        }
                        return ConsumeNumberResult.NeedMoreData;
                    }
                    _totalConsumed += i;
                    _bytePositionInLine += num;
                    num = 0;
                    HasValueSequence = true;
                    i = 0;
                    data = _buffer;
                    while (i < data.Length)
                    {
                        value = data[i];
                        if (!JsonHelpers.IsDigit(value))
                        {
                            break;
                        }
                        i++;
                    }
                    _bytePositionInLine += i;
                    if (i < data.Length)
                    {
                        break;
                    }
                    if (IsLastSpan)
                    {
                        return ConsumeNumberResult.Success;
                    }
                }
            }
            else
            {
                _bytePositionInLine += num;
            }
            if (JsonConstants.Delimiters.IndexOf(value) >= 0)
            {
                return ConsumeNumberResult.Success;
            }
            return ConsumeNumberResult.OperationIncomplete;
        }

        private ConsumeNumberResult ConsumeDecimalDigitsMultiSegment(ref ReadOnlySpan<byte> data, scoped ref int i, scoped in PartialStateForRollback rollBackState)
        {
            if (i >= data.Length)
            {
                if (IsLastSpan)
                {
                    RollBackState(in rollBackState, isError: true);
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
                }
                if (!GetNextSpan())
                {
                    if (IsLastSpan)
                    {
                        RollBackState(in rollBackState, isError: true);
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
                    }
                    return ConsumeNumberResult.NeedMoreData;
                }
                _totalConsumed += i;
                HasValueSequence = true;
                i = 0;
                data = _buffer;
            }
            byte b = data[i];
            if (!JsonHelpers.IsDigit(b))
            {
                RollBackState(in rollBackState, isError: true);
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundAfterDecimal, b);
            }
            i++;
            _bytePositionInLine++;
            return ConsumeIntegerDigitsMultiSegment(ref data, ref i);
        }

        private ConsumeNumberResult ConsumeSignMultiSegment(ref ReadOnlySpan<byte> data, scoped ref int i, scoped in PartialStateForRollback rollBackState)
        {
            if (i >= data.Length)
            {
                if (IsLastSpan)
                {
                    RollBackState(in rollBackState, isError: true);
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
                }
                if (!GetNextSpan())
                {
                    if (IsLastSpan)
                    {
                        RollBackState(in rollBackState, isError: true);
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
                    }
                    return ConsumeNumberResult.NeedMoreData;
                }
                _totalConsumed += i;
                HasValueSequence = true;
                i = 0;
                data = _buffer;
            }
            byte b = data[i];
            if (b == 43 || b == 45)
            {
                i++;
                _bytePositionInLine++;
                if (i >= data.Length)
                {
                    if (IsLastSpan)
                    {
                        RollBackState(in rollBackState, isError: true);
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
                    }
                    if (!GetNextSpan())
                    {
                        if (IsLastSpan)
                        {
                            RollBackState(in rollBackState, isError: true);
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundEndOfData, 0);
                        }
                        return ConsumeNumberResult.NeedMoreData;
                    }
                    _totalConsumed += i;
                    HasValueSequence = true;
                    i = 0;
                    data = _buffer;
                }
                b = data[i];
            }
            if (!JsonHelpers.IsDigit(b))
            {
                RollBackState(in rollBackState, isError: true);
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.RequiredDigitNotFoundAfterSign, b);
            }
            return ConsumeNumberResult.OperationIncomplete;
        }

        private bool ConsumeNextTokenOrRollbackMultiSegment(byte marker)
        {
            long totalConsumed = _totalConsumed;
            int consumed = _consumed;
            long bytePositionInLine = _bytePositionInLine;
            long lineNumber = _lineNumber;
            JsonTokenType tokenType = _tokenType;
            SequencePosition currentPosition = _currentPosition;
            bool trailingCommaBeforeComment = _trailingCommaBeforeComment;
            switch (ConsumeNextTokenMultiSegment(marker))
            {
                case ConsumeTokenResult.Success:
                    return true;
                case ConsumeTokenResult.NotEnoughDataRollBackState:
                    _consumed = consumed;
                    _tokenType = tokenType;
                    _bytePositionInLine = bytePositionInLine;
                    _lineNumber = lineNumber;
                    _totalConsumed = totalConsumed;
                    _currentPosition = currentPosition;
                    _trailingCommaBeforeComment = trailingCommaBeforeComment;
                    break;
            }
            return false;
        }

        /// <summary>
        /// This method consumes the next token regardless of whether we are inside an object or an array.
        /// For an object, it reads the next property name token. For an array, it just reads the next value.
        /// </summary>
        private ConsumeTokenResult ConsumeNextTokenMultiSegment(byte marker)
        {
            if (_readerOptions.CommentHandling != 0)
            {
                if (_readerOptions.CommentHandling != JsonCommentHandling.Allow)
                {
                    return ConsumeNextTokenUntilAfterAllCommentsAreSkippedMultiSegment(marker);
                }
                if (marker == 47)
                {
                    if (!SkipOrConsumeCommentMultiSegmentWithRollback())
                    {
                        return ConsumeTokenResult.NotEnoughDataRollBackState;
                    }
                    return ConsumeTokenResult.Success;
                }
                if (_tokenType == JsonTokenType.Comment)
                {
                    return ConsumeNextTokenFromLastNonCommentTokenMultiSegment();
                }
            }
            if (_bitStack.CurrentDepth == 0)
            {
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndAfterSingleJson, marker);
            }
            switch (marker)
            {
                case 44:
                    {
                        _consumed++;
                        _bytePositionInLine++;
                        if (_consumed >= (uint)_buffer.Length)
                        {
                            if (IsLastSpan)
                            {
                                _consumed--;
                                _bytePositionInLine--;
                                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound, 0);
                            }
                            if (!GetNextSpan())
                            {
                                if (IsLastSpan)
                                {
                                    _consumed--;
                                    _bytePositionInLine--;
                                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound, 0);
                                }
                                return ConsumeTokenResult.NotEnoughDataRollBackState;
                            }
                        }
                        byte b = _buffer[_consumed];
                        if (b <= 32)
                        {
                            SkipWhiteSpaceMultiSegment();
                            if (!HasMoreDataMultiSegment(ExceptionResource.ExpectedStartOfPropertyOrValueNotFound))
                            {
                                return ConsumeTokenResult.NotEnoughDataRollBackState;
                            }
                            b = _buffer[_consumed];
                        }
                        TokenStartIndex = BytesConsumed;
                        if (_readerOptions.CommentHandling == JsonCommentHandling.Allow && b == 47)
                        {
                            _trailingCommaBeforeComment = true;
                            if (!SkipOrConsumeCommentMultiSegmentWithRollback())
                            {
                                return ConsumeTokenResult.NotEnoughDataRollBackState;
                            }
                            return ConsumeTokenResult.Success;
                        }
                        if (_inObject)
                        {
                            if (b != 34)
                            {
                                if (b == 125)
                                {
                                    if (_readerOptions.AllowTrailingCommas)
                                    {
                                        EndObject();
                                        return ConsumeTokenResult.Success;
                                    }
                                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeObjectEnd, 0);
                                }
                                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
                            }
                            if (!ConsumePropertyNameMultiSegment())
                            {
                                return ConsumeTokenResult.NotEnoughDataRollBackState;
                            }
                            return ConsumeTokenResult.Success;
                        }
                        if (b == 93)
                        {
                            if (_readerOptions.AllowTrailingCommas)
                            {
                                EndArray();
                                return ConsumeTokenResult.Success;
                            }
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeArrayEnd, 0);
                        }
                        if (!ConsumeValueMultiSegment(b))
                        {
                            return ConsumeTokenResult.NotEnoughDataRollBackState;
                        }
                        return ConsumeTokenResult.Success;
                    }
                case 125:
                    EndObject();
                    break;
                case 93:
                    EndArray();
                    break;
                default:
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.FoundInvalidCharacter, marker);
                    break;
            }
            return ConsumeTokenResult.Success;
        }

        private ConsumeTokenResult ConsumeNextTokenFromLastNonCommentTokenMultiSegment()
        {
            if (JsonReaderHelper.IsTokenTypePrimitive(_previousTokenType))
            {
                _tokenType = (_inObject ? JsonTokenType.StartObject : JsonTokenType.StartArray);
            }
            else
            {
                _tokenType = _previousTokenType;
            }
            if (HasMoreDataMultiSegment())
            {
                byte b = _buffer[_consumed];
                if (b <= 32)
                {
                    SkipWhiteSpaceMultiSegment();
                    if (!HasMoreDataMultiSegment())
                    {
                        goto IL_0393;
                    }
                    b = _buffer[_consumed];
                }
                if (_bitStack.CurrentDepth == 0 && _tokenType != 0)
                {
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndAfterSingleJson, b);
                }
                TokenStartIndex = BytesConsumed;
                if (b != 44)
                {
                    if (b == 125)
                    {
                        EndObject();
                    }
                    else
                    {
                        if (b != 93)
                        {
                            if (_tokenType == JsonTokenType.None)
                            {
                                if (ReadFirstTokenMultiSegment(b))
                                {
                                    goto IL_0391;
                                }
                            }
                            else if (_tokenType == JsonTokenType.StartObject)
                            {
                                if (b != 34)
                                {
                                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
                                }
                                long totalConsumed = _totalConsumed;
                                int consumed = _consumed;
                                long bytePositionInLine = _bytePositionInLine;
                                long lineNumber = _lineNumber;
                                if (ConsumePropertyNameMultiSegment())
                                {
                                    goto IL_0391;
                                }
                                _consumed = consumed;
                                _tokenType = JsonTokenType.StartObject;
                                _bytePositionInLine = bytePositionInLine;
                                _lineNumber = lineNumber;
                                _totalConsumed = totalConsumed;
                            }
                            else if (_tokenType == JsonTokenType.StartArray)
                            {
                                if (ConsumeValueMultiSegment(b))
                                {
                                    goto IL_0391;
                                }
                            }
                            else if (_tokenType == JsonTokenType.PropertyName)
                            {
                                if (ConsumeValueMultiSegment(b))
                                {
                                    goto IL_0391;
                                }
                            }
                            else if (_inObject)
                            {
                                if (b != 34)
                                {
                                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
                                }
                                if (ConsumePropertyNameMultiSegment())
                                {
                                    goto IL_0391;
                                }
                            }
                            else if (ConsumeValueMultiSegment(b))
                            {
                                goto IL_0391;
                            }
                            goto IL_0393;
                        }
                        EndArray();
                    }
                    goto IL_0391;
                }
                if ((int)_previousTokenType <= 1 || _previousTokenType == JsonTokenType.StartArray || _trailingCommaBeforeComment)
                {
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueAfterComment, b);
                }
                _consumed++;
                _bytePositionInLine++;
                if (_consumed >= (uint)_buffer.Length)
                {
                    if (IsLastSpan)
                    {
                        _consumed--;
                        _bytePositionInLine--;
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound, 0);
                    }
                    if (!GetNextSpan())
                    {
                        if (IsLastSpan)
                        {
                            _consumed--;
                            _bytePositionInLine--;
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound, 0);
                        }
                        goto IL_0393;
                    }
                }
                b = _buffer[_consumed];
                if (b <= 32)
                {
                    SkipWhiteSpaceMultiSegment();
                    if (!HasMoreDataMultiSegment(ExceptionResource.ExpectedStartOfPropertyOrValueNotFound))
                    {
                        goto IL_0393;
                    }
                    b = _buffer[_consumed];
                }
                TokenStartIndex = BytesConsumed;
                if (b == 47)
                {
                    _trailingCommaBeforeComment = true;
                    if (SkipOrConsumeCommentMultiSegmentWithRollback())
                    {
                        goto IL_0391;
                    }
                }
                else if (_inObject)
                {
                    if (b != 34)
                    {
                        if (b == 125)
                        {
                            if (_readerOptions.AllowTrailingCommas)
                            {
                                EndObject();
                                goto IL_0391;
                            }
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeObjectEnd, 0);
                        }
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, b);
                    }
                    if (ConsumePropertyNameMultiSegment())
                    {
                        goto IL_0391;
                    }
                }
                else
                {
                    if (b == 93)
                    {
                        if (_readerOptions.AllowTrailingCommas)
                        {
                            EndArray();
                            goto IL_0391;
                        }
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeArrayEnd, 0);
                    }
                    if (ConsumeValueMultiSegment(b))
                    {
                        goto IL_0391;
                    }
                }
            }
            goto IL_0393;
        IL_0393:
            return ConsumeTokenResult.NotEnoughDataRollBackState;
        IL_0391:
            return ConsumeTokenResult.Success;
        }

        private bool SkipAllCommentsMultiSegment(scoped ref byte marker)
        {
            while (true)
            {
                if (marker == 47)
                {
                    if (!SkipOrConsumeCommentMultiSegmentWithRollback() || !HasMoreDataMultiSegment())
                    {
                        break;
                    }
                    marker = _buffer[_consumed];
                    if (marker <= 32)
                    {
                        SkipWhiteSpaceMultiSegment();
                        if (!HasMoreDataMultiSegment())
                        {
                            break;
                        }
                        marker = _buffer[_consumed];
                    }
                    continue;
                }
                return true;
            }
            return false;
        }

        private bool SkipAllCommentsMultiSegment(scoped ref byte marker, ExceptionResource resource)
        {
            while (true)
            {
                if (marker == 47)
                {
                    if (!SkipOrConsumeCommentMultiSegmentWithRollback() || !HasMoreDataMultiSegment(resource))
                    {
                        break;
                    }
                    marker = _buffer[_consumed];
                    if (marker <= 32)
                    {
                        SkipWhiteSpaceMultiSegment();
                        if (!HasMoreDataMultiSegment(resource))
                        {
                            break;
                        }
                        marker = _buffer[_consumed];
                    }
                    continue;
                }
                return true;
            }
            return false;
        }

        private ConsumeTokenResult ConsumeNextTokenUntilAfterAllCommentsAreSkippedMultiSegment(byte marker)
        {
            if (SkipAllCommentsMultiSegment(ref marker))
            {
                TokenStartIndex = BytesConsumed;
                if (_tokenType == JsonTokenType.StartObject)
                {
                    if (marker == 125)
                    {
                        EndObject();
                    }
                    else
                    {
                        if (marker != 34)
                        {
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, marker);
                        }
                        long totalConsumed = _totalConsumed;
                        int consumed = _consumed;
                        long bytePositionInLine = _bytePositionInLine;
                        long lineNumber = _lineNumber;
                        SequencePosition currentPosition = _currentPosition;
                        if (!ConsumePropertyNameMultiSegment())
                        {
                            _consumed = consumed;
                            _tokenType = JsonTokenType.StartObject;
                            _bytePositionInLine = bytePositionInLine;
                            _lineNumber = lineNumber;
                            _totalConsumed = totalConsumed;
                            _currentPosition = currentPosition;
                            goto IL_02e7;
                        }
                    }
                }
                else if (_tokenType == JsonTokenType.StartArray)
                {
                    if (marker == 93)
                    {
                        EndArray();
                    }
                    else if (!ConsumeValueMultiSegment(marker))
                    {
                        goto IL_02e7;
                    }
                }
                else if (_tokenType == JsonTokenType.PropertyName)
                {
                    if (!ConsumeValueMultiSegment(marker))
                    {
                        goto IL_02e7;
                    }
                }
                else if (_bitStack.CurrentDepth == 0)
                {
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedEndAfterSingleJson, marker);
                }
                else
                {
                    switch (marker)
                    {
                        case 44:
                            _consumed++;
                            _bytePositionInLine++;
                            if (_consumed >= (uint)_buffer.Length)
                            {
                                if (IsLastSpan)
                                {
                                    _consumed--;
                                    _bytePositionInLine--;
                                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound, 0);
                                }
                                if (!GetNextSpan())
                                {
                                    if (IsLastSpan)
                                    {
                                        _consumed--;
                                        _bytePositionInLine--;
                                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound, 0);
                                    }
                                    return ConsumeTokenResult.NotEnoughDataRollBackState;
                                }
                            }
                            marker = _buffer[_consumed];
                            if (marker <= 32)
                            {
                                SkipWhiteSpaceMultiSegment();
                                if (!HasMoreDataMultiSegment(ExceptionResource.ExpectedStartOfPropertyOrValueNotFound))
                                {
                                    return ConsumeTokenResult.NotEnoughDataRollBackState;
                                }
                                marker = _buffer[_consumed];
                            }
                            if (SkipAllCommentsMultiSegment(ref marker, ExceptionResource.ExpectedStartOfPropertyOrValueNotFound))
                            {
                                TokenStartIndex = BytesConsumed;
                                if (_inObject)
                                {
                                    if (marker != 34)
                                    {
                                        if (marker == 125)
                                        {
                                            if (_readerOptions.AllowTrailingCommas)
                                            {
                                                EndObject();
                                                break;
                                            }
                                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeObjectEnd, 0);
                                        }
                                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.ExpectedStartOfPropertyNotFound, marker);
                                    }
                                    if (!ConsumePropertyNameMultiSegment())
                                    {
                                        return ConsumeTokenResult.NotEnoughDataRollBackState;
                                    }
                                    return ConsumeTokenResult.Success;
                                }
                                if (marker == 93)
                                {
                                    if (_readerOptions.AllowTrailingCommas)
                                    {
                                        EndArray();
                                        break;
                                    }
                                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.TrailingCommaNotAllowedBeforeArrayEnd, 0);
                                }
                                if (!ConsumeValueMultiSegment(marker))
                                {
                                    return ConsumeTokenResult.NotEnoughDataRollBackState;
                                }
                                return ConsumeTokenResult.Success;
                            }
                            return ConsumeTokenResult.NotEnoughDataRollBackState;
                        case 125:
                            EndObject();
                            break;
                        case 93:
                            EndArray();
                            break;
                        default:
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.FoundInvalidCharacter, marker);
                            break;
                    }
                }
                return ConsumeTokenResult.Success;
            }
            goto IL_02e7;
        IL_02e7:
            return ConsumeTokenResult.IncompleteNoRollBackNecessary;
        }

        private bool SkipOrConsumeCommentMultiSegmentWithRollback()
        {
            long bytesConsumed = BytesConsumed;
            SequencePosition start = new SequencePosition(_currentPosition.GetObject(), _currentPosition.GetInteger() + _consumed);
            int tailBytesToIgnore;
            bool flag = SkipCommentMultiSegment(out tailBytesToIgnore);
            if (flag)
            {
                if (_readerOptions.CommentHandling == JsonCommentHandling.Allow)
                {
                    SequencePosition end = new SequencePosition(_currentPosition.GetObject(), _currentPosition.GetInteger() + _consumed);
                    ReadOnlySequence<byte> readOnlySequence = _sequence.Slice(start, end);
                    readOnlySequence = readOnlySequence.Slice(2L, readOnlySequence.Length - 2 - tailBytesToIgnore);
                    HasValueSequence = !readOnlySequence.IsSingleSegment;
                    if (HasValueSequence)
                    {
                        ValueSequence = readOnlySequence;
                    }
                    else
                    {
                        ValueSpan = readOnlySequence.First.Span;
                    }
                    if (_tokenType != JsonTokenType.Comment)
                    {
                        _previousTokenType = _tokenType;
                    }
                    _tokenType = JsonTokenType.Comment;
                }
            }
            else
            {
                _totalConsumed = bytesConsumed;
                _consumed = 0;
            }
            return flag;
        }

        private bool SkipCommentMultiSegment(out int tailBytesToIgnore)
        {
            _consumed++;
            _bytePositionInLine++;
            ReadOnlySpan<byte> localBuffer = _buffer.Slice(_consumed);
            if (localBuffer.Length == 0)
            {
                if (IsLastSpan)
                {
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.UnexpectedEndOfDataWhileReadingComment, 0);
                }
                if (!GetNextSpan())
                {
                    if (IsLastSpan)
                    {
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.UnexpectedEndOfDataWhileReadingComment, 0);
                    }
                    tailBytesToIgnore = 0;
                    return false;
                }
                localBuffer = _buffer;
            }
            byte b = localBuffer[0];
            if (b != 47 && b != 42)
            {
                ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.InvalidCharacterAtStartOfComment, b);
            }
            bool flag = b == 42;
            _consumed++;
            _bytePositionInLine++;
            localBuffer = localBuffer.Slice(1);
            if (localBuffer.Length == 0)
            {
                if (IsLastSpan)
                {
                    tailBytesToIgnore = 0;
                    if (flag)
                    {
                        ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.UnexpectedEndOfDataWhileReadingComment, 0);
                    }
                    return true;
                }
                if (!GetNextSpan())
                {
                    tailBytesToIgnore = 0;
                    if (IsLastSpan)
                    {
                        if (flag)
                        {
                            ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.UnexpectedEndOfDataWhileReadingComment, 0);
                        }
                        return true;
                    }
                    return false;
                }
                localBuffer = _buffer;
            }
            if (flag)
            {
                tailBytesToIgnore = 2;
                return SkipMultiLineCommentMultiSegment(localBuffer);
            }
            return SkipSingleLineCommentMultiSegment(localBuffer, out tailBytesToIgnore);
        }

        private bool SkipSingleLineCommentMultiSegment(ReadOnlySpan<byte> localBuffer, out int tailBytesToSkip)
        {
            bool flag = false;
            int dangerousLineSeparatorBytesConsumed = 0;
            tailBytesToSkip = 0;
            while (true)
            {
                if (flag)
                {
                    if (localBuffer[0] == 10)
                    {
                        tailBytesToSkip++;
                        _consumed++;
                    }
                    break;
                }
                int num = FindLineSeparatorMultiSegment(localBuffer, ref dangerousLineSeparatorBytesConsumed);
                if (num != -1)
                {
                    tailBytesToSkip++;
                    _consumed += num + 1;
                    _bytePositionInLine += num + 1;
                    if (localBuffer[num] == 10)
                    {
                        break;
                    }
                    if (num < localBuffer.Length - 1)
                    {
                        if (localBuffer[num + 1] == 10)
                        {
                            tailBytesToSkip++;
                            _consumed++;
                            _bytePositionInLine++;
                        }
                        break;
                    }
                    flag = true;
                }
                else
                {
                    _consumed += localBuffer.Length;
                    _bytePositionInLine += localBuffer.Length;
                }
                if (IsLastSpan)
                {
                    if (flag)
                    {
                        break;
                    }
                    return true;
                }
                if (!GetNextSpan())
                {
                    if (IsLastSpan)
                    {
                        if (flag)
                        {
                            break;
                        }
                        return true;
                    }
                    return false;
                }
                localBuffer = _buffer;
            }
            _bytePositionInLine = 0L;
            _lineNumber++;
            return true;
        }

        private int FindLineSeparatorMultiSegment(ReadOnlySpan<byte> localBuffer, scoped ref int dangerousLineSeparatorBytesConsumed)
        {
            if (dangerousLineSeparatorBytesConsumed != 0)
            {
                ThrowOnDangerousLineSeparatorMultiSegment(localBuffer, ref dangerousLineSeparatorBytesConsumed);
                if (dangerousLineSeparatorBytesConsumed != 0)
                {
                    return -1;
                }
            }
            int num = 0;
            do
            {
                int num2 = localBuffer.IndexOfAny<byte>(10, 13, 226);
                dangerousLineSeparatorBytesConsumed = 0;
                if (num2 == -1)
                {
                    return -1;
                }
                if (localBuffer[num2] != 226)
                {
                    return num + num2;
                }
                int num3 = num2 + 1;
                localBuffer = localBuffer.Slice(num3);
                num += num3;
                dangerousLineSeparatorBytesConsumed++;
                ThrowOnDangerousLineSeparatorMultiSegment(localBuffer, ref dangerousLineSeparatorBytesConsumed);
            }
            while (dangerousLineSeparatorBytesConsumed == 0);
            return -1;
        }

        private void ThrowOnDangerousLineSeparatorMultiSegment(ReadOnlySpan<byte> localBuffer, scoped ref int dangerousLineSeparatorBytesConsumed)
        {
            if (localBuffer.IsEmpty)
            {
                return;
            }
            if (dangerousLineSeparatorBytesConsumed == 1)
            {
                if (localBuffer[0] != 128)
                {
                    dangerousLineSeparatorBytesConsumed = 0;
                    return;
                }
                localBuffer = localBuffer.Slice(1);
                dangerousLineSeparatorBytesConsumed++;
                if (localBuffer.IsEmpty)
                {
                    return;
                }
            }
            if (dangerousLineSeparatorBytesConsumed == 2)
            {
                byte b = localBuffer[0];
                if (b == 168 || b == 169)
                {
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.UnexpectedEndOfLineSeparator, 0);
                }
                else
                {
                    dangerousLineSeparatorBytesConsumed = 0;
                }
            }
        }

        private bool SkipMultiLineCommentMultiSegment(ReadOnlySpan<byte> localBuffer)
        {
            bool flag = false;
            bool flag2 = false;
            while (true)
            {
                if (flag)
                {
                    if (localBuffer[0] == 47)
                    {
                        _consumed++;
                        _bytePositionInLine++;
                        return true;
                    }
                    flag = false;
                }
                if (flag2)
                {
                    if (localBuffer[0] == 10)
                    {
                        _consumed++;
                        localBuffer = localBuffer.Slice(1);
                    }
                    flag2 = false;
                }
                int num = localBuffer.IndexOfAny<byte>(42, 10, 13);
                if (num != -1)
                {
                    int num2 = num + 1;
                    byte b = localBuffer[num];
                    localBuffer = localBuffer.Slice(num2);
                    _consumed += num2;
                    switch (b)
                    {
                        case 42:
                            flag = true;
                            _bytePositionInLine += num2;
                            break;
                        case 10:
                            _bytePositionInLine = 0L;
                            _lineNumber++;
                            break;
                        default:
                            _bytePositionInLine = 0L;
                            _lineNumber++;
                            flag2 = true;
                            break;
                    }
                }
                else
                {
                    _consumed += localBuffer.Length;
                    _bytePositionInLine += localBuffer.Length;
                    localBuffer = ReadOnlySpan<byte>.Empty;
                }
                if (!localBuffer.IsEmpty)
                {
                    continue;
                }
                if (IsLastSpan)
                {
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.UnexpectedEndOfDataWhileReadingComment, 0);
                }
                if (!GetNextSpan())
                {
                    if (!IsLastSpan)
                    {
                        break;
                    }
                    ThrowHelper.ThrowJsonReaderException(ref this, ExceptionResource.UnexpectedEndOfDataWhileReadingComment, 0);
                }
                localBuffer = _buffer;
            }
            return false;
        }

        private PartialStateForRollback CaptureState()
        {
            return new PartialStateForRollback(_totalConsumed, _bytePositionInLine, _consumed, _currentPosition);
        }

        /// <summary>
        /// Parses the current JSON token value from the source, unescaped, and transcoded as a <see cref="T:System.String" />.
        /// </summary>
        /// <remarks>
        /// Returns <see langword="null" /> when <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> is <see cref="F:System.Text.Json.JsonTokenType.Null" />.
        /// </remarks>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of the JSON token that is not a string
        /// (i.e. other than <see cref="F:System.Text.Json.JsonTokenType.String" />, <see cref="F:System.Text.Json.JsonTokenType.PropertyName" /> or
        /// <see cref="F:System.Text.Json.JsonTokenType.Null" />).
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// It will also throw when the JSON string contains invalid UTF-8 bytes, or invalid UTF-16 surrogates.
        /// </exception>
        public string? GetString()
        {
            if (TokenType == JsonTokenType.Null)
            {
                return null;
            }
            if (TokenType != JsonTokenType.String && TokenType != JsonTokenType.PropertyName)
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedString(TokenType);
            }
            ReadOnlySpan<byte> readOnlySpan;
            if (!HasValueSequence)
            {
                readOnlySpan = ValueSpan;
            }
            else
            {
                ReadOnlySequence<byte> sequence = ValueSequence;
                readOnlySpan = BuffersExtensions.ToArray(in sequence);
            }
            ReadOnlySpan<byte> readOnlySpan2 = readOnlySpan;
            if (ValueIsEscaped)
            {
                return JsonReaderHelper.GetUnescapedString(readOnlySpan2);
            }
            return JsonReaderHelper.TranscodeHelper(readOnlySpan2);
        }

        /// <summary>
        /// Copies the current JSON token value from the source, unescaped as a UTF-8 string to the destination buffer.
        /// </summary>
        /// <param name="utf8Destination">A buffer to write the unescaped UTF-8 bytes into.</param>
        /// <returns>The number of bytes written to <paramref name="utf8Destination" />.</returns>
        /// <remarks>
        /// Unlike <see cref="M:System.Text.Json.Utf8JsonReader.GetString" />, this method does not support <see cref="F:System.Text.Json.JsonTokenType.Null" />.
        ///
        /// This method will throw <see cref="System.ArgumentException" /> if the destination buffer is too small to hold the unescaped value.
        /// An appropriately sized buffer can be determined by consulting the length of either <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> or <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" />,
        /// since the unescaped result is always less than or equal to the length of the encoded strings.
        /// </remarks>
        /// <exception cref="System.InvalidOperationException">
        /// Thrown if trying to get the value of the JSON token that is not a string
        /// (i.e. other than <see cref="System.Text.Json.JsonTokenType.String" /> or <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />.
        /// <seealso cref="System.Text.Json.Utf8JsonReader.TokenType" />
        /// It will also throw when the JSON string contains invalid UTF-8 bytes, or invalid UTF-16 surrogates.
        /// </exception>
        /// <exception cref="System.ArgumentException">The destination buffer is too small to hold the unescaped value.</exception>
        public readonly int CopyString(Span<byte> utf8Destination)
        {
            JsonTokenType tokenType = _tokenType;
            if (tokenType != JsonTokenType.String && tokenType != JsonTokenType.PropertyName)
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedString(_tokenType);
            }
            int bytesWritten;
            if (ValueIsEscaped)
            {
                if (!TryCopyEscapedString(utf8Destination, out bytesWritten))
                {
                    utf8Destination.Slice(0, bytesWritten).Clear();
                    ThrowHelper.ThrowArgumentException_DestinationTooShort();
                }
            }
            else if (HasValueSequence)
            {
                ReadOnlySequence<byte> source = ValueSequence;
                source.CopyTo(utf8Destination);
                bytesWritten = (int)source.Length;
            }
            else
            {
                ReadOnlySpan<byte> valueSpan = ValueSpan;
                valueSpan.CopyTo(utf8Destination);
                bytesWritten = valueSpan.Length;
            }
            JsonReaderHelper.ValidateUtf8(utf8Destination.Slice(0, bytesWritten));
            return bytesWritten;
        }

        /// <summary>
        /// Copies the current JSON token value from the source, unescaped, and transcoded as a UTF-16 char buffer.
        /// </summary>
        /// <param name="destination">A buffer to write the transcoded UTF-16 characters into.</param>
        /// <returns>The number of characters written to <paramref name="destination" />.</returns>
        /// <remarks>
        /// Unlike <see cref="M:System.Text.Json.Utf8JsonReader.GetString" />, this method does not support <see cref="F:System.Text.Json.JsonTokenType.Null" />.
        ///
        /// This method will throw <see cref="T:System.ArgumentException" /> if the destination buffer is too small to hold the unescaped value.
        /// An appropriately sized buffer can be determined by consulting the length of either <see cref="P:System.Text.Json.Utf8JsonReader.ValueSpan" /> or <see cref="P:System.Text.Json.Utf8JsonReader.ValueSequence" />,
        /// since the unescaped result is always less than or equal to the length of the encoded strings.
        /// </remarks>
        /// <exception cref="System.InvalidOperationException">
        /// Thrown if trying to get the value of the JSON token that is not a string
        /// (i.e. other than <see cref="System.Text.Json.JsonTokenType.String" /> or <see cref="F:System.Text.Json.JsonTokenType.PropertyName" />.
        /// <seealso cref="System.Text.Json.Utf8JsonReader.TokenType" />
        /// It will also throw when the JSON string contains invalid UTF-8 bytes, or invalid UTF-16 surrogates.
        /// </exception>
        /// <exception cref="System.ArgumentException">The destination buffer is too small to hold the unescaped value.</exception>
        public readonly int CopyString(Span<char> destination)
        {
            if (_tokenType is not (JsonTokenType.String or JsonTokenType.PropertyName))
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedString(_tokenType);
            }

            scoped ReadOnlySpan<byte> unescapedSource;
            byte[]? rentedBuffer = null;
            int valueLength;

            if (ValueIsEscaped)
            {
                valueLength = ValueLength;

                Span<byte> unescapedBuffer = valueLength <= JsonConstants.StackallocByteThreshold ?
                    stackalloc byte[JsonConstants.StackallocByteThreshold] :
                    (rentedBuffer = ArrayPool<byte>.Shared.Rent(valueLength));

                bool success = TryCopyEscapedString(unescapedBuffer, out int bytesWritten);
                Debug.Assert(success);
                unescapedSource = unescapedBuffer.Slice(0, bytesWritten);
            }
            else
            {
                if (HasValueSequence)
                {
                    ReadOnlySequence<byte> valueSequence = ValueSequence;
                    valueLength = checked((int)valueSequence.Length);

                    Span<byte> intermediate = valueLength <= JsonConstants.StackallocByteThreshold ?
                        stackalloc byte[JsonConstants.StackallocByteThreshold] :
                        (rentedBuffer = ArrayPool<byte>.Shared.Rent(valueLength));

                    valueSequence.CopyTo(intermediate);
                    unescapedSource = intermediate.Slice(0, valueLength);
                }
                else
                {
                    unescapedSource = ValueSpan;
                }
            }

            int charsWritten = JsonReaderHelper.TranscodeHelper(unescapedSource, destination);

            if (rentedBuffer != null)
            {
                new Span<byte>(rentedBuffer, 0, unescapedSource.Length).Clear();
                ArrayPool<byte>.Shared.Return(rentedBuffer);
            }

            return charsWritten;
        }

        private readonly bool TryCopyEscapedString(Span<byte> destination, out int bytesWritten)
        {
            Debug.Assert(_tokenType is JsonTokenType.String or JsonTokenType.PropertyName);
            Debug.Assert(ValueIsEscaped);

            byte[]? rentedBuffer = null;
            scoped ReadOnlySpan<byte> source;

            if (HasValueSequence)
            {
                ReadOnlySequence<byte> valueSequence = ValueSequence;
                int sequenceLength = checked((int)valueSequence.Length);

                Span<byte> intermediate = sequenceLength <= JsonConstants.StackallocByteThreshold ?
                    stackalloc byte[JsonConstants.StackallocByteThreshold] :
                    (rentedBuffer = ArrayPool<byte>.Shared.Rent(sequenceLength));

                valueSequence.CopyTo(intermediate);
                source = intermediate.Slice(0, sequenceLength);
            }
            else
            {
                source = ValueSpan;
            }

            bool success = JsonReaderHelper.TryUnescape(source, destination, out bytesWritten);

            if (rentedBuffer != null)
            {
                new Span<byte>(rentedBuffer, 0, source.Length).Clear();
                ArrayPool<byte>.Shared.Return(rentedBuffer);
            }

            Debug.Assert(bytesWritten < source.Length, "source buffer must contain at least one escape sequence");
            return success;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a comment, transcoded as a <see cref="T:System.String" />.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of the JSON token that is not a comment.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        public string GetComment()
        {
            if (TokenType != JsonTokenType.Comment)
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedComment(TokenType);
            }
            ReadOnlySpan<byte> readOnlySpan;
            if (!HasValueSequence)
            {
                readOnlySpan = ValueSpan;
            }
            else
            {
                ReadOnlySequence<byte> sequence = ValueSequence;
                readOnlySpan = BuffersExtensions.ToArray(in sequence);
            }
            ReadOnlySpan<byte> utf8Unescaped = readOnlySpan;
            return JsonReaderHelper.TranscodeHelper(utf8Unescaped);
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.Boolean" />.
        /// Returns <see langword="true" /> if the TokenType is JsonTokenType.True and <see langword="false" /> if the TokenType is JsonTokenType.False.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a boolean (i.e. <see cref="F:System.Text.Json.JsonTokenType.True" /> or <see cref="F:System.Text.Json.JsonTokenType.False" />).
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        public bool GetBoolean()
        {
            switch (TokenType)
            {
                case JsonTokenType.True:
                    return true;
                default:
                    ThrowHelper.ThrowInvalidOperationException_ExpectedBoolean(TokenType);
                    break;
                case JsonTokenType.False:
                    break;
            }
            return false;
        }

        /// <summary>
        /// Parses the current JSON token value from the source and decodes the Base64 encoded JSON string as bytes.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.String" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        /// <exception cref="T:System.FormatException">
        /// The JSON string contains data outside of the expected Base64 range, or if it contains invalid/more than two padding characters,
        /// or is incomplete (i.e. the JSON string length is not a multiple of 4).
        /// </exception>
        public byte[] GetBytesFromBase64()
        {
            if (!TryGetBytesFromBase64(out byte[] value))
            {
                ThrowHelper.ThrowFormatException(DataType.Base64String);
            }
            return value;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.Byte" />.
        /// Returns the value if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Byte" />
        /// value.
        /// Throws exceptions otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        /// <exception cref="T:System.FormatException">
        /// Thrown if the JSON token value is either of incorrect numeric format (for example if it contains a decimal or
        /// is written in scientific notation) or, it represents a number less than <see cref="F:System.Byte.MinValue" /> or greater
        /// than <see cref="F:System.Byte.MaxValue" />.
        /// </exception>
        public byte GetByte()
        {
            if (!TryGetByte(out var value))
            {
                ThrowHelper.ThrowFormatException(NumericType.Byte);
            }
            return value;
        }

        internal byte GetByteWithQuotes()
        {
            ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
            if (!TryGetByteCore(out var value, unescapedSpan))
            {
                ThrowHelper.ThrowFormatException(NumericType.Byte);
            }
            return value;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as an <see cref="T:System.SByte" />.
        /// Returns the value if the entire UTF-8 encoded token value can be successfully parsed to an <see cref="T:System.SByte" />
        /// value.
        /// Throws exceptions otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        /// <exception cref="T:System.FormatException">
        /// Thrown if the JSON token value is either of incorrect numeric format (for example if it contains a decimal or
        /// is written in scientific notation) or, it represents a number less than <see cref="F:System.SByte.MinValue" /> or greater
        /// than <see cref="F:System.SByte.MaxValue" />.
        /// </exception>
        [CLSCompliant(false)]
        public sbyte GetSByte()
        {
            if (!TryGetSByte(out var value))
            {
                ThrowHelper.ThrowFormatException(NumericType.SByte);
            }
            return value;
        }

        internal sbyte GetSByteWithQuotes()
        {
            ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
            if (!TryGetSByteCore(out var value, unescapedSpan))
            {
                ThrowHelper.ThrowFormatException(NumericType.SByte);
            }
            return value;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.Int16" />.
        /// Returns the value if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Int16" />
        /// value.
        /// Throws exceptions otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        /// <exception cref="T:System.FormatException">
        /// Thrown if the JSON token value is either of incorrect numeric format (for example if it contains a decimal or
        /// is written in scientific notation) or, it represents a number less than <see cref="F:System.Int16.MinValue" /> or greater
        /// than <see cref="F:System.Int16.MaxValue" />.
        /// </exception>
        public short GetInt16()
        {
            if (!TryGetInt16(out var value))
            {
                ThrowHelper.ThrowFormatException(NumericType.Int16);
            }
            return value;
        }

        internal short GetInt16WithQuotes()
        {
            ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
            if (!TryGetInt16Core(out var value, unescapedSpan))
            {
                ThrowHelper.ThrowFormatException(NumericType.Int16);
            }
            return value;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as an <see cref="T:System.Int32" />.
        /// Returns the value if the entire UTF-8 encoded token value can be successfully parsed to an <see cref="T:System.Int32" />
        /// value.
        /// Throws exceptions otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        /// <exception cref="T:System.FormatException">
        /// Thrown if the JSON token value is either of incorrect numeric format (for example if it contains a decimal or
        /// is written in scientific notation) or, it represents a number less than <see cref="F:System.Int32.MinValue" /> or greater
        /// than <see cref="F:System.Int32.MaxValue" />.
        /// </exception>
        public int GetInt32()
        {
            if (!TryGetInt32(out var value))
            {
                ThrowHelper.ThrowFormatException(NumericType.Int32);
            }
            return value;
        }

        internal int GetInt32WithQuotes()
        {
            ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
            if (!TryGetInt32Core(out var value, unescapedSpan))
            {
                ThrowHelper.ThrowFormatException(NumericType.Int32);
            }
            return value;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.Int64" />.
        /// Returns the value if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Int64" />
        /// value.
        /// Throws exceptions otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        /// <exception cref="T:System.FormatException">
        /// Thrown if the JSON token value is either of incorrect numeric format (for example if it contains a decimal or
        /// is written in scientific notation) or, it represents a number less than <see cref="F:System.Int64.MinValue" /> or greater
        /// than <see cref="F:System.Int64.MaxValue" />.
        /// </exception>
        public long GetInt64()
        {
            if (!TryGetInt64(out var value))
            {
                ThrowHelper.ThrowFormatException(NumericType.Int64);
            }
            return value;
        }

        internal long GetInt64WithQuotes()
        {
            ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
            if (!TryGetInt64Core(out var value, unescapedSpan))
            {
                ThrowHelper.ThrowFormatException(NumericType.Int64);
            }
            return value;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.UInt16" />.
        /// Returns the value if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.UInt16" />
        /// value.
        /// Throws exceptions otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        /// <exception cref="T:System.FormatException">
        /// Thrown if the JSON token value is either of incorrect numeric format (for example if it contains a decimal or
        /// is written in scientific notation) or, it represents a number less than <see cref="F:System.UInt16.MinValue" /> or greater
        /// than <see cref="F:System.UInt16.MaxValue" />.
        /// </exception>
        [CLSCompliant(false)]
        public ushort GetUInt16()
        {
            if (!TryGetUInt16(out var value))
            {
                ThrowHelper.ThrowFormatException(NumericType.UInt16);
            }
            return value;
        }

        internal ushort GetUInt16WithQuotes()
        {
            ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
            if (!TryGetUInt16Core(out var value, unescapedSpan))
            {
                ThrowHelper.ThrowFormatException(NumericType.UInt16);
            }
            return value;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.UInt32" />.
        /// Returns the value if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.UInt32" />
        /// value.
        /// Throws exceptions otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        /// <exception cref="T:System.FormatException">
        /// Thrown if the JSON token value is either of incorrect numeric format (for example if it contains a decimal or
        /// is written in scientific notation) or, it represents a number less than <see cref="F:System.UInt32.MinValue" /> or greater
        /// than <see cref="F:System.UInt32.MaxValue" />.
        /// </exception>
        [CLSCompliant(false)]
        public uint GetUInt32()
        {
            if (!TryGetUInt32(out var value))
            {
                ThrowHelper.ThrowFormatException(NumericType.UInt32);
            }
            return value;
        }

        internal uint GetUInt32WithQuotes()
        {
            ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
            if (!TryGetUInt32Core(out var value, unescapedSpan))
            {
                ThrowHelper.ThrowFormatException(NumericType.UInt32);
            }
            return value;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.UInt64" />.
        /// Returns the value if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.UInt64" />
        /// value.
        /// Throws exceptions otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        /// <exception cref="T:System.FormatException">
        /// Thrown if the JSON token value is either of incorrect numeric format (for example if it contains a decimal or
        /// is written in scientific notation) or, it represents a number less than <see cref="F:System.UInt64.MinValue" /> or greater
        /// than <see cref="F:System.UInt64.MaxValue" />.
        /// </exception>
        [CLSCompliant(false)]
        public ulong GetUInt64()
        {
            if (!TryGetUInt64(out var value))
            {
                ThrowHelper.ThrowFormatException(NumericType.UInt64);
            }
            return value;
        }

        internal ulong GetUInt64WithQuotes()
        {
            ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
            if (!TryGetUInt64Core(out var value, unescapedSpan))
            {
                ThrowHelper.ThrowFormatException(NumericType.UInt64);
            }
            return value;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.Single" />.
        /// Returns the value if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Single" />
        /// value.
        /// Throws exceptions otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        /// <exception cref="T:System.FormatException">
        /// On any framework that is not .NET Core 3.0 or higher, thrown if the JSON token value represents a number less than <see cref="F:System.Single.MinValue" /> or greater
        /// than <see cref="F:System.Single.MaxValue" />.
        /// </exception>
        public float GetSingle()
        {
            if (!TryGetSingle(out var value))
            {
                ThrowHelper.ThrowFormatException(NumericType.Single);
            }
            return value;
        }

        internal float GetSingleWithQuotes()
        {
            ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
            if (JsonReaderHelper.TryGetFloatingPointConstant(unescapedSpan, out float value))
            {
                return value;
            }
            if (!Utf8Parser.TryParse(unescapedSpan, out value, out int bytesConsumed, '\0') || unescapedSpan.Length != bytesConsumed || !JsonHelpers.IsFinite(value))
            {
                ThrowHelper.ThrowFormatException(NumericType.Single);
            }
            return value;
        }

        internal float GetSingleFloatingPointConstant()
        {
            ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
            if (!JsonReaderHelper.TryGetFloatingPointConstant(unescapedSpan, out float value))
            {
                ThrowHelper.ThrowFormatException(NumericType.Single);
            }
            return value;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.Double" />.
        /// Returns the value if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Double" />
        /// value.
        /// Throws exceptions otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        /// <exception cref="T:System.FormatException">
        /// On any framework that is not .NET Core 3.0 or higher, thrown if the JSON token value represents a number less than <see cref="F:System.Double.MinValue" /> or greater
        /// than <see cref="F:System.Double.MaxValue" />.
        /// </exception>
        public double GetDouble()
        {
            if (!TryGetDouble(out var value))
            {
                ThrowHelper.ThrowFormatException(NumericType.Double);
            }
            return value;
        }

        internal double GetDoubleWithQuotes()
        {
            ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
            if (JsonReaderHelper.TryGetFloatingPointConstant(unescapedSpan, out double value))
            {
                return value;
            }
            if (!Utf8Parser.TryParse(unescapedSpan, out value, out int bytesConsumed, '\0') || unescapedSpan.Length != bytesConsumed || !JsonHelpers.IsFinite(value))
            {
                ThrowHelper.ThrowFormatException(NumericType.Double);
            }
            return value;
        }

        internal double GetDoubleFloatingPointConstant()
        {
            ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
            if (!JsonReaderHelper.TryGetFloatingPointConstant(unescapedSpan, out double value))
            {
                ThrowHelper.ThrowFormatException(NumericType.Double);
            }
            return value;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.Decimal" />.
        /// Returns the value if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Decimal" />
        /// value.
        /// Throws exceptions otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        /// <exception cref="T:System.FormatException">
        /// Thrown if the JSON token value represents a number less than <see cref="F:System.Decimal.MinValue" /> or greater
        /// than <see cref="F:System.Decimal.MaxValue" />.
        /// </exception>
        public decimal GetDecimal()
        {
            if (!TryGetDecimal(out var value))
            {
                ThrowHelper.ThrowFormatException(NumericType.Decimal);
            }
            return value;
        }

        internal decimal GetDecimalWithQuotes()
        {
            ReadOnlySpan<byte> unescapedSpan = GetUnescapedSpan();
            if (!TryGetDecimalCore(out var value, unescapedSpan))
            {
                ThrowHelper.ThrowFormatException(NumericType.Decimal);
            }
            return value;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.DateTime" />.
        /// Returns the value if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.DateTime" />
        /// value.
        /// Throws exceptions otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.String" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        /// <exception cref="T:System.FormatException">
        /// Thrown if the JSON token value is of an unsupported format. Only a subset of ISO 8601 formats are supported.
        /// </exception>
        public DateTime GetDateTime()
        {
            if (!TryGetDateTime(out var value))
            {
                ThrowHelper.ThrowFormatException(DataType.DateTime);
            }
            return value;
        }

        internal DateTime GetDateTimeNoValidation()
        {
            if (!TryGetDateTimeCore(out var value))
            {
                ThrowHelper.ThrowFormatException(DataType.DateTime);
            }
            return value;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.DateTimeOffset" />.
        /// Returns the value if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.DateTimeOffset" />
        /// value.
        /// Throws exceptions otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.String" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        /// <exception cref="T:System.FormatException">
        /// Thrown if the JSON token value is of an unsupported format. Only a subset of ISO 8601 formats are supported.
        /// </exception>
        public DateTimeOffset GetDateTimeOffset()
        {
            if (!TryGetDateTimeOffset(out var value))
            {
                ThrowHelper.ThrowFormatException(DataType.DateTimeOffset);
            }
            return value;
        }

        internal DateTimeOffset GetDateTimeOffsetNoValidation()
        {
            if (!TryGetDateTimeOffsetCore(out var value))
            {
                ThrowHelper.ThrowFormatException(DataType.DateTimeOffset);
            }
            return value;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.Guid" />.
        /// Returns the value if the entire UTF-8 encoded token value can be successfully parsed to a <see cref="T:System.Guid" />
        /// value.
        /// Throws exceptions otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.String" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        /// <exception cref="T:System.FormatException">
        /// Thrown if the JSON token value is of an unsupported format for a Guid.
        /// </exception>
        public Guid GetGuid()
        {
            if (!TryGetGuid(out var value))
            {
                ThrowHelper.ThrowFormatException(DataType.Guid);
            }
            return value;
        }

        internal Guid GetGuidNoValidation()
        {
            if (!TryGetGuidCore(out var value))
            {
                ThrowHelper.ThrowFormatException(DataType.Guid);
            }
            return value;
        }

        /// <summary>
        /// Parses the current JSON token value from the source and decodes the Base64 encoded JSON string as bytes.
        /// Returns <see langword="true" /> if the entire token value is encoded as valid Base64 text and can be successfully
        /// decoded to bytes.
        /// Returns <see langword="false" /> otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.String" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        public bool TryGetBytesFromBase64([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out byte[]? value)
        {
            if (TokenType != JsonTokenType.String)
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedString(TokenType);
            }
            ReadOnlySpan<byte> readOnlySpan;
            if (!HasValueSequence)
            {
                readOnlySpan = ValueSpan;
            }
            else
            {
                ReadOnlySequence<byte> sequence = ValueSequence;
                readOnlySpan = BuffersExtensions.ToArray(in sequence);
            }
            ReadOnlySpan<byte> readOnlySpan2 = readOnlySpan;
            if (ValueIsEscaped)
            {
                return JsonReaderHelper.TryGetUnescapedBase64Bytes(readOnlySpan2, out value);
            }
            return JsonReaderHelper.TryDecodeBase64(readOnlySpan2, out value);
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.Byte" />.
        /// Returns <see langword="true" /> if the entire UTF-8 encoded token value can be successfully
        /// parsed to a <see cref="T:System.Byte" /> value.
        /// Returns <see langword="false" /> otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        public bool TryGetByte(out byte value)
        {
            if (TokenType != JsonTokenType.Number)
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
            }
            ReadOnlySpan<byte> readOnlySpan;
            if (!HasValueSequence)
            {
                readOnlySpan = ValueSpan;
            }
            else
            {
                ReadOnlySequence<byte> sequence = ValueSequence;
                readOnlySpan = BuffersExtensions.ToArray(in sequence);
            }
            ReadOnlySpan<byte> span = readOnlySpan;
            return TryGetByteCore(out value, span);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool TryGetByteCore(out byte value, ReadOnlySpan<byte> span)
        {
            if (Utf8Parser.TryParse(span, out byte value2, out int bytesConsumed, '\0') && span.Length == bytesConsumed)
            {
                value = value2;
                return true;
            }
            value = 0;
            return false;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as an <see cref="T:System.SByte" />.
        /// Returns <see langword="true" /> if the entire UTF-8 encoded token value can be successfully
        /// parsed to an <see cref="T:System.SByte" /> value.
        /// Returns <see langword="false" /> otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        [CLSCompliant(false)]
        public bool TryGetSByte(out sbyte value)
        {
            if (TokenType != JsonTokenType.Number)
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
            }
            ReadOnlySpan<byte> readOnlySpan;
            if (!HasValueSequence)
            {
                readOnlySpan = ValueSpan;
            }
            else
            {
                ReadOnlySequence<byte> sequence = ValueSequence;
                readOnlySpan = BuffersExtensions.ToArray(in sequence);
            }
            ReadOnlySpan<byte> span = readOnlySpan;
            return TryGetSByteCore(out value, span);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool TryGetSByteCore(out sbyte value, ReadOnlySpan<byte> span)
        {
            if (Utf8Parser.TryParse(span, out sbyte value2, out int bytesConsumed, '\0') && span.Length == bytesConsumed)
            {
                value = value2;
                return true;
            }
            value = 0;
            return false;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.Int16" />.
        /// Returns <see langword="true" /> if the entire UTF-8 encoded token value can be successfully
        /// parsed to a <see cref="T:System.Int16" /> value.
        /// Returns <see langword="false" /> otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        public bool TryGetInt16(out short value)
        {
            if (TokenType != JsonTokenType.Number)
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
            }
            ReadOnlySpan<byte> readOnlySpan;
            if (!HasValueSequence)
            {
                readOnlySpan = ValueSpan;
            }
            else
            {
                ReadOnlySequence<byte> sequence = ValueSequence;
                readOnlySpan = BuffersExtensions.ToArray(in sequence);
            }
            ReadOnlySpan<byte> span = readOnlySpan;
            return TryGetInt16Core(out value, span);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool TryGetInt16Core(out short value, ReadOnlySpan<byte> span)
        {
            if (Utf8Parser.TryParse(span, out short value2, out int bytesConsumed, '\0') && span.Length == bytesConsumed)
            {
                value = value2;
                return true;
            }
            value = 0;
            return false;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as an <see cref="T:System.Int32" />.
        /// Returns <see langword="true" /> if the entire UTF-8 encoded token value can be successfully
        /// parsed to an <see cref="T:System.Int32" /> value.
        /// Returns <see langword="false" /> otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        public bool TryGetInt32(out int value)
        {
            if (TokenType != JsonTokenType.Number)
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
            }
            ReadOnlySpan<byte> readOnlySpan;
            if (!HasValueSequence)
            {
                readOnlySpan = ValueSpan;
            }
            else
            {
                ReadOnlySequence<byte> sequence = ValueSequence;
                readOnlySpan = BuffersExtensions.ToArray(in sequence);
            }
            ReadOnlySpan<byte> span = readOnlySpan;
            return TryGetInt32Core(out value, span);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool TryGetInt32Core(out int value, ReadOnlySpan<byte> span)
        {
            if (Utf8Parser.TryParse(span, out int value2, out int bytesConsumed, '\0') && span.Length == bytesConsumed)
            {
                value = value2;
                return true;
            }
            value = 0;
            return false;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.Int64" />.
        /// Returns <see langword="true" /> if the entire UTF-8 encoded token value can be successfully
        /// parsed to a <see cref="T:System.Int64" /> value.
        /// Returns <see langword="false" /> otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        public bool TryGetInt64(out long value)
        {
            if (TokenType != JsonTokenType.Number)
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
            }
            ReadOnlySpan<byte> readOnlySpan;
            if (!HasValueSequence)
            {
                readOnlySpan = ValueSpan;
            }
            else
            {
                ReadOnlySequence<byte> sequence = ValueSequence;
                readOnlySpan = BuffersExtensions.ToArray(in sequence);
            }
            ReadOnlySpan<byte> span = readOnlySpan;
            return TryGetInt64Core(out value, span);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool TryGetInt64Core(out long value, ReadOnlySpan<byte> span)
        {
            if (Utf8Parser.TryParse(span, out long value2, out int bytesConsumed, '\0') && span.Length == bytesConsumed)
            {
                value = value2;
                return true;
            }
            value = 0L;
            return false;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.UInt16" />.
        /// Returns <see langword="true" /> if the entire UTF-8 encoded token value can be successfully
        /// parsed to a <see cref="T:System.UInt16" /> value.
        /// Returns <see langword="false" /> otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        [CLSCompliant(false)]
        public bool TryGetUInt16(out ushort value)
        {
            if (TokenType != JsonTokenType.Number)
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
            }
            ReadOnlySpan<byte> readOnlySpan;
            if (!HasValueSequence)
            {
                readOnlySpan = ValueSpan;
            }
            else
            {
                ReadOnlySequence<byte> sequence = ValueSequence;
                readOnlySpan = BuffersExtensions.ToArray(in sequence);
            }
            ReadOnlySpan<byte> span = readOnlySpan;
            return TryGetUInt16Core(out value, span);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool TryGetUInt16Core(out ushort value, ReadOnlySpan<byte> span)
        {
            if (Utf8Parser.TryParse(span, out ushort value2, out int bytesConsumed, '\0') && span.Length == bytesConsumed)
            {
                value = value2;
                return true;
            }
            value = 0;
            return false;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.UInt32" />.
        /// Returns <see langword="true" /> if the entire UTF-8 encoded token value can be successfully
        /// parsed to a <see cref="T:System.UInt32" /> value.
        /// Returns <see langword="false" /> otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        [CLSCompliant(false)]
        public bool TryGetUInt32(out uint value)
        {
            if (TokenType != JsonTokenType.Number)
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
            }
            ReadOnlySpan<byte> readOnlySpan;
            if (!HasValueSequence)
            {
                readOnlySpan = ValueSpan;
            }
            else
            {
                ReadOnlySequence<byte> sequence = ValueSequence;
                readOnlySpan = BuffersExtensions.ToArray(in sequence);
            }
            ReadOnlySpan<byte> span = readOnlySpan;
            return TryGetUInt32Core(out value, span);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool TryGetUInt32Core(out uint value, ReadOnlySpan<byte> span)
        {
            if (Utf8Parser.TryParse(span, out uint value2, out int bytesConsumed, '\0') && span.Length == bytesConsumed)
            {
                value = value2;
                return true;
            }
            value = 0u;
            return false;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.UInt64" />.
        /// Returns <see langword="true" /> if the entire UTF-8 encoded token value can be successfully
        /// parsed to a <see cref="T:System.UInt64" /> value.
        /// Returns <see langword="false" /> otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        [CLSCompliant(false)]
        public bool TryGetUInt64(out ulong value)
        {
            if (TokenType != JsonTokenType.Number)
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
            }
            ReadOnlySpan<byte> readOnlySpan;
            if (!HasValueSequence)
            {
                readOnlySpan = ValueSpan;
            }
            else
            {
                ReadOnlySequence<byte> sequence = ValueSequence;
                readOnlySpan = BuffersExtensions.ToArray(in sequence);
            }
            ReadOnlySpan<byte> span = readOnlySpan;
            return TryGetUInt64Core(out value, span);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool TryGetUInt64Core(out ulong value, ReadOnlySpan<byte> span)
        {
            if (Utf8Parser.TryParse(span, out ulong value2, out int bytesConsumed, '\0') && span.Length == bytesConsumed)
            {
                value = value2;
                return true;
            }
            value = 0uL;
            return false;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.Single" />.
        /// Returns <see langword="true" /> if the entire UTF-8 encoded token value can be successfully
        /// parsed to a <see cref="T:System.Single" /> value.
        /// Returns <see langword="false" /> otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        public bool TryGetSingle(out float value)
        {
            if (TokenType != JsonTokenType.Number)
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
            }
            ReadOnlySpan<byte> readOnlySpan;
            if (!HasValueSequence)
            {
                readOnlySpan = ValueSpan;
            }
            else
            {
                ReadOnlySequence<byte> sequence = ValueSequence;
                readOnlySpan = BuffersExtensions.ToArray(in sequence);
            }
            ReadOnlySpan<byte> source = readOnlySpan;
            if (Utf8Parser.TryParse(source, out float value2, out int bytesConsumed, '\0') && source.Length == bytesConsumed)
            {
                value = value2;
                return true;
            }
            value = 0f;
            return false;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.Double" />.
        /// Returns <see langword="true" /> if the entire UTF-8 encoded token value can be successfully
        /// parsed to a <see cref="T:System.Double" /> value.
        /// Returns <see langword="false" /> otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        public bool TryGetDouble(out double value)
        {
            if (TokenType != JsonTokenType.Number)
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
            }
            ReadOnlySpan<byte> readOnlySpan;
            if (!HasValueSequence)
            {
                readOnlySpan = ValueSpan;
            }
            else
            {
                ReadOnlySequence<byte> sequence = ValueSequence;
                readOnlySpan = BuffersExtensions.ToArray(in sequence);
            }
            ReadOnlySpan<byte> source = readOnlySpan;
            if (Utf8Parser.TryParse(source, out double value2, out int bytesConsumed, '\0') && source.Length == bytesConsumed)
            {
                value = value2;
                return true;
            }
            value = 0.0;
            return false;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.Decimal" />.
        /// Returns <see langword="true" /> if the entire UTF-8 encoded token value can be successfully
        /// parsed to a <see cref="T:System.Decimal" /> value.
        /// Returns <see langword="false" /> otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.Number" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        public bool TryGetDecimal(out decimal value)
        {
            if (TokenType != JsonTokenType.Number)
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedNumber(TokenType);
            }
            ReadOnlySpan<byte> readOnlySpan;
            if (!HasValueSequence)
            {
                readOnlySpan = ValueSpan;
            }
            else
            {
                ReadOnlySequence<byte> sequence = ValueSequence;
                readOnlySpan = BuffersExtensions.ToArray(in sequence);
            }
            ReadOnlySpan<byte> span = readOnlySpan;
            return TryGetDecimalCore(out value, span);
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static bool TryGetDecimalCore(out decimal value, ReadOnlySpan<byte> span)
        {
            if (Utf8Parser.TryParse(span, out decimal value2, out int bytesConsumed, '\0') && span.Length == bytesConsumed)
            {
                value = value2;
                return true;
            }
            value = default(decimal);
            return false;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.DateTime" />.
        /// Returns <see langword="true" /> if the entire UTF-8 encoded token value can be successfully
        /// parsed to a <see cref="T:System.DateTime" /> value.
        /// Returns <see langword="false" /> otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.String" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        public bool TryGetDateTime(out DateTime value)
        {
            if (TokenType != JsonTokenType.String)
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedString(TokenType);
            }
            return TryGetDateTimeCore(out value);
        }

        internal bool TryGetDateTimeCore(out DateTime value)
        {
            scoped ReadOnlySpan<byte> span;

            if (HasValueSequence)
            {
                long sequenceLength = ValueSequence.Length;
                if (!JsonHelpers.IsInRangeInclusive(sequenceLength, JsonConstants.MinimumDateTimeParseLength, JsonConstants.MaximumEscapedDateTimeOffsetParseLength))
                {
                    value = default;
                    return false;
                }

                Span<byte> stackSpan = stackalloc byte[JsonConstants.MaximumEscapedDateTimeOffsetParseLength];
                ValueSequence.CopyTo(stackSpan);
                span = stackSpan.Slice(0, (int)sequenceLength);
            }
            else
            {
                if (!JsonHelpers.IsInRangeInclusive(ValueSpan.Length, JsonConstants.MinimumDateTimeParseLength, JsonConstants.MaximumEscapedDateTimeOffsetParseLength))
                {
                    value = default;
                    return false;
                }

                span = ValueSpan;
            }

            if (ValueIsEscaped)
            {
                return JsonReaderHelper.TryGetEscapedDateTime(span, out value);
            }

            Debug.Assert(span.IndexOf(JsonConstants.BackSlash) == -1);

            if (JsonHelpers.TryParseAsISO(span, out DateTime tmp))
            {
                value = tmp;
                return true;
            }

            value = default;
            return false;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="System.DateTimeOffset" />.
        /// Returns <see langword="true" /> if the entire UTF-8 encoded token value can be successfully
        /// parsed to a <see cref="System.DateTimeOffset" /> value.
        /// Returns <see langword="false" /> otherwise.
        /// </summary>
        /// <exception cref="System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="System.Text.Json.JsonTokenType.String" />.
        /// <seealso cref="System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        public bool TryGetDateTimeOffset(out DateTimeOffset value)
        {
            if (TokenType != JsonTokenType.String)
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedString(TokenType);
            }
            return TryGetDateTimeOffsetCore(out value);
        }

        internal bool TryGetDateTimeOffsetCore(out DateTimeOffset value)
        {
            scoped ReadOnlySpan<byte> source2;
            if (HasValueSequence)
            {
                long length = ValueSequence.Length;
                if (!JsonHelpers.IsInRangeInclusive(length, 10L, 252L))
                {
                    value = default(DateTimeOffset);
                    return false;
                }
                Span<byte> destination = stackalloc byte[252];
                ReadOnlySequence<byte> source = ValueSequence;
                source.CopyTo(destination);
                source2 = destination.Slice(0, (int)length);
            }
            else
            {
                if (!JsonHelpers.IsInRangeInclusive(ValueSpan.Length, 10, 252))
                {
                    value = default(DateTimeOffset);
                    return false;
                }
                source2 = ValueSpan;
            }
            if (ValueIsEscaped)
            {
                return JsonReaderHelper.TryGetEscapedDateTimeOffset(source2, out value);
            }
            if (JsonHelpers.TryParseAsISO(source2, out DateTimeOffset value2))
            {
                value = value2;
                return true;
            }
            value = default(DateTimeOffset);
            return false;
        }

        /// <summary>
        /// Parses the current JSON token value from the source as a <see cref="T:System.Guid" />.
        /// Returns <see langword="true" /> if the entire UTF-8 encoded token value can be successfully
        /// parsed to a <see cref="T:System.Guid" /> value. Only supports <see cref="T:System.Guid" /> values with hyphens
        /// and without any surrounding decorations.
        /// Returns <see langword="false" /> otherwise.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if trying to get the value of a JSON token that is not a <see cref="F:System.Text.Json.JsonTokenType.String" />.
        /// <seealso cref="P:System.Text.Json.Utf8JsonReader.TokenType" />
        /// </exception>
        public bool TryGetGuid(out Guid value)
        {
            if (TokenType != JsonTokenType.String)
            {
                ThrowHelper.ThrowInvalidOperationException_ExpectedString(TokenType);
            }
            return TryGetGuidCore(out value);
        }

        internal bool TryGetGuidCore(out Guid value)
        {
            scoped ReadOnlySpan<byte> source2;
            if (HasValueSequence)
            {
                long length = ValueSequence.Length;
                if (length > 216)
                {
                    value = default(Guid);
                    return false;
                }
                Span<byte> destination = stackalloc byte[216];
                ReadOnlySequence<byte> source = ValueSequence;
                source.CopyTo(destination);
                source2 = destination.Slice(0, (int)length);
            }
            else
            {
                if (ValueSpan.Length > 216)
                {
                    value = default(Guid);
                    return false;
                }
                source2 = ValueSpan;
            }
            if (ValueIsEscaped)
            {
                return JsonReaderHelper.TryGetEscapedGuid(source2, out value);
            }
            if (source2.Length == 36 && Utf8Parser.TryParse(source2, out Guid value2, out int _, 'D'))
            {
                value = value2;
                return true;
            }
            value = default(Guid);
            return false;
        }
    }

    /// <summary>
	/// Provides a high-performance API for forward-only, non-cached writing of UTF-8 encoded JSON text.
	/// </summary>
	/// <remarks>
	///   <para>
	///     It writes the text sequentially with no caching and adheres to the JSON RFC
	///     by default (https://tools.ietf.org/html/rfc8259), with the exception of writing comments.
	///   </para>
	///   <para>
	///     When the user attempts to write invalid JSON and validation is enabled, it throws
	///     an <see cref="T:System.InvalidOperationException" /> with a context specific error message.
	///   </para>
	///   <para>
	///     To be able to format the output with indentation and whitespace OR to skip validation, create an instance of
	///     <see cref="T:System.Text.Json.JsonWriterOptions" /> and pass that in to the writer.
	///   </para>
	/// </remarks>
	[DebuggerDisplay("{DebuggerDisplay,nq}")]
    public sealed class Utf8JsonWriter : IDisposable, IAsyncDisposable
    {
        private static readonly int s_newLineLength = Environment.NewLine.Length;

        private const int DefaultGrowthSize = 4096;

        private const int InitialGrowthSize = 256;

        private IBufferWriter<byte> _output;

        private Stream _stream;

        private ArrayBufferWriter<byte> _arrayBufferWriter;

        private Memory<byte> _memory;

        private bool _inObject;

        private JsonTokenType _tokenType;

        private BitStack _bitStack;

        private int _currentDepth;

        private JsonWriterOptions _options;

        private static readonly char[] s_singleLineCommentDelimiter = new char[2] { '*', '/' };

        /// <summary>
        /// Returns the amount of bytes written by the <see cref="T:System.Text.Json.Utf8JsonWriter" /> so far
        /// that have not yet been flushed to the output and committed.
        /// </summary>
        public int BytesPending { get; private set; }

        /// <summary>
        /// Returns the amount of bytes committed to the output by the <see cref="T:System.Text.Json.Utf8JsonWriter" /> so far.
        /// </summary>
        /// <remarks>
        /// In the case of IBufferwriter, this is how much the IBufferWriter has advanced.
        /// In the case of Stream, this is how much data has been written to the stream.
        /// </remarks>
        public long BytesCommitted { get; private set; }

        /// <summary>
        /// Gets the custom behavior when writing JSON using
        /// the <see cref="T:System.Text.Json.Utf8JsonWriter" /> which indicates whether to format the output
        /// while writing and whether to skip structural JSON validation or not.
        /// </summary>
        public JsonWriterOptions Options => _options;

        private int Indentation => CurrentDepth * 2;

        internal JsonTokenType TokenType => _tokenType;

        /// <summary>
        /// Tracks the recursive depth of the nested objects / arrays within the JSON text
        /// written so far. This provides the depth of the current token.
        /// </summary>
        public int CurrentDepth => _currentDepth & 0x7FFFFFFF;

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private string DebuggerDisplay => $"BytesCommitted = {BytesCommitted} BytesPending = {BytesPending} CurrentDepth = {CurrentDepth}";

        private static ReadOnlySpan<byte> SingleLineCommentDelimiterUtf8 => new byte[2] { 42, 47 };

        private Utf8JsonWriter()
        {
        }

        /// <summary>
        /// Constructs a new <see cref="T:System.Text.Json.Utf8JsonWriter" /> instance with a specified <paramref name="bufferWriter" />.
        /// </summary>
        /// <param name="bufferWriter">An instance of <see cref="T:System.Buffers.IBufferWriter`1" /> used as a destination for writing JSON text into.</param>
        /// <param name="options">Defines the customized behavior of the <see cref="T:System.Text.Json.Utf8JsonWriter" />
        /// By default, the <see cref="T:System.Text.Json.Utf8JsonWriter" /> writes JSON minimized (that is, with no extra whitespace)
        /// and validates that the JSON being written is structurally valid according to JSON RFC.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// Thrown when the instance of <see cref="T:System.Buffers.IBufferWriter`1" /> that is passed in is null.
        /// </exception>
        public Utf8JsonWriter(IBufferWriter<byte> bufferWriter, JsonWriterOptions options = default(JsonWriterOptions))
        {
            if (bufferWriter == null)
            {
                ThrowHelper.ThrowArgumentNullException("bufferWriter");
            }
            _output = bufferWriter;
            _options = options;
            if (_options.MaxDepth == 0)
            {
                _options.MaxDepth = 1000;
            }
        }

        /// <summary>
        /// Constructs a new <see cref="T:System.Text.Json.Utf8JsonWriter" /> instance with a specified <paramref name="utf8Json" />.
        /// </summary>
        /// <param name="utf8Json">An instance of <see cref="T:System.IO.Stream" /> used as a destination for writing JSON text into.</param>
        /// <param name="options">Defines the customized behavior of the <see cref="T:System.Text.Json.Utf8JsonWriter" />
        /// By default, the <see cref="T:System.Text.Json.Utf8JsonWriter" /> writes JSON minimized (that is, with no extra whitespace)
        /// and validates that the JSON being written is structurally valid according to JSON RFC.</param>
        /// <exception cref="T:System.ArgumentNullException">
        /// Thrown when the instance of <see cref="T:System.IO.Stream" /> that is passed in is null.
        /// </exception>
        public Utf8JsonWriter(Stream utf8Json, JsonWriterOptions options = default(JsonWriterOptions))
        {
            if (utf8Json == null)
            {
                ThrowHelper.ThrowArgumentNullException("utf8Json");
            }
            if (!utf8Json.CanWrite)
            {
                throw new ArgumentException(MDCFR.Properties.Resources.StreamNotWritable);
            }
            _stream = utf8Json;
            _options = options;
            if (_options.MaxDepth == 0)
            {
                _options.MaxDepth = 1000;
            }
            _arrayBufferWriter = new ArrayBufferWriter<byte>();
        }

        /// <summary>
        /// Resets the <see cref="T:System.Text.Json.Utf8JsonWriter" /> internal state so that it can be re-used.
        /// </summary>
        /// <remarks>
        /// The <see cref="T:System.Text.Json.Utf8JsonWriter" /> will continue to use the original writer options
        /// and the original output as the destination (either <see cref="T:System.Buffers.IBufferWriter`1" /> or <see cref="T:System.IO.Stream" />).
        /// </remarks>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The instance of <see cref="T:System.Text.Json.Utf8JsonWriter" /> has been disposed.
        /// </exception>
        public void Reset()
        {
            CheckNotDisposed();
            _arrayBufferWriter?.Clear();
            ResetHelper();
        }

        /// <summary>
        /// Resets the <see cref="T:System.Text.Json.Utf8JsonWriter" /> internal state so that it can be re-used with the new instance of <see cref="T:System.IO.Stream" />.
        /// </summary>
        /// <param name="utf8Json">An instance of <see cref="T:System.IO.Stream" /> used as a destination for writing JSON text into.</param>
        /// <remarks>
        /// The <see cref="T:System.Text.Json.Utf8JsonWriter" /> will continue to use the original writer options
        /// but now write to the passed in <see cref="T:System.IO.Stream" /> as the new destination.
        /// </remarks>
        /// <exception cref="T:System.ArgumentNullException">
        /// Thrown when the instance of <see cref="T:System.IO.Stream" /> that is passed in is null.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The instance of <see cref="T:System.Text.Json.Utf8JsonWriter" /> has been disposed.
        /// </exception>
        public void Reset(Stream utf8Json)
        {
            CheckNotDisposed();
            if (utf8Json == null)
            {
                throw new ArgumentNullException("utf8Json");
            }
            if (!utf8Json.CanWrite)
            {
                throw new ArgumentException(MDCFR.Properties.Resources.StreamNotWritable);
            }
            _stream = utf8Json;
            if (_arrayBufferWriter == null)
            {
                _arrayBufferWriter = new ArrayBufferWriter<byte>();
            }
            else
            {
                _arrayBufferWriter.Clear();
            }
            _output = null;
            ResetHelper();
        }

        /// <summary>
        /// Resets the <see cref="T:System.Text.Json.Utf8JsonWriter" /> internal state so that it can be re-used with the new instance of <see cref="T:System.Buffers.IBufferWriter`1" />.
        /// </summary>
        /// <param name="bufferWriter">An instance of <see cref="T:System.Buffers.IBufferWriter`1" /> used as a destination for writing JSON text into.</param>
        /// <remarks>
        /// The <see cref="T:System.Text.Json.Utf8JsonWriter" /> will continue to use the original writer options
        /// but now write to the passed in <see cref="T:System.Buffers.IBufferWriter`1" /> as the new destination.
        /// </remarks>
        /// <exception cref="T:System.ArgumentNullException">
        /// Thrown when the instance of <see cref="T:System.Buffers.IBufferWriter`1" /> that is passed in is null.
        /// </exception>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The instance of <see cref="T:System.Text.Json.Utf8JsonWriter" /> has been disposed.
        /// </exception>
        public void Reset(IBufferWriter<byte> bufferWriter)
        {
            CheckNotDisposed();
            _output = bufferWriter ?? throw new ArgumentNullException("bufferWriter");
            _stream = null;
            _arrayBufferWriter = null;
            ResetHelper();
        }

        internal void ResetAllStateForCacheReuse()
        {
            ResetHelper();
            _stream = null;
            _arrayBufferWriter = null;
            _output = null;
        }

        internal void Reset(IBufferWriter<byte> bufferWriter, JsonWriterOptions options)
        {
            _output = bufferWriter;
            _options = options;
            if (_options.MaxDepth == 0)
            {
                _options.MaxDepth = 1000;
            }
        }

        internal static Utf8JsonWriter CreateEmptyInstanceForCaching()
        {
            return new Utf8JsonWriter();
        }

        private void ResetHelper()
        {
            BytesPending = 0;
            BytesCommitted = 0L;
            _memory = default(Memory<byte>);
            _inObject = false;
            _tokenType = JsonTokenType.None;
            _currentDepth = 0;
            _bitStack = default(BitStack);
        }

        private void CheckNotDisposed()
        {
            if (_stream == null && _output == null)
            {
                ThrowHelper.ThrowObjectDisposedException_Utf8JsonWriter();
            }
        }

        /// <summary>
        /// Commits the JSON text written so far which makes it visible to the output destination.
        /// </summary>
        /// <remarks>
        /// In the case of IBufferWriter, this advances the underlying <see cref="T:System.Buffers.IBufferWriter`1" /> based on what has been written so far.
        /// In the case of Stream, this writes the data to the stream and flushes it.
        /// </remarks>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The instance of <see cref="T:System.Text.Json.Utf8JsonWriter" /> has been disposed.
        /// </exception>
        public void Flush()
        {
            CheckNotDisposed();
            _memory = default(Memory<byte>);
            if (_stream != null)
            {
                if (BytesPending != 0)
                {
                    _arrayBufferWriter.Advance(BytesPending);
                    BytesPending = 0;
                    ArraySegment<byte> segment;
                    bool flag = MemoryMarshal.TryGetArray(_arrayBufferWriter.WrittenMemory, out segment);
                    _stream.Write(segment.Array, segment.Offset, segment.Count);
                    BytesCommitted += _arrayBufferWriter.WrittenCount;
                    _arrayBufferWriter.Clear();
                }
                _stream.Flush();
            }
            else if (BytesPending != 0)
            {
                _output.Advance(BytesPending);
                BytesCommitted += BytesPending;
                BytesPending = 0;
            }
        }

        /// <summary>
        /// Commits any left over JSON text that has not yet been flushed and releases all resources used by the current instance.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     In the case of IBufferWriter, this advances the underlying <see cref="T:System.Buffers.IBufferWriter`1" /> based on what has been written so far.
        ///     In the case of Stream, this writes the data to the stream and flushes it.
        ///   </para>
        ///   <para>
        ///     The <see cref="T:System.Text.Json.Utf8JsonWriter" /> instance cannot be re-used after disposing.
        ///   </para>
        /// </remarks>
        public void Dispose()
        {
            if (_stream != null || _output != null)
            {
                Flush();
                ResetHelper();
                _stream = null;
                _arrayBufferWriter = null;
                _output = null;
            }
        }

        /// <summary>
        /// Asynchronously commits any left over JSON text that has not yet been flushed and releases all resources used by the current instance.
        /// </summary>
        /// <remarks>
        ///   <para>
        ///     In the case of IBufferWriter, this advances the underlying <see cref="T:System.Buffers.IBufferWriter`1" /> based on what has been written so far.
        ///     In the case of Stream, this writes the data to the stream and flushes it.
        ///   </para>
        ///   <para>
        ///     The <see cref="T:System.Text.Json.Utf8JsonWriter" /> instance cannot be re-used after disposing.
        ///   </para>
        /// </remarks>
        public async ValueTask DisposeAsync()
        {
            if (_stream != null || _output != null)
            {
                await FlushAsync().ConfigureAwait(continueOnCapturedContext: false);
                ResetHelper();
                _stream = null;
                _arrayBufferWriter = null;
                _output = null;
            }
        }

        /// <summary>
        /// Asynchronously commits the JSON text written so far which makes it visible to the output destination.
        /// </summary>
        /// <remarks>
        /// In the case of IBufferWriter, this advances the underlying <see cref="T:System.Buffers.IBufferWriter`1" /> based on what has been written so far.
        /// In the case of Stream, this writes the data to the stream and flushes it asynchronously, while monitoring cancellation requests.
        /// </remarks>
        /// <exception cref="T:System.ObjectDisposedException">
        ///   The instance of <see cref="T:System.Text.Json.Utf8JsonWriter" /> has been disposed.
        /// </exception>
        public async Task FlushAsync(CancellationToken cancellationToken = default(CancellationToken))
        {
            CheckNotDisposed();
            _memory = default(Memory<byte>);
            if (_stream != null)
            {
                if (BytesPending != 0)
                {
                    _arrayBufferWriter.Advance(BytesPending);
                    BytesPending = 0;
                    MemoryMarshal.TryGetArray(_arrayBufferWriter.WrittenMemory, out var segment);
                    await _stream.WriteAsync(segment.Array, segment.Offset, segment.Count, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
                    BytesCommitted += _arrayBufferWriter.WrittenCount;
                    _arrayBufferWriter.Clear();
                }
                await _stream.FlushAsync(cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
            }
            else if (BytesPending != 0)
            {
                _output.Advance(BytesPending);
                BytesCommitted += BytesPending;
                BytesPending = 0;
            }
        }

        /// <summary>
        /// Writes the beginning of a JSON array.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown when the depth of the JSON has exceeded the maximum depth of 1000
        /// OR if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteStartArray()
        {
            WriteStart(91);
            _tokenType = JsonTokenType.StartArray;
        }

        /// <summary>
        /// Writes the beginning of a JSON object.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown when the depth of the JSON has exceeded the maximum depth of 1000
        /// OR if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteStartObject()
        {
            WriteStart(123);
            _tokenType = JsonTokenType.StartObject;
        }

        private void WriteStart(byte token)
        {
            if (CurrentDepth >= _options.MaxDepth)
            {
                ThrowHelper.ThrowInvalidOperationException(ExceptionResource.DepthTooLarge, _currentDepth, _options.MaxDepth, 0, JsonTokenType.None);
            }
            if (_options.IndentedOrNotSkipValidation)
            {
                WriteStartSlow(token);
            }
            else
            {
                WriteStartMinimized(token);
            }
            _currentDepth &= int.MaxValue;
            _currentDepth++;
        }

        private void WriteStartMinimized(byte token)
        {
            if (_memory.Length - BytesPending < 2)
            {
                Grow(2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = token;
        }

        private void WriteStartSlow(byte token)
        {
            if (_options.Indented)
            {
                if (!_options.SkipValidation)
                {
                    ValidateStart();
                    UpdateBitStackOnStart(token);
                }
                WriteStartIndented(token);
            }
            else
            {
                ValidateStart();
                UpdateBitStackOnStart(token);
                WriteStartMinimized(token);
            }
        }

        private void ValidateStart()
        {
            if (_inObject)
            {
                if (_tokenType != JsonTokenType.PropertyName)
                {
                    ThrowHelper.ThrowInvalidOperationException(ExceptionResource.CannotStartObjectArrayWithoutProperty, 0, _options.MaxDepth, 0, _tokenType);
                }
            }
            else if (CurrentDepth == 0 && _tokenType != 0)
            {
                ThrowHelper.ThrowInvalidOperationException(ExceptionResource.CannotStartObjectArrayAfterPrimitiveOrClose, 0, _options.MaxDepth, 0, _tokenType);
            }
        }

        private void WriteStartIndented(byte token)
        {
            int indentation = Indentation;
            int num = indentation + 1;
            int num2 = num + 3;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != JsonTokenType.PropertyName)
            {
                if (_tokenType != 0)
                {
                    WriteNewLine(span);
                }
                JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
                BytesPending += indentation;
            }
            span[BytesPending++] = token;
        }

        /// <summary>
        /// Writes the beginning of a JSON array with a pre-encoded property name as the key.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown when the depth of the JSON has exceeded the maximum depth of 1000
        /// OR if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteStartArray(JsonEncodedText propertyName)
        {
            WriteStartHelper(propertyName.EncodedUtf8Bytes, 91);
            _tokenType = JsonTokenType.StartArray;
        }

        /// <summary>
        /// Writes the beginning of a JSON object with a pre-encoded property name as the key.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown when the depth of the JSON has exceeded the maximum depth of 1000
        /// OR if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteStartObject(JsonEncodedText propertyName)
        {
            WriteStartHelper(propertyName.EncodedUtf8Bytes, 123);
            _tokenType = JsonTokenType.StartObject;
        }

        private void WriteStartHelper(ReadOnlySpan<byte> utf8PropertyName, byte token)
        {
            ValidateDepth();
            WriteStartByOptions(utf8PropertyName, token);
            _currentDepth &= int.MaxValue;
            _currentDepth++;
        }

        /// <summary>
        /// Writes the beginning of a JSON array with a property name as the key.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded property name of the JSON array to be written.</param>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown when the depth of the JSON has exceeded the maximum depth of 1000
        /// OR if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteStartArray(ReadOnlySpan<byte> utf8PropertyName)
        {
            ValidatePropertyNameAndDepth(utf8PropertyName);
            WriteStartEscape(utf8PropertyName, 91);
            _currentDepth &= int.MaxValue;
            _currentDepth++;
            _tokenType = JsonTokenType.StartArray;
        }

        /// <summary>
        /// Writes the beginning of a JSON object with a property name as the key.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded property name of the JSON object to be written.</param>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown when the depth of the JSON has exceeded the maximum depth of 1000
        /// OR if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteStartObject(ReadOnlySpan<byte> utf8PropertyName)
        {
            ValidatePropertyNameAndDepth(utf8PropertyName);
            WriteStartEscape(utf8PropertyName, 123);
            _currentDepth &= int.MaxValue;
            _currentDepth++;
            _tokenType = JsonTokenType.StartObject;
        }

        private void WriteStartEscape(ReadOnlySpan<byte> utf8PropertyName, byte token)
        {
            int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
            if (num != -1)
            {
                WriteStartEscapeProperty(utf8PropertyName, token, num);
            }
            else
            {
                WriteStartByOptions(utf8PropertyName, token);
            }
        }

        private void WriteStartByOptions(ReadOnlySpan<byte> utf8PropertyName, byte token)
        {
            ValidateWritingProperty(token);
            if (_options.Indented)
            {
                WritePropertyNameIndented(utf8PropertyName, token);
            }
            else
            {
                WritePropertyNameMinimized(utf8PropertyName, token);
            }
        }

        private void WriteStartEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, byte token, int firstEscapeIndexProp)
        {
            byte[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
            Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
            Span<byte> destination = span;
            JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteStartByOptions(destination.Slice(0, written), token);
            if (array != null)
            {
                ArrayPool<byte>.Shared.Return(array);
            }
        }

        /// <summary>
        /// Writes the beginning of a JSON array with a property name as the key.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown when the depth of the JSON has exceeded the maximum depth of 1000
        /// OR if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteStartArray(string propertyName)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WriteStartArray(propertyName.AsSpan());
        }

        /// <summary>
        /// Writes the beginning of a JSON object with a property name as the key.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown when the depth of the JSON has exceeded the maximum depth of 1000
        /// OR if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteStartObject(string propertyName)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WriteStartObject(propertyName.AsSpan());
        }

        /// <summary>
        /// Writes the beginning of a JSON array with a property name as the key.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown when the depth of the JSON has exceeded the maximum depth of 1000
        /// OR if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteStartArray(ReadOnlySpan<char> propertyName)
        {
            ValidatePropertyNameAndDepth(propertyName);
            WriteStartEscape(propertyName, 91);
            _currentDepth &= int.MaxValue;
            _currentDepth++;
            _tokenType = JsonTokenType.StartArray;
        }

        /// <summary>
        /// Writes the beginning of a JSON object with a property name as the key.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown when the depth of the JSON has exceeded the maximum depth of 1000
        /// OR if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteStartObject(ReadOnlySpan<char> propertyName)
        {
            ValidatePropertyNameAndDepth(propertyName);
            WriteStartEscape(propertyName, 123);
            _currentDepth &= int.MaxValue;
            _currentDepth++;
            _tokenType = JsonTokenType.StartObject;
        }

        private void WriteStartEscape(ReadOnlySpan<char> propertyName, byte token)
        {
            int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
            if (num != -1)
            {
                WriteStartEscapeProperty(propertyName, token, num);
            }
            else
            {
                WriteStartByOptions(propertyName, token);
            }
        }

        private void WriteStartByOptions(ReadOnlySpan<char> propertyName, byte token)
        {
            ValidateWritingProperty(token);
            if (_options.Indented)
            {
                WritePropertyNameIndented(propertyName, token);
            }
            else
            {
                WritePropertyNameMinimized(propertyName, token);
            }
        }

        private void WriteStartEscapeProperty(ReadOnlySpan<char> propertyName, byte token, int firstEscapeIndexProp)
        {
            char[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
            Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
            Span<char> destination = span;
            JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteStartByOptions(destination.Slice(0, written), token);
            if (array != null)
            {
                ArrayPool<char>.Shared.Return(array);
            }
        }

        /// <summary>
        /// Writes the end of a JSON array.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteEndArray()
        {
            WriteEnd(93);
            _tokenType = JsonTokenType.EndArray;
        }

        /// <summary>
        /// Writes the end of a JSON object.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteEndObject()
        {
            WriteEnd(125);
            _tokenType = JsonTokenType.EndObject;
        }

        private void WriteEnd(byte token)
        {
            if (_options.IndentedOrNotSkipValidation)
            {
                WriteEndSlow(token);
            }
            else
            {
                WriteEndMinimized(token);
            }
            SetFlagToAddListSeparatorBeforeNextItem();
            if (CurrentDepth != 0)
            {
                _currentDepth--;
            }
        }

        private void WriteEndMinimized(byte token)
        {
            if (_memory.Length - BytesPending < 1)
            {
                Grow(1);
            }
            _memory.Span[BytesPending++] = token;
        }

        private void WriteEndSlow(byte token)
        {
            if (_options.Indented)
            {
                if (!_options.SkipValidation)
                {
                    ValidateEnd(token);
                }
                WriteEndIndented(token);
            }
            else
            {
                ValidateEnd(token);
                WriteEndMinimized(token);
            }
        }

        private void ValidateEnd(byte token)
        {
            if (_bitStack.CurrentDepth <= 0 || _tokenType == JsonTokenType.PropertyName)
            {
                ThrowHelper.ThrowInvalidOperationException(ExceptionResource.MismatchedObjectArray, 0, _options.MaxDepth, token, _tokenType);
            }
            if (token == 93)
            {
                if (_inObject)
                {
                    ThrowHelper.ThrowInvalidOperationException(ExceptionResource.MismatchedObjectArray, 0, _options.MaxDepth, token, _tokenType);
                }
            }
            else if (!_inObject)
            {
                ThrowHelper.ThrowInvalidOperationException(ExceptionResource.MismatchedObjectArray, 0, _options.MaxDepth, token, _tokenType);
            }
            _inObject = _bitStack.Pop();
        }

        private void WriteEndIndented(byte token)
        {
            if (_tokenType == JsonTokenType.StartObject || _tokenType == JsonTokenType.StartArray)
            {
                WriteEndMinimized(token);
                return;
            }
            int num = Indentation;
            if (num != 0)
            {
                num -= 2;
            }
            int num2 = num + 3;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            WriteNewLine(span);
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), num);
            BytesPending += num;
            span[BytesPending++] = token;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void WriteNewLine(Span<byte> output)
        {
            if (s_newLineLength == 2)
            {
                output[BytesPending++] = 13;
            }
            output[BytesPending++] = 10;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void UpdateBitStackOnStart(byte token)
        {
            if (token == 91)
            {
                _bitStack.PushFalse();
                _inObject = false;
            }
            else
            {
                _bitStack.PushTrue();
                _inObject = true;
            }
        }

        private void Grow(int requiredSize)
        {
            if (_memory.Length == 0)
            {
                FirstCallToGetMemory(requiredSize);
                return;
            }
            int num = Math.Max(4096, requiredSize);
            if (_stream != null)
            {
                int num2 = BytesPending + num;
                JsonHelpers.ValidateInt32MaxArrayLength((uint)num2);
                _memory = _arrayBufferWriter.GetMemory(num2);
                return;
            }
            _output.Advance(BytesPending);
            BytesCommitted += BytesPending;
            BytesPending = 0;
            _memory = _output.GetMemory(num);
            if (_memory.Length < num)
            {
                ThrowHelper.ThrowInvalidOperationException_NeedLargerSpan();
            }
        }

        private void FirstCallToGetMemory(int requiredSize)
        {
            int num = Math.Max(256, requiredSize);
            if (_stream != null)
            {
                _memory = _arrayBufferWriter.GetMemory(num);
                return;
            }
            _memory = _output.GetMemory(num);
            if (_memory.Length < num)
            {
                ThrowHelper.ThrowInvalidOperationException_NeedLargerSpan();
            }
        }

        private void SetFlagToAddListSeparatorBeforeNextItem()
        {
            _currentDepth |= int.MinValue;
        }

        /// <summary>
        /// Writes the pre-encoded property name and raw bytes value (as a Base64 encoded JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <param name="bytes">The binary data to write as Base64 encoded text.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteBase64String(JsonEncodedText propertyName, ReadOnlySpan<byte> bytes)
        {
            ReadOnlySpan<byte> encodedUtf8Bytes = propertyName.EncodedUtf8Bytes;
            JsonWriterHelper.ValidateBytes(bytes);
            WriteBase64ByOptions(encodedUtf8Bytes, bytes);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the property name and raw bytes value (as a Base64 encoded JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="bytes">The binary data to write as Base64 encoded text.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteBase64String(string propertyName, ReadOnlySpan<byte> bytes)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WriteBase64String(propertyName.AsSpan(), bytes);
        }

        /// <summary>
        /// Writes the property name and raw bytes value (as a Base64 encoded JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="bytes">The binary data to write as Base64 encoded text.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteBase64String(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> bytes)
        {
            JsonWriterHelper.ValidatePropertyAndBytes(propertyName, bytes);
            WriteBase64Escape(propertyName, bytes);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the property name and raw bytes value (as a Base64 encoded JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded name of the property to write.</param>
        /// <param name="bytes">The binary data to write as Base64 encoded text.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteBase64String(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> bytes)
        {
            JsonWriterHelper.ValidatePropertyAndBytes(utf8PropertyName, bytes);
            WriteBase64Escape(utf8PropertyName, bytes);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        private void WriteBase64Escape(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> bytes)
        {
            int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
            if (num != -1)
            {
                WriteBase64EscapeProperty(propertyName, bytes, num);
            }
            else
            {
                WriteBase64ByOptions(propertyName, bytes);
            }
        }

        private void WriteBase64Escape(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> bytes)
        {
            int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
            if (num != -1)
            {
                WriteBase64EscapeProperty(utf8PropertyName, bytes, num);
            }
            else
            {
                WriteBase64ByOptions(utf8PropertyName, bytes);
            }
        }

        private void WriteBase64EscapeProperty(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> bytes, int firstEscapeIndexProp)
        {
            char[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
            Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
            Span<char> destination = span;
            JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteBase64ByOptions(destination.Slice(0, written), bytes);
            if (array != null)
            {
                ArrayPool<char>.Shared.Return(array);
            }
        }

        private void WriteBase64EscapeProperty(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> bytes, int firstEscapeIndexProp)
        {
            byte[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
            Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
            Span<byte> destination = span;
            JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteBase64ByOptions(destination.Slice(0, written), bytes);
            if (array != null)
            {
                ArrayPool<byte>.Shared.Return(array);
            }
        }

        private void WriteBase64ByOptions(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> bytes)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteBase64Indented(propertyName, bytes);
            }
            else
            {
                WriteBase64Minimized(propertyName, bytes);
            }
        }

        private void WriteBase64ByOptions(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> bytes)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteBase64Indented(utf8PropertyName, bytes);
            }
            else
            {
                WriteBase64Minimized(utf8PropertyName, bytes);
            }
        }

        private void WriteBase64Minimized(ReadOnlySpan<char> escapedPropertyName, ReadOnlySpan<byte> bytes)
        {
            int maxEncodedToUtf8Length = Base64.GetMaxEncodedToUtf8Length(bytes.Length);
            int num = escapedPropertyName.Length * 3 + maxEncodedToUtf8Length + 6;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 34;
            Base64EncodeAndWrite(bytes, span, maxEncodedToUtf8Length);
            span[BytesPending++] = 34;
        }

        private void WriteBase64Minimized(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<byte> bytes)
        {
            int maxEncodedToUtf8Length = Base64.GetMaxEncodedToUtf8Length(bytes.Length);
            int num = escapedPropertyName.Length + maxEncodedToUtf8Length + 6;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 34;
            Base64EncodeAndWrite(bytes, span, maxEncodedToUtf8Length);
            span[BytesPending++] = 34;
        }

        private void WriteBase64Indented(ReadOnlySpan<char> escapedPropertyName, ReadOnlySpan<byte> bytes)
        {
            int indentation = Indentation;
            int maxEncodedToUtf8Length = Base64.GetMaxEncodedToUtf8Length(bytes.Length);
            int num = indentation + escapedPropertyName.Length * 3 + maxEncodedToUtf8Length + 7 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            span[BytesPending++] = 34;
            Base64EncodeAndWrite(bytes, span, maxEncodedToUtf8Length);
            span[BytesPending++] = 34;
        }

        private void WriteBase64Indented(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<byte> bytes)
        {
            int indentation = Indentation;
            int maxEncodedToUtf8Length = Base64.GetMaxEncodedToUtf8Length(bytes.Length);
            int num = indentation + escapedPropertyName.Length + maxEncodedToUtf8Length + 7 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            span[BytesPending++] = 34;
            Base64EncodeAndWrite(bytes, span, maxEncodedToUtf8Length);
            span[BytesPending++] = 34;
        }

        /// <summary>
        /// Writes the pre-encoded property name and <see cref="T:System.DateTime" /> value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.DateTime" /> using the round-trippable ('O') <see cref="T:System.Buffers.StandardFormat" /> , for example: 2017-06-12T05:30:45.7680000.
        /// The property name should already be escaped when the instance of <see cref="T:System.Text.Json.JsonEncodedText" /> was created.
        /// </remarks>
        public void WriteString(JsonEncodedText propertyName, DateTime value)
        {
            ReadOnlySpan<byte> encodedUtf8Bytes = propertyName.EncodedUtf8Bytes;
            WriteStringByOptions(encodedUtf8Bytes, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.DateTime" /> value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.DateTime" /> using the round-trippable ('O') <see cref="T:System.Buffers.StandardFormat" /> , for example: 2017-06-12T05:30:45.7680000.
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteString(string propertyName, DateTime value)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WriteString(propertyName.AsSpan(), value);
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.DateTime" /> value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.DateTime" /> using the round-trippable ('O') <see cref="T:System.Buffers.StandardFormat" /> , for example: 2017-06-12T05:30:45.7680000.
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteString(ReadOnlySpan<char> propertyName, DateTime value)
        {
            JsonWriterHelper.ValidateProperty(propertyName);
            WriteStringEscape(propertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.DateTime" /> value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.DateTime" /> using the round-trippable ('O') <see cref="T:System.Buffers.StandardFormat" /> , for example: 2017-06-12T05:30:45.7680000.
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteString(ReadOnlySpan<byte> utf8PropertyName, DateTime value)
        {
            JsonWriterHelper.ValidateProperty(utf8PropertyName);
            WriteStringEscape(utf8PropertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        private void WriteStringEscape(ReadOnlySpan<char> propertyName, DateTime value)
        {
            int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
            if (num != -1)
            {
                WriteStringEscapeProperty(propertyName, value, num);
            }
            else
            {
                WriteStringByOptions(propertyName, value);
            }
        }

        private void WriteStringEscape(ReadOnlySpan<byte> utf8PropertyName, DateTime value)
        {
            int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
            if (num != -1)
            {
                WriteStringEscapeProperty(utf8PropertyName, value, num);
            }
            else
            {
                WriteStringByOptions(utf8PropertyName, value);
            }
        }

        private void WriteStringEscapeProperty(ReadOnlySpan<char> propertyName, DateTime value, int firstEscapeIndexProp)
        {
            char[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
            Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
            Span<char> destination = span;
            JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteStringByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<char>.Shared.Return(array);
            }
        }

        private void WriteStringEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, DateTime value, int firstEscapeIndexProp)
        {
            byte[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
            Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
            Span<byte> destination = span;
            JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteStringByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<byte>.Shared.Return(array);
            }
        }

        private void WriteStringByOptions(ReadOnlySpan<char> propertyName, DateTime value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteStringIndented(propertyName, value);
            }
            else
            {
                WriteStringMinimized(propertyName, value);
            }
        }

        private void WriteStringByOptions(ReadOnlySpan<byte> utf8PropertyName, DateTime value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteStringIndented(utf8PropertyName, value);
            }
            else
            {
                WriteStringMinimized(utf8PropertyName, value);
            }
        }

        private void WriteStringMinimized(ReadOnlySpan<char> escapedPropertyName, DateTime value)
        {
            int num = escapedPropertyName.Length * 3 + 33 + 6;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 34;
            JsonWriterHelper.WriteDateTimeTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 34;
        }

        private void WriteStringMinimized(ReadOnlySpan<byte> escapedPropertyName, DateTime value)
        {
            int num = escapedPropertyName.Length + 33 + 5;
            int num2 = num + 1;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 34;
            JsonWriterHelper.WriteDateTimeTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 34;
        }

        private void WriteStringIndented(ReadOnlySpan<char> escapedPropertyName, DateTime value)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length * 3 + 33 + 7 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            span[BytesPending++] = 34;
            JsonWriterHelper.WriteDateTimeTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 34;
        }

        private void WriteStringIndented(ReadOnlySpan<byte> escapedPropertyName, DateTime value)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length + 33 + 6;
            int num2 = num + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            span[BytesPending++] = 34;
            JsonWriterHelper.WriteDateTimeTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 34;
        }

        internal void WritePropertyName(DateTime value)
        {
            Span<byte> buffer = stackalloc byte[33];
            JsonWriterHelper.WriteDateTimeTrimmed(buffer, value, out var bytesWritten);
            WritePropertyNameUnescaped(buffer.Slice(0, bytesWritten));
        }

        /// <summary>
        /// Writes the pre-encoded property name and <see cref="T:System.DateTimeOffset" /> value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <param name="value">The value to to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.DateTimeOffset" /> using the round-trippable ('O') <see cref="T:System.Buffers.StandardFormat" /> , for example: 2017-06-12T05:30:45.7680000-07:00.
        /// </remarks>
        public void WriteString(JsonEncodedText propertyName, DateTimeOffset value)
        {
            ReadOnlySpan<byte> encodedUtf8Bytes = propertyName.EncodedUtf8Bytes;
            WriteStringByOptions(encodedUtf8Bytes, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.DateTimeOffset" /> value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.DateTimeOffset" /> using the round-trippable ('O') <see cref="T:System.Buffers.StandardFormat" /> , for example: 2017-06-12T05:30:45.7680000-07:00.
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteString(string propertyName, DateTimeOffset value)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WriteString(propertyName.AsSpan(), value);
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.DateTimeOffset" /> value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.DateTimeOffset" /> using the round-trippable ('O') <see cref="T:System.Buffers.StandardFormat" /> , for example: 2017-06-12T05:30:45.7680000-07:00.
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteString(ReadOnlySpan<char> propertyName, DateTimeOffset value)
        {
            JsonWriterHelper.ValidateProperty(propertyName);
            WriteStringEscape(propertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.DateTimeOffset" /> value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded property name of the JSON object to be written.</param>
        /// <param name="value">The value to to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.DateTimeOffset" /> using the round-trippable ('O') <see cref="T:System.Buffers.StandardFormat" /> , for example: 2017-06-12T05:30:45.7680000-07:00.
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteString(ReadOnlySpan<byte> utf8PropertyName, DateTimeOffset value)
        {
            JsonWriterHelper.ValidateProperty(utf8PropertyName);
            WriteStringEscape(utf8PropertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        private void WriteStringEscape(ReadOnlySpan<char> propertyName, DateTimeOffset value)
        {
            int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
            if (num != -1)
            {
                WriteStringEscapeProperty(propertyName, value, num);
            }
            else
            {
                WriteStringByOptions(propertyName, value);
            }
        }

        private void WriteStringEscape(ReadOnlySpan<byte> utf8PropertyName, DateTimeOffset value)
        {
            int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
            if (num != -1)
            {
                WriteStringEscapeProperty(utf8PropertyName, value, num);
            }
            else
            {
                WriteStringByOptions(utf8PropertyName, value);
            }
        }

        private void WriteStringEscapeProperty(ReadOnlySpan<char> propertyName, DateTimeOffset value, int firstEscapeIndexProp)
        {
            char[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
            Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
            Span<char> destination = span;
            JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteStringByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<char>.Shared.Return(array);
            }
        }

        private void WriteStringEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, DateTimeOffset value, int firstEscapeIndexProp)
        {
            byte[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
            Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
            Span<byte> destination = span;
            JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteStringByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<byte>.Shared.Return(array);
            }
        }

        private void WriteStringByOptions(ReadOnlySpan<char> propertyName, DateTimeOffset value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteStringIndented(propertyName, value);
            }
            else
            {
                WriteStringMinimized(propertyName, value);
            }
        }

        private void WriteStringByOptions(ReadOnlySpan<byte> utf8PropertyName, DateTimeOffset value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteStringIndented(utf8PropertyName, value);
            }
            else
            {
                WriteStringMinimized(utf8PropertyName, value);
            }
        }

        private void WriteStringMinimized(ReadOnlySpan<char> escapedPropertyName, DateTimeOffset value)
        {
            int num = escapedPropertyName.Length * 3 + 33 + 6;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 34;
            JsonWriterHelper.WriteDateTimeOffsetTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 34;
        }

        private void WriteStringMinimized(ReadOnlySpan<byte> escapedPropertyName, DateTimeOffset value)
        {
            int num = escapedPropertyName.Length + 33 + 5;
            int num2 = num + 1;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 34;
            JsonWriterHelper.WriteDateTimeOffsetTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 34;
        }

        private void WriteStringIndented(ReadOnlySpan<char> escapedPropertyName, DateTimeOffset value)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length * 3 + 33 + 7 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            span[BytesPending++] = 34;
            JsonWriterHelper.WriteDateTimeOffsetTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 34;
        }

        private void WriteStringIndented(ReadOnlySpan<byte> escapedPropertyName, DateTimeOffset value)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length + 33 + 6;
            int num2 = num + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            span[BytesPending++] = 34;
            JsonWriterHelper.WriteDateTimeOffsetTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 34;
        }

        internal void WritePropertyName(DateTimeOffset value)
        {
            Span<byte> buffer = stackalloc byte[33];
            JsonWriterHelper.WriteDateTimeOffsetTrimmed(buffer, value, out var bytesWritten);
            WritePropertyNameUnescaped(buffer.Slice(0, bytesWritten));
        }

        /// <summary>
        /// Writes the pre-encoded property name and <see cref="T:System.Decimal" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Decimal" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G').
        /// </remarks>
        public void WriteNumber(JsonEncodedText propertyName, decimal value)
        {
            ReadOnlySpan<byte> encodedUtf8Bytes = propertyName.EncodedUtf8Bytes;
            WriteNumberByOptions(encodedUtf8Bytes, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Decimal" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Decimal" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G').
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteNumber(string propertyName, decimal value)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WriteNumber(propertyName.AsSpan(), value);
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Decimal" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Decimal" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G').
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteNumber(ReadOnlySpan<char> propertyName, decimal value)
        {
            JsonWriterHelper.ValidateProperty(propertyName);
            WriteNumberEscape(propertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Decimal" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Decimal" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G').
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteNumber(ReadOnlySpan<byte> utf8PropertyName, decimal value)
        {
            JsonWriterHelper.ValidateProperty(utf8PropertyName);
            WriteNumberEscape(utf8PropertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        private void WriteNumberEscape(ReadOnlySpan<char> propertyName, decimal value)
        {
            int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
            if (num != -1)
            {
                WriteNumberEscapeProperty(propertyName, value, num);
            }
            else
            {
                WriteNumberByOptions(propertyName, value);
            }
        }

        private void WriteNumberEscape(ReadOnlySpan<byte> utf8PropertyName, decimal value)
        {
            int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
            if (num != -1)
            {
                WriteNumberEscapeProperty(utf8PropertyName, value, num);
            }
            else
            {
                WriteNumberByOptions(utf8PropertyName, value);
            }
        }

        private void WriteNumberEscapeProperty(ReadOnlySpan<char> propertyName, decimal value, int firstEscapeIndexProp)
        {
            char[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
            Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
            Span<char> destination = span;
            JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteNumberByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<char>.Shared.Return(array);
            }
        }

        private void WriteNumberEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, decimal value, int firstEscapeIndexProp)
        {
            byte[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
            Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
            Span<byte> destination = span;
            JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteNumberByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<byte>.Shared.Return(array);
            }
        }

        private void WriteNumberByOptions(ReadOnlySpan<char> propertyName, decimal value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteNumberIndented(propertyName, value);
            }
            else
            {
                WriteNumberMinimized(propertyName, value);
            }
        }

        private void WriteNumberByOptions(ReadOnlySpan<byte> utf8PropertyName, decimal value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteNumberIndented(utf8PropertyName, value);
            }
            else
            {
                WriteNumberMinimized(utf8PropertyName, value);
            }
        }

        private void WriteNumberMinimized(ReadOnlySpan<char> escapedPropertyName, decimal value)
        {
            int num = escapedPropertyName.Length * 3 + 31 + 4;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberMinimized(ReadOnlySpan<byte> escapedPropertyName, decimal value)
        {
            int num = escapedPropertyName.Length + 31 + 3;
            int num2 = num + 1;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberIndented(ReadOnlySpan<char> escapedPropertyName, decimal value)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length * 3 + 31 + 5 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberIndented(ReadOnlySpan<byte> escapedPropertyName, decimal value)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length + 31 + 4;
            int num2 = num + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        internal void WritePropertyName(decimal value)
        {
            Span<byte> destination = stackalloc byte[31];
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten);
            WritePropertyNameUnescaped(destination.Slice(0, bytesWritten));
        }

        /// <summary>
        /// Writes the pre-encoded property name and <see cref="T:System.Double" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Double" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G').
        /// </remarks>
        public void WriteNumber(JsonEncodedText propertyName, double value)
        {
            ReadOnlySpan<byte> encodedUtf8Bytes = propertyName.EncodedUtf8Bytes;
            JsonWriterHelper.ValidateDouble(value);
            WriteNumberByOptions(encodedUtf8Bytes, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Double" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Double" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G').
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteNumber(string propertyName, double value)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WriteNumber(propertyName.AsSpan(), value);
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Double" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Double" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G').
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteNumber(ReadOnlySpan<char> propertyName, double value)
        {
            JsonWriterHelper.ValidateProperty(propertyName);
            JsonWriterHelper.ValidateDouble(value);
            WriteNumberEscape(propertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Double" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Double" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G').
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteNumber(ReadOnlySpan<byte> utf8PropertyName, double value)
        {
            JsonWriterHelper.ValidateProperty(utf8PropertyName);
            JsonWriterHelper.ValidateDouble(value);
            WriteNumberEscape(utf8PropertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        private void WriteNumberEscape(ReadOnlySpan<char> propertyName, double value)
        {
            int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
            if (num != -1)
            {
                WriteNumberEscapeProperty(propertyName, value, num);
            }
            else
            {
                WriteNumberByOptions(propertyName, value);
            }
        }

        private void WriteNumberEscape(ReadOnlySpan<byte> utf8PropertyName, double value)
        {
            int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
            if (num != -1)
            {
                WriteNumberEscapeProperty(utf8PropertyName, value, num);
            }
            else
            {
                WriteNumberByOptions(utf8PropertyName, value);
            }
        }

        private void WriteNumberEscapeProperty(ReadOnlySpan<char> propertyName, double value, int firstEscapeIndexProp)
        {
            char[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
            Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
            Span<char> destination = span;
            JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteNumberByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<char>.Shared.Return(array);
            }
        }

        private void WriteNumberEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, double value, int firstEscapeIndexProp)
        {
            byte[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
            Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
            Span<byte> destination = span;
            JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteNumberByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<byte>.Shared.Return(array);
            }
        }

        private void WriteNumberByOptions(ReadOnlySpan<char> propertyName, double value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteNumberIndented(propertyName, value);
            }
            else
            {
                WriteNumberMinimized(propertyName, value);
            }
        }

        private void WriteNumberByOptions(ReadOnlySpan<byte> utf8PropertyName, double value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteNumberIndented(utf8PropertyName, value);
            }
            else
            {
                WriteNumberMinimized(utf8PropertyName, value);
            }
        }

        private void WriteNumberMinimized(ReadOnlySpan<char> escapedPropertyName, double value)
        {
            int num = escapedPropertyName.Length * 3 + 128 + 4;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            int bytesWritten;
            bool flag = TryFormatDouble(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberMinimized(ReadOnlySpan<byte> escapedPropertyName, double value)
        {
            int num = escapedPropertyName.Length + 128 + 3;
            int num2 = num + 1;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            int bytesWritten;
            bool flag = TryFormatDouble(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberIndented(ReadOnlySpan<char> escapedPropertyName, double value)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length * 3 + 128 + 5 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            int bytesWritten;
            bool flag = TryFormatDouble(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberIndented(ReadOnlySpan<byte> escapedPropertyName, double value)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length + 128 + 4;
            int num2 = num + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            int bytesWritten;
            bool flag = TryFormatDouble(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        internal void WritePropertyName(double value)
        {
            JsonWriterHelper.ValidateDouble(value);
            Span<byte> destination = stackalloc byte[128];
            int bytesWritten;
            bool flag = TryFormatDouble(value, destination, out bytesWritten);
            WritePropertyNameUnescaped(destination.Slice(0, bytesWritten));
        }

        /// <summary>
        /// Writes the pre-encoded property name and <see cref="T:System.Single" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write..</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Single" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G').
        /// </remarks>
        public void WriteNumber(JsonEncodedText propertyName, float value)
        {
            ReadOnlySpan<byte> encodedUtf8Bytes = propertyName.EncodedUtf8Bytes;
            JsonWriterHelper.ValidateSingle(value);
            WriteNumberByOptions(encodedUtf8Bytes, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Single" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write..</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Single" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G').
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteNumber(string propertyName, float value)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WriteNumber(propertyName.AsSpan(), value);
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Single" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write..</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Single" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G').
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteNumber(ReadOnlySpan<char> propertyName, float value)
        {
            JsonWriterHelper.ValidateProperty(propertyName);
            JsonWriterHelper.ValidateSingle(value);
            WriteNumberEscape(propertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Single" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded name of the property to write</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Single" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G').
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteNumber(ReadOnlySpan<byte> utf8PropertyName, float value)
        {
            JsonWriterHelper.ValidateProperty(utf8PropertyName);
            JsonWriterHelper.ValidateSingle(value);
            WriteNumberEscape(utf8PropertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        private void WriteNumberEscape(ReadOnlySpan<char> propertyName, float value)
        {
            int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
            if (num != -1)
            {
                WriteNumberEscapeProperty(propertyName, value, num);
            }
            else
            {
                WriteNumberByOptions(propertyName, value);
            }
        }

        private void WriteNumberEscape(ReadOnlySpan<byte> utf8PropertyName, float value)
        {
            int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
            if (num != -1)
            {
                WriteNumberEscapeProperty(utf8PropertyName, value, num);
            }
            else
            {
                WriteNumberByOptions(utf8PropertyName, value);
            }
        }

        private void WriteNumberEscapeProperty(ReadOnlySpan<char> propertyName, float value, int firstEscapeIndexProp)
        {
            char[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
            Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
            Span<char> destination = span;
            JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteNumberByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<char>.Shared.Return(array);
            }
        }

        private void WriteNumberEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, float value, int firstEscapeIndexProp)
        {
            byte[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
            Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
            Span<byte> destination = span;
            JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteNumberByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<byte>.Shared.Return(array);
            }
        }

        private void WriteNumberByOptions(ReadOnlySpan<char> propertyName, float value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteNumberIndented(propertyName, value);
            }
            else
            {
                WriteNumberMinimized(propertyName, value);
            }
        }

        private void WriteNumberByOptions(ReadOnlySpan<byte> utf8PropertyName, float value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteNumberIndented(utf8PropertyName, value);
            }
            else
            {
                WriteNumberMinimized(utf8PropertyName, value);
            }
        }

        private void WriteNumberMinimized(ReadOnlySpan<char> escapedPropertyName, float value)
        {
            int num = escapedPropertyName.Length * 3 + 128 + 4;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            int bytesWritten;
            bool flag = TryFormatSingle(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberMinimized(ReadOnlySpan<byte> escapedPropertyName, float value)
        {
            int num = escapedPropertyName.Length + 128 + 3;
            int num2 = num + 1;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            int bytesWritten;
            bool flag = TryFormatSingle(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberIndented(ReadOnlySpan<char> escapedPropertyName, float value)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length * 3 + 128 + 5 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            int bytesWritten;
            bool flag = TryFormatSingle(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberIndented(ReadOnlySpan<byte> escapedPropertyName, float value)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length + 128 + 4;
            int num2 = num + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            int bytesWritten;
            bool flag = TryFormatSingle(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        internal void WritePropertyName(float value)
        {
            Span<byte> destination = stackalloc byte[128];
            int bytesWritten;
            bool flag = TryFormatSingle(value, destination, out bytesWritten);
            WritePropertyNameUnescaped(destination.Slice(0, bytesWritten));
        }

        /// <summary>
        /// Writes the property name and value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="utf8FormattedNumber">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when <paramref name="utf8FormattedNumber" /> does not represent a valid JSON number.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Int64" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// The property name is escaped before writing.
        /// </remarks>
        internal void WriteNumber(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> utf8FormattedNumber)
        {
            JsonWriterHelper.ValidateProperty(propertyName);
            JsonWriterHelper.ValidateValue(utf8FormattedNumber);
            JsonWriterHelper.ValidateNumber(utf8FormattedNumber);
            WriteNumberEscape(propertyName, utf8FormattedNumber);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        /// <summary>
        /// Writes the property name and value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded name of the property to write..</param>
        /// <param name="utf8FormattedNumber">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when <paramref name="utf8FormattedNumber" /> does not represent a valid JSON number.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Int64" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// The property name is escaped before writing.
        /// </remarks>
        internal void WriteNumber(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> utf8FormattedNumber)
        {
            JsonWriterHelper.ValidateProperty(utf8PropertyName);
            JsonWriterHelper.ValidateValue(utf8FormattedNumber);
            JsonWriterHelper.ValidateNumber(utf8FormattedNumber);
            WriteNumberEscape(utf8PropertyName, utf8FormattedNumber);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        internal void WriteNumber(JsonEncodedText propertyName, ReadOnlySpan<byte> utf8FormattedNumber)
        {
            JsonWriterHelper.ValidateValue(utf8FormattedNumber);
            JsonWriterHelper.ValidateNumber(utf8FormattedNumber);
            WriteNumberByOptions(propertyName.EncodedUtf8Bytes, utf8FormattedNumber);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        private void WriteNumberEscape(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> value)
        {
            int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
            if (num != -1)
            {
                WriteNumberEscapeProperty(propertyName, value, num);
            }
            else
            {
                WriteNumberByOptions(propertyName, value);
            }
        }

        private void WriteNumberEscape(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> value)
        {
            int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
            if (num != -1)
            {
                WriteNumberEscapeProperty(utf8PropertyName, value, num);
            }
            else
            {
                WriteNumberByOptions(utf8PropertyName, value);
            }
        }

        private void WriteNumberEscapeProperty(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> value, int firstEscapeIndexProp)
        {
            char[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
            Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
            Span<char> destination = span;
            JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteNumberByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<char>.Shared.Return(array);
            }
        }

        private void WriteNumberEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> value, int firstEscapeIndexProp)
        {
            byte[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
            Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
            Span<byte> destination = span;
            JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteNumberByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<byte>.Shared.Return(array);
            }
        }

        private void WriteNumberByOptions(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteLiteralIndented(propertyName, value);
            }
            else
            {
                WriteLiteralMinimized(propertyName, value);
            }
        }

        private void WriteNumberByOptions(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteLiteralIndented(utf8PropertyName, value);
            }
            else
            {
                WriteLiteralMinimized(utf8PropertyName, value);
            }
        }

        /// <summary>
        /// Writes the pre-encoded property name and <see cref="T:System.Guid" /> value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Guid" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'D'), as the form: nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn.
        /// </remarks>
        public void WriteString(JsonEncodedText propertyName, Guid value)
        {
            ReadOnlySpan<byte> encodedUtf8Bytes = propertyName.EncodedUtf8Bytes;
            WriteStringByOptions(encodedUtf8Bytes, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Guid" /> value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Guid" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'D'), as the form: nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn.
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteString(string propertyName, Guid value)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WriteString(propertyName.AsSpan(), value);
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Guid" /> value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Guid" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'D'), as the form: nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn.
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteString(ReadOnlySpan<char> propertyName, Guid value)
        {
            JsonWriterHelper.ValidateProperty(propertyName);
            WriteStringEscape(propertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Guid" /> value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Guid" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'D'), as the form: nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn.
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteString(ReadOnlySpan<byte> utf8PropertyName, Guid value)
        {
            JsonWriterHelper.ValidateProperty(utf8PropertyName);
            WriteStringEscape(utf8PropertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        private void WriteStringEscape(ReadOnlySpan<char> propertyName, Guid value)
        {
            int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
            if (num != -1)
            {
                WriteStringEscapeProperty(propertyName, value, num);
            }
            else
            {
                WriteStringByOptions(propertyName, value);
            }
        }

        private void WriteStringEscape(ReadOnlySpan<byte> utf8PropertyName, Guid value)
        {
            int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
            if (num != -1)
            {
                WriteStringEscapeProperty(utf8PropertyName, value, num);
            }
            else
            {
                WriteStringByOptions(utf8PropertyName, value);
            }
        }

        private void WriteStringEscapeProperty(ReadOnlySpan<char> propertyName, Guid value, int firstEscapeIndexProp)
        {
            char[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
            Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
            Span<char> destination = span;
            JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteStringByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<char>.Shared.Return(array);
            }
        }

        private void WriteStringEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, Guid value, int firstEscapeIndexProp)
        {
            byte[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
            Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
            Span<byte> destination = span;
            JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteStringByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<byte>.Shared.Return(array);
            }
        }

        private void WriteStringByOptions(ReadOnlySpan<char> propertyName, Guid value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteStringIndented(propertyName, value);
            }
            else
            {
                WriteStringMinimized(propertyName, value);
            }
        }

        private void WriteStringByOptions(ReadOnlySpan<byte> utf8PropertyName, Guid value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteStringIndented(utf8PropertyName, value);
            }
            else
            {
                WriteStringMinimized(utf8PropertyName, value);
            }
        }

        private void WriteStringMinimized(ReadOnlySpan<char> escapedPropertyName, Guid value)
        {
            int num = escapedPropertyName.Length * 3 + 36 + 6;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 34;
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 34;
        }

        private void WriteStringMinimized(ReadOnlySpan<byte> escapedPropertyName, Guid value)
        {
            int num = escapedPropertyName.Length + 36 + 5;
            int num2 = num + 1;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 34;
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 34;
        }

        private void WriteStringIndented(ReadOnlySpan<char> escapedPropertyName, Guid value)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length * 3 + 36 + 7 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            span[BytesPending++] = 34;
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 34;
        }

        private void WriteStringIndented(ReadOnlySpan<byte> escapedPropertyName, Guid value)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length + 36 + 6;
            int num2 = num + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            span[BytesPending++] = 34;
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 34;
        }

        internal void WritePropertyName(Guid value)
        {
            Span<byte> destination = stackalloc byte[36];
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten);
            WritePropertyNameUnescaped(destination.Slice(0, bytesWritten));
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void ValidatePropertyNameAndDepth(ReadOnlySpan<char> propertyName)
        {
            if (propertyName.Length > 166666666 || CurrentDepth >= _options.MaxDepth)
            {
                ThrowHelper.ThrowInvalidOperationOrArgumentException(propertyName, _currentDepth, _options.MaxDepth);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void ValidatePropertyNameAndDepth(ReadOnlySpan<byte> utf8PropertyName)
        {
            if (utf8PropertyName.Length > 166666666 || CurrentDepth >= _options.MaxDepth)
            {
                ThrowHelper.ThrowInvalidOperationOrArgumentException(utf8PropertyName, _currentDepth, _options.MaxDepth);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void ValidateDepth()
        {
            if (CurrentDepth >= _options.MaxDepth)
            {
                ThrowHelper.ThrowInvalidOperationException(_currentDepth, _options.MaxDepth);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void ValidateWritingProperty()
        {
            if (!_options.SkipValidation && (!_inObject || _tokenType == JsonTokenType.PropertyName))
            {
                ThrowHelper.ThrowInvalidOperationException(ExceptionResource.CannotWritePropertyWithinArray, 0, _options.MaxDepth, 0, _tokenType);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void ValidateWritingProperty(byte token)
        {
            if (!_options.SkipValidation)
            {
                if (!_inObject || _tokenType == JsonTokenType.PropertyName)
                {
                    ThrowHelper.ThrowInvalidOperationException(ExceptionResource.CannotWritePropertyWithinArray, 0, _options.MaxDepth, 0, _tokenType);
                }
                UpdateBitStackOnStart(token);
            }
        }

        private void WritePropertyNameMinimized(ReadOnlySpan<byte> escapedPropertyName, byte token)
        {
            int num = escapedPropertyName.Length + 4;
            int num2 = num + 1;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = token;
        }

        private void WritePropertyNameIndented(ReadOnlySpan<byte> escapedPropertyName, byte token)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length + 5;
            int num2 = num + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            span[BytesPending++] = token;
        }

        private void WritePropertyNameMinimized(ReadOnlySpan<char> escapedPropertyName, byte token)
        {
            int num = escapedPropertyName.Length * 3 + 5;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = token;
        }

        private void WritePropertyNameIndented(ReadOnlySpan<char> escapedPropertyName, byte token)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length * 3 + 6 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            span[BytesPending++] = token;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void TranscodeAndWrite(ReadOnlySpan<char> escapedPropertyName, Span<byte> output)
        {
            ReadOnlySpan<byte> utf16Source = MemoryMarshal.AsBytes(escapedPropertyName);
            int bytesConsumed;
            int bytesWritten;
            OperationStatus operationStatus = JsonWriterHelper.ToUtf8(utf16Source, output.Slice(BytesPending), out bytesConsumed, out bytesWritten);
            BytesPending += bytesWritten;
        }

        /// <summary>
        /// Writes the pre-encoded property name and the JSON literal "null" as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteNull(JsonEncodedText propertyName)
        {
            WriteLiteralHelper(propertyName.EncodedUtf8Bytes, JsonConstants.NullValue);
            _tokenType = JsonTokenType.Null;
        }

        internal void WriteNullSection(ReadOnlySpan<byte> escapedPropertyNameSection)
        {
            if (_options.Indented)
            {
                ReadOnlySpan<byte> utf8PropertyName = escapedPropertyNameSection.Slice(1, escapedPropertyNameSection.Length - 3);
                WriteLiteralHelper(utf8PropertyName, JsonConstants.NullValue);
                _tokenType = JsonTokenType.Null;
            }
            else
            {
                ReadOnlySpan<byte> nullValue = JsonConstants.NullValue;
                WriteLiteralSection(escapedPropertyNameSection, nullValue);
                SetFlagToAddListSeparatorBeforeNextItem();
                _tokenType = JsonTokenType.Null;
            }
        }

        private void WriteLiteralHelper(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> value)
        {
            WriteLiteralByOptions(utf8PropertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
        }

        /// <summary>
        /// Writes the property name and the JSON literal "null" as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteNull(string propertyName)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WriteNull(propertyName.AsSpan());
        }

        /// <summary>
        /// Writes the property name and the JSON literal "null" as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteNull(ReadOnlySpan<char> propertyName)
        {
            JsonWriterHelper.ValidateProperty(propertyName);
            ReadOnlySpan<byte> nullValue = JsonConstants.NullValue;
            WriteLiteralEscape(propertyName, nullValue);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Null;
        }

        /// <summary>
        /// Writes the property name and the JSON literal "null" as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded name of the property to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteNull(ReadOnlySpan<byte> utf8PropertyName)
        {
            JsonWriterHelper.ValidateProperty(utf8PropertyName);
            ReadOnlySpan<byte> nullValue = JsonConstants.NullValue;
            WriteLiteralEscape(utf8PropertyName, nullValue);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Null;
        }

        /// <summary>
        /// Writes the pre-encoded property name and <see cref="T:System.Boolean" /> value (as a JSON literal "true" or "false") as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteBoolean(JsonEncodedText propertyName, bool value)
        {
            if (value)
            {
                WriteLiteralHelper(propertyName.EncodedUtf8Bytes, JsonConstants.TrueValue);
                _tokenType = JsonTokenType.True;
            }
            else
            {
                WriteLiteralHelper(propertyName.EncodedUtf8Bytes, JsonConstants.FalseValue);
                _tokenType = JsonTokenType.False;
            }
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Boolean" /> value (as a JSON literal "true" or "false") as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteBoolean(string propertyName, bool value)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WriteBoolean(propertyName.AsSpan(), value);
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Boolean" /> value (as a JSON literal "true" or "false") as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteBoolean(ReadOnlySpan<char> propertyName, bool value)
        {
            JsonWriterHelper.ValidateProperty(propertyName);
            ReadOnlySpan<byte> value2 = (value ? JsonConstants.TrueValue : JsonConstants.FalseValue);
            WriteLiteralEscape(propertyName, value2);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = (value ? JsonTokenType.True : JsonTokenType.False);
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Boolean" /> value (as a JSON literal "true" or "false") as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteBoolean(ReadOnlySpan<byte> utf8PropertyName, bool value)
        {
            JsonWriterHelper.ValidateProperty(utf8PropertyName);
            ReadOnlySpan<byte> value2 = (value ? JsonConstants.TrueValue : JsonConstants.FalseValue);
            WriteLiteralEscape(utf8PropertyName, value2);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = (value ? JsonTokenType.True : JsonTokenType.False);
        }

        private void WriteLiteralEscape(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> value)
        {
            int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
            if (num != -1)
            {
                WriteLiteralEscapeProperty(propertyName, value, num);
            }
            else
            {
                WriteLiteralByOptions(propertyName, value);
            }
        }

        private void WriteLiteralEscape(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> value)
        {
            int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
            if (num != -1)
            {
                WriteLiteralEscapeProperty(utf8PropertyName, value, num);
            }
            else
            {
                WriteLiteralByOptions(utf8PropertyName, value);
            }
        }

        private void WriteLiteralEscapeProperty(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> value, int firstEscapeIndexProp)
        {
            char[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
            Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
            Span<char> destination = span;
            JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteLiteralByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<char>.Shared.Return(array);
            }
        }

        private void WriteLiteralEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> value, int firstEscapeIndexProp)
        {
            byte[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
            Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
            Span<byte> destination = span;
            JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteLiteralByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<byte>.Shared.Return(array);
            }
        }

        private void WriteLiteralByOptions(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteLiteralIndented(propertyName, value);
            }
            else
            {
                WriteLiteralMinimized(propertyName, value);
            }
        }

        private void WriteLiteralByOptions(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteLiteralIndented(utf8PropertyName, value);
            }
            else
            {
                WriteLiteralMinimized(utf8PropertyName, value);
            }
        }

        private void WriteLiteralMinimized(ReadOnlySpan<char> escapedPropertyName, ReadOnlySpan<byte> value)
        {
            int num = escapedPropertyName.Length * 3 + value.Length + 4;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            value.CopyTo(span.Slice(BytesPending));
            BytesPending += value.Length;
        }

        private void WriteLiteralMinimized(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<byte> value)
        {
            int num = escapedPropertyName.Length + value.Length + 3;
            int num2 = num + 1;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            value.CopyTo(span.Slice(BytesPending));
            BytesPending += value.Length;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void WriteLiteralSection(ReadOnlySpan<byte> escapedPropertyNameSection, ReadOnlySpan<byte> value)
        {
            int num = escapedPropertyNameSection.Length + value.Length;
            int num2 = num + 1;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            escapedPropertyNameSection.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyNameSection.Length;
            value.CopyTo(span.Slice(BytesPending));
            BytesPending += value.Length;
        }

        private void WriteLiteralIndented(ReadOnlySpan<char> escapedPropertyName, ReadOnlySpan<byte> value)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length * 3 + value.Length + 5 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            value.CopyTo(span.Slice(BytesPending));
            BytesPending += value.Length;
        }

        private void WriteLiteralIndented(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<byte> value)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length + value.Length + 4;
            int num2 = num + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            value.CopyTo(span.Slice(BytesPending));
            BytesPending += value.Length;
        }

        internal void WritePropertyName(bool value)
        {
            Span<byte> destination = stackalloc byte[5];
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten);
            WritePropertyNameUnescaped(destination.Slice(0, bytesWritten));
        }

        /// <summary>
        /// Writes the pre-encoded property name and <see cref="T:System.Int64" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Int64" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// </remarks>
        public void WriteNumber(JsonEncodedText propertyName, long value)
        {
            ReadOnlySpan<byte> encodedUtf8Bytes = propertyName.EncodedUtf8Bytes;
            WriteNumberByOptions(encodedUtf8Bytes, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Int64" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Int64" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteNumber(string propertyName, long value)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WriteNumber(propertyName.AsSpan(), value);
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Int64" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Int64" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteNumber(ReadOnlySpan<char> propertyName, long value)
        {
            JsonWriterHelper.ValidateProperty(propertyName);
            WriteNumberEscape(propertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Int64" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Int64" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteNumber(ReadOnlySpan<byte> utf8PropertyName, long value)
        {
            JsonWriterHelper.ValidateProperty(utf8PropertyName);
            WriteNumberEscape(utf8PropertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        /// <summary>
        /// Writes the pre-encoded property name and <see cref="T:System.Int32" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Int32" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// </remarks>
        public void WriteNumber(JsonEncodedText propertyName, int value)
        {
            WriteNumber(propertyName, (long)value);
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Int32" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Int32" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteNumber(string propertyName, int value)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WriteNumber(propertyName.AsSpan(), (long)value);
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Int32" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Int32" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// </remarks>
        public void WriteNumber(ReadOnlySpan<char> propertyName, int value)
        {
            WriteNumber(propertyName, (long)value);
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.Int32" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Int32" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteNumber(ReadOnlySpan<byte> utf8PropertyName, int value)
        {
            WriteNumber(utf8PropertyName, (long)value);
        }

        private void WriteNumberEscape(ReadOnlySpan<char> propertyName, long value)
        {
            int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
            if (num != -1)
            {
                WriteNumberEscapeProperty(propertyName, value, num);
            }
            else
            {
                WriteNumberByOptions(propertyName, value);
            }
        }

        private void WriteNumberEscape(ReadOnlySpan<byte> utf8PropertyName, long value)
        {
            int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
            if (num != -1)
            {
                WriteNumberEscapeProperty(utf8PropertyName, value, num);
            }
            else
            {
                WriteNumberByOptions(utf8PropertyName, value);
            }
        }

        private void WriteNumberEscapeProperty(ReadOnlySpan<char> propertyName, long value, int firstEscapeIndexProp)
        {
            char[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
            Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
            Span<char> destination = span;
            JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteNumberByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<char>.Shared.Return(array);
            }
        }

        private void WriteNumberEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, long value, int firstEscapeIndexProp)
        {
            byte[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
            Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
            Span<byte> destination = span;
            JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteNumberByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<byte>.Shared.Return(array);
            }
        }

        private void WriteNumberByOptions(ReadOnlySpan<char> propertyName, long value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteNumberIndented(propertyName, value);
            }
            else
            {
                WriteNumberMinimized(propertyName, value);
            }
        }

        private void WriteNumberByOptions(ReadOnlySpan<byte> utf8PropertyName, long value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteNumberIndented(utf8PropertyName, value);
            }
            else
            {
                WriteNumberMinimized(utf8PropertyName, value);
            }
        }

        private void WriteNumberMinimized(ReadOnlySpan<char> escapedPropertyName, long value)
        {
            int num = escapedPropertyName.Length * 3 + 20 + 4;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberMinimized(ReadOnlySpan<byte> escapedPropertyName, long value)
        {
            int num = escapedPropertyName.Length + 20 + 3;
            int num2 = num + 1;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberIndented(ReadOnlySpan<char> escapedPropertyName, long value)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length * 3 + 20 + 5 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberIndented(ReadOnlySpan<byte> escapedPropertyName, long value)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length + 20 + 4;
            int num2 = num + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        internal void WritePropertyName(int value)
        {
            WritePropertyName((long)value);
        }

        internal void WritePropertyName(long value)
        {
            Span<byte> destination = stackalloc byte[20];
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten);
            WritePropertyNameUnescaped(destination.Slice(0, bytesWritten));
        }

        /// <summary>
        /// Writes the pre-encoded property name (as a JSON string) as the first part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WritePropertyName(JsonEncodedText propertyName)
        {
            WritePropertyNameHelper(propertyName.EncodedUtf8Bytes);
        }

        internal void WritePropertyNameSection(ReadOnlySpan<byte> escapedPropertyNameSection)
        {
            if (_options.Indented)
            {
                ReadOnlySpan<byte> utf8PropertyName = escapedPropertyNameSection.Slice(1, escapedPropertyNameSection.Length - 3);
                WritePropertyNameHelper(utf8PropertyName);
            }
            else
            {
                WriteStringPropertyNameSection(escapedPropertyNameSection);
                _currentDepth &= int.MaxValue;
                _tokenType = JsonTokenType.PropertyName;
            }
        }

        private void WritePropertyNameHelper(ReadOnlySpan<byte> utf8PropertyName)
        {
            WriteStringByOptionsPropertyName(utf8PropertyName);
            _currentDepth &= int.MaxValue;
            _tokenType = JsonTokenType.PropertyName;
        }

        /// <summary>
        /// Writes the property name (as a JSON string) as the first part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        public void WritePropertyName(string propertyName)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WritePropertyName(propertyName.AsSpan());
        }

        /// <summary>
        /// Writes the property name (as a JSON string) as the first part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        public void WritePropertyName(ReadOnlySpan<char> propertyName)
        {
            JsonWriterHelper.ValidateProperty(propertyName);
            int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
            if (num != -1)
            {
                WriteStringEscapeProperty(propertyName, num);
            }
            else
            {
                WriteStringByOptionsPropertyName(propertyName);
            }
            _currentDepth &= int.MaxValue;
            _tokenType = JsonTokenType.PropertyName;
        }

        private void WriteStringEscapeProperty(scoped ReadOnlySpan<char> propertyName, int firstEscapeIndexProp)
        {
            Debug.Assert(int.MaxValue / JsonConstants.MaxExpansionFactorWhileEscaping >= propertyName.Length);

            char[]? propertyArray = null;
            scoped Span<char> escapedPropertyName;

            if (firstEscapeIndexProp != -1)
            {
                int length = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);

                if (length > JsonConstants.StackallocCharThreshold)
                {
                    propertyArray = ArrayPool<char>.Shared.Rent(length);
                    escapedPropertyName = propertyArray;
                }
                else
                {
                    escapedPropertyName = stackalloc char[JsonConstants.StackallocCharThreshold];
                }

                JsonWriterHelper.EscapeString(propertyName, escapedPropertyName, firstEscapeIndexProp, _options.Encoder, out int written);
                propertyName = escapedPropertyName.Slice(0, written);
            }

            WriteStringByOptionsPropertyName(propertyName);

            if (propertyArray != null)
            {
                ArrayPool<char>.Shared.Return(propertyArray);
            }
        }

        private void WriteStringByOptionsPropertyName(ReadOnlySpan<char> propertyName)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteStringIndentedPropertyName(propertyName);
            }
            else
            {
                WriteStringMinimizedPropertyName(propertyName);
            }
        }

        private void WriteStringMinimizedPropertyName(ReadOnlySpan<char> escapedPropertyName)
        {
            int num = escapedPropertyName.Length * 3 + 4;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
        }

        private void WriteStringIndentedPropertyName(ReadOnlySpan<char> escapedPropertyName)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length * 3 + 5 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
        }

        /// <summary>
        /// Writes the UTF-8 property name (as a JSON string) as the first part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded name of the property to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        public void WritePropertyName(ReadOnlySpan<byte> utf8PropertyName)
        {
            JsonWriterHelper.ValidateProperty(utf8PropertyName);
            int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
            if (num != -1)
            {
                WriteStringEscapeProperty(utf8PropertyName, num);
            }
            else
            {
                WriteStringByOptionsPropertyName(utf8PropertyName);
            }
            _currentDepth &= int.MaxValue;
            _tokenType = JsonTokenType.PropertyName;
        }

        private void WritePropertyNameUnescaped(ReadOnlySpan<byte> utf8PropertyName)
        {
            JsonWriterHelper.ValidateProperty(utf8PropertyName);
            WriteStringByOptionsPropertyName(utf8PropertyName);
            _currentDepth &= int.MaxValue;
            _tokenType = JsonTokenType.PropertyName;
        }

        private void WriteStringEscapeProperty(scoped ReadOnlySpan<byte> utf8PropertyName, int firstEscapeIndexProp)
        {
            Debug.Assert(int.MaxValue / JsonConstants.MaxExpansionFactorWhileEscaping >= utf8PropertyName.Length);

            byte[]? propertyArray = null;
            scoped Span<byte> escapedPropertyName;

            if (firstEscapeIndexProp != -1)
            {
                int length = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);

                if (length > JsonConstants.StackallocByteThreshold)
                {
                    propertyArray = ArrayPool<byte>.Shared.Rent(length);
                    escapedPropertyName = propertyArray;
                }
                else
                {
                    escapedPropertyName = stackalloc byte[JsonConstants.StackallocByteThreshold];
                }

                JsonWriterHelper.EscapeString(utf8PropertyName, escapedPropertyName, firstEscapeIndexProp, _options.Encoder, out int written);
                utf8PropertyName = escapedPropertyName.Slice(0, written);
            }

            WriteStringByOptionsPropertyName(utf8PropertyName);

            if (propertyArray != null)
            {
                ArrayPool<byte>.Shared.Return(propertyArray);
            }
        }

        private void WriteStringByOptionsPropertyName(ReadOnlySpan<byte> utf8PropertyName)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteStringIndentedPropertyName(utf8PropertyName);
            }
            else
            {
                WriteStringMinimizedPropertyName(utf8PropertyName);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void WriteStringMinimizedPropertyName(ReadOnlySpan<byte> escapedPropertyName)
        {
            int num = escapedPropertyName.Length + 3;
            int num2 = num + 1;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void WriteStringPropertyNameSection(ReadOnlySpan<byte> escapedPropertyNameSection)
        {
            int num = escapedPropertyNameSection.Length + 1;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            escapedPropertyNameSection.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyNameSection.Length;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void WriteStringIndentedPropertyName(ReadOnlySpan<byte> escapedPropertyName)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length + 4;
            int num2 = num + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
        }

        /// <summary>
        /// Writes the pre-encoded property name and pre-encoded value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <param name="value">The JSON-encoded value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteString(JsonEncodedText propertyName, JsonEncodedText value)
        {
            WriteStringHelper(propertyName.EncodedUtf8Bytes, value.EncodedUtf8Bytes);
        }

        private void WriteStringHelper(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> utf8Value)
        {
            WriteStringByOptions(utf8PropertyName, utf8Value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the property name and pre-encoded value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <param name="value">The JSON-encoded value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteString(string propertyName, JsonEncodedText value)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WriteString(propertyName.AsSpan(), value);
        }

        /// <summary>
        /// Writes the property name and string text value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name or value is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// <para>
        /// The property name and value is escaped before writing.
        /// </para>
        /// <para>
        /// If <paramref name="value" /> is <see langword="null" /> the JSON null value is written,
        /// as if <see cref="M:System.Text.Json.Utf8JsonWriter.WriteNull(System.ReadOnlySpan{System.Byte})" /> were called.
        /// </para>
        /// </remarks>
        public void WriteString(string propertyName, string? value)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            if (value == null)
            {
                WriteNull(propertyName.AsSpan());
            }
            else
            {
                WriteString(propertyName.AsSpan(), value.AsSpan());
            }
        }

        /// <summary>
        /// Writes the property name and text value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name or value is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name and value is escaped before writing.
        /// </remarks>
        public void WriteString(ReadOnlySpan<char> propertyName, ReadOnlySpan<char> value)
        {
            JsonWriterHelper.ValidatePropertyAndValue(propertyName, value);
            WriteStringEscape(propertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the UTF-8 property name and UTF-8 text value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded name of the property to write.</param>
        /// <param name="utf8Value">The UTF-8 encoded value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name or value is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name and value is escaped before writing.
        /// </remarks>
        public void WriteString(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> utf8Value)
        {
            JsonWriterHelper.ValidatePropertyAndValue(utf8PropertyName, utf8Value);
            WriteStringEscape(utf8PropertyName, utf8Value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the pre-encoded property name and string text value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified value is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// <para>
        /// The value is escaped before writing.
        /// </para>
        /// <para>
        /// If <paramref name="value" /> is <see langword="null" /> the JSON null value is written,
        /// as if <see cref="M:System.Text.Json.Utf8JsonWriter.WriteNull(System.Text.Json.JsonEncodedText)" /> was called.
        /// </para>
        /// </remarks>
        public void WriteString(JsonEncodedText propertyName, string? value)
        {
            if (value == null)
            {
                WriteNull(propertyName);
            }
            else
            {
                WriteString(propertyName, value.AsSpan());
            }
        }

        /// <summary>
        /// Writes the pre-encoded property name and text value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified value is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The value is escaped before writing.
        /// </remarks>
        public void WriteString(JsonEncodedText propertyName, ReadOnlySpan<char> value)
        {
            WriteStringHelperEscapeValue(propertyName.EncodedUtf8Bytes, value);
        }

        private void WriteStringHelperEscapeValue(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<char> value)
        {
            JsonWriterHelper.ValidateValue(value);
            int num = JsonWriterHelper.NeedsEscaping(value, _options.Encoder);
            if (num != -1)
            {
                WriteStringEscapeValueOnly(utf8PropertyName, value, num);
            }
            else
            {
                WriteStringByOptions(utf8PropertyName, value);
            }
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the property name and text value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name or value is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name and value is escaped before writing.
        /// </remarks>
        public void WriteString(string propertyName, ReadOnlySpan<char> value)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WriteString(propertyName.AsSpan(), value);
        }

        /// <summary>
        /// Writes the UTF-8 property name and text value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name or value is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name and value is escaped before writing.
        /// </remarks>
        public void WriteString(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<char> value)
        {
            JsonWriterHelper.ValidatePropertyAndValue(utf8PropertyName, value);
            WriteStringEscape(utf8PropertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the pre-encoded property name and UTF-8 text value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <param name="utf8Value">The UTF-8 encoded value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified value is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The value is escaped before writing.
        /// </remarks>
        public void WriteString(JsonEncodedText propertyName, ReadOnlySpan<byte> utf8Value)
        {
            WriteStringHelperEscapeValue(propertyName.EncodedUtf8Bytes, utf8Value);
        }

        private void WriteStringHelperEscapeValue(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> utf8Value)
        {
            JsonWriterHelper.ValidateValue(utf8Value);
            int num = JsonWriterHelper.NeedsEscaping(utf8Value, _options.Encoder);
            if (num != -1)
            {
                WriteStringEscapeValueOnly(utf8PropertyName, utf8Value, num);
            }
            else
            {
                WriteStringByOptions(utf8PropertyName, utf8Value);
            }
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the property name and UTF-8 text value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="utf8Value">The UTF-8 encoded value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name or value is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name and value is escaped before writing.
        /// </remarks>
        public void WriteString(string propertyName, ReadOnlySpan<byte> utf8Value)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WriteString(propertyName.AsSpan(), utf8Value);
        }

        /// <summary>
        /// Writes the property name and UTF-8 text value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="utf8Value">The UTF-8 encoded value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name or value is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name and value is escaped before writing.
        /// </remarks>
        public void WriteString(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> utf8Value)
        {
            JsonWriterHelper.ValidatePropertyAndValue(propertyName, utf8Value);
            WriteStringEscape(propertyName, utf8Value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the property name and pre-encoded value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The JSON-encoded value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteString(ReadOnlySpan<char> propertyName, JsonEncodedText value)
        {
            WriteStringHelperEscapeProperty(propertyName, value.EncodedUtf8Bytes);
        }

        private void WriteStringHelperEscapeProperty(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> utf8Value)
        {
            JsonWriterHelper.ValidateProperty(propertyName);
            int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
            if (num != -1)
            {
                WriteStringEscapePropertyOnly(propertyName, utf8Value, num);
            }
            else
            {
                WriteStringByOptions(propertyName, utf8Value);
            }
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the property name and string text value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name or value is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// <para>
        /// The property name and value are escaped before writing.
        /// </para>
        /// <para>
        /// If <paramref name="value" /> is <see langword="null" /> the JSON null value is written,
        /// as if <see cref="M:System.Text.Json.Utf8JsonWriter.WriteNull(System.ReadOnlySpan{System.Char})" /> was called.
        /// </para>
        /// </remarks>
        public void WriteString(ReadOnlySpan<char> propertyName, string? value)
        {
            if (value == null)
            {
                WriteNull(propertyName);
            }
            else
            {
                WriteString(propertyName, value.AsSpan());
            }
        }

        /// <summary>
        /// Writes the UTF-8 property name and pre-encoded value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded name of the property to write.</param>
        /// <param name="value">The JSON-encoded value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The property name is escaped before writing.
        /// </remarks>
        public void WriteString(ReadOnlySpan<byte> utf8PropertyName, JsonEncodedText value)
        {
            WriteStringHelperEscapeProperty(utf8PropertyName, value.EncodedUtf8Bytes);
        }

        private void WriteStringHelperEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> utf8Value)
        {
            JsonWriterHelper.ValidateProperty(utf8PropertyName);
            int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
            if (num != -1)
            {
                WriteStringEscapePropertyOnly(utf8PropertyName, utf8Value, num);
            }
            else
            {
                WriteStringByOptions(utf8PropertyName, utf8Value);
            }
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the UTF-8 property name and string text value (as a JSON string) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name or value is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// <para>
        /// The property name and value are escaped before writing.
        /// </para>
        /// <para>
        /// If <paramref name="value" /> is <see langword="null" /> the JSON null value is written,
        /// as if <see cref="M:System.Text.Json.Utf8JsonWriter.WriteNull(System.ReadOnlySpan{System.Byte})" /> was called.
        /// </para>
        /// </remarks>
        public void WriteString(ReadOnlySpan<byte> utf8PropertyName, string? value)
        {
            if (value == null)
            {
                WriteNull(utf8PropertyName);
            }
            else
            {
                WriteString(utf8PropertyName, value.AsSpan());
            }
        }

        private void WriteStringEscapeValueOnly(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<byte> utf8Value, int firstEscapeIndex)
        {
            byte[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8Value.Length, firstEscapeIndex);
            Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
            Span<byte> destination = span;
            JsonWriterHelper.EscapeString(utf8Value, destination, firstEscapeIndex, _options.Encoder, out var written);
            WriteStringByOptions(escapedPropertyName, destination.Slice(0, written));
            if (array != null)
            {
                ArrayPool<byte>.Shared.Return(array);
            }
        }

        private void WriteStringEscapeValueOnly(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<char> value, int firstEscapeIndex)
        {
            char[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(value.Length, firstEscapeIndex);
            Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
            Span<char> destination = span;
            JsonWriterHelper.EscapeString(value, destination, firstEscapeIndex, _options.Encoder, out var written);
            WriteStringByOptions(escapedPropertyName, destination.Slice(0, written));
            if (array != null)
            {
                ArrayPool<char>.Shared.Return(array);
            }
        }

        private void WriteStringEscapePropertyOnly(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> escapedValue, int firstEscapeIndex)
        {
            char[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndex);
            Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
            Span<char> destination = span;
            JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndex, _options.Encoder, out var written);
            WriteStringByOptions(destination.Slice(0, written), escapedValue);
            if (array != null)
            {
                ArrayPool<char>.Shared.Return(array);
            }
        }

        private void WriteStringEscapePropertyOnly(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> escapedValue, int firstEscapeIndex)
        {
            byte[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndex);
            Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
            Span<byte> destination = span;
            JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndex, _options.Encoder, out var written);
            WriteStringByOptions(destination.Slice(0, written), escapedValue);
            if (array != null)
            {
                ArrayPool<byte>.Shared.Return(array);
            }
        }

        private void WriteStringEscape(ReadOnlySpan<char> propertyName, ReadOnlySpan<char> value)
        {
            int num = JsonWriterHelper.NeedsEscaping(value, _options.Encoder);
            int num2 = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
            if (num + num2 != -2)
            {
                WriteStringEscapePropertyOrValue(propertyName, value, num2, num);
            }
            else
            {
                WriteStringByOptions(propertyName, value);
            }
        }

        private void WriteStringEscape(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> utf8Value)
        {
            int num = JsonWriterHelper.NeedsEscaping(utf8Value, _options.Encoder);
            int num2 = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
            if (num + num2 != -2)
            {
                WriteStringEscapePropertyOrValue(utf8PropertyName, utf8Value, num2, num);
            }
            else
            {
                WriteStringByOptions(utf8PropertyName, utf8Value);
            }
        }

        private void WriteStringEscape(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> utf8Value)
        {
            int num = JsonWriterHelper.NeedsEscaping(utf8Value, _options.Encoder);
            int num2 = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
            if (num + num2 != -2)
            {
                WriteStringEscapePropertyOrValue(propertyName, utf8Value, num2, num);
            }
            else
            {
                WriteStringByOptions(propertyName, utf8Value);
            }
        }

        private void WriteStringEscape(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<char> value)
        {
            int num = JsonWriterHelper.NeedsEscaping(value, _options.Encoder);
            int num2 = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
            if (num + num2 != -2)
            {
                WriteStringEscapePropertyOrValue(utf8PropertyName, value, num2, num);
            }
            else
            {
                WriteStringByOptions(utf8PropertyName, value);
            }
        }

        private void WriteStringEscapePropertyOrValue(scoped ReadOnlySpan<char> propertyName, scoped ReadOnlySpan<char> value, int firstEscapeIndexProp, int firstEscapeIndexVal)
        {
            Debug.Assert(int.MaxValue / JsonConstants.MaxExpansionFactorWhileEscaping >= value.Length);
            Debug.Assert(int.MaxValue / JsonConstants.MaxExpansionFactorWhileEscaping >= propertyName.Length);

            char[]? valueArray = null;
            char[]? propertyArray = null;
            scoped Span<char> escapedValue;

            if (firstEscapeIndexVal != -1)
            {
                int length = JsonWriterHelper.GetMaxEscapedLength(value.Length, firstEscapeIndexVal);

                if (length > JsonConstants.StackallocCharThreshold)
                {
                    valueArray = ArrayPool<char>.Shared.Rent(length);
                    escapedValue = valueArray;
                }
                else
                {
                    escapedValue = stackalloc char[JsonConstants.StackallocCharThreshold];
                }

                JsonWriterHelper.EscapeString(value, escapedValue, firstEscapeIndexVal, _options.Encoder, out int written);
                value = escapedValue.Slice(0, written);
            }

            scoped Span<char> escapedPropertyName;

            if (firstEscapeIndexProp != -1)
            {
                int length = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);

                if (length > JsonConstants.StackallocCharThreshold)
                {
                    propertyArray = ArrayPool<char>.Shared.Rent(length);
                    escapedPropertyName = propertyArray;
                }
                else
                {
                    escapedPropertyName = stackalloc char[JsonConstants.StackallocCharThreshold];
                }

                JsonWriterHelper.EscapeString(propertyName, escapedPropertyName, firstEscapeIndexProp, _options.Encoder, out int written);
                propertyName = escapedPropertyName.Slice(0, written);
            }

            WriteStringByOptions(propertyName, value);

            if (valueArray != null)
            {
                ArrayPool<char>.Shared.Return(valueArray);
            }

            if (propertyArray != null)
            {
                ArrayPool<char>.Shared.Return(propertyArray);
            }
        }

        private void WriteStringEscapePropertyOrValue(scoped ReadOnlySpan<byte> utf8PropertyName, scoped ReadOnlySpan<byte> utf8Value, int firstEscapeIndexProp, int firstEscapeIndexVal)
        {
            Debug.Assert(int.MaxValue / JsonConstants.MaxExpansionFactorWhileEscaping >= utf8Value.Length);
            Debug.Assert(int.MaxValue / JsonConstants.MaxExpansionFactorWhileEscaping >= utf8PropertyName.Length);

            byte[]? valueArray = null;
            byte[]? propertyArray = null;
            scoped Span<byte> escapedValue;

            if (firstEscapeIndexVal != -1)
            {
                int length = JsonWriterHelper.GetMaxEscapedLength(utf8Value.Length, firstEscapeIndexVal);

                if (length > JsonConstants.StackallocByteThreshold)
                {
                    valueArray = ArrayPool<byte>.Shared.Rent(length);
                    escapedValue = valueArray;
                }
                else
                {
                    escapedValue = stackalloc byte[JsonConstants.StackallocByteThreshold];
                }

                JsonWriterHelper.EscapeString(utf8Value, escapedValue, firstEscapeIndexVal, _options.Encoder, out int written);
                utf8Value = escapedValue.Slice(0, written);
            }

            scoped Span<byte> escapedPropertyName;

            if (firstEscapeIndexProp != -1)
            {
                int length = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);

                if (length > JsonConstants.StackallocByteThreshold)
                {
                    propertyArray = ArrayPool<byte>.Shared.Rent(length);
                    escapedPropertyName = propertyArray;
                }
                else
                {
                    escapedPropertyName = stackalloc byte[JsonConstants.StackallocByteThreshold];
                }

                JsonWriterHelper.EscapeString(utf8PropertyName, escapedPropertyName, firstEscapeIndexProp, _options.Encoder, out int written);
                utf8PropertyName = escapedPropertyName.Slice(0, written);
            }

            WriteStringByOptions(utf8PropertyName, utf8Value);

            if (valueArray != null)
            {
                ArrayPool<byte>.Shared.Return(valueArray);
            }

            if (propertyArray != null)
            {
                ArrayPool<byte>.Shared.Return(propertyArray);
            }
        }

        private void WriteStringEscapePropertyOrValue(scoped ReadOnlySpan<char> propertyName, scoped ReadOnlySpan<byte> utf8Value, int firstEscapeIndexProp, int firstEscapeIndexVal)
        {
            Debug.Assert(int.MaxValue / JsonConstants.MaxExpansionFactorWhileEscaping >= utf8Value.Length);
            Debug.Assert(int.MaxValue / JsonConstants.MaxExpansionFactorWhileEscaping >= propertyName.Length);

            byte[]? valueArray = null;
            char[]? propertyArray = null;
            scoped Span<byte> escapedValue;

            if (firstEscapeIndexVal != -1)
            {
                int length = JsonWriterHelper.GetMaxEscapedLength(utf8Value.Length, firstEscapeIndexVal);

                if (length > JsonConstants.StackallocByteThreshold)
                {
                    valueArray = ArrayPool<byte>.Shared.Rent(length);
                    escapedValue = valueArray;
                }
                else
                {
                    escapedValue = stackalloc byte[JsonConstants.StackallocByteThreshold];
                }

                JsonWriterHelper.EscapeString(utf8Value, escapedValue, firstEscapeIndexVal, _options.Encoder, out int written);
                utf8Value = escapedValue.Slice(0, written);
            }

            scoped Span<char> escapedPropertyName;

            if (firstEscapeIndexProp != -1)
            {
                int length = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);

                if (length > JsonConstants.StackallocCharThreshold)
                {
                    propertyArray = ArrayPool<char>.Shared.Rent(length);
                    escapedPropertyName = propertyArray;
                }
                else
                {
                    escapedPropertyName = stackalloc char[JsonConstants.StackallocCharThreshold];
                }

                JsonWriterHelper.EscapeString(propertyName, escapedPropertyName, firstEscapeIndexProp, _options.Encoder, out int written);
                propertyName = escapedPropertyName.Slice(0, written);
            }

            WriteStringByOptions(propertyName, utf8Value);

            if (valueArray != null)
            {
                ArrayPool<byte>.Shared.Return(valueArray);
            }

            if (propertyArray != null)
            {
                ArrayPool<char>.Shared.Return(propertyArray);
            }
        }

        private void WriteStringEscapePropertyOrValue(scoped ReadOnlySpan<byte> utf8PropertyName, scoped ReadOnlySpan<char> value, int firstEscapeIndexProp, int firstEscapeIndexVal)
        {
            Debug.Assert(int.MaxValue / JsonConstants.MaxExpansionFactorWhileEscaping >= value.Length);
            Debug.Assert(int.MaxValue / JsonConstants.MaxExpansionFactorWhileEscaping >= utf8PropertyName.Length);

            char[]? valueArray = null;
            byte[]? propertyArray = null;
            scoped Span<char> escapedValue;

            if (firstEscapeIndexVal != -1)
            {
                int length = JsonWriterHelper.GetMaxEscapedLength(value.Length, firstEscapeIndexVal);

                if (length > JsonConstants.StackallocCharThreshold)
                {
                    valueArray = ArrayPool<char>.Shared.Rent(length);
                    escapedValue = valueArray;
                }
                else
                {
                    escapedValue = stackalloc char[JsonConstants.StackallocCharThreshold];
                }

                JsonWriterHelper.EscapeString(value, escapedValue, firstEscapeIndexVal, _options.Encoder, out int written);
                value = escapedValue.Slice(0, written);
            }

            scoped Span<byte> escapedPropertyName;

            if (firstEscapeIndexProp != -1)
            {
                int length = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);

                if (length > JsonConstants.StackallocByteThreshold)
                {
                    propertyArray = ArrayPool<byte>.Shared.Rent(length);
                    escapedPropertyName = propertyArray;
                }
                else
                {
                    escapedPropertyName = stackalloc byte[JsonConstants.StackallocByteThreshold];
                }

                JsonWriterHelper.EscapeString(utf8PropertyName, escapedPropertyName, firstEscapeIndexProp, _options.Encoder, out int written);
                utf8PropertyName = escapedPropertyName.Slice(0, written);
            }

            WriteStringByOptions(utf8PropertyName, value);

            if (valueArray != null)
            {
                ArrayPool<char>.Shared.Return(valueArray);
            }

            if (propertyArray != null)
            {
                ArrayPool<byte>.Shared.Return(propertyArray);
            }
        }

        private void WriteStringByOptions(ReadOnlySpan<char> propertyName, ReadOnlySpan<char> value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteStringIndented(propertyName, value);
            }
            else
            {
                WriteStringMinimized(propertyName, value);
            }
        }

        private void WriteStringByOptions(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<byte> utf8Value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteStringIndented(utf8PropertyName, utf8Value);
            }
            else
            {
                WriteStringMinimized(utf8PropertyName, utf8Value);
            }
        }

        private void WriteStringByOptions(ReadOnlySpan<char> propertyName, ReadOnlySpan<byte> utf8Value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteStringIndented(propertyName, utf8Value);
            }
            else
            {
                WriteStringMinimized(propertyName, utf8Value);
            }
        }

        private void WriteStringByOptions(ReadOnlySpan<byte> utf8PropertyName, ReadOnlySpan<char> value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteStringIndented(utf8PropertyName, value);
            }
            else
            {
                WriteStringMinimized(utf8PropertyName, value);
            }
        }

        private void WriteStringMinimized(ReadOnlySpan<char> escapedPropertyName, ReadOnlySpan<char> escapedValue)
        {
            int num = (escapedPropertyName.Length + escapedValue.Length) * 3 + 6;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedValue, span);
            span[BytesPending++] = 34;
        }

        private void WriteStringMinimized(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<byte> escapedValue)
        {
            int num = escapedPropertyName.Length + escapedValue.Length + 5;
            int num2 = num + 1;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 34;
            escapedValue.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedValue.Length;
            span[BytesPending++] = 34;
        }

        private void WriteStringMinimized(ReadOnlySpan<char> escapedPropertyName, ReadOnlySpan<byte> escapedValue)
        {
            int num = escapedPropertyName.Length * 3 + escapedValue.Length + 6;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 34;
            escapedValue.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedValue.Length;
            span[BytesPending++] = 34;
        }

        private void WriteStringMinimized(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<char> escapedValue)
        {
            int num = escapedValue.Length * 3 + escapedPropertyName.Length + 6;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedValue, span);
            span[BytesPending++] = 34;
        }

        private void WriteStringIndented(ReadOnlySpan<char> escapedPropertyName, ReadOnlySpan<char> escapedValue)
        {
            int indentation = Indentation;
            int num = indentation + (escapedPropertyName.Length + escapedValue.Length) * 3 + 7 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedValue, span);
            span[BytesPending++] = 34;
        }

        private void WriteStringIndented(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<byte> escapedValue)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length + escapedValue.Length + 6;
            int num2 = num + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            span[BytesPending++] = 34;
            escapedValue.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedValue.Length;
            span[BytesPending++] = 34;
        }

        private void WriteStringIndented(ReadOnlySpan<char> escapedPropertyName, ReadOnlySpan<byte> escapedValue)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length * 3 + escapedValue.Length + 7 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            span[BytesPending++] = 34;
            escapedValue.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedValue.Length;
            span[BytesPending++] = 34;
        }

        private void WriteStringIndented(ReadOnlySpan<byte> escapedPropertyName, ReadOnlySpan<char> escapedValue)
        {
            int indentation = Indentation;
            int num = indentation + escapedValue.Length * 3 + escapedPropertyName.Length + 7 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedValue, span);
            span[BytesPending++] = 34;
        }

        /// <summary>
        /// Writes the pre-encoded property name and <see cref="T:System.UInt64" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.UInt64" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// </remarks>
        [CLSCompliant(false)]
        public void WriteNumber(JsonEncodedText propertyName, ulong value)
        {
            ReadOnlySpan<byte> encodedUtf8Bytes = propertyName.EncodedUtf8Bytes;
            WriteNumberByOptions(encodedUtf8Bytes, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.UInt64" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.UInt64" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// The property name is escaped before writing.
        /// </remarks>
        [CLSCompliant(false)]
        public void WriteNumber(string propertyName, ulong value)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WriteNumber(propertyName.AsSpan(), value);
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.UInt64" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.UInt64" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// The property name is escaped before writing.
        /// </remarks>
        [CLSCompliant(false)]
        public void WriteNumber(ReadOnlySpan<char> propertyName, ulong value)
        {
            JsonWriterHelper.ValidateProperty(propertyName);
            WriteNumberEscape(propertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.UInt64" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.UInt64" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// The property name is escaped before writing.
        /// </remarks>
        [CLSCompliant(false)]
        public void WriteNumber(ReadOnlySpan<byte> utf8PropertyName, ulong value)
        {
            JsonWriterHelper.ValidateProperty(utf8PropertyName);
            WriteNumberEscape(utf8PropertyName, value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        /// <summary>
        /// Writes the pre-encoded property name and <see cref="T:System.UInt32" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The JSON-encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.UInt32" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// </remarks>
        [CLSCompliant(false)]
        public void WriteNumber(JsonEncodedText propertyName, uint value)
        {
            WriteNumber(propertyName, (ulong)value);
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.UInt32" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="propertyName" /> parameter is <see langword="null" />.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.UInt32" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// The property name is escaped before writing.
        /// </remarks>
        [CLSCompliant(false)]
        public void WriteNumber(string propertyName, uint value)
        {
            if (propertyName == null)
            {
                ThrowHelper.ThrowArgumentNullException("propertyName");
            }
            WriteNumber(propertyName.AsSpan(), (ulong)value);
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.UInt32" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="propertyName">The name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.UInt32" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// The property name is escaped before writing.
        /// </remarks>
        [CLSCompliant(false)]
        public void WriteNumber(ReadOnlySpan<char> propertyName, uint value)
        {
            WriteNumber(propertyName, (ulong)value);
        }

        /// <summary>
        /// Writes the property name and <see cref="T:System.UInt32" /> value (as a JSON number) as part of a name/value pair of a JSON object.
        /// </summary>
        /// <param name="utf8PropertyName">The UTF-8 encoded name of the property to write.</param>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified property name is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.UInt32" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// The property name is escaped before writing.
        /// </remarks>
        [CLSCompliant(false)]
        public void WriteNumber(ReadOnlySpan<byte> utf8PropertyName, uint value)
        {
            WriteNumber(utf8PropertyName, (ulong)value);
        }

        private void WriteNumberEscape(ReadOnlySpan<char> propertyName, ulong value)
        {
            int num = JsonWriterHelper.NeedsEscaping(propertyName, _options.Encoder);
            if (num != -1)
            {
                WriteNumberEscapeProperty(propertyName, value, num);
            }
            else
            {
                WriteNumberByOptions(propertyName, value);
            }
        }

        private void WriteNumberEscape(ReadOnlySpan<byte> utf8PropertyName, ulong value)
        {
            int num = JsonWriterHelper.NeedsEscaping(utf8PropertyName, _options.Encoder);
            if (num != -1)
            {
                WriteNumberEscapeProperty(utf8PropertyName, value, num);
            }
            else
            {
                WriteNumberByOptions(utf8PropertyName, value);
            }
        }

        private void WriteNumberEscapeProperty(ReadOnlySpan<char> propertyName, ulong value, int firstEscapeIndexProp)
        {
            char[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(propertyName.Length, firstEscapeIndexProp);
            Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
            Span<char> destination = span;
            JsonWriterHelper.EscapeString(propertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteNumberByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<char>.Shared.Return(array);
            }
        }

        private void WriteNumberEscapeProperty(ReadOnlySpan<byte> utf8PropertyName, ulong value, int firstEscapeIndexProp)
        {
            byte[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8PropertyName.Length, firstEscapeIndexProp);
            Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
            Span<byte> destination = span;
            JsonWriterHelper.EscapeString(utf8PropertyName, destination, firstEscapeIndexProp, _options.Encoder, out var written);
            WriteNumberByOptions(destination.Slice(0, written), value);
            if (array != null)
            {
                ArrayPool<byte>.Shared.Return(array);
            }
        }

        private void WriteNumberByOptions(ReadOnlySpan<char> propertyName, ulong value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteNumberIndented(propertyName, value);
            }
            else
            {
                WriteNumberMinimized(propertyName, value);
            }
        }

        private void WriteNumberByOptions(ReadOnlySpan<byte> utf8PropertyName, ulong value)
        {
            ValidateWritingProperty();
            if (_options.Indented)
            {
                WriteNumberIndented(utf8PropertyName, value);
            }
            else
            {
                WriteNumberMinimized(utf8PropertyName, value);
            }
        }

        private void WriteNumberMinimized(ReadOnlySpan<char> escapedPropertyName, ulong value)
        {
            int num = escapedPropertyName.Length * 3 + 20 + 4;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberMinimized(ReadOnlySpan<byte> escapedPropertyName, ulong value)
        {
            int num = escapedPropertyName.Length + 20 + 3;
            int num2 = num + 1;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberIndented(ReadOnlySpan<char> escapedPropertyName, ulong value)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length * 3 + 20 + 5 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedPropertyName, span);
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberIndented(ReadOnlySpan<byte> escapedPropertyName, ulong value)
        {
            int indentation = Indentation;
            int num = indentation + escapedPropertyName.Length + 20 + 4;
            int num2 = num + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 34;
            escapedPropertyName.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedPropertyName.Length;
            span[BytesPending++] = 34;
            span[BytesPending++] = 58;
            span[BytesPending++] = 32;
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        internal void WritePropertyName(uint value)
        {
            WritePropertyName((ulong)value);
        }

        internal void WritePropertyName(ulong value)
        {
            Span<byte> destination = stackalloc byte[20];
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten);
            WritePropertyNameUnescaped(destination.Slice(0, bytesWritten));
        }

        /// <summary>
        /// Writes the raw bytes value as a Base64 encoded JSON string as an element of a JSON array.
        /// </summary>
        /// <param name="bytes">The binary data to write as Base64 encoded text.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified value is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The bytes are encoded before writing.
        /// </remarks>
        public void WriteBase64StringValue(ReadOnlySpan<byte> bytes)
        {
            JsonWriterHelper.ValidateBytes(bytes);
            WriteBase64ByOptions(bytes);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        private void WriteBase64ByOptions(ReadOnlySpan<byte> bytes)
        {
            if (!_options.SkipValidation)
            {
                ValidateWritingValue();
            }
            if (_options.Indented)
            {
                WriteBase64Indented(bytes);
            }
            else
            {
                WriteBase64Minimized(bytes);
            }
        }

        private void WriteBase64Minimized(ReadOnlySpan<byte> bytes)
        {
            int maxEncodedToUtf8Length = Base64.GetMaxEncodedToUtf8Length(bytes.Length);
            int num = maxEncodedToUtf8Length + 3;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            Base64EncodeAndWrite(bytes, span, maxEncodedToUtf8Length);
            span[BytesPending++] = 34;
        }

        private void WriteBase64Indented(ReadOnlySpan<byte> bytes)
        {
            int indentation = Indentation;
            int maxEncodedToUtf8Length = Base64.GetMaxEncodedToUtf8Length(bytes.Length);
            int num = indentation + maxEncodedToUtf8Length + 3 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != JsonTokenType.PropertyName)
            {
                if (_tokenType != 0)
                {
                    WriteNewLine(span);
                }
                JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
                BytesPending += indentation;
            }
            span[BytesPending++] = 34;
            Base64EncodeAndWrite(bytes, span, maxEncodedToUtf8Length);
            span[BytesPending++] = 34;
        }

        /// <summary>
        /// Writes the string text value (as a JSON comment).
        /// </summary>
        /// <param name="value">The value to write as a JSON comment within /*..*/.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified value is too large OR if the given string text value contains a comment delimiter (that is, */).
        /// </exception>
        /// <exception cref="T:System.ArgumentNullException">
        /// The <paramref name="value" /> parameter is <see langword="null" />.
        /// </exception>
        /// <remarks>
        /// The comment value is not escaped before writing.
        /// </remarks>
        public void WriteCommentValue(string value)
        {
            if (value == null)
            {
                ThrowHelper.ThrowArgumentNullException("value");
            }
            WriteCommentValue(value.AsSpan());
        }

        /// <summary>
        /// Writes the text value (as a JSON comment).
        /// </summary>
        /// <param name="value">The value to write as a JSON comment within /*..*/.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified value is too large OR if the given text value contains a comment delimiter (that is, */).
        /// </exception>
        /// <remarks>
        /// The comment value is not escaped before writing.
        /// </remarks>
        public void WriteCommentValue(ReadOnlySpan<char> value)
        {
            JsonWriterHelper.ValidateValue(value);
            if (value.IndexOf(s_singleLineCommentDelimiter) != -1)
            {
                ThrowHelper.ThrowArgumentException_InvalidCommentValue();
            }
            WriteCommentByOptions(value);
        }

        private void WriteCommentByOptions(ReadOnlySpan<char> value)
        {
            if (_options.Indented)
            {
                WriteCommentIndented(value);
            }
            else
            {
                WriteCommentMinimized(value);
            }
        }

        private void WriteCommentMinimized(ReadOnlySpan<char> value)
        {
            int num = value.Length * 3 + 4;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            span[BytesPending++] = 47;
            int bytesConsumed = BytesPending++;
            span[bytesConsumed] = 42;
            ReadOnlySpan<byte> utf16Source = MemoryMarshal.AsBytes(value);
            int bytesWritten;
            OperationStatus operationStatus = JsonWriterHelper.ToUtf8(utf16Source, span.Slice(BytesPending), out bytesConsumed, out bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 42;
            span[BytesPending++] = 47;
        }

        private void WriteCommentIndented(ReadOnlySpan<char> value)
        {
            int indentation = Indentation;
            int num = indentation + value.Length * 3 + 4 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_tokenType != 0)
            {
                WriteNewLine(span);
            }
            JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
            BytesPending += indentation;
            span[BytesPending++] = 47;
            int bytesConsumed = BytesPending++;
            span[bytesConsumed] = 42;
            ReadOnlySpan<byte> utf16Source = MemoryMarshal.AsBytes(value);
            int bytesWritten;
            OperationStatus operationStatus = JsonWriterHelper.ToUtf8(utf16Source, span.Slice(BytesPending), out bytesConsumed, out bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 42;
            span[BytesPending++] = 47;
        }

        /// <summary>
        /// Writes the UTF-8 text value (as a JSON comment).
        /// </summary>
        /// <param name="utf8Value">The UTF-8 encoded value to be written as a JSON comment within /*..*/.</param>
        /// <remarks>
        /// The comment value is not escaped before writing.
        /// </remarks>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified value is too large OR if the given UTF-8 text value contains a comment delimiter (that is, */).
        /// </exception>
        public void WriteCommentValue(ReadOnlySpan<byte> utf8Value)
        {
            JsonWriterHelper.ValidateValue(utf8Value);
            if (utf8Value.IndexOf(SingleLineCommentDelimiterUtf8) != -1)
            {
                ThrowHelper.ThrowArgumentException_InvalidCommentValue();
            }
            WriteCommentByOptions(utf8Value);
        }

        private void WriteCommentByOptions(ReadOnlySpan<byte> utf8Value)
        {
            if (_options.Indented)
            {
                WriteCommentIndented(utf8Value);
            }
            else
            {
                WriteCommentMinimized(utf8Value);
            }
        }

        private void WriteCommentMinimized(ReadOnlySpan<byte> utf8Value)
        {
            int num = utf8Value.Length + 4;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            span[BytesPending++] = 47;
            span[BytesPending++] = 42;
            utf8Value.CopyTo(span.Slice(BytesPending));
            BytesPending += utf8Value.Length;
            span[BytesPending++] = 42;
            span[BytesPending++] = 47;
        }

        private void WriteCommentIndented(ReadOnlySpan<byte> utf8Value)
        {
            int indentation = Indentation;
            int num = indentation + utf8Value.Length + 4;
            int num2 = num + s_newLineLength;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_tokenType != JsonTokenType.PropertyName)
            {
                if (_tokenType != 0)
                {
                    WriteNewLine(span);
                }
                JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
                BytesPending += indentation;
            }
            span[BytesPending++] = 47;
            span[BytesPending++] = 42;
            utf8Value.CopyTo(span.Slice(BytesPending));
            BytesPending += utf8Value.Length;
            span[BytesPending++] = 42;
            span[BytesPending++] = 47;
        }

        /// <summary>
        /// Writes the <see cref="T:System.DateTime" /> value (as a JSON string) as an element of a JSON array.
        /// </summary>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.DateTime" /> using the round-trippable ('O') <see cref="T:System.Buffers.StandardFormat" /> , for example: 2017-06-12T05:30:45.7680000.
        /// </remarks>
        public void WriteStringValue(DateTime value)
        {
            if (!_options.SkipValidation)
            {
                ValidateWritingValue();
            }
            if (_options.Indented)
            {
                WriteStringValueIndented(value);
            }
            else
            {
                WriteStringValueMinimized(value);
            }
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        private void WriteStringValueMinimized(DateTime value)
        {
            int num = 36;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            JsonWriterHelper.WriteDateTimeTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 34;
        }

        private void WriteStringValueIndented(DateTime value)
        {
            int indentation = Indentation;
            int num = indentation + 33 + 3 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != JsonTokenType.PropertyName)
            {
                if (_tokenType != 0)
                {
                    WriteNewLine(span);
                }
                JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
                BytesPending += indentation;
            }
            span[BytesPending++] = 34;
            JsonWriterHelper.WriteDateTimeTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 34;
        }

        /// <summary>
        /// Writes the <see cref="T:System.DateTimeOffset" /> value (as a JSON string) as an element of a JSON array.
        /// </summary>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.DateTimeOffset" /> using the round-trippable ('O') <see cref="T:System.Buffers.StandardFormat" /> , for example: 2017-06-12T05:30:45.7680000-07:00.
        /// </remarks>
        public void WriteStringValue(DateTimeOffset value)
        {
            if (!_options.SkipValidation)
            {
                ValidateWritingValue();
            }
            if (_options.Indented)
            {
                WriteStringValueIndented(value);
            }
            else
            {
                WriteStringValueMinimized(value);
            }
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        private void WriteStringValueMinimized(DateTimeOffset value)
        {
            int num = 36;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            JsonWriterHelper.WriteDateTimeOffsetTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 34;
        }

        private void WriteStringValueIndented(DateTimeOffset value)
        {
            int indentation = Indentation;
            int num = indentation + 33 + 3 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != JsonTokenType.PropertyName)
            {
                if (_tokenType != 0)
                {
                    WriteNewLine(span);
                }
                JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
                BytesPending += indentation;
            }
            span[BytesPending++] = 34;
            JsonWriterHelper.WriteDateTimeOffsetTrimmed(span.Slice(BytesPending), value, out var bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 34;
        }

        /// <summary>
        /// Writes the <see cref="T:System.Decimal" /> value (as a JSON number) as an element of a JSON array.
        /// </summary>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Decimal" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G').
        /// </remarks>
        public void WriteNumberValue(decimal value)
        {
            if (!_options.SkipValidation)
            {
                ValidateWritingValue();
            }
            if (_options.Indented)
            {
                WriteNumberValueIndented(value);
            }
            else
            {
                WriteNumberValueMinimized(value);
            }
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        private void WriteNumberValueMinimized(decimal value)
        {
            int num = 32;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberValueIndented(decimal value)
        {
            int indentation = Indentation;
            int num = indentation + 31 + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != JsonTokenType.PropertyName)
            {
                if (_tokenType != 0)
                {
                    WriteNewLine(span);
                }
                JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
                BytesPending += indentation;
            }
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        internal void WriteNumberValueAsString(decimal value)
        {
            Span<byte> destination = stackalloc byte[31];
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten);
            WriteNumberValueAsStringUnescaped(destination.Slice(0, bytesWritten));
        }

        /// <summary>
        /// Writes the <see cref="T:System.Double" /> value (as a JSON number) as an element of a JSON array.
        /// </summary>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Double" /> using the default <see cref="T:System.Buffers.StandardFormat" /> on .NET Core 3 or higher
        /// and 'G17' on any other framework.
        /// </remarks>
        public void WriteNumberValue(double value)
        {
            JsonWriterHelper.ValidateDouble(value);
            if (!_options.SkipValidation)
            {
                ValidateWritingValue();
            }
            if (_options.Indented)
            {
                WriteNumberValueIndented(value);
            }
            else
            {
                WriteNumberValueMinimized(value);
            }
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        private void WriteNumberValueMinimized(double value)
        {
            int num = 129;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            int bytesWritten;
            bool flag = TryFormatDouble(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberValueIndented(double value)
        {
            int indentation = Indentation;
            int num = indentation + 128 + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != JsonTokenType.PropertyName)
            {
                if (_tokenType != 0)
                {
                    WriteNewLine(span);
                }
                JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
                BytesPending += indentation;
            }
            int bytesWritten;
            bool flag = TryFormatDouble(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private static bool TryFormatDouble(double value, Span<byte> destination, out int bytesWritten)
        {
            string text = value.ToString("G17", CultureInfo.InvariantCulture);
            if (text.Length > destination.Length)
            {
                bytesWritten = 0;
                return false;
            }
            try
            {
                byte[] bytes = Encoding.UTF8.GetBytes(text);
                if (bytes.Length > destination.Length)
                {
                    bytesWritten = 0;
                    return false;
                }
                bytes.CopyTo(destination);
                bytesWritten = bytes.Length;
                return true;
            }
            catch
            {
                bytesWritten = 0;
                return false;
            }
        }

        internal void WriteNumberValueAsString(double value)
        {
            Span<byte> destination = stackalloc byte[128];
            int bytesWritten;
            bool flag = TryFormatDouble(value, destination, out bytesWritten);
            WriteNumberValueAsStringUnescaped(destination.Slice(0, bytesWritten));
        }

        internal void WriteFloatingPointConstant(double value)
        {
            if (double.IsNaN(value))
            {
                WriteNumberValueAsStringUnescaped(JsonConstants.NaNValue);
            }
            else if (double.IsPositiveInfinity(value))
            {
                WriteNumberValueAsStringUnescaped(JsonConstants.PositiveInfinityValue);
            }
            else if (double.IsNegativeInfinity(value))
            {
                WriteNumberValueAsStringUnescaped(JsonConstants.NegativeInfinityValue);
            }
            else
            {
                WriteNumberValue(value);
            }
        }

        /// <summary>
        /// Writes the <see cref="T:System.Single" /> value (as a JSON number) as an element of a JSON array.
        /// </summary>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Single" /> using the default <see cref="T:System.Buffers.StandardFormat" /> on .NET Core 3 or higher
        /// and 'G9' on any other framework.
        /// </remarks>
        public void WriteNumberValue(float value)
        {
            JsonWriterHelper.ValidateSingle(value);
            if (!_options.SkipValidation)
            {
                ValidateWritingValue();
            }
            if (_options.Indented)
            {
                WriteNumberValueIndented(value);
            }
            else
            {
                WriteNumberValueMinimized(value);
            }
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        private void WriteNumberValueMinimized(float value)
        {
            int num = 129;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            int bytesWritten;
            bool flag = TryFormatSingle(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberValueIndented(float value)
        {
            int indentation = Indentation;
            int num = indentation + 128 + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != JsonTokenType.PropertyName)
            {
                if (_tokenType != 0)
                {
                    WriteNewLine(span);
                }
                JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
                BytesPending += indentation;
            }
            int bytesWritten;
            bool flag = TryFormatSingle(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private static bool TryFormatSingle(float value, Span<byte> destination, out int bytesWritten)
        {
            string text = value.ToString("G9", CultureInfo.InvariantCulture);
            if (text.Length > destination.Length)
            {
                bytesWritten = 0;
                return false;
            }
            try
            {
                byte[] bytes = Encoding.UTF8.GetBytes(text);
                if (bytes.Length > destination.Length)
                {
                    bytesWritten = 0;
                    return false;
                }
                bytes.CopyTo(destination);
                bytesWritten = bytes.Length;
                return true;
            }
            catch
            {
                bytesWritten = 0;
                return false;
            }
        }

        internal void WriteNumberValueAsString(float value)
        {
            Span<byte> destination = stackalloc byte[128];
            int bytesWritten;
            bool flag = TryFormatSingle(value, destination, out bytesWritten);
            WriteNumberValueAsStringUnescaped(destination.Slice(0, bytesWritten));
        }

        internal void WriteFloatingPointConstant(float value)
        {
            if (float.IsNaN(value))
            {
                WriteNumberValueAsStringUnescaped(JsonConstants.NaNValue);
            }
            else if (float.IsPositiveInfinity(value))
            {
                WriteNumberValueAsStringUnescaped(JsonConstants.PositiveInfinityValue);
            }
            else if (float.IsNegativeInfinity(value))
            {
                WriteNumberValueAsStringUnescaped(JsonConstants.NegativeInfinityValue);
            }
            else
            {
                WriteNumberValue(value);
            }
        }

        /// <summary>
        /// Writes the value (as a JSON number) as an element of a JSON array.
        /// </summary>
        /// <param name="utf8FormattedNumber">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when <paramref name="utf8FormattedNumber" /> does not represent a valid JSON number.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Int32" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// </remarks>
        internal void WriteNumberValue(ReadOnlySpan<byte> utf8FormattedNumber)
        {
            JsonWriterHelper.ValidateValue(utf8FormattedNumber);
            JsonWriterHelper.ValidateNumber(utf8FormattedNumber);
            if (!_options.SkipValidation)
            {
                ValidateWritingValue();
            }
            if (_options.Indented)
            {
                WriteNumberValueIndented(utf8FormattedNumber);
            }
            else
            {
                WriteNumberValueMinimized(utf8FormattedNumber);
            }
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        private void WriteNumberValueMinimized(ReadOnlySpan<byte> utf8Value)
        {
            int num = utf8Value.Length + 1;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            utf8Value.CopyTo(span.Slice(BytesPending));
            BytesPending += utf8Value.Length;
        }

        private void WriteNumberValueIndented(ReadOnlySpan<byte> utf8Value)
        {
            int indentation = Indentation;
            int num = indentation + utf8Value.Length + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != JsonTokenType.PropertyName)
            {
                if (_tokenType != 0)
                {
                    WriteNewLine(span);
                }
                JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
                BytesPending += indentation;
            }
            utf8Value.CopyTo(span.Slice(BytesPending));
            BytesPending += utf8Value.Length;
        }

        /// <summary>
        /// Writes the <see cref="T:System.Guid" /> value (as a JSON string) as an element of a JSON array.
        /// </summary>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Guid" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'D'), as the form: nnnnnnnn-nnnn-nnnn-nnnn-nnnnnnnnnnnn.
        /// </remarks>
        public void WriteStringValue(Guid value)
        {
            if (!_options.SkipValidation)
            {
                ValidateWritingValue();
            }
            if (_options.Indented)
            {
                WriteStringValueIndented(value);
            }
            else
            {
                WriteStringValueMinimized(value);
            }
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        private void WriteStringValueMinimized(Guid value)
        {
            int num = 39;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 34;
        }

        private void WriteStringValueIndented(Guid value)
        {
            int indentation = Indentation;
            int num = indentation + 36 + 3 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != JsonTokenType.PropertyName)
            {
                if (_tokenType != 0)
                {
                    WriteNewLine(span);
                }
                JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
                BytesPending += indentation;
            }
            span[BytesPending++] = 34;
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
            span[BytesPending++] = 34;
        }

        private void ValidateWritingValue()
        {
            if (_inObject)
            {
                if (_tokenType != JsonTokenType.PropertyName)
                {
                    ThrowHelper.ThrowInvalidOperationException(ExceptionResource.CannotWriteValueWithinObject, 0, _options.MaxDepth, 0, _tokenType);
                }
            }
            else if (CurrentDepth == 0 && _tokenType != 0)
            {
                ThrowHelper.ThrowInvalidOperationException(ExceptionResource.CannotWriteValueAfterPrimitiveOrClose, 0, _options.MaxDepth, 0, _tokenType);
            }
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private void Base64EncodeAndWrite(ReadOnlySpan<byte> bytes, Span<byte> output, int encodingLength)
        {
            byte[] array = null;
            Span<byte> span = ((encodingLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(encodingLength))) : stackalloc byte[256]);
            Span<byte> utf = span;
            int bytesConsumed;
            int bytesWritten;
            OperationStatus operationStatus = Base64.EncodeToUtf8(bytes, utf, out bytesConsumed, out bytesWritten);
            utf = utf.Slice(0, bytesWritten);
            Span<byte> destination = output.Slice(BytesPending);
            utf.Slice(0, bytesWritten).CopyTo(destination);
            BytesPending += bytesWritten;
            if (array != null)
            {
                ArrayPool<byte>.Shared.Return(array);
            }
        }

        /// <summary>
        /// Writes the JSON literal "null" as an element of a JSON array.
        /// </summary>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteNullValue()
        {
            WriteLiteralByOptions(JsonConstants.NullValue);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Null;
        }

        /// <summary>
        /// Writes the <see cref="T:System.Boolean" /> value (as a JSON literal "true" or "false") as an element of a JSON array.
        /// </summary>
        /// <param name="value">The value write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteBooleanValue(bool value)
        {
            if (value)
            {
                WriteLiteralByOptions(JsonConstants.TrueValue);
                _tokenType = JsonTokenType.True;
            }
            else
            {
                WriteLiteralByOptions(JsonConstants.FalseValue);
                _tokenType = JsonTokenType.False;
            }
            SetFlagToAddListSeparatorBeforeNextItem();
        }

        private void WriteLiteralByOptions(ReadOnlySpan<byte> utf8Value)
        {
            if (!_options.SkipValidation)
            {
                ValidateWritingValue();
            }
            if (_options.Indented)
            {
                WriteLiteralIndented(utf8Value);
            }
            else
            {
                WriteLiteralMinimized(utf8Value);
            }
        }

        private void WriteLiteralMinimized(ReadOnlySpan<byte> utf8Value)
        {
            int num = utf8Value.Length + 1;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            utf8Value.CopyTo(span.Slice(BytesPending));
            BytesPending += utf8Value.Length;
        }

        private void WriteLiteralIndented(ReadOnlySpan<byte> utf8Value)
        {
            int indentation = Indentation;
            int num = indentation + utf8Value.Length + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != JsonTokenType.PropertyName)
            {
                if (_tokenType != 0)
                {
                    WriteNewLine(span);
                }
                JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
                BytesPending += indentation;
            }
            utf8Value.CopyTo(span.Slice(BytesPending));
            BytesPending += utf8Value.Length;
        }

        /// <summary>
        /// Writes the input as JSON content. It is expected that the input content is a single complete JSON value.
        /// </summary>
        /// <param name="json">The raw JSON content to write.</param>
        /// <param name="skipInputValidation">Whether to validate if the input is an RFC 8259-compliant JSON payload.</param>
        /// <exception cref="T:System.ArgumentNullException">Thrown if <paramref name="json" /> is <see langword="null" />.</exception>
        /// <exception cref="T:System.ArgumentException">Thrown if the length of the input is zero or greater than 715,827,882 (<see cref="F:System.Int32.MaxValue" /> / 3).</exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// Thrown if <paramref name="skipInputValidation" /> is <see langword="false" />, and the input
        /// is not a valid, complete, single JSON value according to the JSON RFC (https://tools.ietf.org/html/rfc8259)
        /// or the input JSON exceeds a recursive depth of 64.
        /// </exception>
        /// <remarks>
        /// When writing untrused JSON values, do not set <paramref name="skipInputValidation" /> to <see langword="true" /> as this can result in invalid JSON
        /// being written, and/or the overall payload being written to the writer instance being invalid.
        ///
        /// When using this method, the input content will be written to the writer destination as-is, unless validation fails (when it is enabled).
        ///
        /// The <see cref="P:System.Text.Json.JsonWriterOptions.SkipValidation" /> value for the writer instance is honored when using this method.
        ///
        /// The <see cref="P:System.Text.Json.JsonWriterOptions.Indented" /> and <see cref="P:System.Text.Json.JsonWriterOptions.Encoder" /> values for the writer instance are not applied when using this method.
        /// </remarks>
        public void WriteRawValue([StringSyntax("Json")] string json, bool skipInputValidation = false)
        {
            if (!_options.SkipValidation)
            {
                ValidateWritingValue();
            }
            if (json == null)
            {
                throw new ArgumentNullException("json");
            }
            TranscodeAndWriteRawValue(json.AsSpan(), skipInputValidation);
        }

        /// <summary>
        /// Writes the input as JSON content. It is expected that the input content is a single complete JSON value.
        /// </summary>
        /// <param name="json">The raw JSON content to write.</param>
        /// <param name="skipInputValidation">Whether to validate if the input is an RFC 8259-compliant JSON payload.</param>
        /// <exception cref="T:System.ArgumentException">Thrown if the length of the input is zero or greater than 715,827,882 (<see cref="F:System.Int32.MaxValue" /> / 3).</exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// Thrown if <paramref name="skipInputValidation" /> is <see langword="false" />, and the input
        /// is not a valid, complete, single JSON value according to the JSON RFC (https://tools.ietf.org/html/rfc8259)
        /// or the input JSON exceeds a recursive depth of 64.
        /// </exception>
        /// <remarks>
        /// When writing untrused JSON values, do not set <paramref name="skipInputValidation" /> to <see langword="true" /> as this can result in invalid JSON
        /// being written, and/or the overall payload being written to the writer instance being invalid.
        ///
        /// When using this method, the input content will be written to the writer destination as-is, unless validation fails (when it is enabled).
        ///
        /// The <see cref="P:System.Text.Json.JsonWriterOptions.SkipValidation" /> value for the writer instance is honored when using this method.
        ///
        /// The <see cref="P:System.Text.Json.JsonWriterOptions.Indented" /> and <see cref="P:System.Text.Json.JsonWriterOptions.Encoder" /> values for the writer instance are not applied when using this method.
        /// </remarks>
        public void WriteRawValue([StringSyntax("Json")] ReadOnlySpan<char> json, bool skipInputValidation = false)
        {
            if (!_options.SkipValidation)
            {
                ValidateWritingValue();
            }
            TranscodeAndWriteRawValue(json, skipInputValidation);
        }

        /// <summary>
        /// Writes the input as JSON content. It is expected that the input content is a single complete JSON value.
        /// </summary>
        /// <param name="utf8Json">The raw JSON content to write.</param>
        /// <param name="skipInputValidation">Whether to validate if the input is an RFC 8259-compliant JSON payload.</param>
        /// <exception cref="T:System.ArgumentException">Thrown if the length of the input is zero or equal to <see cref="F:System.Int32.MaxValue" />.</exception>
        /// <exception cref="T:System.Text.Json.JsonException">
        /// Thrown if <paramref name="skipInputValidation" /> is <see langword="false" />, and the input
        /// is not a valid, complete, single JSON value according to the JSON RFC (https://tools.ietf.org/html/rfc8259)
        /// or the input JSON exceeds a recursive depth of 64.
        /// </exception>
        /// <remarks>
        /// When writing untrused JSON values, do not set <paramref name="skipInputValidation" /> to <see langword="true" /> as this can result in invalid JSON
        /// being written, and/or the overall payload being written to the writer instance being invalid.
        ///
        /// When using this method, the input content will be written to the writer destination as-is, unless validation fails (when it is enabled).
        ///
        /// The <see cref="P:System.Text.Json.JsonWriterOptions.SkipValidation" /> value for the writer instance is honored when using this method.
        ///
        /// The <see cref="P:System.Text.Json.JsonWriterOptions.Indented" /> and <see cref="P:System.Text.Json.JsonWriterOptions.Encoder" /> values for the writer instance are not applied when using this method.
        /// </remarks>
        public void WriteRawValue(ReadOnlySpan<byte> utf8Json, bool skipInputValidation = false)
        {
            if (!_options.SkipValidation)
            {
                ValidateWritingValue();
            }
            if (utf8Json.Length == int.MaxValue)
            {
                ThrowHelper.ThrowArgumentException_ValueTooLarge(int.MaxValue);
            }
            WriteRawValueCore(utf8Json, skipInputValidation);
        }

        private void TranscodeAndWriteRawValue(ReadOnlySpan<char> json, bool skipInputValidation)
        {
            if (json.Length > 715827882)
            {
                ThrowHelper.ThrowArgumentException_ValueTooLarge(json.Length);
            }
            byte[] array = null;
            Span<byte> span = (((long)json.Length > 349525L) ? new byte[JsonReaderHelper.GetUtf8ByteCount(json)] : (array = ArrayPool<byte>.Shared.Rent(json.Length * 3)));
            try
            {
                int utf8FromText = JsonReaderHelper.GetUtf8FromText(json, span);
                span = span.Slice(0, utf8FromText);
                WriteRawValueCore(span, skipInputValidation);
            }
            finally
            {
                if (array != null)
                {
                    span.Clear();
                    ArrayPool<byte>.Shared.Return(array);
                }
            }
        }

        private void WriteRawValueCore(ReadOnlySpan<byte> utf8Json, bool skipInputValidation)
        {
            int length = utf8Json.Length;
            if (length == 0)
            {
                ThrowHelper.ThrowArgumentException(MDCFR.Properties.Resources.ExpectedJsonTokens);
            }
            if (skipInputValidation)
            {
                _tokenType = JsonTokenType.String;
            }
            else
            {
                Utf8JsonReader utf8JsonReader = new Utf8JsonReader(utf8Json);
                while (utf8JsonReader.Read())
                {
                }
                _tokenType = utf8JsonReader.TokenType;
            }
            int num = length + 1;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            utf8Json.CopyTo(span.Slice(BytesPending));
            BytesPending += length;
            SetFlagToAddListSeparatorBeforeNextItem();
        }

        /// <summary>
        /// Writes the <see cref="T:System.Int32" /> value (as a JSON number) as an element of a JSON array.
        /// </summary>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Int32" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// </remarks>
        public void WriteNumberValue(int value)
        {
            WriteNumberValue((long)value);
        }

        /// <summary>
        /// Writes the <see cref="T:System.Int64" /> value (as a JSON number) as an element of a JSON array.
        /// </summary>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.Int64" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// </remarks>
        public void WriteNumberValue(long value)
        {
            if (!_options.SkipValidation)
            {
                ValidateWritingValue();
            }
            if (_options.Indented)
            {
                WriteNumberValueIndented(value);
            }
            else
            {
                WriteNumberValueMinimized(value);
            }
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        private void WriteNumberValueMinimized(long value)
        {
            int num = 21;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberValueIndented(long value)
        {
            int indentation = Indentation;
            int num = indentation + 20 + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != JsonTokenType.PropertyName)
            {
                if (_tokenType != 0)
                {
                    WriteNewLine(span);
                }
                JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
                BytesPending += indentation;
            }
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        internal void WriteNumberValueAsString(long value)
        {
            Span<byte> destination = stackalloc byte[20];
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten);
            WriteNumberValueAsStringUnescaped(destination.Slice(0, bytesWritten));
        }

        /// <summary>
        /// Writes the pre-encoded text value (as a JSON string) as an element of a JSON array.
        /// </summary>
        /// <param name="value">The JSON-encoded value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        public void WriteStringValue(JsonEncodedText value)
        {
            ReadOnlySpan<byte> encodedUtf8Bytes = value.EncodedUtf8Bytes;
            WriteStringByOptions(encodedUtf8Bytes);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the string text value (as a JSON string) as an element of a JSON array.
        /// </summary>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified value is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// <para>
        /// The value is escaped before writing.</para>
        /// <para>
        /// If <paramref name="value" /> is <see langword="null" /> the JSON null value is written,
        /// as if <see cref="M:System.Text.Json.Utf8JsonWriter.WriteNullValue" /> was called.
        /// </para>
        /// </remarks>
        public void WriteStringValue(string? value)
        {
            if (value == null)
            {
                WriteNullValue();
            }
            else
            {
                WriteStringValue(value.AsSpan());
            }
        }

        /// <summary>
        /// Writes the text value (as a JSON string) as an element of a JSON array.
        /// </summary>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified value is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The value is escaped before writing.
        /// </remarks>
        public void WriteStringValue(ReadOnlySpan<char> value)
        {
            JsonWriterHelper.ValidateValue(value);
            WriteStringEscape(value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        private void WriteStringEscape(ReadOnlySpan<char> value)
        {
            int num = JsonWriterHelper.NeedsEscaping(value, _options.Encoder);
            if (num != -1)
            {
                WriteStringEscapeValue(value, num);
            }
            else
            {
                WriteStringByOptions(value);
            }
        }

        private void WriteStringByOptions(ReadOnlySpan<char> value)
        {
            if (!_options.SkipValidation)
            {
                ValidateWritingValue();
            }
            if (_options.Indented)
            {
                WriteStringIndented(value);
            }
            else
            {
                WriteStringMinimized(value);
            }
        }

        private void WriteStringMinimized(ReadOnlySpan<char> escapedValue)
        {
            int num = escapedValue.Length * 3 + 3;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedValue, span);
            span[BytesPending++] = 34;
        }

        private void WriteStringIndented(ReadOnlySpan<char> escapedValue)
        {
            int indentation = Indentation;
            int num = indentation + escapedValue.Length * 3 + 3 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != JsonTokenType.PropertyName)
            {
                if (_tokenType != 0)
                {
                    WriteNewLine(span);
                }
                JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
                BytesPending += indentation;
            }
            span[BytesPending++] = 34;
            TranscodeAndWrite(escapedValue, span);
            span[BytesPending++] = 34;
        }

        private void WriteStringEscapeValue(ReadOnlySpan<char> value, int firstEscapeIndexVal)
        {
            char[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(value.Length, firstEscapeIndexVal);
            Span<char> span = ((maxEscapedLength > 128) ? ((Span<char>)(array = ArrayPool<char>.Shared.Rent(maxEscapedLength))) : stackalloc char[128]);
            Span<char> destination = span;
            JsonWriterHelper.EscapeString(value, destination, firstEscapeIndexVal, _options.Encoder, out var written);
            WriteStringByOptions(destination.Slice(0, written));
            if (array != null)
            {
                ArrayPool<char>.Shared.Return(array);
            }
        }

        /// <summary>
        /// Writes the UTF-8 text value (as a JSON string) as an element of a JSON array.
        /// </summary>
        /// <param name="utf8Value">The UTF-8 encoded value to be written as a JSON string element of a JSON array.</param>
        /// <exception cref="T:System.ArgumentException">
        /// Thrown when the specified value is too large.
        /// </exception>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// The value is escaped before writing.
        /// </remarks>
        public void WriteStringValue(ReadOnlySpan<byte> utf8Value)
        {
            JsonWriterHelper.ValidateValue(utf8Value);
            WriteStringEscape(utf8Value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        private void WriteStringEscape(ReadOnlySpan<byte> utf8Value)
        {
            int num = JsonWriterHelper.NeedsEscaping(utf8Value, _options.Encoder);
            if (num != -1)
            {
                WriteStringEscapeValue(utf8Value, num);
            }
            else
            {
                WriteStringByOptions(utf8Value);
            }
        }

        private void WriteStringByOptions(ReadOnlySpan<byte> utf8Value)
        {
            if (!_options.SkipValidation)
            {
                ValidateWritingValue();
            }
            if (_options.Indented)
            {
                WriteStringIndented(utf8Value);
            }
            else
            {
                WriteStringMinimized(utf8Value);
            }
        }

        private void WriteStringMinimized(ReadOnlySpan<byte> escapedValue)
        {
            int num = escapedValue.Length + 2;
            int num2 = num + 1;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            span[BytesPending++] = 34;
            escapedValue.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedValue.Length;
            span[BytesPending++] = 34;
        }

        private void WriteStringIndented(ReadOnlySpan<byte> escapedValue)
        {
            int indentation = Indentation;
            int num = indentation + escapedValue.Length + 2;
            int num2 = num + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num2)
            {
                Grow(num2);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != JsonTokenType.PropertyName)
            {
                if (_tokenType != 0)
                {
                    WriteNewLine(span);
                }
                JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
                BytesPending += indentation;
            }
            span[BytesPending++] = 34;
            escapedValue.CopyTo(span.Slice(BytesPending));
            BytesPending += escapedValue.Length;
            span[BytesPending++] = 34;
        }

        private void WriteStringEscapeValue(ReadOnlySpan<byte> utf8Value, int firstEscapeIndexVal)
        {
            byte[] array = null;
            int maxEscapedLength = JsonWriterHelper.GetMaxEscapedLength(utf8Value.Length, firstEscapeIndexVal);
            Span<byte> span = ((maxEscapedLength > 256) ? ((Span<byte>)(array = ArrayPool<byte>.Shared.Rent(maxEscapedLength))) : stackalloc byte[256]);
            Span<byte> destination = span;
            JsonWriterHelper.EscapeString(utf8Value, destination, firstEscapeIndexVal, _options.Encoder, out var written);
            WriteStringByOptions(destination.Slice(0, written));
            if (array != null)
            {
                ArrayPool<byte>.Shared.Return(array);
            }
        }

        /// <summary>
        /// Writes a number as a JSON string. The string value is not escaped.
        /// </summary>
        /// <param name="utf8Value"></param>
        internal void WriteNumberValueAsStringUnescaped(ReadOnlySpan<byte> utf8Value)
        {
            WriteStringByOptions(utf8Value);
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.String;
        }

        /// <summary>
        /// Writes the <see cref="T:System.UInt32" /> value (as a JSON number) as an element of a JSON array.
        /// </summary>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.UInt32" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// </remarks>
        [CLSCompliant(false)]
        public void WriteNumberValue(uint value)
        {
            WriteNumberValue((ulong)value);
        }

        /// <summary>
        /// Writes the <see cref="T:System.UInt64" /> value (as a JSON number) as an element of a JSON array.
        /// </summary>
        /// <param name="value">The value to write.</param>
        /// <exception cref="T:System.InvalidOperationException">
        /// Thrown if this would result in invalid JSON being written (while validation is enabled).
        /// </exception>
        /// <remarks>
        /// Writes the <see cref="T:System.UInt64" /> using the default <see cref="T:System.Buffers.StandardFormat" /> (that is, 'G'), for example: 32767.
        /// </remarks>
        [CLSCompliant(false)]
        public void WriteNumberValue(ulong value)
        {
            if (!_options.SkipValidation)
            {
                ValidateWritingValue();
            }
            if (_options.Indented)
            {
                WriteNumberValueIndented(value);
            }
            else
            {
                WriteNumberValueMinimized(value);
            }
            SetFlagToAddListSeparatorBeforeNextItem();
            _tokenType = JsonTokenType.Number;
        }

        private void WriteNumberValueMinimized(ulong value)
        {
            int num = 21;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        private void WriteNumberValueIndented(ulong value)
        {
            int indentation = Indentation;
            int num = indentation + 20 + 1 + s_newLineLength;
            if (_memory.Length - BytesPending < num)
            {
                Grow(num);
            }
            Span<byte> span = _memory.Span;
            if (_currentDepth < 0)
            {
                span[BytesPending++] = 44;
            }
            if (_tokenType != JsonTokenType.PropertyName)
            {
                if (_tokenType != 0)
                {
                    WriteNewLine(span);
                }
                JsonWriterHelper.WriteIndentation(span.Slice(BytesPending), indentation);
                BytesPending += indentation;
            }
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, span.Slice(BytesPending), out bytesWritten);
            BytesPending += bytesWritten;
        }

        internal void WriteNumberValueAsString(ulong value)
        {
            Span<byte> destination = stackalloc byte[20];
            int bytesWritten;
            bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten);
            WriteNumberValueAsStringUnescaped(destination.Slice(0, bytesWritten));
        }
    }

    /// <summary>
	/// Defines a thread-local cache for JsonSerializer to store reusable Utf8JsonWriter/IBufferWriter instances.
	/// </summary>
	internal static class Utf8JsonWriterCache
    {
        private sealed class ThreadLocalState
        {
            public readonly PooledByteBufferWriter BufferWriter;

            public readonly Utf8JsonWriter Writer;

            public int RentedWriters;

            public ThreadLocalState()
            {
                BufferWriter = PooledByteBufferWriter.CreateEmptyInstanceForCaching();
                Writer = Utf8JsonWriter.CreateEmptyInstanceForCaching();
            }
        }

        [ThreadStatic]
        private static ThreadLocalState t_threadLocalState;

        public static Utf8JsonWriter RentWriterAndBuffer(JsonSerializerOptions options, out PooledByteBufferWriter bufferWriter)
        {
            ThreadLocalState threadLocalState = t_threadLocalState ?? (t_threadLocalState = new ThreadLocalState());
            Utf8JsonWriter utf8JsonWriter;
            if (threadLocalState.RentedWriters++ == 0)
            {
                bufferWriter = threadLocalState.BufferWriter;
                utf8JsonWriter = threadLocalState.Writer;
                bufferWriter.InitializeEmptyInstance(options.DefaultBufferSize);
                utf8JsonWriter.Reset(bufferWriter, options.GetWriterOptions());
            }
            else
            {
                bufferWriter = new PooledByteBufferWriter(options.DefaultBufferSize);
                utf8JsonWriter = new Utf8JsonWriter(bufferWriter, options.GetWriterOptions());
            }
            return utf8JsonWriter;
        }

        public static Utf8JsonWriter RentWriter(JsonSerializerOptions options, PooledByteBufferWriter bufferWriter)
        {
            ThreadLocalState threadLocalState = t_threadLocalState ?? (t_threadLocalState = new ThreadLocalState());
            Utf8JsonWriter utf8JsonWriter;
            if (threadLocalState.RentedWriters++ == 0)
            {
                utf8JsonWriter = threadLocalState.Writer;
                utf8JsonWriter.Reset(bufferWriter, options.GetWriterOptions());
            }
            else
            {
                utf8JsonWriter = new Utf8JsonWriter(bufferWriter, options.GetWriterOptions());
            }
            return utf8JsonWriter;
        }

        public static void ReturnWriterAndBuffer(Utf8JsonWriter writer, PooledByteBufferWriter bufferWriter)
        {
            ThreadLocalState threadLocalState = t_threadLocalState;
            writer.ResetAllStateForCacheReuse();
            bufferWriter.ClearAndReturnBuffers();
            threadLocalState.RentedWriters--;
        }

        public static void ReturnWriter(Utf8JsonWriter writer)
        {
            ThreadLocalState threadLocalState = t_threadLocalState;
            writer.ResetAllStateForCacheReuse();
            threadLocalState.RentedWriters--;
        }
    }

    [StructLayout(LayoutKind.Auto)]
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    internal struct WriteStack
    {
        /// <summary>
        /// Exposes the stackframe that is currently active.
        /// </summary>
        public WriteStackFrame Current;

        /// <summary>
        /// Buffer containing all frames in the stack. For performance it is only populated for serialization depths &gt; 1.
        /// </summary>
        private WriteStackFrame[] _stack;

        /// <summary>
        /// Tracks the current depth of the stack.
        /// </summary>
        private int _count;

        /// <summary>
        /// If not zero, indicates that the stack is part of a re-entrant continuation of given depth.
        /// </summary>
        private int _continuationCount;

        /// <summary>
        /// Offset used to derive the index of the current frame in the stack buffer from the current value of <see cref="F:System.Text.Json.WriteStack._count" />,
        /// following the formula currentIndex := _count - _indexOffset.
        /// Value can vary between 0 or 1 depending on whether we need to allocate a new frame on the first Push() operation,
        /// which can happen if the root converter is polymorphic.
        /// </summary>
        private byte _indexOffset;

        /// <summary>
        /// Cancellation token used by converters performing async serialization (e.g. IAsyncEnumerable)
        /// </summary>
        public CancellationToken CancellationToken;

        /// <summary>
        /// In the case of async serialization, used by resumable converters to signal that
        /// the current buffer contents should not be flushed to the underlying stream.
        /// </summary>
        public bool SuppressFlush;

        /// <summary>
        /// Stores a pending task that a resumable converter depends on to continue work.
        /// It must be awaited by the root context before serialization is resumed.
        /// </summary>
        public Task PendingTask;

        /// <summary>
        /// List of completed IAsyncDisposables that have been scheduled for disposal by converters.
        /// </summary>
        public List<IAsyncDisposable> CompletedAsyncDisposables;

        /// <summary>
        /// The amount of bytes to write before the underlying Stream should be flushed and the
        /// current buffer adjusted to remove the processed bytes.
        /// </summary>
        public int FlushThreshold;

        /// <summary>
        /// Indicates that the root-level JsonTypeInfo is the result of
        /// polymorphic dispatch from the internal System.Object converter.
        /// </summary>
        public bool IsPolymorphicRootValue;

        public ReferenceResolver ReferenceResolver;

        /// <summary>
        /// Internal flag to let us know that we need to read ahead in the inner read loop.
        /// </summary>
        public bool SupportContinuation;

        /// <summary>
        /// Internal flag indicating that async serialization is supported. Implies `SupportContinuation`.
        /// </summary>
        public bool SupportAsync;

        /// <summary>
        /// Stores a reference id that has been calculated for a newly serialized object.
        /// </summary>
        public string NewReferenceId;

        /// <summary>
        /// Indicates that the next converter is polymorphic and must serialize a type discriminator.
        /// </summary>
        public object PolymorphicTypeDiscriminator;

        public int CurrentDepth => _count;

        /// <summary>
        /// Gets the parent stackframe, if it exists.
        /// </summary>
        public ref WriteStackFrame Parent => ref _stack[_count - _indexOffset - 1];

        /// <summary>
        /// Indicates that the state still contains suspended frames waiting re-entry.
        /// </summary>
        public bool IsContinuation => _continuationCount != 0;

        /// <summary>
        /// Whether the current frame needs to write out any metadata.
        /// </summary>
        public bool CurrentContainsMetadata
        {
            get
            {
                if (NewReferenceId == null)
                {
                    return PolymorphicTypeDiscriminator != null;
                }
                return true;
            }
        }

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private string DebuggerDisplay => $"Path:{PropertyPath()} Current: ConverterStrategy.{Current.JsonPropertyInfo?.ConverterStrategy}, {Current.JsonTypeInfo?.Type.Name}";

        private void EnsurePushCapacity()
        {
            if (_stack == null)
            {
                _stack = new WriteStackFrame[4];
            }
            else if (_count - _indexOffset == _stack.Length)
            {
                Array.Resize(ref _stack, 2 * _stack.Length);
            }
        }

        internal void Initialize(JsonTypeInfo jsonTypeInfo, bool supportContinuation = false, bool supportAsync = false)
        {
            Current.JsonTypeInfo = jsonTypeInfo;
            Current.JsonPropertyInfo = jsonTypeInfo.PropertyInfoForTypeInfo;
            Current.NumberHandling = Current.JsonPropertyInfo.EffectiveNumberHandling;
            SupportContinuation = supportContinuation;
            SupportAsync = supportAsync;
            JsonSerializerOptions options = jsonTypeInfo.Options;
            if (options.ReferenceHandlingStrategy != 0)
            {
                ReferenceResolver = options.ReferenceHandler.CreateResolver(writing: true);
            }
        }

        /// <summary>
        /// Gets the nested JsonTypeInfo before resolving any polymorphic converters
        /// </summary>
        public JsonTypeInfo PeekNestedJsonTypeInfo()
        {
            if (_count != 0)
            {
                return Current.JsonPropertyInfo.JsonTypeInfo;
            }
            return Current.JsonTypeInfo;
        }

        public void Push()
        {
            if (_continuationCount == 0)
            {
                if (_count == 0 && Current.PolymorphicSerializationState == PolymorphicSerializationState.None)
                {
                    _count = 1;
                    _indexOffset = 1;
                    return;
                }
                JsonTypeInfo nestedJsonTypeInfo = Current.GetNestedJsonTypeInfo();
                JsonNumberHandling? numberHandling = Current.NumberHandling;
                EnsurePushCapacity();
                _stack[_count - _indexOffset] = Current;
                Current = default(WriteStackFrame);
                _count++;
                Current.JsonTypeInfo = nestedJsonTypeInfo;
                Current.JsonPropertyInfo = nestedJsonTypeInfo.PropertyInfoForTypeInfo;
                Current.NumberHandling = numberHandling ?? Current.JsonPropertyInfo.EffectiveNumberHandling;
            }
            else
            {
                if (_count++ > 0 || _indexOffset == 0)
                {
                    Current = _stack[_count - _indexOffset];
                }
                if (_continuationCount == _count)
                {
                    _continuationCount = 0;
                }
            }
        }

        public void Pop(bool success)
        {
            if (!success)
            {
                if (_continuationCount == 0)
                {
                    if (_count == 1 && _indexOffset > 0)
                    {
                        _continuationCount = 1;
                        _count = 0;
                        return;
                    }
                    EnsurePushCapacity();
                    _continuationCount = _count--;
                }
                else if (--_count == 0 && _indexOffset > 0)
                {
                    return;
                }
                int num = _count - _indexOffset;
                _stack[num + 1] = Current;
                Current = _stack[num];
            }
            else if (--_count > 0 || _indexOffset == 0)
            {
                Current = _stack[_count - _indexOffset];
            }
        }

        public void AddCompletedAsyncDisposable(IAsyncDisposable asyncDisposable)
        {
            (CompletedAsyncDisposables ?? (CompletedAsyncDisposables = new List<IAsyncDisposable>())).Add(asyncDisposable);
        }

        public async ValueTask DisposeCompletedAsyncDisposables()
        {
            Exception exception = null;
            foreach (IAsyncDisposable completedAsyncDisposable in CompletedAsyncDisposables)
            {
                try
                {
                    await completedAsyncDisposable.DisposeAsync().ConfigureAwait(continueOnCapturedContext: false);
                }
                catch (Exception ex)
                {
                    exception = ex;
                }
            }
            if (exception != null)
            {
                ExceptionDispatchInfo.Capture(exception).Throw();
            }
            CompletedAsyncDisposables.Clear();
        }

        /// <summary>
        /// Walks the stack cleaning up any leftover IDisposables
        /// in the event of an exception on serialization
        /// </summary>
        public void DisposePendingDisposablesOnException()
        {
            Exception exception2 = null;
            DisposeFrame(Current.CollectionEnumerator, ref exception2);
            int num = Math.Max(_count, _continuationCount);
            for (int i = 0; i < num - 1; i++)
            {
                DisposeFrame(_stack[i].CollectionEnumerator, ref exception2);
            }
            if (exception2 != null)
            {
                ExceptionDispatchInfo.Capture(exception2).Throw();
            }
            static void DisposeFrame(IEnumerator collectionEnumerator, ref Exception exception)
            {
                try
                {
                    if (collectionEnumerator is IDisposable disposable)
                    {
                        disposable.Dispose();
                    }
                }
                catch (Exception ex)
                {
                    exception = ex;
                }
            }
        }

        /// <summary>
        /// Walks the stack cleaning up any leftover I(Async)Disposables
        /// in the event of an exception on async serialization
        /// </summary>
        public async ValueTask DisposePendingDisposablesOnExceptionAsync()
        {
            Exception exception2 = null;
            exception2 = await DisposeFrame(Current.CollectionEnumerator, Current.AsyncDisposable, exception2).ConfigureAwait(continueOnCapturedContext: false);
            int stackSize = Math.Max(_count, _continuationCount);
            for (int i = 0; i < stackSize - 1; i++)
            {
                exception2 = await DisposeFrame(_stack[i].CollectionEnumerator, _stack[i].AsyncDisposable, exception2).ConfigureAwait(continueOnCapturedContext: false);
            }
            if (exception2 != null)
            {
                ExceptionDispatchInfo.Capture(exception2).Throw();
            }
            static async ValueTask<Exception> DisposeFrame(IEnumerator collectionEnumerator, IAsyncDisposable asyncDisposable, Exception exception)
            {
                try
                {
                    if (collectionEnumerator is IDisposable disposable)
                    {
                        disposable.Dispose();
                    }
                    else if (asyncDisposable != null)
                    {
                        await asyncDisposable.DisposeAsync().ConfigureAwait(continueOnCapturedContext: false);
                    }
                }
                catch (Exception ex)
                {
                    exception = ex;
                }
                return exception;
            }
        }

        public string PropertyPath()
        {
            StringBuilder stringBuilder = new StringBuilder("$");
            int continuationCount = _continuationCount;
            (int, bool) tuple = continuationCount switch
            {
                0 => (_count - 1, true),
                1 => (0, true),
                _ => (continuationCount, false),
            };
            int item = tuple.Item1;
            bool item2 = tuple.Item2;
            for (int i = 1; i <= item; i++)
            {
                AppendStackFrame(stringBuilder, ref _stack[i - _indexOffset]);
            }
            if (item2)
            {
                AppendStackFrame(stringBuilder, ref Current);
            }
            return stringBuilder.ToString();
            static void AppendPropertyName(StringBuilder sb, string propertyName)
            {
                if (propertyName != null)
                {
                    if (propertyName.IndexOfAny(ReadStack.SpecialCharacters) != -1)
                    {
                        sb.Append("['");
                        sb.Append(propertyName);
                        sb.Append("']");
                    }
                    else
                    {
                        sb.Append('.');
                        sb.Append(propertyName);
                    }
                }
            }
            static void AppendStackFrame(StringBuilder sb, ref WriteStackFrame frame)
            {
                string propertyName2 = frame.JsonPropertyInfo?.MemberName ?? frame.JsonPropertyNameAsString;
                AppendPropertyName(sb, propertyName2);
            }
        }
    }

    [StructLayout(LayoutKind.Auto)]
    [DebuggerDisplay("{DebuggerDisplay,nq}")]
    internal struct WriteStackFrame
    {
        /// <summary>
        /// The enumerator for resumable collections.
        /// </summary>
        public IEnumerator CollectionEnumerator;

        /// <summary>
        /// The enumerator for resumable async disposables.
        /// </summary>
        public IAsyncDisposable AsyncDisposable;

        /// <summary>
        /// The current stackframe has suspended serialization due to a pending task,
        /// stored in the <see cref="F:System.Text.Json.WriteStack.PendingTask" /> property.
        /// </summary>
        public bool AsyncEnumeratorIsPendingCompletion;

        /// <summary>
        /// The original JsonPropertyInfo that is not changed. It contains all properties.
        /// </summary>
        /// <remarks>
        /// For objects, it is either the actual (real) JsonPropertyInfo or the <see cref="P:System.Text.Json.Serialization.Metadata.JsonTypeInfo.PropertyInfoForTypeInfo" /> for the class.
        /// For collections, it is the <see cref="P:System.Text.Json.Serialization.Metadata.JsonTypeInfo.PropertyInfoForTypeInfo" /> for the class and current element.
        /// </remarks>
        public JsonPropertyInfo JsonPropertyInfo;

        /// <summary>
        /// Used when processing extension data dictionaries.
        /// </summary>
        public bool IsWritingExtensionDataProperty;

        /// <summary>
        /// The class (POCO or IEnumerable) that is being populated.
        /// </summary>
        public JsonTypeInfo JsonTypeInfo;

        /// <summary>
        /// Validation state for a class.
        /// </summary>
        public int OriginalDepth;

        public bool ProcessedStartToken;

        public bool ProcessedEndToken;

        /// <summary>
        /// Property or Element state.
        /// </summary>
        public StackFramePropertyState PropertyState;

        /// <summary>
        /// The enumerator index for resumable collections.
        /// </summary>
        public int EnumeratorIndex;

        public string JsonPropertyNameAsString;

        public MetadataPropertyName MetadataPropertyName;

        public PolymorphicSerializationState PolymorphicSerializationState;

        private JsonPropertyInfo PolymorphicJsonTypeInfo;

        public JsonNumberHandling? NumberHandling;

        public bool IsPushedReferenceForCycleDetection;

        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private string DebuggerDisplay => $"ConverterStrategy.{JsonTypeInfo?.PropertyInfoForTypeInfo.ConverterStrategy}, {JsonTypeInfo?.Type.Name}";

        public void EndCollectionElement()
        {
            PolymorphicSerializationState = PolymorphicSerializationState.None;
        }

        public void EndDictionaryEntry()
        {
            PropertyState = StackFramePropertyState.None;
            PolymorphicSerializationState = PolymorphicSerializationState.None;
        }

        public void EndProperty()
        {
            JsonPropertyInfo = null;
            JsonPropertyNameAsString = null;
            PropertyState = StackFramePropertyState.None;
            PolymorphicSerializationState = PolymorphicSerializationState.None;
        }

        /// <summary>
        /// Returns the JsonTypeInfo instance for the nested value we are trying to access.
        /// </summary>
        public JsonTypeInfo GetNestedJsonTypeInfo()
        {
            JsonPropertyInfo jsonPropertyInfo = ((PolymorphicSerializationState == PolymorphicSerializationState.PolymorphicReEntryStarted) ? PolymorphicJsonTypeInfo : JsonPropertyInfo);
            return jsonPropertyInfo.JsonTypeInfo;
        }

        /// <summary>
        /// Configures the next stack frame for a polymorphic converter.
        /// </summary>
        public JsonConverter InitializePolymorphicReEntry(Type runtimeType, JsonSerializerOptions options)
        {
            if (PolymorphicJsonTypeInfo?.PropertyType != runtimeType)
            {
                JsonTypeInfo typeInfoInternal = options.GetTypeInfoInternal(runtimeType);
                PolymorphicJsonTypeInfo = typeInfoInternal.PropertyInfoForTypeInfo;
            }
            PolymorphicSerializationState = PolymorphicSerializationState.PolymorphicReEntryStarted;
            return PolymorphicJsonTypeInfo.EffectiveConverter;
        }

        /// <summary>
        /// Configures the next stack frame for a polymorphic converter.
        /// </summary>
        public JsonConverter InitializePolymorphicReEntry(JsonTypeInfo derivedJsonTypeInfo)
        {
            PolymorphicJsonTypeInfo = derivedJsonTypeInfo.PropertyInfoForTypeInfo;
            PolymorphicSerializationState = PolymorphicSerializationState.PolymorphicReEntryStarted;
            return PolymorphicJsonTypeInfo.EffectiveConverter;
        }

        /// <summary>
        /// Configures the next frame for a continuation of a polymorphic converter.
        /// </summary>
        public JsonConverter ResumePolymorphicReEntry()
        {
            PolymorphicSerializationState = PolymorphicSerializationState.PolymorphicReEntryStarted;
            return PolymorphicJsonTypeInfo.EffectiveConverter;
        }

        /// <summary>
        /// Updates frame state after a polymorphic converter has returned.
        /// </summary>
        public void ExitPolymorphicConverter(bool success)
        {
            PolymorphicSerializationState = ((!success) ? PolymorphicSerializationState.PolymorphicReEntrySuspended : PolymorphicSerializationState.None);
        }
    }

    namespace Nodes
    {
        using System.Text.Json.Serialization.Converters;
        using System.Text.Json.Serialization.Metadata;

        /// <summary>
        ///   Represents a mutable JSON array.
        /// </summary>
        /// <remarks>
        /// It is safe to perform multiple concurrent read operations on a <see cref="T:System.Text.Json.Nodes.JsonArray" />,
        /// but issues can occur if the collection is modified while it's being read.
        /// </remarks>
        [DebuggerDisplay("JsonArray[{List.Count}]")]
        [DebuggerTypeProxy(typeof(DebugView))]
        public sealed class JsonArray : JsonNode, IList<JsonNode?>, ICollection<JsonNode?>, IEnumerable<JsonNode?>, IEnumerable
        {
            [ExcludeFromCodeCoverage]
            private sealed class DebugView
            {
                [DebuggerDisplay("{Display,nq}")]
                private struct DebugViewItem
                {
                    [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
                    public JsonNode Value;

                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    public string Display
                    {
                        get
                        {
                            if (Value == null)
                            {
                                return "null";
                            }
                            if (Value is JsonValue)
                            {
                                return Value.ToJsonString();
                            }
                            if (Value is JsonObject jsonObject)
                            {
                                return $"JsonObject[{jsonObject.Count}]";
                            }
                            JsonArray jsonArray = (JsonArray)Value;
                            return $"JsonArray[{jsonArray.List.Count}]";
                        }
                    }
                }

                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private JsonArray _node;

                public string Json => _node.ToJsonString();

                public string Path => _node.GetPath();

                [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
                private DebugViewItem[] Items
                {
                    get
                    {
                        DebugViewItem[] array = new DebugViewItem[_node.List.Count];
                        for (int i = 0; i < _node.List.Count; i++)
                        {
                            array[i].Value = _node.List[i];
                        }
                        return array;
                    }
                }

                public DebugView(JsonArray node)
                {
                    _node = node;
                }
            }

            private JsonElement? _jsonElement;

            private List<JsonNode> _list;

            internal List<JsonNode?> List
            {
                get
                {
                    CreateNodes();
                    return _list;
                }
            }

            /// <summary>
            ///   Gets the number of elements contained in the <see cref="T:System.Text.Json.Nodes.JsonArray" />.
            /// </summary>
            public int Count => List.Count;

            /// <summary>
            ///   Returns <see langword="false" />.
            /// </summary>
            bool ICollection<JsonNode>.IsReadOnly => false;

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonArray" /> class that is empty.
            /// </summary>
            /// <param name="options">Options to control the behavior.</param>
            public JsonArray(JsonNodeOptions? options = null)
                : base(options)
            {
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonArray" /> class that contains items from the specified params array.
            /// </summary>
            /// <param name="options">Options to control the behavior.</param>
            /// <param name="items">The items to add to the new <see cref="T:System.Text.Json.Nodes.JsonArray" />.</param>
            public JsonArray(JsonNodeOptions options, params JsonNode?[] items)
                : base(options)
            {
                InitializeFromArray(items);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonArray" /> class that contains items from the specified array.
            /// </summary>
            /// <param name="items">The items to add to the new <see cref="T:System.Text.Json.Nodes.JsonArray" />.</param>
            public JsonArray(params JsonNode?[] items)
            {
                InitializeFromArray(items);
            }

            private void InitializeFromArray(JsonNode[] items)
            {
                List<JsonNode> list = new List<JsonNode>(items);
                for (int i = 0; i < items.Length; i++)
                {
                    items[i]?.AssignParent(this);
                }
                _list = list;
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonArray" /> class that contains items from the specified <see cref="T:System.Text.Json.JsonElement" />.
            /// </summary>
            /// <returns>
            ///   The new instance of the <see cref="T:System.Text.Json.Nodes.JsonArray" /> class that contains items from the specified <see cref="T:System.Text.Json.JsonElement" />.
            /// </returns>
            /// <param name="element">The <see cref="T:System.Text.Json.JsonElement" />.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <exception cref="T:System.InvalidOperationException">
            ///   The <paramref name="element" /> is not a <see cref="F:System.Text.Json.JsonValueKind.Array" />.
            /// </exception>
            public static JsonArray? Create(JsonElement element, JsonNodeOptions? options = null)
            {
                if (element.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                if (element.ValueKind == JsonValueKind.Array)
                {
                    return new JsonArray(element, options);
                }
                throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.NodeElementWrongType, "Array"));
            }

            internal JsonArray(JsonElement element, JsonNodeOptions? options = null)
                : base(options)
            {
                _jsonElement = element;
            }

            /// <summary>
            ///   Adds an object to the end of the <see cref="T:System.Text.Json.Nodes.JsonArray" />.
            /// </summary>
            /// <typeparam name="T">The type of object to be added.</typeparam>
            /// <param name="value">
            ///   The object to be added to the end of the <see cref="T:System.Text.Json.Nodes.JsonArray" />.
            /// </param>
            [RequiresUnreferencedCode("Creating JsonValue instances with non-primitive types is not compatible with trimming. It can result in non-primitive types being serialized, which may have their members trimmed.")]
            [RequiresDynamicCode("Creating JsonValue instances with non-primitive types requires generating code at runtime.")]
            public void Add<T>(T? value)
            {
                if (value == null)
                {
                    Add(null);
                    return;
                }
                JsonNode item = (value as JsonNode) ?? new JsonValueNotTrimmable<T>(value);
                Add(item);
            }

            internal JsonNode GetItem(int index)
            {
                return List[index];
            }

            internal void SetItem(int index, JsonNode value)
            {
                value?.AssignParent(this);
                DetachParent(List[index]);
                List[index] = value;
            }

            internal override void GetPath(List<string> path, JsonNode child)
            {
                if (child != null)
                {
                    int num = List.IndexOf(child);
                    path.Add($"[{num}]");
                }
                base.Parent?.GetPath(path, this);
            }

            /// <inheritdoc />
            public override void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions? options = null)
            {
                if (writer == null)
                {
                    ThrowHelper.ThrowArgumentNullException("writer");
                }
                if (_jsonElement.HasValue)
                {
                    _jsonElement.Value.WriteTo(writer);
                    return;
                }
                CreateNodes();
                if (options == null)
                {
                    options = JsonNode.s_defaultOptions;
                }
                writer.WriteStartArray();
                for (int i = 0; i < _list.Count; i++)
                {
                    JsonNodeConverter.Instance.Write(writer, _list[i], options);
                }
                writer.WriteEndArray();
            }

            private void CreateNodes()
            {
                if (_list != null)
                {
                    return;
                }
                List<JsonNode> list;
                if (!_jsonElement.HasValue)
                {
                    list = new List<JsonNode>();
                }
                else
                {
                    JsonElement value = _jsonElement.Value;
                    list = new List<JsonNode>(value.GetArrayLength());
                    foreach (JsonElement item in value.EnumerateArray())
                    {
                        JsonNode jsonNode = JsonNodeConverter.Create(item, base.Options);
                        jsonNode?.AssignParent(this);
                        list.Add(jsonNode);
                    }
                    _jsonElement = null;
                }
                _list = list;
            }

            /// <summary>
            ///   Adds a <see cref="T:System.Text.Json.Nodes.JsonNode" /> to the end of the <see cref="T:System.Text.Json.Nodes.JsonArray" />.
            /// </summary>
            /// <param name="item">
            ///   The <see cref="T:System.Text.Json.Nodes.JsonNode" /> to be added to the end of the <see cref="T:System.Text.Json.Nodes.JsonArray" />.
            /// </param>
            public void Add(JsonNode? item)
            {
                item?.AssignParent(this);
                List.Add(item);
            }

            /// <summary>
            ///   Removes all elements from the <see cref="T:System.Text.Json.Nodes.JsonArray" />.
            /// </summary>
            public void Clear()
            {
                for (int i = 0; i < List.Count; i++)
                {
                    DetachParent(List[i]);
                }
                List.Clear();
            }

            /// <summary>
            ///   Determines whether an element is in the <see cref="T:System.Text.Json.Nodes.JsonArray" />.
            /// </summary>
            /// <param name="item">The object to locate in the <see cref="T:System.Text.Json.Nodes.JsonArray" />.</param>
            /// <returns>
            ///   <see langword="true" /> if <paramref name="item" /> is found in the <see cref="T:System.Text.Json.Nodes.JsonArray" />; otherwise, <see langword="false" />.
            /// </returns>
            public bool Contains(JsonNode? item)
            {
                return List.Contains(item);
            }

            /// <summary>
            ///   The object to locate in the <see cref="T:System.Text.Json.Nodes.JsonArray" />.
            /// </summary>
            /// <param name="item">The <see cref="T:System.Text.Json.Nodes.JsonNode" /> to locate in the <see cref="T:System.Text.Json.Nodes.JsonArray" />.</param>
            /// <returns>
            ///  The index of item if found in the list; otherwise, -1.
            /// </returns>
            public int IndexOf(JsonNode? item)
            {
                return List.IndexOf(item);
            }

            /// <summary>
            ///   Inserts an element into the <see cref="T:System.Text.Json.Nodes.JsonArray" /> at the specified index.
            /// </summary>
            /// <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
            /// <param name="item">The <see cref="T:System.Text.Json.Nodes.JsonNode" /> to insert.</param>
            /// <exception cref="T:System.ArgumentOutOfRangeException">
            ///   <paramref name="index" /> is less than 0 or <paramref name="index" /> is greater than <see cref="P:System.Text.Json.Nodes.JsonArray.Count" />.
            /// </exception>
            public void Insert(int index, JsonNode? item)
            {
                item?.AssignParent(this);
                List.Insert(index, item);
            }

            /// <summary>
            ///   Removes the first occurrence of a specific <see cref="T:System.Text.Json.Nodes.JsonNode" /> from the <see cref="T:System.Text.Json.Nodes.JsonArray" />.
            /// </summary>
            /// <param name="item">
            ///   The <see cref="T:System.Text.Json.Nodes.JsonNode" /> to remove from the <see cref="T:System.Text.Json.Nodes.JsonArray" />.
            /// </param>
            /// <returns>
            ///   <see langword="true" /> if <paramref name="item" /> is successfully removed; otherwise, <see langword="false" />.
            /// </returns>
            public bool Remove(JsonNode? item)
            {
                if (List.Remove(item))
                {
                    DetachParent(item);
                    return true;
                }
                return false;
            }

            /// <summary>
            ///   Removes the element at the specified index of the <see cref="T:System.Text.Json.Nodes.JsonArray" />.
            /// </summary>
            /// <param name="index">The zero-based index of the element to remove.</param>
            /// <exception cref="T:System.ArgumentOutOfRangeException">
            ///   <paramref name="index" /> is less than 0 or <paramref name="index" /> is greater than <see cref="P:System.Text.Json.Nodes.JsonArray.Count" />.
            /// </exception>
            public void RemoveAt(int index)
            {
                JsonNode item = List[index];
                List.RemoveAt(index);
                DetachParent(item);
            }

            /// <summary>
            ///   Copies the entire <see cref="T:System.Array" /> to a compatible one-dimensional array,
            ///   starting at the specified index of the target array.
            /// </summary>
            /// <param name="array">
            ///   The one-dimensional <see cref="T:System.Array" /> that is the destination of the elements copied
            ///   from <see cref="T:System.Text.Json.Nodes.JsonArray" />. The Array must have zero-based indexing.</param>
            /// <param name="index">
            ///   The zero-based index in <paramref name="array" /> at which copying begins.
            /// </param>
            /// <exception cref="T:System.ArgumentNullException">
            ///   <paramref name="array" /> is <see langword="null" />.
            /// </exception>
            /// <exception cref="T:System.ArgumentOutOfRangeException">
            ///   <paramref name="index" /> is less than 0.
            /// </exception>
            /// <exception cref="T:System.ArgumentException">
            ///   The number of elements in the source ICollection is greater than the available space from <paramref name="index" />
            ///   to the end of the destination <paramref name="array" />.
            /// </exception>
            void ICollection<JsonNode>.CopyTo(JsonNode[] array, int index)
            {
                List.CopyTo(array, index);
            }

            /// <summary>
            ///   Returns an enumerator that iterates through the <see cref="T:System.Text.Json.Nodes.JsonArray" />.
            /// </summary>
            /// <returns>A <see cref="T:System.Collections.Generic.IEnumerator`1" /> for the <see cref="T:System.Text.Json.Nodes.JsonNode" />.</returns>
            public IEnumerator<JsonNode?> GetEnumerator()
            {
                return List.GetEnumerator();
            }

            /// <summary>
            ///   Returns an enumerator that iterates through the <see cref="T:System.Text.Json.Nodes.JsonArray" />.
            /// </summary>
            /// <returns>
            ///   A <see cref="T:System.Collections.IEnumerator" /> for the <see cref="T:System.Text.Json.Nodes.JsonArray" />.
            /// </returns>
            IEnumerator IEnumerable.GetEnumerator()
            {
                return ((IEnumerable)List).GetEnumerator();
            }

            private static void DetachParent(JsonNode item)
            {
                if (item != null)
                {
                    item.Parent = null;
                }
            }
        }

        /// <summary>
        ///   The base class that represents a single node within a mutable JSON document.
        /// </summary>
        /// <seealso cref="P:System.Text.Json.JsonSerializerOptions.UnknownTypeHandling" /> to specify that a type
        /// declared as an <see cref="T:System.Object" /> should be deserialized as a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
        public abstract class JsonNode
        {
            private JsonNode _parent;

            private JsonNodeOptions? _options;

            private protected static readonly JsonSerializerOptions s_defaultOptions = new JsonSerializerOptions();

            /// <summary>
            ///   Options to control the behavior.
            /// </summary>
            public JsonNodeOptions? Options
            {
                get
                {
                    if (!_options.HasValue && Parent != null)
                    {
                        _options = Parent.Options;
                    }
                    return _options;
                }
            }

            /// <summary>
            ///   Gets the parent <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            ///   If there is no parent, <see langword="null" /> is returned.
            ///   A parent can either be a <see cref="T:System.Text.Json.Nodes.JsonObject" /> or a <see cref="T:System.Text.Json.Nodes.JsonArray" />.
            /// </summary>
            public JsonNode? Parent
            {
                get
                {
                    return _parent;
                }
                internal set
                {
                    _parent = value;
                }
            }

            /// <summary>
            ///   Gets the root <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <remarks>
            ///   The current node is returned if it is a root.
            /// </remarks>
            public JsonNode Root
            {
                get
                {
                    JsonNode parent = Parent;
                    if (parent == null)
                    {
                        return this;
                    }
                    while (parent.Parent != null)
                    {
                        parent = parent.Parent;
                    }
                    return parent;
                }
            }

            /// <summary>
            ///   Gets or sets the element at the specified index.
            /// </summary>
            /// <param name="index">The zero-based index of the element to get or set.</param>
            /// <exception cref="T:System.ArgumentOutOfRangeException">
            ///   <paramref name="index" /> is less than 0 or <paramref name="index" /> is greater than the number of properties.
            /// </exception>
            /// <exception cref="T:System.InvalidOperationException">
            ///   The current <see cref="T:System.Text.Json.Nodes.JsonNode" /> is not a <see cref="T:System.Text.Json.Nodes.JsonArray" />.
            /// </exception>
            public JsonNode? this[int index]
            {
                get
                {
                    return AsArray().GetItem(index);
                }
                set
                {
                    AsArray().SetItem(index, value);
                }
            }

            /// <summary>
            ///   Gets or sets the element with the specified property name.
            ///   If the property is not found, <see langword="null" /> is returned.
            /// </summary>
            /// <param name="propertyName">The name of the property to return.</param>
            /// <exception cref="T:System.ArgumentNullException">
            ///   <paramref name="propertyName" /> is <see langword="null" />.
            /// </exception>
            /// <exception cref="T:System.InvalidOperationException">
            ///   The current <see cref="T:System.Text.Json.Nodes.JsonNode" /> is not a <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </exception>
            public JsonNode? this[string propertyName]
            {
                get
                {
                    return AsObject().GetItem(propertyName);
                }
                set
                {
                    AsObject().SetItem(propertyName, value);
                }
            }

            internal JsonNode(JsonNodeOptions? options = null)
            {
                _options = options;
            }

            /// <summary>
            ///   Casts to the derived <see cref="T:System.Text.Json.Nodes.JsonArray" /> type.
            /// </summary>
            /// <returns>
            ///   A <see cref="T:System.Text.Json.Nodes.JsonArray" />.
            /// </returns>
            /// <exception cref="T:System.InvalidOperationException">
            ///   The node is not a <see cref="T:System.Text.Json.Nodes.JsonArray" />.
            /// </exception>
            public JsonArray AsArray()
            {
                if (this is JsonArray result)
                {
                    return result;
                }
                throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.NodeWrongType, "JsonArray"));
            }

            /// <summary>
            ///   Casts to the derived <see cref="T:System.Text.Json.Nodes.JsonObject" /> type.
            /// </summary>
            /// <returns>
            ///   A <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </returns>
            /// <exception cref="T:System.InvalidOperationException">
            ///   The node is not a <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </exception>
            public JsonObject AsObject()
            {
                if (this is JsonObject result)
                {
                    return result;
                }
                throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.NodeWrongType, "JsonObject"));
            }

            /// <summary>
            ///   Casts to the derived <see cref="T:System.Text.Json.Nodes.JsonValue" /> type.
            /// </summary>
            /// <returns>
            ///   A <see cref="T:System.Text.Json.Nodes.JsonValue" />.
            /// </returns>
            /// <exception cref="T:System.InvalidOperationException">
            ///   The node is not a <see cref="T:System.Text.Json.Nodes.JsonValue" />.
            /// </exception>
            public JsonValue AsValue()
            {
                if (this is JsonValue result)
                {
                    return result;
                }
                throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.NodeWrongType, "JsonValue"));
            }

            /// <summary>
            ///   Gets the JSON path.
            /// </summary>
            /// <returns>The JSON Path value.</returns>
            public string GetPath()
            {
                if (Parent == null)
                {
                    return "$";
                }
                List<string> list = new List<string>();
                GetPath(list, null);
                StringBuilder stringBuilder = new StringBuilder("$");
                for (int num = list.Count - 1; num >= 0; num--)
                {
                    stringBuilder.Append(list[num]);
                }
                return stringBuilder.ToString();
            }

            internal abstract void GetPath(List<string> path, JsonNode child);

            /// <summary>
            ///   Gets the value for the current <see cref="T:System.Text.Json.Nodes.JsonValue" />.
            /// </summary>
            /// <typeparam name="T">The type of the value to obtain from the <see cref="T:System.Text.Json.Nodes.JsonValue" />.</typeparam>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</returns>
            /// <remarks>
            ///   {T} can be the type or base type of the underlying value.
            ///   If the underlying value is a <see cref="T:System.Text.Json.JsonElement" /> then {T} can also be the type of any primitive
            ///   value supported by current <see cref="T:System.Text.Json.JsonElement" />.
            ///   Specifying the <see cref="T:System.Object" /> type for {T} will always succeed and return the underlying value as <see cref="T:System.Object" />.<br />
            ///   The underlying value of a <see cref="T:System.Text.Json.Nodes.JsonValue" /> after deserialization is an instance of <see cref="T:System.Text.Json.JsonElement" />,
            ///   otherwise it's the value specified when the <see cref="T:System.Text.Json.Nodes.JsonValue" /> was created.
            /// </remarks>
            /// <seealso cref="M:System.Text.Json.Nodes.JsonValue.TryGetValue``1(``0@)"></seealso>
            /// <exception cref="T:System.FormatException">
            ///   The current <see cref="T:System.Text.Json.Nodes.JsonNode" /> cannot be represented as a {T}.
            /// </exception>
            /// <exception cref="T:System.InvalidOperationException">
            ///   The current <see cref="T:System.Text.Json.Nodes.JsonNode" /> is not a <see cref="T:System.Text.Json.Nodes.JsonValue" /> or
            ///   is not compatible with {T}.
            /// </exception>
            public virtual T GetValue<T>()
            {
                throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.NodeWrongType, "JsonValue"));
            }

            internal void AssignParent(JsonNode parent)
            {
                if (Parent != null)
                {
                    ThrowHelper.ThrowInvalidOperationException_NodeAlreadyHasParent();
                }
                for (JsonNode jsonNode = parent; jsonNode != null; jsonNode = jsonNode.Parent)
                {
                    if (jsonNode == this)
                    {
                        ThrowHelper.ThrowInvalidOperationException_NodeCycleDetected();
                    }
                }
                Parent = parent;
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Boolean" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Boolean" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode(bool value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Boolean" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Boolean" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode?(bool? value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Byte" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Byte" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode(byte value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Byte" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Byte" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode?(byte? value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Char" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Char" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode(char value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Char" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Char" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode?(char? value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.DateTime" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.DateTime" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode(DateTime value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.DateTime" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.DateTime" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode?(DateTime? value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.DateTimeOffset" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.DateTimeOffset" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode(DateTimeOffset value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.DateTimeOffset" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.DateTimeOffset" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode?(DateTimeOffset? value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Decimal" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Decimal" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode(decimal value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Decimal" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Decimal" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode?(decimal? value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Double" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Double" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode(double value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Double" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Double" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode?(double? value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Guid" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Guid" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode(Guid value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Guid" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Guid" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode?(Guid? value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Int16" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Int16" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode(short value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Int16" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Int16" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode?(short? value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Int32" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Int32" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode(int value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Int32" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Int32" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode?(int? value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Int64" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Int64" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode(long value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Int64" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Int64" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode?(long? value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.SByte" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.SByte" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            [CLSCompliant(false)]
            public static implicit operator JsonNode(sbyte value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.SByte" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.SByte" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            [CLSCompliant(false)]
            public static implicit operator JsonNode?(sbyte? value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Single" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Single" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode(float value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.Single" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Single" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode?(float? value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.String" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.String" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            public static implicit operator JsonNode?(string? value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.UInt16" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.UInt16" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            [CLSCompliant(false)]
            public static implicit operator JsonNode(ushort value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.UInt16" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.UInt16" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            [CLSCompliant(false)]
            public static implicit operator JsonNode?(ushort? value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.UInt32" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.UInt32" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            [CLSCompliant(false)]
            public static implicit operator JsonNode(uint value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.UInt32" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.UInt32" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            [CLSCompliant(false)]
            public static implicit operator JsonNode?(uint? value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.UInt64" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.UInt64" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            [CLSCompliant(false)]
            public static implicit operator JsonNode(ulong value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an implicit conversion of a given <see cref="T:System.UInt64" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.UInt64" /> to implicitly convert.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance converted from the <paramref name="value" /> parameter.</returns>
            [CLSCompliant(false)]
            public static implicit operator JsonNode?(ulong? value)
            {
                return JsonValue.Create(value);
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Boolean" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Boolean" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator bool(JsonNode value)
            {
                return value.GetValue<bool>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Boolean" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Boolean" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator bool?(JsonNode? value)
            {
                return value?.GetValue<bool>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Byte" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Byte" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator byte(JsonNode value)
            {
                return value.GetValue<byte>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Byte" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Byte" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator byte?(JsonNode? value)
            {
                return value?.GetValue<byte>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Char" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Char" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator char(JsonNode value)
            {
                return value.GetValue<char>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Char" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Char" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator char?(JsonNode? value)
            {
                return value?.GetValue<char>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.DateTime" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.DateTime" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator DateTime(JsonNode value)
            {
                return value.GetValue<DateTime>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.DateTime" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.DateTime" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator DateTime?(JsonNode? value)
            {
                return value?.GetValue<DateTime>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.DateTimeOffset" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.DateTimeOffset" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator DateTimeOffset(JsonNode value)
            {
                return value.GetValue<DateTimeOffset>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.DateTimeOffset" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.DateTimeOffset" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator DateTimeOffset?(JsonNode? value)
            {
                return value?.GetValue<DateTimeOffset>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Decimal" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Decimal" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator decimal(JsonNode value)
            {
                return value.GetValue<decimal>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Decimal" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Decimal" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator decimal?(JsonNode? value)
            {
                return value?.GetValue<decimal>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Double" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Double" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator double(JsonNode value)
            {
                return value.GetValue<double>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Double" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Double" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator double?(JsonNode? value)
            {
                return value?.GetValue<double>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Guid" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Guid" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator Guid(JsonNode value)
            {
                return value.GetValue<Guid>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Guid" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Guid" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator Guid?(JsonNode? value)
            {
                return value?.GetValue<Guid>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Int16" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Int16" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator short(JsonNode value)
            {
                return value.GetValue<short>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Int16" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Int16" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator short?(JsonNode? value)
            {
                return value?.GetValue<short>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Int32" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Int32" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator int(JsonNode value)
            {
                return value.GetValue<int>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Int32" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Int32" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator int?(JsonNode? value)
            {
                return value?.GetValue<int>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Int64" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Int64" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator long(JsonNode value)
            {
                return value.GetValue<long>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Int64" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Int64" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator long?(JsonNode? value)
            {
                return value?.GetValue<long>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.SByte" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.SByte" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            [CLSCompliant(false)]
            public static explicit operator sbyte(JsonNode value)
            {
                return value.GetValue<sbyte>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.SByte" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.SByte" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            [CLSCompliant(false)]
            public static explicit operator sbyte?(JsonNode? value)
            {
                return value?.GetValue<sbyte>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Single" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Single" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator float(JsonNode value)
            {
                return value.GetValue<float>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.Single" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.Single" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator float?(JsonNode? value)
            {
                return value?.GetValue<float>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.String" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.String" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            public static explicit operator string?(JsonNode? value)
            {
                return value?.GetValue<string>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.UInt16" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.UInt16" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            [CLSCompliant(false)]
            public static explicit operator ushort(JsonNode value)
            {
                return value.GetValue<ushort>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.UInt16" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.UInt16" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            [CLSCompliant(false)]
            public static explicit operator ushort?(JsonNode? value)
            {
                return value?.GetValue<ushort>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.UInt32" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.UInt32" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            [CLSCompliant(false)]
            public static explicit operator uint(JsonNode value)
            {
                return value.GetValue<uint>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.UInt32" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.UInt32" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            [CLSCompliant(false)]
            public static explicit operator uint?(JsonNode? value)
            {
                return value?.GetValue<uint>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.UInt64" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.UInt64" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            [CLSCompliant(false)]
            public static explicit operator ulong(JsonNode value)
            {
                return value.GetValue<ulong>();
            }

            /// <summary>
            ///   Defines an explicit conversion of a given <see cref="T:System.UInt64" /> to a <see cref="T:System.Text.Json.Nodes.JsonNode" />.
            /// </summary>
            /// <param name="value">A <see cref="T:System.UInt64" /> to explicitly convert.</param>
            /// <returns>A value converted from the <see cref="T:System.Text.Json.Nodes.JsonNode" /> instance.</returns>
            [CLSCompliant(false)]
            public static explicit operator ulong?(JsonNode? value)
            {
                return value?.GetValue<ulong>();
            }

            /// <summary>
            ///   Parses one JSON value (including objects or arrays) from the provided reader.
            /// </summary>
            /// <param name="reader">The reader to read.</param>
            /// <param name="nodeOptions">Options to control the behavior.</param>
            /// <returns>
            ///   The <see cref="T:System.Text.Json.Nodes.JsonNode" /> from the reader.
            /// </returns>
            /// <remarks>
            ///   <para>
            ///     If the <see cref="P:System.Text.Json.Utf8JsonReader.TokenType" /> property of <paramref name="reader" />
            ///     is <see cref="F:System.Text.Json.JsonTokenType.PropertyName" /> or <see cref="F:System.Text.Json.JsonTokenType.None" />, the
            ///     reader will be advanced by one call to <see cref="M:System.Text.Json.Utf8JsonReader.Read" /> to determine
            ///     the start of the value.
            ///   </para>
            ///   <para>
            ///     Upon completion of this method, <paramref name="reader" /> will be positioned at the
            ///     final token in the JSON value.  If an exception is thrown, the reader is reset to the state it was in when the method was called.
            ///   </para>
            ///   <para>
            ///     This method makes a copy of the data the reader acted on, so there is no caller
            ///     requirement to maintain data integrity beyond the return of this method.
            ///   </para>
            /// </remarks>
            /// <exception cref="T:System.ArgumentException">
            ///   <paramref name="reader" /> is using unsupported options.
            /// </exception>
            /// <exception cref="T:System.ArgumentException">
            ///   The current <paramref name="reader" /> token does not start or represent a value.
            /// </exception>
            /// <exception cref="T:System.Text.Json.JsonException">
            ///   A value could not be read from the reader.
            /// </exception>
            public static JsonNode? Parse(ref Utf8JsonReader reader, JsonNodeOptions? nodeOptions = null)
            {
                JsonElement element = JsonElement.ParseValue(ref reader);
                return JsonNodeConverter.Create(element, nodeOptions);
            }

            /// <summary>
            ///   Parses text representing a single JSON value.
            /// </summary>
            /// <param name="json">JSON text to parse.</param>
            /// <param name="nodeOptions">Options to control the node behavior after parsing.</param>
            /// <param name="documentOptions">Options to control the document behavior during parsing.</param>
            /// <returns>
            ///   A <see cref="T:System.Text.Json.Nodes.JsonNode" /> representation of the JSON value.
            /// </returns>
            /// <exception cref="T:System.ArgumentNullException">
            ///   <paramref name="json" /> is <see langword="null" />.
            /// </exception>
            /// <exception cref="T:System.Text.Json.JsonException">
            ///   <paramref name="json" /> does not represent a valid single JSON value.
            /// </exception>
            public static JsonNode? Parse([StringSyntax("Json")] string json, JsonNodeOptions? nodeOptions = null, JsonDocumentOptions documentOptions = default(JsonDocumentOptions))
            {
                if (json == null)
                {
                    ThrowHelper.ThrowArgumentNullException("json");
                }
                JsonElement element = JsonElement.ParseValue(json, documentOptions);
                return JsonNodeConverter.Create(element, nodeOptions);
            }

            /// <summary>
            ///   Parses text representing a single JSON value.
            /// </summary>
            /// <param name="utf8Json">JSON text to parse.</param>
            /// <param name="nodeOptions">Options to control the node behavior after parsing.</param>
            /// <param name="documentOptions">Options to control the document behavior during parsing.</param>
            /// <returns>
            ///   A <see cref="T:System.Text.Json.Nodes.JsonNode" /> representation of the JSON value.
            /// </returns>
            /// <exception cref="T:System.Text.Json.JsonException">
            ///   <paramref name="utf8Json" /> does not represent a valid single JSON value.
            /// </exception>
            public static JsonNode? Parse(ReadOnlySpan<byte> utf8Json, JsonNodeOptions? nodeOptions = null, JsonDocumentOptions documentOptions = default(JsonDocumentOptions))
            {
                JsonElement element = JsonElement.ParseValue(utf8Json, documentOptions);
                return JsonNodeConverter.Create(element, nodeOptions);
            }

            /// <summary>
            ///   Parse a <see cref="T:System.IO.Stream" /> as UTF-8-encoded data representing a single JSON value into a
            ///   <see cref="T:System.Text.Json.Nodes.JsonNode" />.  The Stream will be read to completion.
            /// </summary>
            /// <param name="utf8Json">JSON text to parse.</param>
            /// <param name="nodeOptions">Options to control the node behavior after parsing.</param>
            /// <param name="documentOptions">Options to control the document behavior during parsing.</param>
            /// <returns>
            ///   A <see cref="T:System.Text.Json.Nodes.JsonNode" /> representation of the JSON value.
            /// </returns>
            /// <exception cref="T:System.Text.Json.JsonException">
            ///   <paramref name="utf8Json" /> does not represent a valid single JSON value.
            /// </exception>
            public static JsonNode? Parse(Stream utf8Json, JsonNodeOptions? nodeOptions = null, JsonDocumentOptions documentOptions = default(JsonDocumentOptions))
            {
                if (utf8Json == null)
                {
                    ThrowHelper.ThrowArgumentNullException("utf8Json");
                }
                JsonElement element = JsonElement.ParseValue(utf8Json, documentOptions);
                return JsonNodeConverter.Create(element, nodeOptions);
            }

            /// <summary>
            ///   Converts the current instance to string in JSON format.
            /// </summary>
            /// <param name="options">Options to control the serialization behavior.</param>
            /// <returns>JSON representation of current instance.</returns>
            public string ToJsonString(JsonSerializerOptions? options = null)
            {
                using PooledByteBufferWriter pooledByteBufferWriter = new PooledByteBufferWriter(16384);
                using (Utf8JsonWriter writer = new Utf8JsonWriter(pooledByteBufferWriter, options?.GetWriterOptions() ?? default(JsonWriterOptions)))
                {
                    WriteTo(writer, options);
                }
                return JsonHelpers.Utf8GetString(pooledByteBufferWriter.WrittenMemory.ToArray());
            }

            /// <summary>
            ///   Gets a string representation for the current value appropriate to the node type.
            /// </summary>
            /// <returns>A string representation for the current value appropriate to the node type.</returns>
            public override string ToString()
            {
                if (this is JsonValue)
                {
                    if (this is JsonValue<string> jsonValue)
                    {
                        return jsonValue.Value;
                    }
                    if (this is JsonValue<JsonElement> jsonValue2 && jsonValue2.Value.ValueKind == JsonValueKind.String)
                    {
                        return jsonValue2.Value.GetString();
                    }
                }
                using PooledByteBufferWriter pooledByteBufferWriter = new PooledByteBufferWriter(16384);
                using (Utf8JsonWriter writer = new Utf8JsonWriter(pooledByteBufferWriter, new JsonWriterOptions
                {
                    Indented = true
                }))
                {
                    WriteTo(writer);
                }
                return JsonHelpers.Utf8GetString(pooledByteBufferWriter.WrittenMemory.ToArray());
            }

            /// <summary>
            ///   Write the <see cref="T:System.Text.Json.Nodes.JsonNode" /> into the provided <see cref="T:System.Text.Json.Utf8JsonWriter" /> as JSON.
            /// </summary>
            /// <param name="writer">The <see cref="T:System.Text.Json.Utf8JsonWriter" />.</param>
            /// <exception cref="T:System.ArgumentNullException">
            ///   The <paramref name="writer" /> parameter is <see langword="null" />.
            /// </exception>
            /// <param name="options">Options to control the serialization behavior.</param>
            public abstract void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions? options = null);
        }

        /// <summary>
        ///   Options to control <see cref="T:System.Text.Json.Nodes.JsonNode" /> behavior.
        /// </summary>
        public struct JsonNodeOptions
        {
            /// <summary>
            ///   Specifies whether property names on <see cref="T:System.Text.Json.Nodes.JsonObject" /> are case insensitive.
            /// </summary>
            public bool PropertyNameCaseInsensitive { get; set; }
        }

        /// <summary>
        ///   Represents a mutable JSON object.
        /// </summary>
        /// <remarks>
        /// It's safe to perform multiple concurrent read operations on a <see cref="T:System.Text.Json.Nodes.JsonObject" />,
        /// but issues can occur if the collection is modified while it's being read.
        /// </remarks>
        [DebuggerDisplay("JsonObject[{Count}]")]
        [DebuggerTypeProxy(typeof(DebugView))]
        public sealed class JsonObject : JsonNode, IDictionary<string, JsonNode?>, ICollection<KeyValuePair<string, JsonNode?>>, IEnumerable<KeyValuePair<string, JsonNode?>>, IEnumerable
        {
            [ExcludeFromCodeCoverage]
            private sealed class DebugView
            {
                [DebuggerDisplay("{Display,nq}")]
                private struct DebugViewProperty
                {
                    [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
                    public JsonNode Value;

                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    public string PropertyName;

                    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                    public string Display
                    {
                        get
                        {
                            if (Value == null)
                            {
                                return PropertyName + " = null";
                            }
                            if (Value is JsonValue)
                            {
                                return PropertyName + " = " + Value.ToJsonString();
                            }
                            if (Value is JsonObject jsonObject)
                            {
                                return $"{PropertyName} = JsonObject[{jsonObject.Count}]";
                            }
                            JsonArray jsonArray = (JsonArray)Value;
                            return $"{PropertyName} = JsonArray[{jsonArray.Count}]";
                        }
                    }
                }

                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private JsonObject _node;

                public string Json => _node.ToJsonString();

                public string Path => _node.GetPath();

                [DebuggerBrowsable(DebuggerBrowsableState.RootHidden)]
                private DebugViewProperty[] Items
                {
                    get
                    {
                        DebugViewProperty[] array = new DebugViewProperty[_node.Count];
                        int num = 0;
                        foreach (KeyValuePair<string, JsonNode> item in _node)
                        {
                            array[num].PropertyName = item.Key;
                            array[num].Value = item.Value;
                            num++;
                        }
                        return array;
                    }
                }

                public DebugView(JsonObject node)
                {
                    _node = node;
                }
            }

            private JsonElement? _jsonElement;

            private JsonPropertyDictionary<JsonNode> _dictionary;

            /// <summary>
            ///   Gets the number of elements contained in <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </summary>
            public int Count
            {
                get
                {
                    InitializeIfRequired();
                    return _dictionary.Count;
                }
            }

            /// <summary>
            ///   Gets a collection containing the property names in the <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </summary>
            ICollection<string> IDictionary<string, JsonNode>.Keys
            {
                get
                {
                    InitializeIfRequired();
                    return _dictionary.Keys;
                }
            }

            /// <summary>
            ///   Gets a collection containing the property values in the <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </summary>
            ICollection<JsonNode?> IDictionary<string, JsonNode>.Values
            {
                get
                {
                    InitializeIfRequired();
                    return _dictionary.Values;
                }
            }

            /// <summary>
            ///   Returns <see langword="false" />.
            /// </summary>
            bool ICollection<KeyValuePair<string, JsonNode>>.IsReadOnly => false;

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonObject" /> class that is empty.
            /// </summary>
            /// <param name="options">Options to control the behavior.</param>
            public JsonObject(JsonNodeOptions? options = null)
                : base(options)
            {
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonObject" /> class that contains the specified <paramref name="properties" />.
            /// </summary>
            /// <param name="properties">The properties to be added.</param>
            /// <param name="options">Options to control the behavior.</param>
            public JsonObject(IEnumerable<KeyValuePair<string, JsonNode?>> properties, JsonNodeOptions? options = null)
                : this(options)
            {
                foreach (KeyValuePair<string, JsonNode> property in properties)
                {
                    Add(property.Key, property.Value);
                }
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonObject" /> class that contains properties from the specified <see cref="T:System.Text.Json.JsonElement" />.
            /// </summary>
            /// <returns>
            ///   The new instance of the <see cref="T:System.Text.Json.Nodes.JsonObject" /> class that contains properties from the specified <see cref="T:System.Text.Json.JsonElement" />.
            /// </returns>
            /// <param name="element">The <see cref="T:System.Text.Json.JsonElement" />.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>A <see cref="T:System.Text.Json.Nodes.JsonObject" />.</returns>
            public static JsonObject? Create(JsonElement element, JsonNodeOptions? options = null)
            {
                if (element.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                if (element.ValueKind == JsonValueKind.Object)
                {
                    return new JsonObject(element, options);
                }
                throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.NodeElementWrongType, "Object"));
            }

            internal JsonObject(JsonElement element, JsonNodeOptions? options = null)
                : this(options)
            {
                _jsonElement = element;
            }

            /// <summary>
            ///   Returns the value of a property with the specified name.
            /// </summary>
            /// <param name="propertyName">The name of the property to return.</param>
            /// <param name="jsonNode">The JSON value of the property with the specified name.</param>
            /// <returns>
            ///   <see langword="true" /> if a property with the specified name was found; otherwise, <see langword="false" />.
            /// </returns>
            public bool TryGetPropertyValue(string propertyName, out JsonNode? jsonNode)
            {
                return ((IDictionary<string, JsonNode>)this).TryGetValue(propertyName, out jsonNode);
            }

            /// <inheritdoc />
            public override void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions? options = null)
            {
                if (writer == null)
                {
                    ThrowHelper.ThrowArgumentNullException("writer");
                }
                if (_jsonElement.HasValue)
                {
                    _jsonElement.Value.WriteTo(writer);
                    return;
                }
                if (options == null)
                {
                    options = JsonNode.s_defaultOptions;
                }
                writer.WriteStartObject();
                using (IEnumerator<KeyValuePair<string, JsonNode>> enumerator = GetEnumerator())
                {
                    while (enumerator.MoveNext())
                    {
                        KeyValuePair<string, JsonNode> current = enumerator.Current;
                        writer.WritePropertyName(current.Key);
                        JsonNodeConverter.Instance.Write(writer, current.Value, options);
                    }
                }
                writer.WriteEndObject();
            }

            internal JsonNode GetItem(string propertyName)
            {
                if (TryGetPropertyValue(propertyName, out JsonNode jsonNode))
                {
                    return jsonNode;
                }
                return null;
            }

            internal override void GetPath(List<string> path, JsonNode child)
            {
                if (child != null)
                {
                    InitializeIfRequired();
                    string key = _dictionary.FindValue(child).Value.Key;
                    if (key.IndexOfAny(ReadStack.SpecialCharacters) != -1)
                    {
                        path.Add("['" + key + "']");
                    }
                    else
                    {
                        path.Add("." + key);
                    }
                }
                base.Parent?.GetPath(path, this);
            }

            internal void SetItem(string propertyName, JsonNode value)
            {
                InitializeIfRequired();
                JsonNode item = _dictionary.SetValue(propertyName, value, delegate
                {
                    value?.AssignParent(this);
                });
                DetachParent(item);
            }

            private void DetachParent(JsonNode item)
            {
                InitializeIfRequired();
                if (item != null)
                {
                    item.Parent = null;
                }
            }

            /// <summary>
            ///   Adds an element with the provided property name and value to the <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </summary>
            /// <param name="propertyName">The property name of the element to add.</param>
            /// <param name="value">The value of the element to add.</param>
            /// <exception cref="T:System.ArgumentNullException">
            ///   <paramref name="propertyName" />is <see langword="null" />.
            /// </exception>
            /// <exception cref="T:System.ArgumentException">
            ///   An element with the same property name already exists in the <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </exception>
            public void Add(string propertyName, JsonNode? value)
            {
                InitializeIfRequired();
                _dictionary.Add(propertyName, value);
                value?.AssignParent(this);
            }

            /// <summary>
            ///   Adds the specified property to the <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </summary>
            /// <param name="property">
            ///   The KeyValuePair structure representing the property name and value to add to the <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </param>
            /// <exception cref="T:System.ArgumentException">
            ///   An element with the same property name already exists in the <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </exception>
            /// <exception cref="T:System.ArgumentNullException">
            ///   The property name of <paramref name="property" /> is <see langword="null" />.
            /// </exception>
            public void Add(KeyValuePair<string, JsonNode?> property)
            {
                Add(property.Key, property.Value);
            }

            /// <summary>
            ///   Removes all elements from the <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </summary>
            public void Clear()
            {
                if (_jsonElement.HasValue)
                {
                    _jsonElement = null;
                }
                else
                {
                    if (_dictionary == null)
                    {
                        return;
                    }
                    foreach (JsonNode item in _dictionary.GetValueCollection())
                    {
                        DetachParent(item);
                    }
                    _dictionary.Clear();
                }
            }

            /// <summary>
            ///   Determines whether the <see cref="T:System.Text.Json.Nodes.JsonObject" /> contains an element with the specified property name.
            /// </summary>
            /// <param name="propertyName">The property name to locate in the <see cref="T:System.Text.Json.Nodes.JsonObject" />.</param>
            /// <returns>
            ///   <see langword="true" /> if the <see cref="T:System.Text.Json.Nodes.JsonObject" /> contains an element with the specified property name; otherwise, <see langword="false" />.
            /// </returns>
            /// <exception cref="T:System.ArgumentNullException">
            ///   <paramref name="propertyName" /> is <see langword="null" />.
            /// </exception>
            public bool ContainsKey(string propertyName)
            {
                InitializeIfRequired();
                return _dictionary.ContainsKey(propertyName);
            }

            /// <summary>
            ///   Removes the element with the specified property name from the <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </summary>
            /// <param name="propertyName">The property name of the element to remove.</param>
            /// <returns>
            ///   <see langword="true" /> if the element is successfully removed; otherwise, <see langword="false" />.
            /// </returns>
            /// <exception cref="T:System.ArgumentNullException">
            ///   <paramref name="propertyName" /> is <see langword="null" />.
            /// </exception>
            public bool Remove(string propertyName)
            {
                if (propertyName == null)
                {
                    ThrowHelper.ThrowArgumentNullException("propertyName");
                }
                InitializeIfRequired();
                JsonNode existing;
                bool flag = _dictionary.TryRemoveProperty(propertyName, out existing);
                if (flag)
                {
                    DetachParent(existing);
                }
                return flag;
            }

            /// <summary>
            ///   Determines whether the <see cref="T:System.Text.Json.Nodes.JsonObject" /> contains a specific property name and <see cref="T:System.Text.Json.Nodes.JsonNode" /> reference.
            /// </summary>
            /// <param name="item">The element to locate in the <see cref="T:System.Text.Json.Nodes.JsonObject" />.</param>
            /// <returns>
            ///   <see langword="true" /> if the <see cref="T:System.Text.Json.Nodes.JsonObject" /> contains an element with the property name; otherwise, <see langword="false" />.
            /// </returns>
            bool ICollection<KeyValuePair<string, JsonNode>>.Contains(KeyValuePair<string, JsonNode> item)
            {
                InitializeIfRequired();
                return _dictionary.Contains(item);
            }

            /// <summary>
            ///   Copies the elements of the <see cref="T:System.Text.Json.Nodes.JsonObject" /> to an array of type KeyValuePair starting at the specified array index.
            /// </summary>
            /// <param name="array">
            ///   The one-dimensional Array that is the destination of the elements copied from <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </param>
            /// <param name="index">The zero-based index in <paramref name="array" /> at which copying begins.</param>
            /// <exception cref="T:System.ArgumentNullException">
            ///   <paramref name="array" /> is <see langword="null" />.
            /// </exception>
            /// <exception cref="T:System.ArgumentOutOfRangeException">
            ///   <paramref name="index" /> is less than 0.
            /// </exception>
            /// <exception cref="T:System.ArgumentException">
            ///   The number of elements in the source ICollection is greater than the available space from <paramref name="index" />
            ///   to the end of the destination <paramref name="array" />.
            /// </exception>
            void ICollection<KeyValuePair<string, JsonNode>>.CopyTo(KeyValuePair<string, JsonNode>[] array, int index)
            {
                InitializeIfRequired();
                _dictionary.CopyTo(array, index);
            }

            /// <summary>
            ///   Returns an enumerator that iterates through the <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </summary>
            /// <returns>
            ///   An enumerator that iterates through the <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </returns>
            public IEnumerator<KeyValuePair<string, JsonNode?>> GetEnumerator()
            {
                InitializeIfRequired();
                return _dictionary.GetEnumerator();
            }

            /// <summary>
            ///   Removes a key and value from the <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </summary>
            /// <param name="item">
            ///   The KeyValuePair structure representing the property name and value to remove from the <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </param>
            /// <returns>
            ///   <see langword="true" /> if the element is successfully removed; otherwise, <see langword="false" />.
            /// </returns>
            bool ICollection<KeyValuePair<string, JsonNode>>.Remove(KeyValuePair<string, JsonNode> item)
            {
                return Remove(item.Key);
            }

            /// <summary>
            ///   Gets the value associated with the specified property name.
            /// </summary>
            /// <param name="propertyName">The property name of the value to get.</param>
            /// <param name="jsonNode">
            ///   When this method returns, contains the value associated with the specified property name, if the property name is found;
            ///   otherwise, <see langword="null" />.
            /// </param>
            /// <returns>
            ///   <see langword="true" /> if the <see cref="T:System.Text.Json.Nodes.JsonObject" /> contains an element with the specified property name; otherwise, <see langword="false" />.
            /// </returns>
            /// <exception cref="T:System.ArgumentNullException">
            ///   <paramref name="propertyName" /> is <see langword="null" />.
            /// </exception>
            bool IDictionary<string, JsonNode>.TryGetValue(string propertyName, out JsonNode jsonNode)
            {
                InitializeIfRequired();
                return _dictionary.TryGetValue(propertyName, out jsonNode);
            }

            /// <summary>
            ///   Returns an enumerator that iterates through the <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </summary>
            /// <returns>
            ///   An enumerator that iterates through the <see cref="T:System.Text.Json.Nodes.JsonObject" />.
            /// </returns>
            IEnumerator IEnumerable.GetEnumerator()
            {
                InitializeIfRequired();
                return _dictionary.GetEnumerator();
            }

            private void InitializeIfRequired()
            {
                if (_dictionary != null)
                {
                    return;
                }
                bool caseInsensitive = base.Options.HasValue && base.Options.Value.PropertyNameCaseInsensitive;
                JsonPropertyDictionary<JsonNode> jsonPropertyDictionary = new JsonPropertyDictionary<JsonNode>(caseInsensitive);
                if (_jsonElement.HasValue)
                {
                    foreach (JsonProperty item in _jsonElement.Value.EnumerateObject())
                    {
                        JsonNode jsonNode = JsonNodeConverter.Create(item.Value, base.Options);
                        if (jsonNode != null)
                        {
                            jsonNode.Parent = this;
                        }
                        jsonPropertyDictionary.Add(new KeyValuePair<string, JsonNode>(item.Name, jsonNode));
                    }
                    _jsonElement = null;
                }
                _dictionary = jsonPropertyDictionary;
            }
        }

        /// <summary>
        /// Represents a mutable JSON value.
        /// </summary>
        public abstract class JsonValue : JsonNode
        {
            internal const string CreateUnreferencedCodeMessage = "Creating JsonValue instances with non-primitive types is not compatible with trimming. It can result in non-primitive types being serialized, which may have their members trimmed.";

            internal const string CreateDynamicCodeMessage = "Creating JsonValue instances with non-primitive types requires generating code at runtime.";

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue Create(bool value, JsonNodeOptions? options = null)
            {
                return new JsonValueTrimmable<bool>(value, JsonMetadataServices.BooleanConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue? Create(bool? value, JsonNodeOptions? options = null)
            {
                if (!value.HasValue)
                {
                    return null;
                }
                return new JsonValueTrimmable<bool>(value.Value, JsonMetadataServices.BooleanConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue Create(byte value, JsonNodeOptions? options = null)
            {
                return new JsonValueTrimmable<byte>(value, JsonMetadataServices.ByteConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue? Create(byte? value, JsonNodeOptions? options = null)
            {
                if (!value.HasValue)
                {
                    return null;
                }
                return new JsonValueTrimmable<byte>(value.Value, JsonMetadataServices.ByteConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue Create(char value, JsonNodeOptions? options = null)
            {
                return new JsonValueTrimmable<char>(value, JsonMetadataServices.CharConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue? Create(char? value, JsonNodeOptions? options = null)
            {
                if (!value.HasValue)
                {
                    return null;
                }
                return new JsonValueTrimmable<char>(value.Value, JsonMetadataServices.CharConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue Create(DateTime value, JsonNodeOptions? options = null)
            {
                return new JsonValueTrimmable<DateTime>(value, JsonMetadataServices.DateTimeConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue? Create(DateTime? value, JsonNodeOptions? options = null)
            {
                if (!value.HasValue)
                {
                    return null;
                }
                return new JsonValueTrimmable<DateTime>(value.Value, JsonMetadataServices.DateTimeConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue Create(DateTimeOffset value, JsonNodeOptions? options = null)
            {
                return new JsonValueTrimmable<DateTimeOffset>(value, JsonMetadataServices.DateTimeOffsetConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue? Create(DateTimeOffset? value, JsonNodeOptions? options = null)
            {
                if (!value.HasValue)
                {
                    return null;
                }
                return new JsonValueTrimmable<DateTimeOffset>(value.Value, JsonMetadataServices.DateTimeOffsetConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue Create(decimal value, JsonNodeOptions? options = null)
            {
                return new JsonValueTrimmable<decimal>(value, JsonMetadataServices.DecimalConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue? Create(decimal? value, JsonNodeOptions? options = null)
            {
                if (!value.HasValue)
                {
                    return null;
                }
                return new JsonValueTrimmable<decimal>(value.Value, JsonMetadataServices.DecimalConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue Create(double value, JsonNodeOptions? options = null)
            {
                return new JsonValueTrimmable<double>(value, JsonMetadataServices.DoubleConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue? Create(double? value, JsonNodeOptions? options = null)
            {
                if (!value.HasValue)
                {
                    return null;
                }
                return new JsonValueTrimmable<double>(value.Value, JsonMetadataServices.DoubleConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue Create(Guid value, JsonNodeOptions? options = null)
            {
                return new JsonValueTrimmable<Guid>(value, JsonMetadataServices.GuidConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue? Create(Guid? value, JsonNodeOptions? options = null)
            {
                if (!value.HasValue)
                {
                    return null;
                }
                return new JsonValueTrimmable<Guid>(value.Value, JsonMetadataServices.GuidConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue Create(short value, JsonNodeOptions? options = null)
            {
                return new JsonValueTrimmable<short>(value, JsonMetadataServices.Int16Converter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue? Create(short? value, JsonNodeOptions? options = null)
            {
                if (!value.HasValue)
                {
                    return null;
                }
                return new JsonValueTrimmable<short>(value.Value, JsonMetadataServices.Int16Converter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue Create(int value, JsonNodeOptions? options = null)
            {
                return new JsonValueTrimmable<int>(value, JsonMetadataServices.Int32Converter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue? Create(int? value, JsonNodeOptions? options = null)
            {
                if (!value.HasValue)
                {
                    return null;
                }
                return new JsonValueTrimmable<int>(value.Value, JsonMetadataServices.Int32Converter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue Create(long value, JsonNodeOptions? options = null)
            {
                return new JsonValueTrimmable<long>(value, JsonMetadataServices.Int64Converter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue? Create(long? value, JsonNodeOptions? options = null)
            {
                if (!value.HasValue)
                {
                    return null;
                }
                return new JsonValueTrimmable<long>(value.Value, JsonMetadataServices.Int64Converter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            [CLSCompliant(false)]
            public static JsonValue Create(sbyte value, JsonNodeOptions? options = null)
            {
                return new JsonValueTrimmable<sbyte>(value, JsonMetadataServices.SByteConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            [CLSCompliant(false)]
            public static JsonValue? Create(sbyte? value, JsonNodeOptions? options = null)
            {
                if (!value.HasValue)
                {
                    return null;
                }
                return new JsonValueTrimmable<sbyte>(value.Value, JsonMetadataServices.SByteConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue Create(float value, JsonNodeOptions? options = null)
            {
                return new JsonValueTrimmable<float>(value, JsonMetadataServices.SingleConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue? Create(float? value, JsonNodeOptions? options = null)
            {
                if (!value.HasValue)
                {
                    return null;
                }
                return new JsonValueTrimmable<float>(value.Value, JsonMetadataServices.SingleConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue? Create(string? value, JsonNodeOptions? options = null)
            {
                if (value == null)
                {
                    return null;
                }
                return new JsonValueTrimmable<string>(value, JsonMetadataServices.StringConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            [CLSCompliant(false)]
            public static JsonValue Create(ushort value, JsonNodeOptions? options = null)
            {
                return new JsonValueTrimmable<ushort>(value, JsonMetadataServices.UInt16Converter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            [CLSCompliant(false)]
            public static JsonValue? Create(ushort? value, JsonNodeOptions? options = null)
            {
                if (!value.HasValue)
                {
                    return null;
                }
                return new JsonValueTrimmable<ushort>(value.Value, JsonMetadataServices.UInt16Converter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            [CLSCompliant(false)]
            public static JsonValue Create(uint value, JsonNodeOptions? options = null)
            {
                return new JsonValueTrimmable<uint>(value, JsonMetadataServices.UInt32Converter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            [CLSCompliant(false)]
            public static JsonValue? Create(uint? value, JsonNodeOptions? options = null)
            {
                if (!value.HasValue)
                {
                    return null;
                }
                return new JsonValueTrimmable<uint>(value.Value, JsonMetadataServices.UInt32Converter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            [CLSCompliant(false)]
            public static JsonValue Create(ulong value, JsonNodeOptions? options = null)
            {
                return new JsonValueTrimmable<ulong>(value, JsonMetadataServices.UInt64Converter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            [CLSCompliant(false)]
            public static JsonValue? Create(ulong? value, JsonNodeOptions? options = null)
            {
                if (!value.HasValue)
                {
                    return null;
                }
                return new JsonValueTrimmable<ulong>(value.Value, JsonMetadataServices.UInt64Converter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue? Create(JsonElement value, JsonNodeOptions? options = null)
            {
                if (value.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                VerifyJsonElementIsNotArrayOrObject(ref value);
                return new JsonValueTrimmable<JsonElement>(value, JsonMetadataServices.JsonElementConverter);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <param name="value">The underlying value of the new <see cref="T:System.Text.Json.Nodes.JsonValue" /> instance.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue? Create(JsonElement? value, JsonNodeOptions? options = null)
            {
                if (!value.HasValue)
                {
                    return null;
                }
                JsonElement element = value.Value;
                if (element.ValueKind == JsonValueKind.Null)
                {
                    return null;
                }
                VerifyJsonElementIsNotArrayOrObject(ref element);
                return new JsonValueTrimmable<JsonElement>(element, JsonMetadataServices.JsonElementConverter);
            }

            private protected JsonValue(JsonNodeOptions? options = null)
                : base(options)
            {
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <returns>
            ///   The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </returns>
            /// <typeparam name="T">The type of value to create.</typeparam>
            /// <param name="value">The value to create.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            [RequiresUnreferencedCode("Creating JsonValue instances with non-primitive types is not compatible with trimming. It can result in non-primitive types being serialized, which may have their members trimmed. Use the overload that takes a JsonTypeInfo, or make sure all of the required types are preserved.")]
            [RequiresDynamicCode("Creating JsonValue instances with non-primitive types requires generating code at runtime.")]
            public static JsonValue? Create<T>(T? value, JsonNodeOptions? options = null)
            {
                if (value == null)
                {
                    return null;
                }
                if (value is JsonElement)
                {
                    object obj = value;
                    JsonElement element = (JsonElement)((obj is JsonElement) ? obj : null);
                    if (element.ValueKind == JsonValueKind.Null)
                    {
                        return null;
                    }
                    VerifyJsonElementIsNotArrayOrObject(ref element);
                    return new JsonValueTrimmable<JsonElement>(element, JsonMetadataServices.JsonElementConverter, options);
                }
                return new JsonValueNotTrimmable<T>(value, options);
            }

            /// <summary>
            ///   Initializes a new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </summary>
            /// <returns>
            ///   The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.
            /// </returns>
            /// <typeparam name="T">The type of value to create.</typeparam>
            /// <param name="value">The value to create.</param>
            /// <param name="jsonTypeInfo">The <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> that will be used to serialize the value.</param>
            /// <param name="options">Options to control the behavior.</param>
            /// <returns>The new instance of the <see cref="T:System.Text.Json.Nodes.JsonValue" /> class that contains the specified value.</returns>
            public static JsonValue? Create<T>(T? value, JsonTypeInfo<T> jsonTypeInfo, JsonNodeOptions? options = null)
            {
                if (jsonTypeInfo == null)
                {
                    ThrowHelper.ThrowArgumentNullException("jsonTypeInfo");
                }
                if (value == null)
                {
                    return null;
                }
                if (value is JsonElement)
                {
                    object obj = value;
                    JsonElement element = (JsonElement)((obj is JsonElement) ? obj : null);
                    if (element.ValueKind == JsonValueKind.Null)
                    {
                        return null;
                    }
                    VerifyJsonElementIsNotArrayOrObject(ref element);
                }
                return new JsonValueTrimmable<T>(value, jsonTypeInfo, options);
            }

            internal override void GetPath(List<string> path, JsonNode child)
            {
                base.Parent?.GetPath(path, this);
            }

            /// <summary>
            ///   Tries to obtain the current JSON value and returns a value that indicates whether the operation succeeded.
            /// </summary>
            /// <remarks>
            ///   {T} can be the type or base type of the underlying value.
            ///   If the underlying value is a <see cref="T:System.Text.Json.JsonElement" /> then {T} can also be the type of any primitive
            ///   value supported by current <see cref="T:System.Text.Json.JsonElement" />.
            ///   Specifying the <see cref="T:System.Object" /> type for {T} will always succeed and return the underlying value as <see cref="T:System.Object" />.<br />
            ///   The underlying value of a <see cref="T:System.Text.Json.Nodes.JsonValue" /> after deserialization is an instance of <see cref="T:System.Text.Json.JsonElement" />,
            ///   otherwise it's the value specified when the <see cref="T:System.Text.Json.Nodes.JsonValue" /> was created.
            /// </remarks>
            /// <seealso cref="M:System.Text.Json.Nodes.JsonNode.GetValue``1"></seealso>
            /// <typeparam name="T">The type of value to obtain.</typeparam>
            /// <param name="value">When this method returns, contains the parsed value.</param>
            /// <returns><see langword="true" /> if the value can be successfully obtained; otherwise, <see langword="false" />.</returns>
            public abstract bool TryGetValue<T>([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out T? value);

            private static void VerifyJsonElementIsNotArrayOrObject(ref JsonElement element)
            {
                if (element.ValueKind == JsonValueKind.Object || element.ValueKind == JsonValueKind.Array)
                {
                    throw new InvalidOperationException(MDCFR.Properties.Resources.NodeElementCannotBeObjectOrArray);
                }
            }
        }
        
        [DebuggerDisplay("{ToJsonString(),nq}")]
        [DebuggerTypeProxy(typeof(JsonValue<>.DebugView))]
        internal abstract class JsonValue<TValue> : JsonValue
        {
            [ExcludeFromCodeCoverage]
            [DebuggerDisplay("{Json,nq}")]
            private sealed class DebugView
            {
                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                public JsonValue<TValue> _node;

                public string Json => _node.ToJsonString();

                public string Path => _node.GetPath();

                public TValue Value => _node.Value;

                public DebugView(JsonValue<TValue> node)
                {
                    _node = node;
                }
            }

            public readonly TValue _value;

            public TValue Value => _value;

            public JsonValue(TValue value, JsonNodeOptions? options = null)
                : base(options)
            {
                if (value is JsonNode)
                {
                    ThrowHelper.ThrowArgumentException_NodeValueNotAllowed("value");
                }
                _value = value;
            }

            public override T GetValue<T>()
            {
                TValue value = _value;
                if (value is T)
                {
                    object obj = value;
                    return (T)((obj is T) ? obj : null);
                }
                if (_value is JsonElement)
                {
                    return ConvertJsonElement<T>();
                }
                string nodeUnableToConvert = MDCFR.Properties.Resources.NodeUnableToConvert;
                value = _value;
                throw new InvalidOperationException(System.SR.Format(nodeUnableToConvert, value.GetType(), typeof(T)));
            }

            public override bool TryGetValue<T>([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out T value)
            {
                TValue value2 = _value;
                if (value2 is T)
                {
                    object obj = value2;
                    T val = (T)((obj is T) ? obj : null);
                    value = val;
                    return true;
                }
                if (_value is JsonElement)
                {
                    return TryConvertJsonElement<T>(out value);
                }
                value = default(T);
                return false;
            }

            internal TypeToConvert ConvertJsonElement<TypeToConvert>()
            {
                JsonElement jsonElement = (JsonElement)(object)_value;
                switch (jsonElement.ValueKind)
                {
                    case JsonValueKind.Number:
                        if (typeof(TypeToConvert) == typeof(int) || typeof(TypeToConvert) == typeof(int?))
                        {
                            return (TypeToConvert)(object)jsonElement.GetInt32();
                        }
                        if (typeof(TypeToConvert) == typeof(long) || typeof(TypeToConvert) == typeof(long?))
                        {
                            return (TypeToConvert)(object)jsonElement.GetInt64();
                        }
                        if (typeof(TypeToConvert) == typeof(double) || typeof(TypeToConvert) == typeof(double?))
                        {
                            return (TypeToConvert)(object)jsonElement.GetDouble();
                        }
                        if (typeof(TypeToConvert) == typeof(short) || typeof(TypeToConvert) == typeof(short?))
                        {
                            return (TypeToConvert)(object)jsonElement.GetInt16();
                        }
                        if (typeof(TypeToConvert) == typeof(decimal) || typeof(TypeToConvert) == typeof(decimal?))
                        {
                            return (TypeToConvert)(object)jsonElement.GetDecimal();
                        }
                        if (typeof(TypeToConvert) == typeof(byte) || typeof(TypeToConvert) == typeof(byte?))
                        {
                            return (TypeToConvert)(object)jsonElement.GetByte();
                        }
                        if (typeof(TypeToConvert) == typeof(float) || typeof(TypeToConvert) == typeof(float?))
                        {
                            return (TypeToConvert)(object)jsonElement.GetSingle();
                        }
                        if (typeof(TypeToConvert) == typeof(uint) || typeof(TypeToConvert) == typeof(uint?))
                        {
                            return (TypeToConvert)(object)jsonElement.GetUInt32();
                        }
                        if (typeof(TypeToConvert) == typeof(ushort) || typeof(TypeToConvert) == typeof(ushort?))
                        {
                            return (TypeToConvert)(object)jsonElement.GetUInt16();
                        }
                        if (typeof(TypeToConvert) == typeof(ulong) || typeof(TypeToConvert) == typeof(ulong?))
                        {
                            return (TypeToConvert)(object)jsonElement.GetUInt64();
                        }
                        if (typeof(TypeToConvert) == typeof(sbyte) || typeof(TypeToConvert) == typeof(sbyte?))
                        {
                            return (TypeToConvert)(object)jsonElement.GetSByte();
                        }
                        break;
                    case JsonValueKind.String:
                        if (typeof(TypeToConvert) == typeof(string))
                        {
                            return (TypeToConvert)(object)jsonElement.GetString();
                        }
                        if (typeof(TypeToConvert) == typeof(DateTime) || typeof(TypeToConvert) == typeof(DateTime?))
                        {
                            return (TypeToConvert)(object)jsonElement.GetDateTime();
                        }
                        if (typeof(TypeToConvert) == typeof(DateTimeOffset) || typeof(TypeToConvert) == typeof(DateTimeOffset?))
                        {
                            return (TypeToConvert)(object)jsonElement.GetDateTimeOffset();
                        }
                        if (typeof(TypeToConvert) == typeof(Guid) || typeof(TypeToConvert) == typeof(Guid?))
                        {
                            return (TypeToConvert)(object)jsonElement.GetGuid();
                        }
                        if (typeof(TypeToConvert) == typeof(char) || typeof(TypeToConvert) == typeof(char?))
                        {
                            string @string = jsonElement.GetString();
                            if (@string.Length == 1)
                            {
                                return (TypeToConvert)(object)@string[0];
                            }
                        }
                        break;
                    case JsonValueKind.True:
                    case JsonValueKind.False:
                        if (typeof(TypeToConvert) == typeof(bool) || typeof(TypeToConvert) == typeof(bool?))
                        {
                            return (TypeToConvert)(object)jsonElement.GetBoolean();
                        }
                        break;
                }
                throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.NodeUnableToConvertElement, jsonElement.ValueKind, typeof(TypeToConvert)));
            }

            internal bool TryConvertJsonElement<TypeToConvert>([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out TypeToConvert result)
            {
                JsonElement jsonElement = (JsonElement)(object)_value;
                switch (jsonElement.ValueKind)
                {
                    case JsonValueKind.Number:
                        if (typeof(TypeToConvert) == typeof(int) || typeof(TypeToConvert) == typeof(int?))
                        {
                            int value;
                            bool result2 = jsonElement.TryGetInt32(out value);
                            result = (TypeToConvert)(object)value;
                            return result2;
                        }
                        if (typeof(TypeToConvert) == typeof(long) || typeof(TypeToConvert) == typeof(long?))
                        {
                            long value2;
                            bool result2 = jsonElement.TryGetInt64(out value2);
                            result = (TypeToConvert)(object)value2;
                            return result2;
                        }
                        if (typeof(TypeToConvert) == typeof(double) || typeof(TypeToConvert) == typeof(double?))
                        {
                            double value3;
                            bool result2 = jsonElement.TryGetDouble(out value3);
                            result = (TypeToConvert)(object)value3;
                            return result2;
                        }
                        if (typeof(TypeToConvert) == typeof(short) || typeof(TypeToConvert) == typeof(short?))
                        {
                            short value4;
                            bool result2 = jsonElement.TryGetInt16(out value4);
                            result = (TypeToConvert)(object)value4;
                            return result2;
                        }
                        if (typeof(TypeToConvert) == typeof(decimal) || typeof(TypeToConvert) == typeof(decimal?))
                        {
                            decimal value5;
                            bool result2 = jsonElement.TryGetDecimal(out value5);
                            result = (TypeToConvert)(object)value5;
                            return result2;
                        }
                        if (typeof(TypeToConvert) == typeof(byte) || typeof(TypeToConvert) == typeof(byte?))
                        {
                            byte value6;
                            bool result2 = jsonElement.TryGetByte(out value6);
                            result = (TypeToConvert)(object)value6;
                            return result2;
                        }
                        if (typeof(TypeToConvert) == typeof(float) || typeof(TypeToConvert) == typeof(float?))
                        {
                            float value7;
                            bool result2 = jsonElement.TryGetSingle(out value7);
                            result = (TypeToConvert)(object)value7;
                            return result2;
                        }
                        if (typeof(TypeToConvert) == typeof(uint) || typeof(TypeToConvert) == typeof(uint?))
                        {
                            uint value8;
                            bool result2 = jsonElement.TryGetUInt32(out value8);
                            result = (TypeToConvert)(object)value8;
                            return result2;
                        }
                        if (typeof(TypeToConvert) == typeof(ushort) || typeof(TypeToConvert) == typeof(ushort?))
                        {
                            ushort value9;
                            bool result2 = jsonElement.TryGetUInt16(out value9);
                            result = (TypeToConvert)(object)value9;
                            return result2;
                        }
                        if (typeof(TypeToConvert) == typeof(ulong) || typeof(TypeToConvert) == typeof(ulong?))
                        {
                            ulong value10;
                            bool result2 = jsonElement.TryGetUInt64(out value10);
                            result = (TypeToConvert)(object)value10;
                            return result2;
                        }
                        if (typeof(TypeToConvert) == typeof(sbyte) || typeof(TypeToConvert) == typeof(sbyte?))
                        {
                            sbyte value11;
                            bool result2 = jsonElement.TryGetSByte(out value11);
                            result = (TypeToConvert)(object)value11;
                            return result2;
                        }
                        break;
                    case JsonValueKind.String:
                        if (typeof(TypeToConvert) == typeof(string))
                        {
                            string @string = jsonElement.GetString();
                            result = (TypeToConvert)(object)@string;
                            return true;
                        }
                        if (typeof(TypeToConvert) == typeof(DateTime) || typeof(TypeToConvert) == typeof(DateTime?))
                        {
                            DateTime value12;
                            bool result2 = jsonElement.TryGetDateTime(out value12);
                            result = (TypeToConvert)(object)value12;
                            return result2;
                        }
                        if (typeof(TypeToConvert) == typeof(DateTimeOffset) || typeof(TypeToConvert) == typeof(DateTimeOffset?))
                        {
                            DateTimeOffset value13;
                            bool result2 = jsonElement.TryGetDateTimeOffset(out value13);
                            result = (TypeToConvert)(object)value13;
                            return result2;
                        }
                        if (typeof(TypeToConvert) == typeof(Guid) || typeof(TypeToConvert) == typeof(Guid?))
                        {
                            Guid value14;
                            bool result2 = jsonElement.TryGetGuid(out value14);
                            result = (TypeToConvert)(object)value14;
                            return result2;
                        }
                        if (typeof(TypeToConvert) == typeof(char) || typeof(TypeToConvert) == typeof(char?))
                        {
                            string string2 = jsonElement.GetString();
                            if (string2.Length == 1)
                            {
                                result = (TypeToConvert)(object)string2[0];
                                return true;
                            }
                        }
                        break;
                    case JsonValueKind.True:
                    case JsonValueKind.False:
                        if (typeof(TypeToConvert) == typeof(bool) || typeof(TypeToConvert) == typeof(bool?))
                        {
                            result = (TypeToConvert)(object)jsonElement.GetBoolean();
                            return true;
                        }
                        break;
                }
                result = default(TypeToConvert);
                return false;
            }
        }

        /// <summary>
        /// Not trim-safe since it calls JsonSerializer.Serialize(JsonSerializerOptions).
        /// </summary>
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        internal sealed class JsonValueNotTrimmable<TValue> : JsonValue<TValue>
        {
            [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
            public JsonValueNotTrimmable(TValue value, JsonNodeOptions? options = null)
                : base(value, options)
            {
            }

            [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "The ctor is marked RequiresUnreferencedCode.")]
            public override void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options = null)
            {
                if (writer == null)
                {
                    ThrowHelper.ThrowArgumentNullException("writer");
                }
                JsonSerializer.Serialize(writer, _value, options);
            }
        }

        /// <summary>
        /// Trim-safe since it either calls the converter directly or calls the JsonSerializer.Serialize(JsonTypeInfo{TValue}).
        /// </summary>
        internal sealed class JsonValueTrimmable<TValue> : JsonValue<TValue>
        {
            private readonly JsonTypeInfo<TValue> _jsonTypeInfo;

            private readonly JsonConverter<TValue> _converter;

            public JsonValueTrimmable(TValue value, JsonTypeInfo<TValue> jsonTypeInfo, JsonNodeOptions? options = null)
                : base(value, options)
            {
                _jsonTypeInfo = jsonTypeInfo;
            }

            public JsonValueTrimmable(TValue value, JsonConverter<TValue> converter, JsonNodeOptions? options = null)
                : base(value, options)
            {
                _converter = converter;
            }

            public override void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options = null)
            {
                if (writer == null)
                {
                    ThrowHelper.ThrowArgumentNullException("writer");
                }
                if (_converter != null)
                {
                    if (options == null)
                    {
                        options = JsonNode.s_defaultOptions;
                    }
                    if (_converter.IsInternalConverterForNumberType)
                    {
                        _converter.WriteNumberWithCustomHandling(writer, _value, options.NumberHandling);
                    }
                    else
                    {
                        _converter.Write(writer, _value, options);
                    }
                }
                else
                {
                    JsonSerializer.Serialize(writer, _value, _jsonTypeInfo);
                }
            }
        }

    }

    namespace Reflection
    {
        using System.Runtime.ExceptionServices;
        using System.Text.Json.Serialization;

        internal static class ReflectionExtensions
        {
            private const string ImmutableArrayGenericTypeName = "System.Collections.Immutable.ImmutableArray`1";

            private const string ImmutableListGenericTypeName = "System.Collections.Immutable.ImmutableList`1";

            private const string ImmutableListGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableList`1";

            private const string ImmutableStackGenericTypeName = "System.Collections.Immutable.ImmutableStack`1";

            private const string ImmutableStackGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableStack`1";

            private const string ImmutableQueueGenericTypeName = "System.Collections.Immutable.ImmutableQueue`1";

            private const string ImmutableQueueGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableQueue`1";

            private const string ImmutableSortedSetGenericTypeName = "System.Collections.Immutable.ImmutableSortedSet`1";

            private const string ImmutableHashSetGenericTypeName = "System.Collections.Immutable.ImmutableHashSet`1";

            private const string ImmutableSetGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableSet`1";

            private const string ImmutableDictionaryGenericTypeName = "System.Collections.Immutable.ImmutableDictionary`2";

            private const string ImmutableDictionaryGenericInterfaceTypeName = "System.Collections.Immutable.IImmutableDictionary`2";

            private const string ImmutableSortedDictionaryGenericTypeName = "System.Collections.Immutable.ImmutableSortedDictionary`2";

            private const string ImmutableArrayTypeName = "System.Collections.Immutable.ImmutableArray";

            private const string ImmutableListTypeName = "System.Collections.Immutable.ImmutableList";

            private const string ImmutableStackTypeName = "System.Collections.Immutable.ImmutableStack";

            private const string ImmutableQueueTypeName = "System.Collections.Immutable.ImmutableQueue";

            private const string ImmutableSortedSetTypeName = "System.Collections.Immutable.ImmutableSortedSet";

            private const string ImmutableHashSetTypeName = "System.Collections.Immutable.ImmutableHashSet";

            private const string ImmutableDictionaryTypeName = "System.Collections.Immutable.ImmutableDictionary";

            private const string ImmutableSortedDictionaryTypeName = "System.Collections.Immutable.ImmutableSortedDictionary";

            public const string CreateRangeMethodName = "CreateRange";

            private static readonly Type s_nullableType = typeof(Nullable<>);

            public static Type GetCompatibleGenericBaseClass(this Type type, Type baseType, bool sourceGenType = false)
            {
                Type type2 = type;
                while (type2 != null && type2 != typeof(object))
                {
                    if (type2.IsGenericType)
                    {
                        Type genericTypeDefinition = type2.GetGenericTypeDefinition();
                        if (genericTypeDefinition == baseType || (sourceGenType && OpenGenericTypesHaveSamePrefix(baseType, genericTypeDefinition)))
                        {
                            return type2;
                        }
                    }
                    type2 = type2.BaseType;
                }
                return null;
            }

            [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern", Justification = "The 'interfaceType' must exist and so trimmer kept it. In which case It also kept it on any type which implements it. The below call to GetInterfaces may return fewer results when trimmed but it will return the 'interfaceType' if the type implemented it, even after trimming.")]
            public static Type GetCompatibleGenericInterface(this Type type, Type interfaceType)
            {
                if ((object)interfaceType == null)
                {
                    return null;
                }
                Type type2 = type;
                if (type2.IsGenericType)
                {
                    type2 = type2.GetGenericTypeDefinition();
                }
                if (type2 == interfaceType)
                {
                    return type;
                }
                Type[] interfaces = type.GetInterfaces();
                foreach (Type type3 in interfaces)
                {
                    if (type3.IsGenericType)
                    {
                        Type genericTypeDefinition = type3.GetGenericTypeDefinition();
                        if (genericTypeDefinition == interfaceType)
                        {
                            return type3;
                        }
                    }
                }
                return null;
            }

            public static bool IsImmutableDictionaryType(this Type type, bool sourceGenType = false)
            {
                if (!type.IsGenericType || !type.Assembly.FullName.StartsWith("System.Collections.Immutable", StringComparison.Ordinal))
                {
                    return false;
                }
                switch (GetBaseNameFromGenericType(type, sourceGenType))
                {
                    case "System.Collections.Immutable.ImmutableDictionary`2":
                    case "System.Collections.Immutable.IImmutableDictionary`2":
                    case "System.Collections.Immutable.ImmutableSortedDictionary`2":
                        return true;
                    default:
                        return false;
                }
            }

            public static bool IsImmutableEnumerableType(this Type type, bool sourceGenType = false)
            {
                if (!type.IsGenericType || !type.Assembly.FullName.StartsWith("System.Collections.Immutable", StringComparison.Ordinal))
                {
                    return false;
                }
                switch (GetBaseNameFromGenericType(type, sourceGenType))
                {
                    case "System.Collections.Immutable.ImmutableArray`1":
                    case "System.Collections.Immutable.ImmutableList`1":
                    case "System.Collections.Immutable.IImmutableList`1":
                    case "System.Collections.Immutable.ImmutableStack`1":
                    case "System.Collections.Immutable.IImmutableStack`1":
                    case "System.Collections.Immutable.ImmutableQueue`1":
                    case "System.Collections.Immutable.IImmutableQueue`1":
                    case "System.Collections.Immutable.ImmutableSortedSet`1":
                    case "System.Collections.Immutable.ImmutableHashSet`1":
                    case "System.Collections.Immutable.IImmutableSet`1":
                        return true;
                    default:
                        return false;
                }
            }

            public static string GetImmutableDictionaryConstructingTypeName(this Type type, bool sourceGenType = false)
            {
                switch (GetBaseNameFromGenericType(type, sourceGenType))
                {
                    case "System.Collections.Immutable.ImmutableDictionary`2":
                    case "System.Collections.Immutable.IImmutableDictionary`2":
                        return "System.Collections.Immutable.ImmutableDictionary";
                    case "System.Collections.Immutable.ImmutableSortedDictionary`2":
                        return "System.Collections.Immutable.ImmutableSortedDictionary";
                    default:
                        return null;
                }
            }

            public static string GetImmutableEnumerableConstructingTypeName(this Type type, bool sourceGenType = false)
            {
                switch (GetBaseNameFromGenericType(type, sourceGenType))
                {
                    case "System.Collections.Immutable.ImmutableArray`1":
                        return "System.Collections.Immutable.ImmutableArray";
                    case "System.Collections.Immutable.ImmutableList`1":
                    case "System.Collections.Immutable.IImmutableList`1":
                        return "System.Collections.Immutable.ImmutableList";
                    case "System.Collections.Immutable.ImmutableStack`1":
                    case "System.Collections.Immutable.IImmutableStack`1":
                        return "System.Collections.Immutable.ImmutableStack";
                    case "System.Collections.Immutable.ImmutableQueue`1":
                    case "System.Collections.Immutable.IImmutableQueue`1":
                        return "System.Collections.Immutable.ImmutableQueue";
                    case "System.Collections.Immutable.ImmutableSortedSet`1":
                        return "System.Collections.Immutable.ImmutableSortedSet";
                    case "System.Collections.Immutable.ImmutableHashSet`1":
                    case "System.Collections.Immutable.IImmutableSet`1":
                        return "System.Collections.Immutable.ImmutableHashSet";
                    default:
                        return null;
                }
            }

            private static bool OpenGenericTypesHaveSamePrefix(Type t1, Type t2)
            {
                return t1.FullName == GetBaseNameFromGenericTypeDef(t2);
            }

            private static string GetBaseNameFromGenericType(Type genericType, bool sourceGenType)
            {
                Type genericTypeDefinition = genericType.GetGenericTypeDefinition();
                if (!sourceGenType)
                {
                    return genericTypeDefinition.FullName;
                }
                return GetBaseNameFromGenericTypeDef(genericTypeDefinition);
            }

            private static string GetBaseNameFromGenericTypeDef(Type genericTypeDef)
            {
                string fullName = genericTypeDef.FullName;
                int length = fullName.IndexOf("`") + 2;
                return fullName.Substring(0, length);
            }

            public static bool IsVirtual(this PropertyInfo propertyInfo)
            {
                if (propertyInfo != null)
                {
                    MethodInfo getMethod = propertyInfo.GetMethod;
                    if ((object)getMethod == null || !getMethod.IsVirtual)
                    {
                        return propertyInfo.SetMethod?.IsVirtual ?? false;
                    }
                    return true;
                }
                return false;
            }

            public static bool IsKeyValuePair(this Type type, Type keyValuePairType = null)
            {
                if (!type.IsGenericType)
                {
                    return false;
                }
                if ((object)keyValuePairType == null)
                {
                    keyValuePairType = typeof(KeyValuePair<,>);
                }
                Type genericTypeDefinition = type.GetGenericTypeDefinition();
                return genericTypeDefinition == keyValuePairType;
            }

            public static bool TryGetDeserializationConstructor([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors | DynamicallyAccessedMemberTypes.NonPublicConstructors)] this Type type, bool useDefaultCtorInAnnotatedStructs, out ConstructorInfo deserializationCtor)
            {
                ConstructorInfo constructorInfo = null;
                ConstructorInfo constructorInfo2 = null;
                ConstructorInfo constructorInfo3 = null;
                ConstructorInfo[] constructors = type.GetConstructors(BindingFlags.Instance | BindingFlags.Public);
                if (constructors.Length == 1)
                {
                    constructorInfo3 = constructors[0];
                }
                ConstructorInfo[] array = constructors;
                foreach (ConstructorInfo constructorInfo4 in array)
                {
                    if (HasJsonConstructorAttribute(constructorInfo4))
                    {
                        if (constructorInfo != null)
                        {
                            deserializationCtor = null;
                            return false;
                        }
                        constructorInfo = constructorInfo4;
                    }
                    else if (constructorInfo4.GetParameters().Length == 0)
                    {
                        constructorInfo2 = constructorInfo4;
                    }
                }
                ConstructorInfo constructorInfo5 = constructorInfo;
                constructors = type.GetConstructors(BindingFlags.Instance | BindingFlags.NonPublic);
                ConstructorInfo[] array2 = constructors;
                foreach (ConstructorInfo constructorInfo6 in array2)
                {
                    if (HasJsonConstructorAttribute(constructorInfo6))
                    {
                        if (constructorInfo5 != null)
                        {
                            deserializationCtor = null;
                            return false;
                        }
                        constructorInfo5 = constructorInfo6;
                    }
                }
                if (useDefaultCtorInAnnotatedStructs && type.IsValueType && constructorInfo == null)
                {
                    deserializationCtor = null;
                    return true;
                }
                deserializationCtor = constructorInfo ?? constructorInfo2 ?? constructorInfo3;
                return true;
            }

            public static object GetDefaultValue(this ParameterInfo parameterInfo)
            {
                object defaultValue = parameterInfo.DefaultValue;
                if (defaultValue == DBNull.Value && parameterInfo.ParameterType != typeof(DBNull))
                {
                    return null;
                }
                return defaultValue;
            }

            /// <summary>
            /// Returns <see langword="true" /> when the given type is of type <see cref="T:System.Nullable`1" />.
            /// </summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            public static bool IsNullableOfT(this Type type)
            {
                if (type.IsGenericType)
                {
                    return type.GetGenericTypeDefinition() == s_nullableType;
                }
                return false;
            }

            /// <summary>
            /// Returns <see langword="true" /> when the given type is assignable from <paramref name="from" /> including support
            /// when <paramref name="from" /> is <see cref="T:System.Nullable`1" /> by using the {T} generic parameter for <paramref name="from" />.
            /// </summary>
            public static bool IsAssignableFromInternal(this Type type, Type from)
            {
                if (from.IsNullableOfT() && type.IsInterface)
                {
                    return type.IsAssignableFrom(from.GetGenericArguments()[0]);
                }
                return type.IsAssignableFrom(from);
            }

            /// <summary>
            /// Returns <see langword="true" /> when either type is assignable to the other.
            /// </summary>
            public static bool IsInSubtypeRelationshipWith(this Type type, Type other)
            {
                if (!type.IsAssignableFromInternal(other))
                {
                    return other.IsAssignableFromInternal(type);
                }
                return true;
            }

            private static bool HasJsonConstructorAttribute(ConstructorInfo constructorInfo)
            {
                return constructorInfo.GetCustomAttribute<JsonConstructorAttribute>() != null;
            }

            public static bool HasRequiredMemberAttribute(this ICustomAttributeProvider memberInfo)
            {
                return memberInfo.HasCustomAttributeWithName("System.Runtime.CompilerServices.RequiredMemberAttribute", inherit: true);
            }

            public static bool HasSetsRequiredMembersAttribute(this ICustomAttributeProvider memberInfo)
            {
                return memberInfo.HasCustomAttributeWithName("System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute", inherit: true);
            }

            private static bool HasCustomAttributeWithName(this ICustomAttributeProvider memberInfo, string fullName, bool inherit)
            {
                object[] customAttributes = memberInfo.GetCustomAttributes(inherit);
                foreach (object obj in customAttributes)
                {
                    if (obj.GetType().FullName == fullName)
                    {
                        return true;
                    }
                }
                return false;
            }

            public static TAttribute GetUniqueCustomAttribute<TAttribute>(this MemberInfo memberInfo, bool inherit) where TAttribute : Attribute
            {
                object[] customAttributes = memberInfo.GetCustomAttributes(typeof(TAttribute), inherit);
                if (customAttributes.Length == 0)
                {
                    return null;
                }
                if (customAttributes.Length == 1)
                {
                    return (TAttribute)customAttributes[0];
                }
                ThrowHelper.ThrowInvalidOperationException_SerializationDuplicateAttribute(typeof(TAttribute), memberInfo);
                return null;
            }

            /// <summary>
            /// Polyfill for BindingFlags.DoNotWrapExceptions
            /// </summary>
            public static object CreateInstanceNoWrapExceptions([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.NonPublicConstructors)] this Type type, Type[] parameterTypes, object[] parameters)
            {
                ConstructorInfo constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic, null, parameterTypes, null);
                object result = null;
                try
                {
                    result = constructor.Invoke(parameters);
                }
                catch (TargetInvocationException ex)
                {
                    ExceptionDispatchInfo.Capture(ex.InnerException).Throw();
                }
                return result;
            }
        }
    }

    namespace Serialization
    {
        using System.Text.Json.Reflection;
        using System.Text.Json.Serialization.Converters;
        using System.Text.Json.Serialization.Metadata;


        /// <summary>
        /// A list of configuration items that can be locked for modification
        /// </summary>
        internal abstract class ConfigurationList<TItem> : IList<TItem>, ICollection<TItem>, IEnumerable<TItem>, IEnumerable
        {
            protected readonly List<TItem> _list;

            protected abstract bool IsImmutable { get; }

            public TItem this[int index]
            {
                get
                {
                    return _list[index];
                }
                set
                {
                    if (value == null)
                    {
                        throw new ArgumentNullException("value");
                    }
                    VerifyMutable();
                    OnAddingElement(value);
                    _list[index] = value;
                }
            }

            public int Count => _list.Count;

            public bool IsReadOnly => IsImmutable;

            public ConfigurationList(IList<TItem> source = null)
            {
                _list = ((source == null) ? new List<TItem>() : new List<TItem>(source));
            }

            protected abstract void VerifyMutable();

            protected virtual void OnAddingElement(TItem item)
            {
            }

            public void Add(TItem item)
            {
                if (item == null)
                {
                    ThrowHelper.ThrowArgumentNullException("item");
                }
                VerifyMutable();
                OnAddingElement(item);
                _list.Add(item);
            }

            public void Clear()
            {
                VerifyMutable();
                _list.Clear();
            }

            public bool Contains(TItem item)
            {
                return _list.Contains(item);
            }

            public void CopyTo(TItem[] array, int arrayIndex)
            {
                _list.CopyTo(array, arrayIndex);
            }

            public IEnumerator<TItem> GetEnumerator()
            {
                return _list.GetEnumerator();
            }

            public int IndexOf(TItem item)
            {
                return _list.IndexOf(item);
            }

            public void Insert(int index, TItem item)
            {
                if (item == null)
                {
                    ThrowHelper.ThrowArgumentNullException("item");
                }
                VerifyMutable();
                OnAddingElement(item);
                _list.Insert(index, item);
            }

            public bool Remove(TItem item)
            {
                VerifyMutable();
                return _list.Remove(item);
            }

            public void RemoveAt(int index)
            {
                VerifyMutable();
                _list.RemoveAt(index);
            }

            IEnumerator IEnumerable.GetEnumerator()
            {
                return _list.GetEnumerator();
            }
        }

        /// <summary>
        /// Converter for streaming <see cref="T:System.Collections.Generic.IAsyncEnumerable`1" /> values.
        /// </summary>
        [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
        internal sealed class IAsyncEnumerableConverterFactory : JsonConverterFactory
        {
            [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
            public IAsyncEnumerableConverterFactory()
            {
            }

            public override bool CanConvert(Type typeToConvert)
            {
                return (object)GetAsyncEnumerableInterface(typeToConvert) != null;
            }

            [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "The ctor is marked RequiresUnreferencedCode.")]
            public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
            {
                Type asyncEnumerableInterface = GetAsyncEnumerableInterface(typeToConvert);
                Type type = asyncEnumerableInterface.GetGenericArguments()[0];
                Type type2 = typeof(IAsyncEnumerableOfTConverter<,>).MakeGenericType(typeToConvert, type);
                return (JsonConverter)Activator.CreateInstance(type2);
            }

            private static Type GetAsyncEnumerableInterface(Type type)
            {
                return type.GetCompatibleGenericInterface(typeof(IAsyncEnumerable<>));
            }
        }

        internal static class IEnumerableConverterFactoryHelpers
        {
            internal const string ImmutableConvertersUnreferencedCodeMessage = "System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.";

            [RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
            [RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
            public static MethodInfo GetImmutableEnumerableCreateRangeMethod(this Type type, Type elementType)
            {
                Type immutableEnumerableConstructingType = GetImmutableEnumerableConstructingType(type);
                if (immutableEnumerableConstructingType != null)
                {
                    MethodInfo[] methods = immutableEnumerableConstructingType.GetMethods();
                    MethodInfo[] array = methods;
                    foreach (MethodInfo methodInfo in array)
                    {
                        if (methodInfo.Name == "CreateRange" && methodInfo.GetParameters().Length == 1 && methodInfo.IsGenericMethod && methodInfo.GetGenericArguments().Length == 1)
                        {
                            return methodInfo.MakeGenericMethod(elementType);
                        }
                    }
                }
                ThrowHelper.ThrowNotSupportedException_SerializationNotSupported(type);
                return null;
            }

            [RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
            [RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
            public static MethodInfo GetImmutableDictionaryCreateRangeMethod(this Type type, Type keyType, Type valueType)
            {
                Type immutableDictionaryConstructingType = GetImmutableDictionaryConstructingType(type);
                if (immutableDictionaryConstructingType != null)
                {
                    MethodInfo[] methods = immutableDictionaryConstructingType.GetMethods();
                    MethodInfo[] array = methods;
                    foreach (MethodInfo methodInfo in array)
                    {
                        if (methodInfo.Name == "CreateRange" && methodInfo.GetParameters().Length == 1 && methodInfo.IsGenericMethod && methodInfo.GetGenericArguments().Length == 2)
                        {
                            return methodInfo.MakeGenericMethod(keyType, valueType);
                        }
                    }
                }
                ThrowHelper.ThrowNotSupportedException_SerializationNotSupported(type);
                return null;
            }

            [RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
            [RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
            private static Type GetImmutableEnumerableConstructingType(Type type)
            {
                string immutableEnumerableConstructingTypeName = type.GetImmutableEnumerableConstructingTypeName();
                if (immutableEnumerableConstructingTypeName != null)
                {
                    return type.Assembly.GetType(immutableEnumerableConstructingTypeName);
                }
                return null;
            }

            [RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
            [RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
            private static Type GetImmutableDictionaryConstructingType(Type type)
            {
                string immutableDictionaryConstructingTypeName = type.GetImmutableDictionaryConstructingTypeName();
                if (immutableDictionaryConstructingTypeName != null)
                {
                    return type.Assembly.GetType(immutableDictionaryConstructingTypeName);
                }
                return null;
            }

            public static bool IsNonGenericStackOrQueue(this Type type)
            {
                Type typeIfExists = GetTypeIfExists("System.Collections.Stack, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
                if ((object)typeIfExists != null && typeIfExists.IsAssignableFrom(type))
                {
                    return true;
                }
                Type typeIfExists2 = GetTypeIfExists("System.Collections.Queue, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
                if ((object)typeIfExists2 != null && typeIfExists2.IsAssignableFrom(type))
                {
                    return true;
                }
                return false;
            }

            [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2057:TypeGetType", Justification = "This method exists to allow for 'weak references' to the Stack and Queue types. If those types are used in the app, they will be preserved by the app and Type.GetType will return them. If those types are not used in the app, we don't want to preserve them here.")]
            private static Type GetTypeIfExists(string name)
            {
                return Type.GetType(name, throwOnError: false);
            }
        }

        internal sealed class IgnoreReferenceHandler : ReferenceHandler
        {
            public IgnoreReferenceHandler()
            {
                HandlingStrategy = ReferenceHandlingStrategy.IgnoreCycles;
            }

            public override ReferenceResolver CreateResolver()
            {
                return new IgnoreReferenceResolver();
            }
        }
        
        internal sealed class IgnoreReferenceResolver : ReferenceResolver
        {
            private Stack<ReferenceEqualsWrapper> _stackForCycleDetection;

            internal override void PopReferenceForCycleDetection()
            {
                _stackForCycleDetection.Pop();
            }

            internal override bool ContainsReferenceForCycleDetection(object value)
            {
                return _stackForCycleDetection?.Contains(new ReferenceEqualsWrapper(value)) ?? false;
            }

            internal override void PushReferenceForCycleDetection(object value)
            {
                ReferenceEqualsWrapper item = new ReferenceEqualsWrapper(value);
                if (_stackForCycleDetection == null)
                {
                    _stackForCycleDetection = new Stack<ReferenceEqualsWrapper>();
                }
                _stackForCycleDetection.Push(item);
            }

            public override void AddReference(string referenceId, object value)
            {
                throw new InvalidOperationException();
            }

            public override string GetReference(object value, out bool alreadyExists)
            {
                throw new InvalidOperationException();
            }

            public override object ResolveReference(string referenceId)
            {
                throw new InvalidOperationException();
            }
        }

        /// <summary>
        /// Specifies that the JSON type should have its <see cref="M:System.Text.Json.Serialization.IJsonOnDeserialized.OnDeserialized" /> method called after deserialization occurs.
        /// </summary>
        /// <remarks>
        /// This behavior is only supported on types representing JSON objects.
        /// Types that have a custom converter or represent either collections or primitive values do not support this behavior.
        /// </remarks>
        public interface IJsonOnDeserialized
        {
            /// <summary>
            /// The method that is called after deserialization.
            /// </summary>
            void OnDeserialized();
        }

        /// <summary>
        /// Specifies that the type should have its <see cref="M:System.Text.Json.Serialization.IJsonOnDeserializing.OnDeserializing" /> method called before deserialization occurs.
        /// </summary>
        /// <remarks>
        /// This behavior is only supported on types representing JSON objects.
        /// Types that have a custom converter or represent either collections or primitive values do not support this behavior.
        /// </remarks>
        public interface IJsonOnDeserializing
        {
            /// <summary>
            /// The method that is called before deserialization.
            /// </summary>
            void OnDeserializing();
        }

        /// <summary>
        /// Specifies that the type should have its <see cref="M:System.Text.Json.Serialization.IJsonOnSerialized.OnSerialized" /> method called after serialization occurs.
        /// </summary>
        /// <remarks>
        /// This behavior is only supported on types representing JSON objects.
        /// Types that have a custom converter or represent either collections or primitive values do not support this behavior.
        /// </remarks>
        public interface IJsonOnSerialized
        {
            /// <summary>
            /// The method that is called after serialization.
            /// </summary>
            void OnSerialized();
        }

        /// <summary>
        /// Specifies that the type should have its <see cref="M:System.Text.Json.Serialization.IJsonOnSerializing.OnSerializing" /> method called before serialization occurs.
        /// </summary>
        /// <remarks>
        /// This behavior is only supported on types representing JSON objects.
        /// Types that have a custom converter or represent either collections or primitive values do not support this behavior.
        /// </remarks>
        public interface IJsonOnSerializing
        {
            /// <summary>
            /// The method that is called before serialization.
            /// </summary>
            void OnSerializing();
        }

        /// <summary>
        /// The base class of serialization attributes.
        /// </summary>
        public abstract class JsonAttribute : Attribute { }

        /// <summary>
        /// Base class for all collections. Collections are assumed to implement <see cref="T:System.Collections.Generic.IEnumerable`1" />
        /// or a variant thereof e.g. <see cref="T:System.Collections.Generic.IAsyncEnumerable`1" />.
        /// </summary>
        internal abstract class JsonCollectionConverter<TCollection, TElement> : JsonResumableConverter<TCollection>
        {
            internal override bool SupportsCreateObjectDelegate => true;

            internal sealed override ConverterStrategy ConverterStrategy => ConverterStrategy.Enumerable;

            internal override Type ElementType => typeof(TElement);

            protected abstract void Add(in TElement value, ref ReadStack state);

            /// <summary>
            /// When overridden, create the collection. It may be a temporary collection or the final collection.
            /// </summary>
            protected virtual void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
            {
                JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
                if (jsonTypeInfo.CreateObject == null)
                {
                    if (TypeToConvert.IsAbstract || TypeToConvert.IsInterface)
                    {
                        ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(TypeToConvert, ref reader, ref state);
                    }
                    else
                    {
                        ThrowHelper.ThrowNotSupportedException_DeserializeNoConstructor(TypeToConvert, ref reader, ref state);
                    }
                }
                state.Current.ReturnValue = jsonTypeInfo.CreateObject();
            }

            protected virtual void ConvertCollection(ref ReadStack state, JsonSerializerOptions options)
            {
            }

            protected static JsonConverter<TElement> GetElementConverter(JsonTypeInfo elementTypeInfo)
            {
                return ((JsonTypeInfo<TElement>)elementTypeInfo).EffectiveConverter;
            }

            protected static JsonConverter<TElement> GetElementConverter(ref WriteStack state)
            {
                return (JsonConverter<TElement>)state.Current.JsonPropertyInfo.EffectiveConverter;
            }

            internal override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, [System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out TCollection value)
            {
                JsonTypeInfo elementTypeInfo = state.Current.JsonTypeInfo.ElementTypeInfo;
                if (!state.SupportContinuation && !state.Current.CanContainMetadata)
                {
                    if (reader.TokenType != JsonTokenType.StartArray)
                    {
                        ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(TypeToConvert);
                    }
                    CreateCollection(ref reader, ref state, options);
                    state.Current.JsonPropertyInfo = elementTypeInfo.PropertyInfoForTypeInfo;
                    JsonConverter<TElement> elementConverter = GetElementConverter(elementTypeInfo);
                    if (elementConverter.CanUseDirectReadOrWrite && !state.Current.NumberHandling.HasValue)
                    {
                        while (true)
                        {
                            reader.ReadWithVerify();
                            if (reader.TokenType == JsonTokenType.EndArray)
                            {
                                break;
                            }
                            TElement value2 = elementConverter.Read(ref reader, elementConverter.TypeToConvert, options);
                            Add(in value2, ref state);
                        }
                    }
                    else
                    {
                        while (true)
                        {
                            reader.ReadWithVerify();
                            if (reader.TokenType == JsonTokenType.EndArray)
                            {
                                break;
                            }
                            elementConverter.TryRead(ref reader, typeof(TElement), options, ref state, out var value3);
                            Add(in value3, ref state);
                        }
                    }
                }
                else
                {
                    JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
                    if (state.Current.ObjectState == StackFrameObjectState.None)
                    {
                        if (reader.TokenType == JsonTokenType.StartArray)
                        {
                            state.Current.ObjectState = StackFrameObjectState.ReadMetadata;
                        }
                        else if (state.Current.CanContainMetadata)
                        {
                            if (reader.TokenType != JsonTokenType.StartObject)
                            {
                                ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(TypeToConvert);
                            }
                            state.Current.ObjectState = StackFrameObjectState.StartToken;
                        }
                        else
                        {
                            ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(TypeToConvert);
                        }
                        state.Current.JsonPropertyInfo = elementTypeInfo.PropertyInfoForTypeInfo;
                    }
                    if (state.Current.CanContainMetadata && (int)state.Current.ObjectState < 2)
                    {
                        if (!JsonSerializer.TryReadMetadata(this, jsonTypeInfo, ref reader, ref state))
                        {
                            value = default(TCollection);
                            return false;
                        }
                        if (state.Current.MetadataPropertyNames == MetadataPropertyName.Ref)
                        {
                            value = JsonSerializer.ResolveReferenceId<TCollection>(ref state);
                            return true;
                        }
                        state.Current.ObjectState = StackFrameObjectState.ReadMetadata;
                    }
                    if (state.Current.MetadataPropertyNames.HasFlag(MetadataPropertyName.Type) && state.Current.PolymorphicSerializationState != PolymorphicSerializationState.PolymorphicReEntryStarted)
                    {
                        JsonConverter jsonConverter = ResolvePolymorphicConverter(jsonTypeInfo, options, ref state);
                        if (jsonConverter != null)
                        {
                            object value4;
                            bool flag = jsonConverter.OnTryReadAsObject(ref reader, options, ref state, out value4);
                            value = (TCollection)value4;
                            state.ExitPolymorphicConverter(flag);
                            return flag;
                        }
                    }
                    if ((int)state.Current.ObjectState < 4)
                    {
                        if (state.Current.CanContainMetadata)
                        {
                            JsonSerializer.ValidateMetadataForArrayConverter(this, ref reader, ref state);
                        }
                        CreateCollection(ref reader, ref state, options);
                        if (state.Current.MetadataPropertyNames.HasFlag(MetadataPropertyName.Id))
                        {
                            state.ReferenceResolver.AddReference(state.ReferenceId, state.Current.ReturnValue);
                            state.ReferenceId = null;
                        }
                        state.Current.ObjectState = StackFrameObjectState.CreatedObject;
                    }
                    if ((int)state.Current.ObjectState < 5)
                    {
                        JsonConverter<TElement> elementConverter2 = GetElementConverter(elementTypeInfo);
                        while (true)
                        {
                            if ((int)state.Current.PropertyState < 3)
                            {
                                state.Current.PropertyState = StackFramePropertyState.ReadValue;
                                if (!JsonConverter.SingleValueReadWithReadAhead(elementConverter2.RequiresReadAhead, ref reader, ref state))
                                {
                                    value = default(TCollection);
                                    return false;
                                }
                            }
                            if ((int)state.Current.PropertyState < 4)
                            {
                                if (reader.TokenType == JsonTokenType.EndArray)
                                {
                                    break;
                                }
                                state.Current.PropertyState = StackFramePropertyState.ReadValueIsEnd;
                            }
                            if ((int)state.Current.PropertyState < 5)
                            {
                                if (!elementConverter2.TryRead(ref reader, typeof(TElement), options, ref state, out var value5))
                                {
                                    value = default(TCollection);
                                    return false;
                                }
                                Add(in value5, ref state);
                                state.Current.EndElement();
                            }
                        }
                        state.Current.ObjectState = StackFrameObjectState.ReadElements;
                    }
                    if ((int)state.Current.ObjectState < 6)
                    {
                        state.Current.ObjectState = StackFrameObjectState.EndToken;
                        if (state.Current.MetadataPropertyNames.HasFlag(MetadataPropertyName.Values) && !reader.Read())
                        {
                            value = default(TCollection);
                            return false;
                        }
                    }
                    if ((int)state.Current.ObjectState < 7 && state.Current.MetadataPropertyNames.HasFlag(MetadataPropertyName.Values) && reader.TokenType != JsonTokenType.EndObject)
                    {
                        ThrowHelper.ThrowJsonException_MetadataInvalidPropertyInArrayMetadata(ref state, typeToConvert, in reader);
                    }
                }
                ConvertCollection(ref state, options);
                value = (TCollection)state.Current.ReturnValue;
                return true;
            }

            internal override bool OnTryWrite(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, ref WriteStack state)
            {
                bool flag;
                if (value == null)
                {
                    writer.WriteNullValue();
                    flag = true;
                }
                else
                {
                    if (!state.Current.ProcessedStartToken)
                    {
                        state.Current.ProcessedStartToken = true;
                        if (state.CurrentContainsMetadata && CanHaveMetadata)
                        {
                            state.Current.MetadataPropertyName = JsonSerializer.WriteMetadataForCollection(this, ref state, writer);
                        }
                        writer.WriteStartArray();
                        state.Current.JsonPropertyInfo = state.Current.JsonTypeInfo.ElementTypeInfo.PropertyInfoForTypeInfo;
                    }
                    flag = OnWriteResume(writer, value, options, ref state);
                    if (flag && !state.Current.ProcessedEndToken)
                    {
                        state.Current.ProcessedEndToken = true;
                        writer.WriteEndArray();
                        if (state.Current.MetadataPropertyName != 0)
                        {
                            writer.WriteEndObject();
                        }
                    }
                }
                return flag;
            }

            protected abstract bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, ref WriteStack state);
        }

        /// <summary>
        /// When placed on a constructor, indicates that the constructor should be used to create
        /// instances of the type on deserialization.
        /// </summary>
        [AttributeUsage(AttributeTargets.Constructor, AllowMultiple = false)]
        public sealed class JsonConstructorAttribute : JsonAttribute
        {
            /// <summary>
            /// Initializes a new instance of <see cref="T:System.Text.Json.Serialization.JsonConstructorAttribute" />.
            /// </summary>
            public JsonConstructorAttribute() { }
        }

        /// <summary>
        /// Converts an object or value to or from JSON.
        /// </summary>
        /// <summary>
        /// Converts an object or value to or from JSON.
        /// </summary>
        public abstract class JsonConverter
        {
            /// <summary>
            /// Whether the converter is built-in and handles a number type.
            /// </summary>
            internal bool IsInternalConverterForNumberType;

            internal abstract ConverterStrategy ConverterStrategy { get; }

            /// <summary>
            /// Indicates that the converter can consume the <see cref="P:System.Text.Json.Serialization.Metadata.JsonTypeInfo.CreateObject" /> delegate.
            /// Needed because certain collection converters cannot support arbitrary delegates.
            /// TODO remove once https://github.com/dotnet/runtime/pull/73395/ and
            /// https://github.com/dotnet/runtime/issues/71944 have been addressed.
            /// </summary>
            internal virtual bool SupportsCreateObjectDelegate => false;

            /// <summary>
            /// Can direct Read or Write methods be called (for performance).
            /// </summary>
            internal bool CanUseDirectReadOrWrite { get; set; }

            /// <summary>
            /// The converter supports writing and reading metadata.
            /// </summary>
            internal virtual bool CanHaveMetadata => false;

            /// <summary>
            /// The converter supports polymorphic writes; only reserved for System.Object types.
            /// </summary>
            internal bool CanBePolymorphic { get; set; }

            /// <summary>
            /// The serializer must read ahead all contents of the next JSON value
            /// before calling into the converter for deserialization.
            /// </summary>
            internal bool RequiresReadAhead { get; set; }

            internal abstract Type? ElementType { get; }

            internal abstract Type? KeyType { get; }

            /// <summary>
            /// Cached value of TypeToConvert.IsValueType, which is an expensive call.
            /// </summary>
            internal bool IsValueType { get; set; }

            /// <summary>
            /// Whether the converter is built-in.
            /// </summary>
            internal bool IsInternalConverter { get; set; }

            internal abstract Type TypeToConvert { get; }

            internal virtual bool ConstructorIsParameterized { get; }

            internal ConstructorInfo? ConstructorInfo { get; set; }

            internal JsonConverter()
            {
            }

            /// <summary>
            /// Determines whether the type can be converted.
            /// </summary>
            /// <param name="typeToConvert">The type is checked as to whether it can be converted.</param>
            /// <returns>True if the type can be converted, false otherwise.</returns>
            public abstract bool CanConvert(Type typeToConvert);

            /// <summary>
            /// Used to support JsonObject as an extension property in a loosely-typed, trimmable manner.
            /// </summary>
            internal virtual void ReadElementAndSetProperty(object obj, string propertyName, ref Utf8JsonReader reader, JsonSerializerOptions options, scoped ref ReadStack state)
            {
                throw new InvalidOperationException();
            }

            [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
            [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
            internal virtual JsonTypeInfo CreateReflectionJsonTypeInfo(JsonSerializerOptions options)
            {
                throw new InvalidOperationException();
            }

            internal virtual JsonTypeInfo CreateCustomJsonTypeInfo(JsonSerializerOptions options)
            {
                throw new InvalidOperationException();
            }

            internal abstract JsonParameterInfo CreateJsonParameterInfo();

            internal abstract JsonConverter<TTarget> CreateCastingConverter<TTarget>();

            /// <summary>
            /// Loosely-typed ReadCore() that forwards to strongly-typed ReadCore().
            /// </summary>
            internal abstract object ReadCoreAsObject(ref Utf8JsonReader reader, JsonSerializerOptions options, scoped ref ReadStack state);

            internal static bool ShouldFlush(Utf8JsonWriter writer, ref WriteStack state)
            {
                if (state.FlushThreshold > 0)
                {
                    return writer.BytesPending > state.FlushThreshold;
                }
                return false;
            }

            internal abstract bool OnTryReadAsObject(ref Utf8JsonReader reader, JsonSerializerOptions options, scoped ref ReadStack state, out object value);

            internal abstract bool TryReadAsObject(ref Utf8JsonReader reader, JsonSerializerOptions options, scoped ref ReadStack state, out object value);

            internal abstract bool TryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, ref WriteStack state);

            /// <summary>
            /// Loosely-typed WriteCore() that forwards to strongly-typed WriteCore().
            /// </summary>
            internal abstract bool WriteCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, ref WriteStack state);

            /// <summary>
            /// Loosely-typed WriteToPropertyName() that forwards to strongly-typed WriteToPropertyName().
            /// </summary>
            internal abstract void WriteAsPropertyNameCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty);

            /// <summary>
            /// Used for hooking custom configuration to a newly created associated JsonTypeInfo instance.
            /// </summary>
            internal virtual void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
            {
            }

            /// <summary>
            /// Additional reflection-specific configuration required by certain collection converters.
            /// </summary>
            [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
            [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
            internal virtual void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
            {
            }

            /// <summary>
            /// Initializes the state for polymorphic cases and returns the appropriate derived converter.
            /// </summary>
            internal JsonConverter ResolvePolymorphicConverter(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options, ref ReadStack state)
            {
                JsonConverter jsonConverter = null;
                switch (state.Current.PolymorphicSerializationState)
                {
                    case PolymorphicSerializationState.None:
                        {
                            PolymorphicTypeResolver polymorphicTypeResolver = jsonTypeInfo.PolymorphicTypeResolver;
                            if (polymorphicTypeResolver.TryGetDerivedJsonTypeInfo(state.PolymorphicTypeDiscriminator, out var jsonTypeInfo2))
                            {
                                jsonConverter = state.InitializePolymorphicReEntry(jsonTypeInfo2);
                                if (!jsonConverter.CanHaveMetadata)
                                {
                                    ThrowHelper.ThrowNotSupportedException_DerivedConverterDoesNotSupportMetadata(jsonTypeInfo2.Type);
                                }
                            }
                            else
                            {
                                state.Current.PolymorphicSerializationState = PolymorphicSerializationState.PolymorphicReEntryNotFound;
                            }
                            state.PolymorphicTypeDiscriminator = null;
                            break;
                        }
                    case PolymorphicSerializationState.PolymorphicReEntrySuspended:
                        jsonConverter = state.ResumePolymorphicReEntry();
                        break;
                }
                return jsonConverter;
            }

            /// <summary>
            /// Initializes the state for polymorphic cases and returns the appropriate derived converter.
            /// </summary>
            internal JsonConverter ResolvePolymorphicConverter(object value, JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options, ref WriteStack state)
            {
                JsonConverter jsonConverter = null;
                switch (state.Current.PolymorphicSerializationState)
                {
                    case PolymorphicSerializationState.None:
                        {
                            if (state.IsPolymorphicRootValue && state.CurrentDepth == 0)
                            {
                                state.Current.PolymorphicSerializationState = PolymorphicSerializationState.PolymorphicReEntryNotFound;
                                break;
                            }
                            Type type = value.GetType();
                            PolymorphicTypeResolver polymorphicTypeResolver = jsonTypeInfo.PolymorphicTypeResolver;
                            if (polymorphicTypeResolver != null)
                            {
                                if (polymorphicTypeResolver.TryGetDerivedJsonTypeInfo(type, out var jsonTypeInfo2, out var typeDiscriminator))
                                {
                                    jsonConverter = state.Current.InitializePolymorphicReEntry(jsonTypeInfo2);
                                    if (typeDiscriminator != null)
                                    {
                                        if (!jsonConverter.CanHaveMetadata)
                                        {
                                            ThrowHelper.ThrowNotSupportedException_DerivedConverterDoesNotSupportMetadata(jsonTypeInfo2.Type);
                                        }
                                        state.PolymorphicTypeDiscriminator = typeDiscriminator;
                                    }
                                }
                                else
                                {
                                    state.Current.PolymorphicSerializationState = PolymorphicSerializationState.PolymorphicReEntryNotFound;
                                }
                            }
                            else if (type != TypeToConvert)
                            {
                                jsonConverter = state.Current.InitializePolymorphicReEntry(type, options);
                            }
                            else
                            {
                                state.Current.PolymorphicSerializationState = PolymorphicSerializationState.PolymorphicReEntryNotFound;
                            }
                            break;
                        }
                    case PolymorphicSerializationState.PolymorphicReEntrySuspended:
                        jsonConverter = state.Current.ResumePolymorphicReEntry();
                        break;
                }
                return jsonConverter;
            }

            internal bool TryHandleSerializedObjectReference(Utf8JsonWriter writer, object value, JsonSerializerOptions options, JsonConverter polymorphicConverter, ref WriteStack state)
            {
                switch (options.ReferenceHandlingStrategy)
                {
                    case ReferenceHandlingStrategy.IgnoreCycles:
                        {
                            ReferenceResolver referenceResolver = state.ReferenceResolver;
                            if (referenceResolver.ContainsReferenceForCycleDetection(value))
                            {
                                writer.WriteNullValue();
                                return true;
                            }
                            referenceResolver.PushReferenceForCycleDetection(value);
                            state.Current.IsPushedReferenceForCycleDetection = state.CurrentDepth > 0;
                            break;
                        }
                    case ReferenceHandlingStrategy.Preserve:
                        if ((polymorphicConverter?.CanHaveMetadata ?? CanHaveMetadata) && JsonSerializer.TryGetReferenceForValue(value, ref state, writer))
                        {
                            return true;
                        }
                        break;
                }
                return false;
            }

            /// <summary>
            /// Perform a Read() and if read-ahead is required, also read-ahead (to the end of the current JSON level).
            /// </summary>
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            internal static bool SingleValueReadWithReadAhead(bool requiresReadAhead, ref Utf8JsonReader reader, scoped ref ReadStack state)
            {
                if (!requiresReadAhead || !state.ReadAhead)
                {
                    return reader.Read();
                }
                return DoSingleValueReadWithReadAhead(ref reader, ref state);
            }

            internal static bool DoSingleValueReadWithReadAhead(ref Utf8JsonReader reader, scoped ref ReadStack state)
            {
                Utf8JsonReader utf8JsonReader = reader;
                if (!reader.Read())
                {
                    return false;
                }
                JsonTokenType tokenType = reader.TokenType;
                if (tokenType == JsonTokenType.StartObject || tokenType == JsonTokenType.StartArray)
                {
                    bool flag = reader.TrySkip();
                    reader = utf8JsonReader;
                    if (!flag)
                    {
                        return false;
                    }
                    reader.ReadWithVerify();
                }
                return true;
            }
        }
        
        /// <summary>
        /// Converts an object or value to or from JSON.
        /// </summary>
        /// <typeparam name="T">The <see cref="T:System.Type" /> to convert.</typeparam>
        public abstract class JsonConverter<T> : JsonConverter
        {
            internal override ConverterStrategy ConverterStrategy => ConverterStrategy.Value;

            /// <summary>
            /// Set if this converter is itself a casting converter.
            /// </summary>
            internal virtual JsonConverter? SourceConverterForCastingConverter => null;

            internal override Type? KeyType => null;

            internal override Type? ElementType => null;

            /// <summary>
            /// Indicates whether <see langword="null" /> should be passed to the converter on serialization,
            /// and whether <see cref="F:System.Text.Json.JsonTokenType.Null" /> should be passed on deserialization.
            /// </summary>
            /// <remarks>
            /// The default value is <see langword="true" /> for converters based on value types, and <see langword="false" /> for converters based on reference types.
            /// </remarks>
            public virtual bool HandleNull
            {
                get
                {
                    HandleNullOnRead = default(T) != null;
                    HandleNullOnWrite = false;
                    return false;
                }
            }

            /// <summary>
            /// Does the converter want to be called when reading null tokens.
            /// </summary>
            internal bool HandleNullOnRead { get; private set; }

            /// <summary>
            /// Does the converter want to be called for null values.
            /// </summary>
            internal bool HandleNullOnWrite { get; private set; }

            internal sealed override Type TypeToConvert { get; } = typeof(T);


            internal sealed override object ReadCoreAsObject(ref Utf8JsonReader reader, JsonSerializerOptions options, scoped ref ReadStack state)
            {
                return ReadCore(ref reader, options, ref state);
            }

            internal T ReadCore(ref Utf8JsonReader reader, JsonSerializerOptions options, scoped ref ReadStack state)
            {
                try
                {
                    if (!state.IsContinuation)
                    {
                        if (!JsonConverter.SingleValueReadWithReadAhead(base.RequiresReadAhead, ref reader, ref state))
                        {
                            if (state.SupportContinuation)
                            {
                                state.BytesConsumed += reader.BytesConsumed;
                                if (state.Current.ReturnValue == null)
                                {
                                    return default(T);
                                }
                                return (T)state.Current.ReturnValue;
                            }
                            state.BytesConsumed += reader.BytesConsumed;
                            return default(T);
                        }
                    }
                    else if (!JsonConverter.SingleValueReadWithReadAhead(requiresReadAhead: true, ref reader, ref state))
                    {
                        state.BytesConsumed += reader.BytesConsumed;
                        return default(T);
                    }
                    if (TryRead(ref reader, state.Current.JsonTypeInfo.Type, options, ref state, out var value) && !reader.Read() && !reader.IsFinalBlock)
                    {
                        state.Current.ReturnValue = value;
                    }
                    state.BytesConsumed += reader.BytesConsumed;
                    return value;
                }
                catch (JsonReaderException ex)
                {
                    ThrowHelper.ReThrowWithPath(ref state, ex);
                    return default(T);
                }
                catch (FormatException ex2) when (ex2.Source == "System.Text.Json.Rethrowable")
                {
                    ThrowHelper.ReThrowWithPath(ref state, in reader, ex2);
                    return default(T);
                }
                catch (InvalidOperationException ex3) when (ex3.Source == "System.Text.Json.Rethrowable")
                {
                    ThrowHelper.ReThrowWithPath(ref state, in reader, ex3);
                    return default(T);
                }
                catch (JsonException ex4) when (ex4.Path == null)
                {
                    ThrowHelper.AddJsonExceptionInformation(ref state, in reader, ex4);
                    throw;
                }
                catch (NotSupportedException ex5)
                {
                    if (ex5.Message.Contains(" Path: "))
                    {
                        throw;
                    }
                    ThrowHelper.ThrowNotSupportedException(ref state, in reader, ex5);
                    return default(T);
                }
            }

            internal sealed override bool WriteCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, ref WriteStack state)
            {
                if (base.IsValueType)
                {
                    if (default(T) != null && value == null)
                    {
                        ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(TypeToConvert);
                    }
                    if (options.ReferenceHandlingStrategy == ReferenceHandlingStrategy.IgnoreCycles && value != null)
                    {
                        state.ReferenceResolver.PushReferenceForCycleDetection(value);
                    }
                }
                T value2 = (T)value;
                return WriteCore(writer, in value2, options, ref state);
            }

            internal bool WriteCore(Utf8JsonWriter writer, in T value, JsonSerializerOptions options, ref WriteStack state)
            {
                try
                {
                    return TryWrite(writer, in value, options, ref state);
                }
                catch (InvalidOperationException ex) when (ex.Source == "System.Text.Json.Rethrowable")
                {
                    ThrowHelper.ReThrowWithPath(ref state, ex);
                    throw;
                }
                catch (JsonException ex2) when (ex2.Path == null)
                {
                    ThrowHelper.AddJsonExceptionInformation(ref state, ex2);
                    throw;
                }
                catch (NotSupportedException ex3)
                {
                    if (ex3.Message.Contains(" Path: "))
                    {
                        throw;
                    }
                    ThrowHelper.ThrowNotSupportedException(ref state, ex3);
                    return false;
                }
            }

            /// <summary>
            /// When overridden, constructs a new <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance.
            /// </summary>
            protected internal JsonConverter()
                : this(initialize: true)
            {
            }

            internal JsonConverter(bool initialize)
            {
                base.IsValueType = typeof(T).IsValueType;
                base.IsInternalConverter = GetType().Assembly == typeof(JsonConverter).Assembly;
                if (initialize)
                {
                    Initialize();
                }
            }

            private protected void Initialize()
            {
                if (HandleNull)
                {
                    HandleNullOnRead = true;
                    HandleNullOnWrite = true;
                }
                base.CanUseDirectReadOrWrite = ConverterStrategy == ConverterStrategy.Value && base.IsInternalConverter;
                base.RequiresReadAhead = ConverterStrategy == ConverterStrategy.Value;
            }

            /// <summary>
            /// Determines whether the type can be converted.
            /// </summary>
            /// <remarks>
            /// The default implementation is to return True when <paramref name="typeToConvert" /> equals typeof(T).
            /// </remarks>
            /// <param name="typeToConvert"></param>
            /// <returns>True if the type can be converted, False otherwise.</returns>
            public override bool CanConvert(Type typeToConvert)
            {
                return typeToConvert == typeof(T);
            }

            [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
            [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
            internal sealed override JsonTypeInfo CreateReflectionJsonTypeInfo(JsonSerializerOptions options)
            {
                return new ReflectionJsonTypeInfo<T>(this, options);
            }

            internal sealed override JsonTypeInfo CreateCustomJsonTypeInfo(JsonSerializerOptions options)
            {
                return new CustomJsonTypeInfo<T>(this, options);
            }

            internal sealed override JsonParameterInfo CreateJsonParameterInfo()
            {
                return new JsonParameterInfo<T>();
            }

            internal sealed override JsonConverter<TTarget> CreateCastingConverter<TTarget>()
            {
                if (this is JsonConverter<TTarget> result)
                {
                    return result;
                }
                JsonSerializerOptions.CheckConverterNullabilityIsSameAsPropertyType(this, typeof(TTarget));
                return SourceConverterForCastingConverter?.CreateCastingConverter<TTarget>() ?? new CastingConverter<TTarget, T>(this);
            }

            internal sealed override bool TryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, ref WriteStack state)
            {
                T value2 = (T)value;
                return TryWrite(writer, in value2, options, ref state);
            }

            internal virtual bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, ref WriteStack state)
            {
                Write(writer, value, options);
                return true;
            }

            internal virtual bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out T value)
            {
                value = Read(ref reader, typeToConvert, options);
                return true;
            }

            /// <summary>
            /// Read and convert the JSON to T.
            /// </summary>
            /// <remarks>
            /// A converter may throw any Exception, but should throw <cref>JsonException</cref> when the JSON is invalid.
            /// </remarks>
            /// <param name="reader">The <see cref="T:System.Text.Json.Utf8JsonReader" /> to read from.</param>
            /// <param name="typeToConvert">The <see cref="T:System.Type" /> being converted.</param>
            /// <param name="options">The <see cref="T:System.Text.Json.JsonSerializerOptions" /> being used.</param>
            /// <returns>The value that was converted.</returns>
            /// <remarks>Note that the value of <seealso cref="P:System.Text.Json.Serialization.JsonConverter`1.HandleNull" /> determines if the converter handles null JSON tokens.</remarks>
            public abstract T? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options);

            internal bool TryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out T value)
            {
                if (reader.TokenType == JsonTokenType.Null && !HandleNullOnRead && !state.IsContinuation)
                {
                    if (default(T) != null)
                    {
                        ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(TypeToConvert);
                    }
                    value = default(T);
                    return true;
                }
                if (ConverterStrategy == ConverterStrategy.Value)
                {
                    if (base.IsInternalConverter)
                    {
                        if (state.Current.NumberHandling.HasValue && IsInternalConverterForNumberType)
                        {
                            value = ReadNumberWithCustomHandling(ref reader, state.Current.NumberHandling.Value, options);
                        }
                        else
                        {
                            value = Read(ref reader, typeToConvert, options);
                        }
                    }
                    else
                    {
                        JsonTokenType tokenType = reader.TokenType;
                        int currentDepth = reader.CurrentDepth;
                        long bytesConsumed = reader.BytesConsumed;
                        if (state.Current.NumberHandling.HasValue && IsInternalConverterForNumberType)
                        {
                            value = ReadNumberWithCustomHandling(ref reader, state.Current.NumberHandling.Value, options);
                        }
                        else
                        {
                            value = Read(ref reader, typeToConvert, options);
                        }
                        VerifyRead(tokenType, currentDepth, bytesConsumed, isValueConverter: true, ref reader);
                    }
                    return true;
                }
                bool isContinuation = state.IsContinuation;
                bool flag;
                if (base.CanBePolymorphic)
                {
                    flag = OnTryRead(ref reader, typeToConvert, options, ref state, out value);
                    return true;
                }
                state.Push();
                flag = OnTryRead(ref reader, typeToConvert, options, ref state, out value);
                state.Pop(flag);
                return flag;
            }

            internal sealed override bool OnTryReadAsObject(ref Utf8JsonReader reader, JsonSerializerOptions options, scoped ref ReadStack state, out object value)
            {
                T value2;
                bool result = OnTryRead(ref reader, TypeToConvert, options, ref state, out value2);
                value = value2;
                return result;
            }

            internal sealed override bool TryReadAsObject(ref Utf8JsonReader reader, JsonSerializerOptions options, scoped ref ReadStack state, out object value)
            {
                T value2;
                bool result = TryRead(ref reader, TypeToConvert, options, ref state, out value2);
                value = value2;
                return result;
            }

            /// <summary>
            /// Performance optimization.
            /// The 'in' modifier in 'TryWrite(in T Value)' causes boxing for Nullable{T}, so this helper avoids that.
            /// TODO: Remove this work-around once https://github.com/dotnet/runtime/issues/50915 is addressed.
            /// </summary>
            private static bool IsNull(T value)
            {
                return value == null;
            }

            internal bool TryWrite(Utf8JsonWriter writer, in T value, JsonSerializerOptions options, ref WriteStack state)
            {
                if (writer.CurrentDepth >= options.EffectiveMaxDepth)
                {
                    ThrowHelper.ThrowJsonException_SerializerCycleDetected(options.EffectiveMaxDepth);
                }
                if (default(T) == null && !HandleNullOnWrite && IsNull(value))
                {
                    writer.WriteNullValue();
                    return true;
                }
                if (ConverterStrategy == ConverterStrategy.Value)
                {
                    int currentDepth = writer.CurrentDepth;
                    if (state.Current.NumberHandling.HasValue && IsInternalConverterForNumberType)
                    {
                        WriteNumberWithCustomHandling(writer, value, state.Current.NumberHandling.Value);
                    }
                    else
                    {
                        Write(writer, value, options);
                    }
                    VerifyWrite(currentDepth, writer);
                    return true;
                }
                bool isContinuation = state.IsContinuation;
                bool flag;
                if (!base.IsValueType && value != null && state.Current.PolymorphicSerializationState != PolymorphicSerializationState.PolymorphicReEntryStarted)
                {
                    JsonTypeInfo jsonTypeInfo = state.PeekNestedJsonTypeInfo();
                    JsonConverter jsonConverter = ((base.CanBePolymorphic || jsonTypeInfo.PolymorphicTypeResolver != null) ? ResolvePolymorphicConverter(value, jsonTypeInfo, options, ref state) : null);
                    if (!isContinuation && options.ReferenceHandlingStrategy != 0 && TryHandleSerializedObjectReference(writer, value, options, jsonConverter, ref state))
                    {
                        return true;
                    }
                    if (jsonConverter != null)
                    {
                        flag = jsonConverter.TryWriteAsObject(writer, value, options, ref state);
                        state.Current.ExitPolymorphicConverter(flag);
                        if (flag && state.Current.IsPushedReferenceForCycleDetection)
                        {
                            state.ReferenceResolver.PopReferenceForCycleDetection();
                            state.Current.IsPushedReferenceForCycleDetection = false;
                        }
                        return flag;
                    }
                }
                state.Push();
                flag = OnTryWrite(writer, value, options, ref state);
                state.Pop(flag);
                if (flag && state.Current.IsPushedReferenceForCycleDetection)
                {
                    state.ReferenceResolver.PopReferenceForCycleDetection();
                    state.Current.IsPushedReferenceForCycleDetection = false;
                }
                return flag;
            }

            internal bool TryWriteDataExtensionProperty(Utf8JsonWriter writer, T value, JsonSerializerOptions options, ref WriteStack state)
            {
                if (!base.IsInternalConverter)
                {
                    return TryWrite(writer, in value, options, ref state);
                }
                JsonDictionaryConverter<T> jsonDictionaryConverter = (this as JsonDictionaryConverter<T>) ?? ((this as JsonMetadataServicesConverter<T>)?.Converter as JsonDictionaryConverter<T>);
                if (jsonDictionaryConverter == null)
                {
                    return TryWrite(writer, in value, options, ref state);
                }
                if (writer.CurrentDepth >= options.EffectiveMaxDepth)
                {
                    ThrowHelper.ThrowJsonException_SerializerCycleDetected(options.EffectiveMaxDepth);
                }
                bool isContinuation = state.IsContinuation;
                state.Push();
                if (!isContinuation)
                {
                    state.Current.OriginalDepth = writer.CurrentDepth;
                }
                state.Current.IsWritingExtensionDataProperty = true;
                state.Current.JsonPropertyInfo = state.Current.JsonTypeInfo.ElementTypeInfo.PropertyInfoForTypeInfo;
                bool flag = jsonDictionaryConverter.OnWriteResume(writer, value, options, ref state);
                if (flag)
                {
                    VerifyWrite(state.Current.OriginalDepth, writer);
                }
                state.Pop(flag);
                return flag;
            }

            internal void VerifyRead(JsonTokenType tokenType, int depth, long bytesConsumed, bool isValueConverter, ref Utf8JsonReader reader)
            {
                switch (tokenType)
                {
                    case JsonTokenType.StartArray:
                        if (reader.TokenType != JsonTokenType.EndArray)
                        {
                            ThrowHelper.ThrowJsonException_SerializationConverterRead(this);
                        }
                        else if (depth != reader.CurrentDepth)
                        {
                            ThrowHelper.ThrowJsonException_SerializationConverterRead(this);
                        }
                        return;
                    case JsonTokenType.StartObject:
                        if (reader.TokenType != JsonTokenType.EndObject)
                        {
                            ThrowHelper.ThrowJsonException_SerializationConverterRead(this);
                        }
                        else if (depth != reader.CurrentDepth)
                        {
                            ThrowHelper.ThrowJsonException_SerializationConverterRead(this);
                        }
                        return;
                }
                if (isValueConverter)
                {
                    if (reader.BytesConsumed != bytesConsumed)
                    {
                        ThrowHelper.ThrowJsonException_SerializationConverterRead(this);
                    }
                }
                else if (!base.CanBePolymorphic && (!HandleNullOnRead || tokenType != JsonTokenType.Null))
                {
                    ThrowHelper.ThrowJsonException_SerializationConverterRead(this);
                }
            }

            internal void VerifyWrite(int originalDepth, Utf8JsonWriter writer)
            {
                if (originalDepth != writer.CurrentDepth)
                {
                    ThrowHelper.ThrowJsonException_SerializationConverterWrite(this);
                }
            }

            /// <summary>
            /// Write the value as JSON.
            /// </summary>
            /// <remarks>
            /// A converter may throw any Exception, but should throw <cref>JsonException</cref> when the JSON
            /// cannot be created.
            /// </remarks>
            /// <param name="writer">The <see cref="T:System.Text.Json.Utf8JsonWriter" /> to write to.</param>
            /// <param name="value">The value to convert. Note that the value of <seealso cref="P:System.Text.Json.Serialization.JsonConverter`1.HandleNull" /> determines if the converter handles <see langword="null" /> values.</param>
            /// <param name="options">The <see cref="T:System.Text.Json.JsonSerializerOptions" /> being used.</param>
            public abstract void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);

            /// <summary>
            /// Reads a dictionary key from a JSON property name.
            /// </summary>
            /// <param name="reader">The <see cref="T:System.Text.Json.Utf8JsonReader" /> to read from.</param>
            /// <param name="typeToConvert">The <see cref="T:System.Type" /> being converted.</param>
            /// <param name="options">The <see cref="T:System.Text.Json.JsonSerializerOptions" /> being used.</param>
            /// <returns>The value that was converted.</returns>
            /// <remarks>Method should be overridden in custom converters of types used in deserialized dictionary keys.</remarks>
            public virtual T ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
            {
                if (!base.IsInternalConverter && options.SerializerContext == null && DefaultJsonTypeInfoResolver.TryGetDefaultSimpleConverter(TypeToConvert, out var converter))
                {
                    return ((JsonConverter<T>)converter).ReadAsPropertyNameCore(ref reader, TypeToConvert, options);
                }
                ThrowHelper.ThrowNotSupportedException_DictionaryKeyTypeNotSupported(TypeToConvert, this);
                return default(T);
            }

            internal virtual T ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
            {
                long bytesConsumed = reader.BytesConsumed;
                T result = ReadAsPropertyName(ref reader, typeToConvert, options);
                if (reader.BytesConsumed != bytesConsumed)
                {
                    ThrowHelper.ThrowJsonException_SerializationConverterRead(this);
                }
                return result;
            }

            /// <summary>
            /// Writes a dictionary key as a JSON property name.
            /// </summary>
            /// <param name="writer">The <see cref="T:System.Text.Json.Utf8JsonWriter" /> to write to.</param>
            /// <param name="value">The value to convert. Note that the value of <seealso cref="P:System.Text.Json.Serialization.JsonConverter`1.HandleNull" /> determines if the converter handles <see langword="null" /> values.</param>
            /// <param name="options">The <see cref="T:System.Text.Json.JsonSerializerOptions" /> being used.</param>
            /// <remarks>Method should be overridden in custom converters of types used in serialized dictionary keys.</remarks>
            public virtual void WriteAsPropertyName(Utf8JsonWriter writer, T value, JsonSerializerOptions options)
            {
                if (!base.IsInternalConverter && options.SerializerContext == null && DefaultJsonTypeInfoResolver.TryGetDefaultSimpleConverter(TypeToConvert, out var converter))
                {
                    ((JsonConverter<T>)converter).WriteAsPropertyNameCore(writer, value, options, isWritingExtensionDataProperty: false);
                }
                else
                {
                    ThrowHelper.ThrowNotSupportedException_DictionaryKeyTypeNotSupported(TypeToConvert, this);
                }
            }

            internal virtual void WriteAsPropertyNameCore(Utf8JsonWriter writer, T value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
            {
                if (isWritingExtensionDataProperty)
                {
                    writer.WritePropertyName((string)(object)value);
                    return;
                }
                int currentDepth = writer.CurrentDepth;
                WriteAsPropertyName(writer, value, options);
                if (currentDepth != writer.CurrentDepth || writer.TokenType != JsonTokenType.PropertyName)
                {
                    ThrowHelper.ThrowJsonException_SerializationConverterWrite(this);
                }
            }

            internal sealed override void WriteAsPropertyNameCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
            {
                WriteAsPropertyNameCore(writer, (T)value, options, isWritingExtensionDataProperty);
            }

            internal virtual T ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
            {
                throw new InvalidOperationException();
            }

            internal virtual void WriteNumberWithCustomHandling(Utf8JsonWriter writer, T value, JsonNumberHandling handling)
            {
                throw new InvalidOperationException();
            }
        }

        /// <summary>
        /// When placed on a property, field, or type, specifies the converter type to use.
        /// </summary>
        /// <remarks>
        /// The specified converter type must derive from <see cref="T:System.Text.Json.Serialization.JsonConverter" />.
        /// When placed on a property or field, the specified converter will always be used.
        /// When placed on a type, the specified converter will be used unless a compatible converter is added to
        /// <see cref="P:System.Text.Json.JsonSerializerOptions.Converters" /> or there is another <see cref="T:System.Text.Json.Serialization.JsonConverterAttribute" /> on a property or field
        /// of the same type.
        /// </remarks>
        [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Interface, AllowMultiple = false)]
        public class JsonConverterAttribute : JsonAttribute
        {
            /// <summary>
            /// The type of the converter to create, or null if <see cref="M:System.Text.Json.Serialization.JsonConverterAttribute.CreateConverter(System.Type)" /> should be used to obtain the converter.
            /// </summary>
            [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)]
            public Type? ConverterType { get; private set; }

            /// <summary>
            /// Initializes a new instance of <see cref="T:System.Text.Json.Serialization.JsonConverterAttribute" /> with the specified converter type.
            /// </summary>
            /// <param name="converterType">The type of the converter.</param>
            public JsonConverterAttribute([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicParameterlessConstructor)] Type converterType)
            {
                ConverterType = converterType;
            }

            /// <summary>
            /// Initializes a new instance of <see cref="T:System.Text.Json.Serialization.JsonConverterAttribute" />.
            /// </summary>
            protected JsonConverterAttribute()
            {
            }

            /// <summary>
            /// If overridden and <see cref="P:System.Text.Json.Serialization.JsonConverterAttribute.ConverterType" /> is null, allows a custom attribute to create the converter in order to pass additional state.
            /// </summary>
            /// <returns>
            /// The custom converter.
            /// </returns>
            public virtual JsonConverter? CreateConverter(Type typeToConvert)
            {
                return null;
            }
        }

        /// <summary>
        /// Supports converting several types by using a factory pattern.
        /// </summary>
        /// <remarks>
        /// This is useful for converters supporting generics, such as a converter for <see cref="T:System.Collections.Generic.List`1" />.
        /// </remarks>
        public abstract class JsonConverterFactory : JsonConverter
        {
            internal sealed override ConverterStrategy ConverterStrategy => ConverterStrategy.None;

            internal sealed override Type? KeyType => null;

            internal sealed override Type? ElementType => null;

            internal sealed override Type TypeToConvert => null;

            /// <summary>
            /// When overridden, constructs a new <see cref="T:System.Text.Json.Serialization.JsonConverterFactory" /> instance.
            /// </summary>
            protected JsonConverterFactory()
            {
            }

            /// <summary>
            /// Create a converter for the provided <see cref="T:System.Type" />.
            /// </summary>
            /// <param name="typeToConvert">The <see cref="T:System.Type" /> being converted.</param>
            /// <param name="options">The <see cref="T:System.Text.Json.JsonSerializerOptions" /> being used.</param>
            /// <returns>
            /// An instance of a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> where T is compatible with <paramref name="typeToConvert" />.
            /// If <see langword="null" /> is returned, a <see cref="T:System.NotSupportedException" /> will be thrown.
            /// </returns>
            public abstract JsonConverter? CreateConverter(Type typeToConvert, JsonSerializerOptions options);

            internal override JsonParameterInfo CreateJsonParameterInfo()
            {
                throw new InvalidOperationException();
            }

            internal JsonConverter GetConverterInternal(Type typeToConvert, JsonSerializerOptions options)
            {
                JsonConverter jsonConverter = CreateConverter(typeToConvert, options);
                if (jsonConverter != null)
                {
                    if (jsonConverter is JsonConverterFactory)
                    {
                        ThrowHelper.ThrowInvalidOperationException_SerializerConverterFactoryReturnsJsonConverterFactorty(GetType());
                    }
                }
                else
                {
                    ThrowHelper.ThrowInvalidOperationException_SerializerConverterFactoryReturnsNull(GetType());
                }
                return jsonConverter;
            }

            internal sealed override object ReadCoreAsObject(ref Utf8JsonReader reader, JsonSerializerOptions options, scoped ref ReadStack state)
            {
                throw new InvalidOperationException();
            }

            internal sealed override bool OnTryReadAsObject(ref Utf8JsonReader reader, JsonSerializerOptions options, scoped ref ReadStack state, out object value)
            {
                throw new InvalidOperationException();
            }

            internal sealed override bool TryReadAsObject(ref Utf8JsonReader reader, JsonSerializerOptions options, scoped ref ReadStack state, out object value)
            {
                throw new InvalidOperationException();
            }

            internal sealed override bool TryWriteAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, ref WriteStack state)
            {
                throw new InvalidOperationException();
            }

            internal sealed override bool WriteCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, ref WriteStack state)
            {
                throw new InvalidOperationException();
            }

            internal sealed override void WriteAsPropertyNameCoreAsObject(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
            {
                throw new InvalidOperationException();
            }

            internal sealed override JsonConverter<TTarget> CreateCastingConverter<TTarget>()
            {
                ThrowHelper.ThrowInvalidOperationException_ConverterCanConvertMultipleTypes(typeof(TTarget), this);
                return null;
            }
        }

        /// <summary>
        /// When placed on a type declaration, indicates that the specified subtype should be opted into polymorphic serialization.
        /// </summary>
        [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = true, Inherited = false)]
        public class JsonDerivedTypeAttribute : JsonAttribute
        {
            /// <summary>
            /// A derived type that should be supported in polymorphic serialization of the declared base type.
            /// </summary>
            public Type DerivedType { get; }

            /// <summary>
            /// The type discriminator identifier to be used for the serialization of the subtype.
            /// </summary>
            public object? TypeDiscriminator { get; }

            /// <summary>
            /// Initializes a new attribute with specified parameters.
            /// </summary>
            /// <param name="derivedType">A derived type that should be supported in polymorphic serialization of the declared based type.</param>
            public JsonDerivedTypeAttribute(Type derivedType)
            {
                DerivedType = derivedType;
            }

            /// <summary>
            /// Initializes a new attribute with specified parameters.
            /// </summary>
            /// <param name="derivedType">A derived type that should be supported in polymorphic serialization of the declared base type.</param>
            /// <param name="typeDiscriminator">The type discriminator identifier to be used for the serialization of the subtype.</param>
            public JsonDerivedTypeAttribute(Type derivedType, string typeDiscriminator)
            {
                DerivedType = derivedType;
                TypeDiscriminator = typeDiscriminator;
            }

            /// <summary>
            /// Initializes a new attribute with specified parameters.
            /// </summary>
            /// <param name="derivedType">A derived type that should be supported in polymorphic serialization of the declared base type.</param>
            /// <param name="typeDiscriminator">The type discriminator identifier to be used for the serialization of the subtype.</param>
            public JsonDerivedTypeAttribute(Type derivedType, int typeDiscriminator)
            {
                DerivedType = derivedType;
                TypeDiscriminator = typeDiscriminator;
            }
        }

        /// <summary>
        /// Base class for dictionary converters such as IDictionary, Hashtable, Dictionary{,} IDictionary{,} and SortedList.
        /// </summary>
        internal abstract class JsonDictionaryConverter<TDictionary> : JsonResumableConverter<TDictionary>
        {
            internal override bool SupportsCreateObjectDelegate => true;

            internal sealed override ConverterStrategy ConverterStrategy => ConverterStrategy.Dictionary;

            protected internal abstract bool OnWriteResume(Utf8JsonWriter writer, TDictionary dictionary, JsonSerializerOptions options, ref WriteStack state);
        }

        /// <summary>
        /// Base class for dictionary converters such as IDictionary, Hashtable, Dictionary{,} IDictionary{,} and SortedList.
        /// </summary>
        internal abstract class JsonDictionaryConverter<TDictionary, TKey, TValue> : JsonDictionaryConverter<TDictionary>
        {
            protected JsonConverter<TKey> _keyConverter;

            protected JsonConverter<TValue> _valueConverter;

            internal override Type ElementType => typeof(TValue);

            internal override Type KeyType => typeof(TKey);

            /// <summary>
            /// When overridden, adds the value to the collection.
            /// </summary>
            protected abstract void Add(TKey key, in TValue value, JsonSerializerOptions options, ref ReadStack state);

            /// <summary>
            /// When overridden, converts the temporary collection held in state.Current.ReturnValue to the final collection.
            /// This is used with immutable collections.
            /// </summary>
            protected virtual void ConvertCollection(ref ReadStack state, JsonSerializerOptions options)
            {
            }

            /// <summary>
            /// When overridden, create the collection. It may be a temporary collection or the final collection.
            /// </summary>
            protected virtual void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state)
            {
                JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
                if (jsonTypeInfo.CreateObject == null)
                {
                    if (TypeToConvert.IsAbstract || TypeToConvert.IsInterface)
                    {
                        ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(TypeToConvert, ref reader, ref state);
                    }
                    else
                    {
                        ThrowHelper.ThrowNotSupportedException_DeserializeNoConstructor(TypeToConvert, ref reader, ref state);
                    }
                }
                state.Current.ReturnValue = jsonTypeInfo.CreateObject();
            }

            protected static JsonConverter<T> GetConverter<T>(JsonTypeInfo typeInfo)
            {
                return ((JsonTypeInfo<T>)typeInfo).EffectiveConverter;
            }

            internal sealed override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, [System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out TDictionary value)
            {
                JsonTypeInfo keyTypeInfo = state.Current.JsonTypeInfo.KeyTypeInfo;
                JsonTypeInfo elementTypeInfo = state.Current.JsonTypeInfo.ElementTypeInfo;
                if (!state.SupportContinuation && !state.Current.CanContainMetadata)
                {
                    if (reader.TokenType != JsonTokenType.StartObject)
                    {
                        ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(TypeToConvert);
                    }
                    CreateCollection(ref reader, ref state);
                    if (_keyConverter == null)
                    {
                        _keyConverter = GetConverter<TKey>(keyTypeInfo);
                    }
                    if (_valueConverter == null)
                    {
                        _valueConverter = GetConverter<TValue>(elementTypeInfo);
                    }
                    if (_valueConverter.CanUseDirectReadOrWrite && !state.Current.NumberHandling.HasValue)
                    {
                        while (true)
                        {
                            reader.ReadWithVerify();
                            if (reader.TokenType == JsonTokenType.EndObject)
                            {
                                break;
                            }
                            state.Current.JsonPropertyInfo = keyTypeInfo.PropertyInfoForTypeInfo;
                            TKey key = ReadDictionaryKey(_keyConverter, ref reader, ref state, options);
                            reader.ReadWithVerify();
                            state.Current.JsonPropertyInfo = elementTypeInfo.PropertyInfoForTypeInfo;
                            TValue value2 = _valueConverter.Read(ref reader, ElementType, options);
                            Add(key, in value2, options, ref state);
                        }
                    }
                    else
                    {
                        while (true)
                        {
                            reader.ReadWithVerify();
                            if (reader.TokenType == JsonTokenType.EndObject)
                            {
                                break;
                            }
                            state.Current.JsonPropertyInfo = keyTypeInfo.PropertyInfoForTypeInfo;
                            TKey key2 = ReadDictionaryKey(_keyConverter, ref reader, ref state, options);
                            reader.ReadWithVerify();
                            state.Current.JsonPropertyInfo = elementTypeInfo.PropertyInfoForTypeInfo;
                            _valueConverter.TryRead(ref reader, ElementType, options, ref state, out var value3);
                            Add(key2, in value3, options, ref state);
                        }
                    }
                }
                else
                {
                    JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
                    if (state.Current.ObjectState == StackFrameObjectState.None)
                    {
                        if (reader.TokenType != JsonTokenType.StartObject)
                        {
                            ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(TypeToConvert);
                        }
                        state.Current.ObjectState = StackFrameObjectState.StartToken;
                    }
                    if (state.Current.CanContainMetadata && (int)state.Current.ObjectState < 2)
                    {
                        if (!JsonSerializer.TryReadMetadata(this, jsonTypeInfo, ref reader, ref state))
                        {
                            value = default(TDictionary);
                            return false;
                        }
                        if (state.Current.MetadataPropertyNames == MetadataPropertyName.Ref)
                        {
                            value = JsonSerializer.ResolveReferenceId<TDictionary>(ref state);
                            return true;
                        }
                        state.Current.ObjectState = StackFrameObjectState.ReadMetadata;
                    }
                    if (state.Current.MetadataPropertyNames.HasFlag(MetadataPropertyName.Type) && state.Current.PolymorphicSerializationState != PolymorphicSerializationState.PolymorphicReEntryStarted)
                    {
                        JsonConverter jsonConverter = ResolvePolymorphicConverter(jsonTypeInfo, options, ref state);
                        if (jsonConverter != null)
                        {
                            object value4;
                            bool flag = jsonConverter.OnTryReadAsObject(ref reader, options, ref state, out value4);
                            value = (TDictionary)value4;
                            state.ExitPolymorphicConverter(flag);
                            return flag;
                        }
                    }
                    if ((int)state.Current.ObjectState < 4)
                    {
                        if (state.Current.CanContainMetadata)
                        {
                            JsonSerializer.ValidateMetadataForObjectConverter(this, ref reader, ref state);
                        }
                        CreateCollection(ref reader, ref state);
                        if (state.Current.MetadataPropertyNames.HasFlag(MetadataPropertyName.Id))
                        {
                            state.ReferenceResolver.AddReference(state.ReferenceId, state.Current.ReturnValue);
                            state.ReferenceId = null;
                        }
                        state.Current.ObjectState = StackFrameObjectState.CreatedObject;
                    }
                    if (_keyConverter == null)
                    {
                        _keyConverter = GetConverter<TKey>(keyTypeInfo);
                    }
                    if (_valueConverter == null)
                    {
                        _valueConverter = GetConverter<TValue>(elementTypeInfo);
                    }
                    while (true)
                    {
                        if (state.Current.PropertyState == StackFramePropertyState.None)
                        {
                            state.Current.PropertyState = StackFramePropertyState.ReadName;
                            if (!reader.Read())
                            {
                                value = default(TDictionary);
                                return false;
                            }
                        }
                        TKey val;
                        if ((int)state.Current.PropertyState < 2)
                        {
                            if (reader.TokenType == JsonTokenType.EndObject)
                            {
                                break;
                            }
                            state.Current.PropertyState = StackFramePropertyState.Name;
                            if (state.Current.CanContainMetadata)
                            {
                                ReadOnlySpan<byte> span = reader.GetSpan();
                                if (JsonSerializer.IsMetadataPropertyName(span, state.Current.BaseJsonTypeInfo.PolymorphicTypeResolver))
                                {
                                    ThrowHelper.ThrowUnexpectedMetadataException(span, ref reader, ref state);
                                }
                            }
                            state.Current.JsonPropertyInfo = keyTypeInfo.PropertyInfoForTypeInfo;
                            val = ReadDictionaryKey(_keyConverter, ref reader, ref state, options);
                        }
                        else
                        {
                            val = (TKey)state.Current.DictionaryKey;
                        }
                        if ((int)state.Current.PropertyState < 3)
                        {
                            state.Current.PropertyState = StackFramePropertyState.ReadValue;
                            if (!JsonConverter.SingleValueReadWithReadAhead(_valueConverter.RequiresReadAhead, ref reader, ref state))
                            {
                                state.Current.DictionaryKey = val;
                                value = default(TDictionary);
                                return false;
                            }
                        }
                        if ((int)state.Current.PropertyState < 5)
                        {
                            state.Current.JsonPropertyInfo = elementTypeInfo.PropertyInfoForTypeInfo;
                            if (!_valueConverter.TryRead(ref reader, typeof(TValue), options, ref state, out var value5))
                            {
                                state.Current.DictionaryKey = val;
                                value = default(TDictionary);
                                return false;
                            }
                            Add(val, in value5, options, ref state);
                            state.Current.EndElement();
                        }
                    }
                }
                ConvertCollection(ref state, options);
                value = (TDictionary)state.Current.ReturnValue;
                return true;
                static TKey ReadDictionaryKey(JsonConverter<TKey> keyConverter, ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
                {
                    string @string = reader.GetString();
                    state.Current.JsonPropertyNameAsString = @string;
                    if (keyConverter.IsInternalConverter && keyConverter.TypeToConvert == typeof(string))
                    {
                        return (TKey)(object)@string;
                    }
                    return keyConverter.ReadAsPropertyNameCore(ref reader, keyConverter.TypeToConvert, options);
                }
            }

            internal sealed override bool OnTryWrite(Utf8JsonWriter writer, TDictionary dictionary, JsonSerializerOptions options, ref WriteStack state)
            {
                if (dictionary == null)
                {
                    writer.WriteNullValue();
                    return true;
                }
                if (!state.Current.ProcessedStartToken)
                {
                    state.Current.ProcessedStartToken = true;
                    writer.WriteStartObject();
                    if (state.CurrentContainsMetadata && CanHaveMetadata)
                    {
                        JsonSerializer.WriteMetadataForObject(this, ref state, writer);
                    }
                    state.Current.JsonPropertyInfo = state.Current.JsonTypeInfo.ElementTypeInfo.PropertyInfoForTypeInfo;
                }
                bool flag = OnWriteResume(writer, dictionary, options, ref state);
                if (flag && !state.Current.ProcessedEndToken)
                {
                    state.Current.ProcessedEndToken = true;
                    writer.WriteEndObject();
                }
                return flag;
            }
        }

        /// <summary>
        /// When placed on a property or field of type <see cref="T:System.Text.Json.Nodes.JsonObject" /> or
        /// <see cref="T:System.Collections.Generic.IDictionary`2" />, any properties that do not have a
        /// matching property or field are added during deserialization and written during serialization.
        /// </summary>
        /// <remarks>
        /// When using <see cref="T:System.Collections.Generic.IDictionary`2" />, the TKey value must be <see cref="T:System.String" />
        /// and TValue must be <see cref="T:System.Text.Json.JsonElement" /> or <see cref="T:System.Object" />.
        ///
        /// During deserializing with a <see cref="T:System.Collections.Generic.IDictionary`2" /> extension property with TValue as
        /// <see cref="T:System.Object" />, the type of object created will either be a <see cref="T:System.Text.Json.Nodes.JsonNode" /> or a
        /// <see cref="T:System.Text.Json.JsonElement" /> depending on the value of <see cref="P:System.Text.Json.JsonSerializerOptions.UnknownTypeHandling" />.
        ///
        /// If a <see cref="T:System.Text.Json.JsonElement" /> is created, a "null" JSON value is treated as a JsonElement with <see cref="P:System.Text.Json.JsonElement.ValueKind" />
        /// set to <see cref="F:System.Text.Json.JsonValueKind.Null" />, otherwise a "null" JSON value is treated as a <c>null</c> object reference.
        ///
        /// During serializing, the name of the extension data member is not included in the JSON;
        /// the data contained within the extension data is serialized as properties of the JSON object.
        ///
        /// If there is more than one extension member on a type, or the member is not of the correct type,
        /// an <see cref="T:System.InvalidOperationException" /> is thrown during the first serialization or deserialization of that type.
        /// </remarks>
        [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
        public sealed class JsonExtensionDataAttribute : JsonAttribute { }

        /// <summary>
        /// Prevents a property or field from being serialized or deserialized.
        /// </summary>
        [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
        public sealed class JsonIgnoreAttribute : JsonAttribute
        {
            /// <summary>
            /// Specifies the condition that must be met before a property or field will be ignored.
            /// </summary>
            /// <remarks>The default value is <see cref="F:System.Text.Json.Serialization.JsonIgnoreCondition.Always" />.</remarks>
            public JsonIgnoreCondition Condition { get; set; } = JsonIgnoreCondition.Always;


            /// <summary>
            /// Initializes a new instance of <see cref="T:System.Text.Json.Serialization.JsonIgnoreAttribute" />.
            /// </summary>
            public JsonIgnoreAttribute()
            {
            }
        }

        /// <summary>
        /// When specified on <see cref="JsonSerializerOptions.DefaultIgnoreCondition" />,
        /// determines when properties and fields across the type graph are ignored.
        /// When specified on <see cref="JsonIgnoreAttribute.Condition" />, controls whether
        /// a property or field is ignored during serialization and deserialization. This option
        /// overrides the setting on <see cref="JsonSerializerOptions.DefaultIgnoreCondition" />.
        /// </summary>
        public enum JsonIgnoreCondition
        {
            /// <summary>
            /// Property is never ignored during serialization or deserialization.
            /// </summary>
            Never,
            /// <summary>
            /// Property is always ignored during serialization and deserialization.
            /// </summary>
            Always,
            /// <summary>
            /// If the value is the default, the property is ignored during serialization.
            /// This is applied to both reference and value-type properties and fields.
            /// </summary>
            WhenWritingDefault,
            /// <summary>
            /// If the value is <see langword="null" />, the property is ignored during serialization.
            /// This is applied only to reference-type properties and fields.
            /// </summary>
            WhenWritingNull
        }

        /// <summary>
        /// Indicates that the property or field should be included for serialization and deserialization.
        /// </summary>
        /// <remarks>
        /// When applied to a public property, indicates that non-public getters and setters should be used for serialization and deserialization.
        ///
        /// Non-public properties and fields are not allowed when serializing and deserializing. If the attribute is used on a non-public property or field,
        /// an <see cref="InvalidOperationException" /> is thrown during the first serialization or deserialization of the declaring type.
        /// </remarks>
        [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
        public sealed class JsonIncludeAttribute : JsonAttribute
        {
            /// <summary>
            /// Initializes a new instance of <see cref="JsonIncludeAttribute" />.
            /// </summary>
            public JsonIncludeAttribute() { }
        }

        /// <summary>
        /// The <see cref="JsonNamingPolicy" /> to be used at run time.
        /// </summary>
        public enum JsonKnownNamingPolicy
        {
            /// <summary>
            /// Specifies that JSON property names should not be converted.
            /// </summary>
            Unspecified,
            /// <summary>
            /// Specifies that the built-in <see cref="P:System.Text.Json.JsonNamingPolicy.CamelCase" /> be used to convert JSON property names.
            /// </summary>
            CamelCase
        }

        /// <summary>
        /// Determines how <see cref="T:System.Text.Json.JsonSerializer" /> handles numbers when serializing and deserializing.
        /// <remarks>
        /// The behavior of <see cref="F:System.Text.Json.Serialization.JsonNumberHandling.WriteAsString" /> and <see cref="F:System.Text.Json.Serialization.JsonNumberHandling.AllowNamedFloatingPointLiterals" /> is not defined by the JSON specification. Altering the default number handling can potentially produce JSON that cannot be parsed by other JSON implementations.
        /// </remarks>
        /// </summary>
        [Flags]
        public enum JsonNumberHandling
        {
            /// <summary>
            /// Numbers will only be read from <see cref="F:System.Text.Json.JsonTokenType.Number" /> tokens and will only be written as JSON numbers (without quotes).
            /// </summary>
            Strict = 0,
            /// <summary>
            /// Numbers can be read from <see cref="F:System.Text.Json.JsonTokenType.String" /> tokens.
            /// Does not prevent numbers from being read from <see cref="F:System.Text.Json.JsonTokenType.Number" /> token.
            /// Strings that have escaped characters will be unescaped before reading.
            /// Leading or trailing trivia within the string token, including whitespace, is not allowed.
            /// </summary>
            AllowReadingFromString = 1,
            /// <summary>
            /// Numbers will be written as JSON strings (with quotes), not as JSON numbers.
            /// <remarks>
            /// This behavior is not defined by the JSON specification. Altering the default number handling can potentially produce JSON that cannot be parsed by other JSON implementations.
            /// </remarks>
            /// </summary>
            WriteAsString = 2,
            /// <summary>
            /// The "NaN", "Infinity", and "-Infinity" <see cref="F:System.Text.Json.JsonTokenType.String" /> tokens can be read as
            /// floating-point constants, and the <see cref="T:System.Single" /> and <see cref="T:System.Double" /> values for these
            /// constants (such as <see cref="F:System.Single.PositiveInfinity" /> and <see cref="F:System.Double.NaN" />)
            /// will be written as their corresponding JSON string representations.
            /// Strings that have escaped characters will be unescaped before reading.
            /// Leading or trailing trivia within the string token, including whitespace, is not allowed.
            /// <remarks>
            /// This behavior is not defined by the JSON specification. Altering the default number handling can potentially produce JSON that cannot be parsed by other JSON implementations.
            /// </remarks>
            /// </summary>
            AllowNamedFloatingPointLiterals = 4
        }

        /// <summary>
        /// When placed on a type, property, or field, indicates what <see cref="T:System.Text.Json.Serialization.JsonNumberHandling" />
        /// settings should be used when serializing or deserializing numbers.
        /// </summary>
        [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
        public sealed class JsonNumberHandlingAttribute : JsonAttribute
        {
            /// <summary>
            /// Indicates what settings should be used when serializing or deserializing numbers.
            /// </summary>
            public JsonNumberHandling Handling { get; }

            /// <summary>
            /// Initializes a new instance of <see cref="T:System.Text.Json.Serialization.JsonNumberHandlingAttribute" />.
            /// </summary>
            public JsonNumberHandlingAttribute(JsonNumberHandling handling)
            {
                if (!JsonSerializer.IsValidNumberHandlingValue(handling))
                {
                    throw new ArgumentOutOfRangeException("handling");
                }
                Handling = handling;
            }
        }

        /// <summary>
        /// Base class for non-enumerable, non-primitive objects where public properties
        /// are (de)serialized as a JSON object.
        /// </summary>
        internal abstract class JsonObjectConverter<T> : JsonResumableConverter<T>
        {
            internal sealed override ConverterStrategy ConverterStrategy => ConverterStrategy.Object;

            internal sealed override Type ElementType => null;
        }

        /// <summary>
        /// When placed on a type, indicates that the type should be serialized polymorphically.
        /// </summary>
        [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple = false, Inherited = false)]
        public sealed class JsonPolymorphicAttribute : JsonAttribute
        {
            /// <summary>
            /// Gets or sets a custom type discriminator property name for the polymorhic type.
            /// Uses the default '$type' property name if left unset.
            /// </summary>
            public string? TypeDiscriminatorPropertyName { get; set; }

            /// <summary>
            /// Gets or sets the behavior when serializing an undeclared derived runtime type.
            /// </summary>
            public JsonUnknownDerivedTypeHandling UnknownDerivedTypeHandling { get; set; }

            /// <summary>
            /// When set to <see langword="true" />, instructs the deserializer to ignore any
            /// unrecognized type discriminator id's and reverts to the contract of the base type.
            /// Otherwise, it will fail the deserialization.
            /// </summary>
            public bool IgnoreUnrecognizedTypeDiscriminators { get; set; }
        }

        /// <summary>
        /// Specifies the property name that is present in the JSON when serializing and deserializing.
        /// This overrides any naming policy specified by <see cref="T:System.Text.Json.JsonNamingPolicy" />.
        /// </summary>
        [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
        public sealed class JsonPropertyNameAttribute : JsonAttribute
        {
            /// <summary>
            /// The name of the property.
            /// </summary>
            public string Name { get; }

            /// <summary>
            /// Initializes a new instance of <see cref="T:System.Text.Json.Serialization.JsonPropertyNameAttribute" /> with the specified property name.
            /// </summary>
            /// <param name="name">The name of the property.</param>
            public JsonPropertyNameAttribute(string name)
            {
                Name = name;
            }
        }

        /// <summary>
        /// Specifies the property order that is present in the JSON when serializing. Lower values are serialized first.
        /// If the attribute is not specified, the default value is 0.
        /// </summary>
        /// <remarks>If multiple properties have the same value, the ordering is undefined between them.</remarks>
        [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
        public sealed class JsonPropertyOrderAttribute : JsonAttribute
        {
            /// <summary>
            /// The serialization order of the property.
            /// </summary>
            public int Order { get; }

            /// <summary>
            /// Initializes a new instance of <see cref="T:System.Text.Json.Serialization.JsonPropertyOrderAttribute" /> with the specified order.
            /// </summary>
            /// <param name="order">The order of the property.</param>
            public JsonPropertyOrderAttribute(int order)
            {
                Order = order;
            }
        }

        /// <summary>
        /// Indicates that the annotated member must bind to a JSON property on deserialization.
        /// </summary>
        /// <remarks>
        /// <see langword="null" /> token in JSON will not trigger a validation error.
        /// For contracts originating from <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" /> or <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" />,
        /// this attribute will be mapped to <see cref="P:System.Text.Json.Serialization.Metadata.JsonPropertyInfo.IsRequired" />.
        /// </remarks>
        [AttributeUsage(AttributeTargets.Property | AttributeTargets.Field, AllowMultiple = false)]
        public sealed class JsonRequiredAttribute : JsonAttribute
        {
            /// <summary>
            /// Initializes a new instance of <see cref="T:System.Text.Json.Serialization.JsonRequiredAttribute" />.
            /// </summary>
            public JsonRequiredAttribute() { }
        }

        /// <summary>
        /// Base class for converters that are able to resume after reading or writing to a buffer.
        /// This is used when the Stream-based serialization APIs are used.
        /// </summary>
        /// <typeparam name="T"></typeparam>
        internal abstract class JsonResumableConverter<T> : JsonConverter<T>
        {
            public sealed override bool HandleNull => false;

            public sealed override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
            {
                if (options == null)
                {
                    ThrowHelper.ThrowArgumentNullException("options");
                }
                ReadStack state = default(ReadStack);
                JsonTypeInfo typeInfoInternal = options.GetTypeInfoInternal(typeToConvert);
                state.Initialize(typeInfoInternal);
                TryRead(ref reader, typeToConvert, options, ref state, out var value);
                return value;
            }

            public sealed override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options)
            {
                if (options == null)
                {
                    ThrowHelper.ThrowArgumentNullException("options");
                }
                WriteStack state = default(WriteStack);
                JsonTypeInfo typeInfoInternal = options.GetTypeInfoInternal(typeof(T));
                state.Initialize(typeInfoInternal);
                try
                {
                    TryWrite(writer, in value, options, ref state);
                }
                catch
                {
                    state.DisposePendingDisposablesOnException();
                    throw;
                }
            }
        }

        /// <summary>
        /// Instructs the System.Text.Json source generator to generate source code to help optimize performance
        /// when serializing and deserializing instances of the specified type and types in its object graph.
        /// </summary>
        [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
        public sealed class JsonSerializableAttribute : JsonAttribute
        {
            /// <summary>
            /// The name of the property for the generated <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo`1" /> for
            /// the type on the generated, derived <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" /> type.
            /// </summary>
            /// <remarks>
            /// Useful to resolve a name collision with another type in the compilation closure.
            /// </remarks>
            public string? TypeInfoPropertyName { get; set; }

            /// <summary>
            /// Determines what the source generator should generate for the type. If the value is <see cref="F:System.Text.Json.Serialization.JsonSourceGenerationMode.Default" />,
            /// then the setting specified on <see cref="P:System.Text.Json.Serialization.JsonSourceGenerationOptionsAttribute.GenerationMode" /> will be used.
            /// </summary>
            public JsonSourceGenerationMode GenerationMode { get; set; }

            /// <summary>
            /// Initializes a new instance of <see cref="T:System.Text.Json.Serialization.JsonSerializableAttribute" /> with the specified type.
            /// </summary>
            /// <param name="type">The type to generate source code for.</param>
            public JsonSerializableAttribute(Type type)
            {
            }
        }

        /// <summary>
        /// Provides metadata about a set of types that is relevant to JSON serialization.
        /// </summary>
        public abstract class JsonSerializerContext : IJsonTypeInfoResolver
        {
            private bool? _canUseSerializationLogic;

            private JsonSerializerOptions _options;

            /// <summary>
            /// Gets the run time specified options of the context. If no options were passed
            /// when instanciating the context, then a new instance is bound and returned.
            /// </summary>
            /// <remarks>
            /// The options instance cannot be mutated once it is bound to the context instance.
            /// </remarks>
            public JsonSerializerOptions Options
            {
                get
                {
                    JsonSerializerOptions jsonSerializerOptions = _options;
                    if (jsonSerializerOptions == null)
                    {
                        JsonSerializerOptions obj = new JsonSerializerOptions
                        {
                            TypeInfoResolver = this,
                            IsImmutable = true
                        };
                        JsonSerializerOptions jsonSerializerOptions2 = obj;
                        _options = obj;
                        jsonSerializerOptions = jsonSerializerOptions2;
                    }
                    return jsonSerializerOptions;
                }
                internal set
                {
                    value.TypeInfoResolver = this;
                    value.IsImmutable = true;
                    _options = value;
                }
            }

            /// <summary>
            /// Indicates whether pre-generated serialization logic for types in the context
            /// is compatible with the run time specified <see cref="T:System.Text.Json.JsonSerializerOptions" />.
            /// </summary>
            internal bool CanUseSerializationLogic
            {
                get
                {
                    if (!_canUseSerializationLogic.HasValue)
                    {
                        if (GeneratedSerializerOptions == null)
                        {
                            _canUseSerializationLogic = false;
                        }
                        else
                        {
                            _canUseSerializationLogic = Options.Converters.Count == 0 && Options.Encoder == null && (Options.NumberHandling & (JsonNumberHandling.WriteAsString | JsonNumberHandling.AllowNamedFloatingPointLiterals)) == 0 && Options.ReferenceHandlingStrategy == ReferenceHandlingStrategy.None && !Options.IgnoreNullValues && Options.DefaultIgnoreCondition == GeneratedSerializerOptions.DefaultIgnoreCondition && Options.IgnoreReadOnlyFields == GeneratedSerializerOptions.IgnoreReadOnlyFields && Options.IgnoreReadOnlyProperties == GeneratedSerializerOptions.IgnoreReadOnlyProperties && Options.IncludeFields == GeneratedSerializerOptions.IncludeFields && Options.PropertyNamingPolicy == GeneratedSerializerOptions.PropertyNamingPolicy && Options.DictionaryKeyPolicy == GeneratedSerializerOptions.DictionaryKeyPolicy && Options.WriteIndented == GeneratedSerializerOptions.WriteIndented;
                        }
                    }
                    return _canUseSerializationLogic.Value;
                }
            }

            /// <summary>
            /// The default run time options for the context. Its values are defined at design-time via <see cref="T:System.Text.Json.Serialization.JsonSourceGenerationOptionsAttribute" />.
            /// </summary>
            protected abstract JsonSerializerOptions? GeneratedSerializerOptions { get; }

            /// <summary>
            /// Creates an instance of <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" /> and binds it with the indicated <see cref="T:System.Text.Json.JsonSerializerOptions" />.
            /// </summary>
            /// <param name="options">The run time provided options for the context instance.</param>
            /// <remarks>
            /// If no instance options are passed, then no options are set until the context is bound using <see cref="M:System.Text.Json.JsonSerializerOptions.AddContext``1" />,
            /// or until <see cref="P:System.Text.Json.Serialization.JsonSerializerContext.Options" /> is called, where a new options instance is created and bound.
            /// </remarks>
            protected JsonSerializerContext(JsonSerializerOptions? options)
            {
                if (options != null)
                {
                    options.VerifyMutable();
                    Options = options;
                }
            }

            /// <summary>
            /// Returns a <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance representing the given type.
            /// </summary>
            /// <param name="type">The type to fetch metadata about.</param>
            /// <returns>The metadata for the specified type, or <see langword="null" /> if the context has no metadata for the type.</returns>
            public abstract JsonTypeInfo? GetTypeInfo(Type type);

            JsonTypeInfo IJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options)
            {
                if (options != null && options != _options)
                {
                    ThrowHelper.ThrowInvalidOperationException_ResolverTypeInfoOptionsNotCompatible();
                }
                return GetTypeInfo(type);
            }
        }

        /// <summary>
        /// The generation mode for the System.Text.Json source generator.
        /// </summary>
        [Flags]
        public enum JsonSourceGenerationMode
        {
            /// <summary>
            /// When specified on <see cref="P:System.Text.Json.Serialization.JsonSourceGenerationOptionsAttribute.GenerationMode" />, indicates that both type-metadata initialization logic
            /// and optimized serialization logic should be generated for all types. When specified on <see cref="P:System.Text.Json.Serialization.JsonSerializableAttribute.GenerationMode" />,
            /// indicates that the setting on <see cref="P:System.Text.Json.Serialization.JsonSourceGenerationOptionsAttribute.GenerationMode" /> should be used.
            /// </summary>
            Default = 0,
            /// <summary>
            /// Instructs the JSON source generator to generate type-metadata initialization logic.
            /// </summary>
            /// <remarks>
            /// This mode supports all <see cref="T:System.Text.Json.JsonSerializer" /> features.
            /// </remarks>
            Metadata = 1,
            /// <summary>
            /// Instructs the JSON source generator to generate optimized serialization logic.
            /// </summary>
            /// <remarks>
            /// This mode supports only a subset of <see cref="T:System.Text.Json.JsonSerializer" /> features.
            /// </remarks>
            Serialization = 2
        }

        /// <summary>
        /// Instructs the System.Text.Json source generator to assume the specified
        /// options will be used at run time via <see cref="T:System.Text.Json.JsonSerializerOptions" />.
        /// </summary>
        [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
        public sealed class JsonSourceGenerationOptionsAttribute : JsonAttribute
        {
            /// <summary>
            /// Specifies the default ignore condition.
            /// </summary>
            public JsonIgnoreCondition DefaultIgnoreCondition { get; set; }

            /// <summary>
            /// Specifies whether to ignore read-only fields.
            /// </summary>
            public bool IgnoreReadOnlyFields { get; set; }

            /// <summary>
            /// Specifies whether to ignore read-only properties.
            /// </summary>
            public bool IgnoreReadOnlyProperties { get; set; }

            /// <summary>
            /// Specifies whether to include fields for serialization and deserialization.
            /// </summary>
            public bool IncludeFields { get; set; }

            /// <summary>
            /// Specifies a built-in naming polices to convert JSON property names with.
            /// </summary>
            public JsonKnownNamingPolicy PropertyNamingPolicy { get; set; }

            /// <summary>
            /// Specifies whether JSON output should be pretty-printed.
            /// </summary>
            public bool WriteIndented { get; set; }

            /// <summary>
            /// Specifies the source generation mode for types that don't explicitly set the mode with <see cref="P:System.Text.Json.Serialization.JsonSerializableAttribute.GenerationMode" />.
            /// </summary>
            public JsonSourceGenerationMode GenerationMode { get; set; }
        }

        /// <summary>
        /// Converter to convert enums to and from strings.
        /// </summary>
        /// <remarks>
        /// Reading is case insensitive, writing can be customized via a <see cref="T:System.Text.Json.JsonNamingPolicy" />.
        /// </remarks>
        [RequiresDynamicCode("JsonStringEnumConverter cannot be statically analyzed and requires runtime code generation. Consider authoring a custom converter that is not a factory to work around the issue. See https://github.com/dotnet/runtime/issues/73124.")]
        public class JsonStringEnumConverter : JsonConverterFactory
        {
            private readonly JsonNamingPolicy _namingPolicy;

            private readonly EnumConverterOptions _converterOptions;

            /// <summary>
            /// Constructor. Creates the <see cref="T:System.Text.Json.Serialization.JsonStringEnumConverter" /> with the
            /// default naming policy and allows integer values.
            /// </summary>
            public JsonStringEnumConverter()
                : this(null, allowIntegerValues: true)
            {
            }

            /// <summary>
            /// Constructor.
            /// </summary>
            /// <param name="namingPolicy">
            /// Optional naming policy for writing enum values.
            /// </param>
            /// <param name="allowIntegerValues">
            /// True to allow undefined enum values. When true, if an enum value isn't
            /// defined it will output as a number rather than a string.
            /// </param>
            public JsonStringEnumConverter(JsonNamingPolicy? namingPolicy = null, bool allowIntegerValues = true)
            {
                _namingPolicy = namingPolicy;
                _converterOptions = ((!allowIntegerValues) ? EnumConverterOptions.AllowStrings : (EnumConverterOptions.AllowStrings | EnumConverterOptions.AllowNumbers));
            }

            /// <inheritdoc />
            public sealed override bool CanConvert(Type typeToConvert)
            {
                return typeToConvert.IsEnum;
            }

            /// <inheritdoc />
            public sealed override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
            {
                return EnumConverterFactory.Create(typeToConvert, _converterOptions, _namingPolicy, options);
            }
        }

        /// <summary>
        /// Defines how objects of a derived runtime type that has not been explicitly declared for polymorphic serialization should be handled.
        /// </summary>
        public enum JsonUnknownDerivedTypeHandling
        {
            /// <summary>
            /// An object of undeclared runtime type will fail polymorphic serialization.
            /// </summary>
            FailSerialization,
            /// <summary>
            /// An object of undeclared runtime type will fall back to the serialization contract of the base type.
            /// </summary>
            FallBackToBaseType,
            /// <summary>
            /// An object of undeclared runtime type will revert to the serialization contract of the nearest declared ancestor type.
            /// Certain interface hierarchies are not supported due to diamond ambiguity constraints.
            /// </summary>
            FallBackToNearestAncestor
        }

        /// <summary>
        /// Defines how deserializing a type declared as an <see cref="T:System.Object" /> is handled during deserialization.
        /// </summary>
        public enum JsonUnknownTypeHandling
        {
            /// <summary>
            /// A type declared as <see cref="T:System.Object" /> is deserialized as a <see cref="F:System.Text.Json.Serialization.JsonUnknownTypeHandling.JsonElement" />.
            /// </summary>
            JsonElement,
            /// <summary>
            /// A type declared as <see cref="T:System.Object" /> is deserialized as a <see cref="F:System.Text.Json.Serialization.JsonUnknownTypeHandling.JsonNode" />.
            /// </summary>
            JsonNode
        }

        internal sealed class PreserveReferenceHandler : ReferenceHandler
        {
            public override ReferenceResolver CreateResolver()
            {
                throw new InvalidOperationException();
            }

            internal override ReferenceResolver CreateResolver(bool writing)
            {
                return new PreserveReferenceResolver(writing);
            }
        }

        /// <summary>
        /// The default ReferenceResolver implementation to handle duplicate object references.
        /// </summary>
        internal sealed class PreserveReferenceResolver : ReferenceResolver
        {
            private uint _referenceCount;

            private readonly Dictionary<string, object> _referenceIdToObjectMap;

            private readonly Dictionary<object, string> _objectToReferenceIdMap;

            public PreserveReferenceResolver(bool writing)
            {
                if (writing)
                {
                    _objectToReferenceIdMap = new Dictionary<object, string>(ReferenceEqualityComparer.Instance);
                }
                else
                {
                    _referenceIdToObjectMap = new Dictionary<string, object>();
                }
            }

            public override void AddReference(string referenceId, object value)
            {
                if (!_referenceIdToObjectMap.TryAdd(in referenceId, in value))
                {
                    ThrowHelper.ThrowJsonException_MetadataDuplicateIdFound(referenceId);
                }
            }

            public override string GetReference(object value, out bool alreadyExists)
            {
                if (_objectToReferenceIdMap.TryGetValue(value, out var value2))
                {
                    alreadyExists = true;
                }
                else
                {
                    _referenceCount++;
                    value2 = _referenceCount.ToString();
                    _objectToReferenceIdMap.Add(value, value2);
                    alreadyExists = false;
                }
                return value2;
            }

            public override object ResolveReference(string referenceId)
            {
                if (!_referenceIdToObjectMap.TryGetValue(referenceId, out var value))
                {
                    ThrowHelper.ThrowJsonException_MetadataReferenceNotFound(referenceId);
                }
                return value;
            }
        }

        [StructLayout(LayoutKind.Auto)]
        internal struct ReadBufferState : IDisposable
        {
            private byte[] _buffer;

            private byte _offset;

            private int _count;

            private int _maxCount;

            private bool _isFirstBlock;

            private bool _isFinalBlock;

            public bool IsFinalBlock => _isFinalBlock;

            public ReadOnlySpan<byte> Bytes => _buffer.AsSpan(_offset, _count);

            public ReadBufferState(int initialBufferSize)
            {
                _buffer = ArrayPool<byte>.Shared.Rent(Math.Max(initialBufferSize, JsonConstants.Utf8Bom.Length));
                _maxCount = (_count = (_offset = 0));
                _isFirstBlock = true;
                _isFinalBlock = false;
            }

            /// <summary>
            /// Read from the stream until either our buffer is filled or we hit EOF.
            /// Calling ReadCore is relatively expensive, so we minimize the number of times
            /// we need to call it.
            /// </summary>
            public readonly async ValueTask<ReadBufferState> ReadFromStreamAsync(Stream utf8Json, CancellationToken cancellationToken, bool fillBuffer = true)
            {
                ReadBufferState bufferState = this;
                do
                {
                    int num = await utf8Json.ReadAsync(bufferState._buffer, bufferState._count, bufferState._buffer.Length - bufferState._count, cancellationToken).ConfigureAwait(continueOnCapturedContext: false);
                    if (num == 0)
                    {
                        bufferState._isFinalBlock = true;
                        break;
                    }
                    bufferState._count += num;
                }
                while (fillBuffer && bufferState._count < bufferState._buffer.Length);
                bufferState.ProcessReadBytes();
                return bufferState;
            }

            /// <summary>
            /// Read from the stream until either our buffer is filled or we hit EOF.
            /// Calling ReadCore is relatively expensive, so we minimize the number of times
            /// we need to call it.
            /// </summary>
            public void ReadFromStream(Stream utf8Json)
            {
                do
                {
                    int num = utf8Json.Read(_buffer, _count, _buffer.Length - _count);
                    if (num == 0)
                    {
                        _isFinalBlock = true;
                        break;
                    }
                    _count += num;
                }
                while (_count < _buffer.Length);
                ProcessReadBytes();
            }

            /// <summary>
            /// Advances the buffer in anticipation of a subsequent read operation.
            /// </summary>
            public void AdvanceBuffer(int bytesConsumed)
            {
                _count -= bytesConsumed;
                if (!_isFinalBlock)
                {
                    if ((uint)_count > (uint)_buffer.Length / 2u)
                    {
                        byte[] buffer = _buffer;
                        int maxCount = _maxCount;
                        byte[] array = ArrayPool<byte>.Shared.Rent((_buffer.Length < 1073741823) ? (_buffer.Length * 2) : int.MaxValue);
                        Buffer.BlockCopy(buffer, _offset + bytesConsumed, array, 0, _count);
                        _buffer = array;
                        _maxCount = _count;
                        new Span<byte>(buffer, 0, maxCount).Clear();
                        ArrayPool<byte>.Shared.Return(buffer);
                    }
                    else if (_count != 0)
                    {
                        Buffer.BlockCopy(_buffer, _offset + bytesConsumed, _buffer, 0, _count);
                    }
                }
                _offset = 0;
            }

            private void ProcessReadBytes()
            {
                if (_count > _maxCount)
                {
                    _maxCount = _count;
                }
                if (_isFirstBlock)
                {
                    _isFirstBlock = false;
                    if (_buffer.AsSpan(0, _count).StartsWith(JsonConstants.Utf8Bom))
                    {
                        _offset = (byte)JsonConstants.Utf8Bom.Length;
                        _count -= JsonConstants.Utf8Bom.Length;
                    }
                }
            }

            public void Dispose()
            {
                new Span<byte>(_buffer, 0, _maxCount).Clear();
                byte[] buffer = _buffer;
                _buffer = null;
                ArrayPool<byte>.Shared.Return(buffer);
            }
        }

        internal struct ReferenceEqualsWrapper : IEquatable<ReferenceEqualsWrapper>
        {
            private object _object;

            public ReferenceEqualsWrapper(object obj)
            {
                _object = obj;
            }

            public override bool Equals([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] object obj)
            {
                if (obj is ReferenceEqualsWrapper obj2)
                {
                    return Equals(obj2);
                }
                return false;
            }

            public bool Equals(ReferenceEqualsWrapper obj)
            {
                return _object == obj._object;
            }

            public override int GetHashCode()
            {
                return RuntimeHelpers.GetHashCode(_object);
            }
        }

        /// <summary>
        /// This class defines how the <see cref="T:System.Text.Json.JsonSerializer" /> deals with references on serialization and deserialization.
        /// </summary>
        public abstract class ReferenceHandler
        {
            /// <summary>
            /// Indicates whether this ReferenceHandler implementation should use <see cref="F:System.Text.Json.Serialization.ReferenceHandlingStrategy.Preserve" /> semantics or <see cref="F:System.Text.Json.Serialization.ReferenceHandlingStrategy.IgnoreCycles" /> semantics.
            /// The defualt is Preserve.
            /// </summary>
            internal ReferenceHandlingStrategy HandlingStrategy = ReferenceHandlingStrategy.Preserve;

            /// <summary>
            /// Metadata properties will be honored when deserializing JSON objects and arrays into reference types and written when serializing reference types. This is necessary to create round-trippable JSON from objects that contain cycles or duplicate references.
            /// </summary>
            /// <remarks>
            /// * On Serialize:
            /// When writing complex reference types, the serializer also writes metadata properties (`$id`, `$values`, and `$ref`) within them.
            /// The output JSON will contain an extra `$id` property for every object, and for every enumerable type the JSON array emitted will be nested within a JSON object containing an `$id` and `$values` property.
            /// <see cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" /> is used to determine whether objects are identical.
            /// When an object is identical to a previously serialized one, a pointer (`$ref`) to the identifier (`$id`) of such object is written instead.
            /// No metadata properties are written for value types.
            /// * On Deserialize:
            /// The metadata properties within the JSON that are used to preserve duplicated references and cycles will be honored as long as they are well-formed**.
            /// For JSON objects that don't contain any metadata properties, the deserialization behavior is identical to <see langword="null" />.
            /// For value types:
            ///   * The `$id` metadata property is ignored.
            ///   * A <see cref="T:System.Text.Json.JsonException" /> is thrown if a `$ref` metadata property is found within the JSON object.
            ///   * For enumerable value types, the `$values` metadata property is ignored.
            /// ** For the metadata properties within the JSON to be considered well-formed, they must follow these rules:
            ///   1) The `$id` metadata property must be the first property in the JSON object.
            ///   2) A JSON object that contains a `$ref` metadata property must not contain any other properties.
            ///   3) The value of the `$ref` metadata property must refer to an `$id` that has appeared earlier in the JSON.
            ///   4) The value of the `$id` and `$ref` metadata properties must be a JSON string.
            ///   5) For enumerable types, such as <see cref="T:System.Collections.Generic.List`1" />, the JSON array must be nested within a JSON object containing an `$id` and `$values` metadata property, in that order.
            ///   6) For enumerable types, the `$values` metadata property must be a JSON array.
            ///   7) The `$values` metadata property is only valid when referring to enumerable types.
            /// If the JSON is not well-formed, a <see cref="T:System.Text.Json.JsonException" /> is thrown.
            /// </remarks>
            public static ReferenceHandler Preserve { get; } = new PreserveReferenceHandler();


            /// <summary>
            /// Ignores an object when a reference cycle is detected during serialization.
            /// </summary>
            public static ReferenceHandler IgnoreCycles { get; } = new IgnoreReferenceHandler();


            /// <summary>
            /// Returns the <see cref="T:System.Text.Json.Serialization.ReferenceResolver" /> used for each serialization call.
            /// </summary>
            /// <returns>The resolver to use for serialization and deserialization.</returns>
            public abstract ReferenceResolver CreateResolver();

            /// <summary>
            /// Optimization for the resolver used when <see cref="P:System.Text.Json.Serialization.ReferenceHandler.Preserve" /> is set in <see cref="P:System.Text.Json.JsonSerializerOptions.ReferenceHandler" />;
            /// we pass a flag signaling whether this is called from serialization or deserialization to save one dictionary instantiation.
            /// </summary>
            internal virtual ReferenceResolver CreateResolver(bool writing)
            {
                return CreateResolver();
            }
        }
       
        /// <summary>
        /// This class defines how the <see cref="T:System.Text.Json.JsonSerializer" /> deals with references on serialization and deserialization.
        /// </summary>
        /// <typeparam name="T">The type of the <see cref="T:System.Text.Json.Serialization.ReferenceResolver" /> to create on each serialization or deserialization call.</typeparam>
        public sealed class ReferenceHandler<T> : ReferenceHandler where T : ReferenceResolver, new()
        {
            /// <summary>
            /// Creates a new <see cref="T:System.Text.Json.Serialization.ReferenceResolver" /> of type <typeparamref name="T" /> used for each serialization call.
            /// </summary>
            /// <returns>The new resolver to use for serialization and deserialization.</returns>
            public override ReferenceResolver CreateResolver()
            {
                return new T();
            }
        }

        internal enum ReferenceHandlingStrategy { None, Preserve, IgnoreCycles }

        /// <summary>
        /// This class defines how the <see cref="T:System.Text.Json.JsonSerializer" /> deals with references on serialization and deserialization.
        /// Defines the core behavior of preserving references on serialization and deserialization.
        /// </summary>
        public abstract class ReferenceResolver
        {
            /// <summary>
            /// Adds an entry to the bag of references using the specified id and value.
            /// This method gets called when an $id metadata property from a JSON object is read.
            /// </summary>
            /// <param name="referenceId">The identifier of the respective JSON object or array.</param>
            /// <param name="value">The value of the respective CLR reference type object that results from parsing the JSON object.</param>
            public abstract void AddReference(string referenceId, object value);

            /// <summary>
            /// Gets the reference identifier of the specified value if exists; otherwise a new id is assigned.
            /// This method gets called before a CLR object is written so we can decide whether to write $id and enumerate the rest of its properties or $ref and step into the next object.
            /// </summary>
            /// <param name="value">The value of the CLR reference type object to get an id for.</param>
            /// <param name="alreadyExists">When this method returns, <see langword="true" /> if a reference to value already exists; otherwise, <see langword="false" />.</param>
            /// <returns>The reference id for the specified object.</returns>
            public abstract string GetReference(object value, out bool alreadyExists);

            /// <summary>
            /// Returns the CLR reference type object related to the specified reference id.
            /// This method gets called when $ref metadata property is read.
            /// </summary>
            /// <param name="referenceId">The reference id related to the returned object.</param>
            /// <returns>The reference type object related to specified reference id.</returns>
            public abstract object ResolveReference(string referenceId);

            internal virtual void PopReferenceForCycleDetection()
            {
                throw new InvalidOperationException();
            }

            internal virtual void PushReferenceForCycleDetection(object value)
            {
                throw new InvalidOperationException();
            }

            internal virtual bool ContainsReferenceForCycleDetection(object value)
            {
                throw new InvalidOperationException();
            }
        }

        namespace Converters
        {
            using System.Text.Json.Nodes;
            using System.Text.Json.Serialization.Metadata;

            /// <summary>
            /// Converter for <cref>System.Array</cref>.
            /// </summary>
            internal sealed class ArrayConverter<TCollection, TElement> : IEnumerableDefaultConverter<TElement[], TElement>
            {
                internal override bool CanHaveMetadata => false;

                internal override bool SupportsCreateObjectDelegate => false;

                protected override void Add(in TElement value, ref ReadStack state)
                {
                    ((List<TElement>)state.Current.ReturnValue).Add(value);
                }

                protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
                {
                    state.Current.ReturnValue = new List<TElement>();
                }

                protected override void ConvertCollection(ref ReadStack state, JsonSerializerOptions options)
                {
                    List<TElement> list = (List<TElement>)state.Current.ReturnValue;
                    state.Current.ReturnValue = list.ToArray();
                }

                protected override bool OnWriteResume(Utf8JsonWriter writer, TElement[] array, JsonSerializerOptions options, ref WriteStack state)
                {
                    int i = state.Current.EnumeratorIndex;
                    JsonConverter<TElement> elementConverter = JsonCollectionConverter<TElement[], TElement>.GetElementConverter(ref state);
                    if (elementConverter.CanUseDirectReadOrWrite && !state.Current.NumberHandling.HasValue)
                    {
                        for (; i < array.Length; i++)
                        {
                            elementConverter.Write(writer, array[i], options);
                        }
                    }
                    else
                    {
                        for (; i < array.Length; i++)
                        {
                            TElement value = array[i];
                            if (!elementConverter.TryWrite(writer, in value, options, ref state))
                            {
                                state.Current.EnumeratorIndex = i;
                                return false;
                            }
                            state.Current.EndCollectionElement();
                            if (JsonConverter.ShouldFlush(writer, ref state))
                            {
                                i = (state.Current.EnumeratorIndex = i + 1);
                                return false;
                            }
                        }
                    }
                    return true;
                }
            }

            internal sealed class BooleanConverter : JsonConverter<bool>
            {
                public override bool Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetBoolean();
                }

                public override void Write(Utf8JsonWriter writer, bool value, JsonSerializerOptions options)
                {
                    writer.WriteBooleanValue(value);
                }

                internal override bool ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    ReadOnlySpan<byte> span = reader.GetSpan();
                    if (!Utf8Parser.TryParse(span, out bool value, out int bytesConsumed, '\0') || span.Length != bytesConsumed)
                    {
                        ThrowHelper.ThrowFormatException(DataType.Boolean);
                    }
                    return value;
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, bool value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    writer.WritePropertyName(value);
                }
            }

            internal sealed class ByteArrayConverter : JsonConverter<byte[]>
            {
                public override byte[] Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    if (reader.TokenType == JsonTokenType.Null)
                    {
                        return null;
                    }
                    return reader.GetBytesFromBase64();
                }

                public override void Write(Utf8JsonWriter writer, byte[] value, JsonSerializerOptions options)
                {
                    if (value == null)
                    {
                        writer.WriteNullValue();
                    }
                    else
                    {
                        writer.WriteBase64StringValue(value);
                    }
                }
            }

            internal sealed class ByteConverter : JsonConverter<byte>
            {
                public ByteConverter()
                {
                    IsInternalConverterForNumberType = true;
                }

                public override byte Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetByte();
                }

                public override void Write(Utf8JsonWriter writer, byte value, JsonSerializerOptions options)
                {
                    writer.WriteNumberValue(value);
                }

                internal override byte ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetByteWithQuotes();
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, byte value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    writer.WritePropertyName(value);
                }

                internal override byte ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
                {
                    if (reader.TokenType == JsonTokenType.String && (JsonNumberHandling.AllowReadingFromString & handling) != 0)
                    {
                        return reader.GetByteWithQuotes();
                    }
                    return reader.GetByte();
                }

                internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, byte value, JsonNumberHandling handling)
                {
                    if ((JsonNumberHandling.WriteAsString & handling) != 0)
                    {
                        writer.WriteNumberValueAsString(value);
                    }
                    else
                    {
                        writer.WriteNumberValue(value);
                    }
                }
            }

            /// <summary>
            /// Converter wrapper which casts SourceType into TargetType
            /// </summary>
            internal sealed class CastingConverter<T, TSource> : JsonConverter<T>
            {
                private readonly JsonConverter<TSource> _sourceConverter;

                internal override Type KeyType => _sourceConverter.KeyType;

                internal override Type ElementType => _sourceConverter.ElementType;

                public override bool HandleNull => _sourceConverter.HandleNull;

                internal override ConverterStrategy ConverterStrategy => _sourceConverter.ConverterStrategy;

                internal override bool SupportsCreateObjectDelegate => _sourceConverter.SupportsCreateObjectDelegate;

                internal override JsonConverter SourceConverterForCastingConverter => _sourceConverter;

                internal CastingConverter(JsonConverter<TSource> sourceConverter)
                    : base(initialize: false)
                {
                    _sourceConverter = sourceConverter;
                    Initialize();
                    base.IsInternalConverter = sourceConverter.IsInternalConverter;
                    IsInternalConverterForNumberType = sourceConverter.IsInternalConverterForNumberType;
                    base.RequiresReadAhead = sourceConverter.RequiresReadAhead;
                    base.CanUseDirectReadOrWrite = sourceConverter.CanUseDirectReadOrWrite;
                    base.CanBePolymorphic = sourceConverter.CanBePolymorphic;
                }

                public override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return CastOnRead(_sourceConverter.Read(ref reader, typeToConvert, options));
                }

                public override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options)
                {
                    _sourceConverter.Write(writer, CastOnWrite(value), options);
                }

                internal override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out T value)
                {
                    TSource value2;
                    bool result = _sourceConverter.OnTryRead(ref reader, typeToConvert, options, ref state, out value2);
                    value = CastOnRead(value2);
                    return result;
                }

                internal override bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, ref WriteStack state)
                {
                    return _sourceConverter.OnTryWrite(writer, CastOnWrite(value), options, ref state);
                }

                public override T ReadAsPropertyName(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return CastOnRead(_sourceConverter.ReadAsPropertyName(ref reader, typeToConvert, options));
                }

                internal override T ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return CastOnRead(_sourceConverter.ReadAsPropertyNameCore(ref reader, typeToConvert, options));
                }

                public override void WriteAsPropertyName(Utf8JsonWriter writer, T value, JsonSerializerOptions options)
                {
                    _sourceConverter.WriteAsPropertyName(writer, CastOnWrite(value), options);
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, T value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    _sourceConverter.WriteAsPropertyNameCore(writer, CastOnWrite(value), options, isWritingExtensionDataProperty);
                }

                internal override T ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
                {
                    return CastOnRead(_sourceConverter.ReadNumberWithCustomHandling(ref reader, handling, options));
                }

                internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, T value, JsonNumberHandling handling)
                {
                    _sourceConverter.WriteNumberWithCustomHandling(writer, CastOnWrite(value), handling);
                }

                private static T CastOnRead(TSource source)
                {
                    if (default(T) == null && default(TSource) == null && source == null)
                    {
                        return default(T);
                    }
                    if (source is T)
                    {
                        object obj = source;
                        return (T)((obj is T) ? obj : null);
                    }
                    HandleFailure(source);
                    return default(T);
                    static void HandleFailure(TSource source)
                    {
                        if (source == null)
                        {
                            ThrowHelper.ThrowInvalidOperationException_DeserializeUnableToAssignNull(typeof(T));
                        }
                        else
                        {
                            ThrowHelper.ThrowInvalidCastException_DeserializeUnableToAssignValue(typeof(TSource), typeof(T));
                        }
                    }
                }

                private static TSource CastOnWrite(T source)
                {
                    if (default(TSource) != null && default(T) == null && source == null)
                    {
                        ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(typeof(TSource));
                    }
                    return (TSource)(object)source;
                }
            }

            internal sealed class CharConverter : JsonConverter<char>
            {
                private const int MaxEscapedCharacterLength = 6;

                public override char Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    if (!JsonHelpers.IsInRangeInclusive(reader.ValueLength, 1, 6))
                    {
                        ThrowHelper.ThrowInvalidOperationException_ExpectedChar(reader.TokenType);
                    }
                    Span<char> destination = stackalloc char[6];
                    int num = reader.CopyString(destination);
                    if (num != 1)
                    {
                        ThrowHelper.ThrowInvalidOperationException_ExpectedChar(reader.TokenType);
                    }
                    return destination[0];
                }

                public override void Write(Utf8JsonWriter writer, char value, JsonSerializerOptions options)
                {
                    writer.WriteStringValue(value.ToString());
                }

                internal override char ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return Read(ref reader, typeToConvert, options);
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, char value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    writer.WritePropertyName(value.ToString());
                }
            }

            internal sealed class ConcurrentQueueOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : ConcurrentQueue<TElement>
            {
                protected override void Add(in TElement value, ref ReadStack state) { ((TCollection)state.Current.ReturnValue).Enqueue(value); }
            }

            internal sealed class ConcurrentStackOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : ConcurrentStack<TElement>
            {
                protected override void Add(in TElement value, ref ReadStack state)
                {
                    ((TCollection)state.Current.ReturnValue).Push(value);
                }
            }

            internal sealed class DateTimeConverter : JsonConverter<DateTime>
            {
                public override DateTime Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetDateTime();
                }

                public override void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options)
                {
                    writer.WriteStringValue(value);
                }

                internal override DateTime ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetDateTimeNoValidation();
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    writer.WritePropertyName(value);
                }
            }

            internal sealed class DateTimeOffsetConverter : JsonConverter<DateTimeOffset>
            {
                public override DateTimeOffset Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetDateTimeOffset();
                }

                public override void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options)
                {
                    writer.WriteStringValue(value);
                }

                internal override DateTimeOffset ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetDateTimeOffsetNoValidation();
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    writer.WritePropertyName(value);
                }
            }

            internal sealed class DecimalConverter : JsonConverter<decimal>
            {
                public DecimalConverter()
                {
                    IsInternalConverterForNumberType = true;
                }

                public override decimal Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetDecimal();
                }

                public override void Write(Utf8JsonWriter writer, decimal value, JsonSerializerOptions options)
                {
                    writer.WriteNumberValue(value);
                }

                internal override decimal ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetDecimalWithQuotes();
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, decimal value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    writer.WritePropertyName(value);
                }

                internal override decimal ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
                {
                    if (reader.TokenType == JsonTokenType.String && (JsonNumberHandling.AllowReadingFromString & handling) != 0)
                    {
                        return reader.GetDecimalWithQuotes();
                    }
                    return reader.GetDecimal();
                }

                internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, decimal value, JsonNumberHandling handling)
                {
                    if ((JsonNumberHandling.WriteAsString & handling) != 0)
                    {
                        writer.WriteNumberValueAsString(value);
                    }
                    else
                    {
                        writer.WriteNumberValue(value);
                    }
                }
            }

            /// <summary>
            /// Default base class implementation of <cref>JsonDictionaryConverter{TCollection}</cref> .
            /// </summary>
            internal abstract class DictionaryDefaultConverter<TDictionary, TKey, TValue> : JsonDictionaryConverter<TDictionary, TKey, TValue> where TDictionary : IEnumerable<KeyValuePair<TKey, TValue>>
            {
                internal override bool CanHaveMetadata => true;

                protected internal override bool OnWriteResume(Utf8JsonWriter writer, TDictionary value, JsonSerializerOptions options, ref WriteStack state)
                {
                    IEnumerator<KeyValuePair<TKey, TValue>> enumerator;
                    if (state.Current.CollectionEnumerator == null)
                    {
                        enumerator = value.GetEnumerator();
                        if (!enumerator.MoveNext())
                        {
                            enumerator.Dispose();
                            return true;
                        }
                    }
                    else
                    {
                        enumerator = (IEnumerator<KeyValuePair<TKey, TValue>>)state.Current.CollectionEnumerator;
                    }
                    JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
                    if (_keyConverter == null)
                    {
                        _keyConverter = JsonDictionaryConverter<TDictionary, TKey, TValue>.GetConverter<TKey>(jsonTypeInfo.KeyTypeInfo);
                    }
                    if (_valueConverter == null)
                    {
                        _valueConverter = JsonDictionaryConverter<TDictionary, TKey, TValue>.GetConverter<TValue>(jsonTypeInfo.ElementTypeInfo);
                    }
                    do
                    {
                        if (JsonConverter.ShouldFlush(writer, ref state))
                        {
                            state.Current.CollectionEnumerator = enumerator;
                            return false;
                        }
                        if ((int)state.Current.PropertyState < 2)
                        {
                            state.Current.PropertyState = StackFramePropertyState.Name;
                            TKey key = enumerator.Current.Key;
                            _keyConverter.WriteAsPropertyNameCore(writer, key, options, state.Current.IsWritingExtensionDataProperty);
                        }
                        TValue value2 = enumerator.Current.Value;
                        if (!_valueConverter.TryWrite(writer, in value2, options, ref state))
                        {
                            state.Current.CollectionEnumerator = enumerator;
                            return false;
                        }
                        state.Current.EndDictionaryEntry();
                    }
                    while (enumerator.MoveNext());
                    enumerator.Dispose();
                    return true;
                }
            }

            /// <summary>
            /// Converter for Dictionary{string, TValue} that (de)serializes as a JSON object with properties
            /// representing the dictionary element key and value.
            /// </summary>
            internal sealed class DictionaryOfTKeyTValueConverter<TCollection, TKey, TValue> : DictionaryDefaultConverter<TCollection, TKey, TValue> where TCollection : Dictionary<TKey, TValue>
            {
                protected override void Add(TKey key, in TValue value, JsonSerializerOptions options, ref ReadStack state)
                {
                    ((TCollection)state.Current.ReturnValue)[key] = value;
                }

                protected internal override bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, ref WriteStack state)
                {
                    Dictionary<TKey, TValue>.Enumerator enumerator;
                    if (state.Current.CollectionEnumerator == null)
                    {
                        enumerator = value.GetEnumerator();
                        if (!enumerator.MoveNext())
                        {
                            enumerator.Dispose();
                            return true;
                        }
                    }
                    else
                    {
                        enumerator = (Dictionary<TKey, TValue>.Enumerator)(object)state.Current.CollectionEnumerator;
                    }
                    JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
                    if (_keyConverter == null)
                    {
                        _keyConverter = JsonDictionaryConverter<TCollection, TKey, TValue>.GetConverter<TKey>(jsonTypeInfo.KeyTypeInfo);
                    }
                    if (_valueConverter == null)
                    {
                        _valueConverter = JsonDictionaryConverter<TCollection, TKey, TValue>.GetConverter<TValue>(jsonTypeInfo.ElementTypeInfo);
                    }
                    if (!state.SupportContinuation && _valueConverter.CanUseDirectReadOrWrite && !state.Current.NumberHandling.HasValue)
                    {
                        do
                        {
                            TKey key = enumerator.Current.Key;
                            _keyConverter.WriteAsPropertyNameCore(writer, key, options, state.Current.IsWritingExtensionDataProperty);
                            _valueConverter.Write(writer, enumerator.Current.Value, options);
                        }
                        while (enumerator.MoveNext());
                    }
                    else
                    {
                        do
                        {
                            if (JsonConverter.ShouldFlush(writer, ref state))
                            {
                                state.Current.CollectionEnumerator = enumerator;
                                return false;
                            }
                            if ((int)state.Current.PropertyState < 2)
                            {
                                state.Current.PropertyState = StackFramePropertyState.Name;
                                TKey key2 = enumerator.Current.Key;
                                _keyConverter.WriteAsPropertyNameCore(writer, key2, options, state.Current.IsWritingExtensionDataProperty);
                            }
                            TValue value2 = enumerator.Current.Value;
                            if (!_valueConverter.TryWrite(writer, in value2, options, ref state))
                            {
                                state.Current.CollectionEnumerator = enumerator;
                                return false;
                            }
                            state.Current.EndDictionaryEntry();
                        }
                        while (enumerator.MoveNext());
                    }
                    enumerator.Dispose();
                    return true;
                }
            }

            internal sealed class DoubleConverter : JsonConverter<double>
            {
                public DoubleConverter()
                {
                    IsInternalConverterForNumberType = true;
                }

                public override double Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetDouble();
                }

                public override void Write(Utf8JsonWriter writer, double value, JsonSerializerOptions options)
                {
                    writer.WriteNumberValue(value);
                }

                internal override double ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetDoubleWithQuotes();
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, double value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    writer.WritePropertyName(value);
                }

                internal override double ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
                {
                    if (reader.TokenType == JsonTokenType.String)
                    {
                        if ((JsonNumberHandling.AllowReadingFromString & handling) != 0)
                        {
                            return reader.GetDoubleWithQuotes();
                        }
                        if ((JsonNumberHandling.AllowNamedFloatingPointLiterals & handling) != 0)
                        {
                            return reader.GetDoubleFloatingPointConstant();
                        }
                    }
                    return reader.GetDouble();
                }

                internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, double value, JsonNumberHandling handling)
                {
                    if ((JsonNumberHandling.WriteAsString & handling) != 0)
                    {
                        writer.WriteNumberValueAsString(value);
                    }
                    else if ((JsonNumberHandling.AllowNamedFloatingPointLiterals & handling) != 0)
                    {
                        writer.WriteFloatingPointConstant(value);
                    }
                    else
                    {
                        writer.WriteNumberValue(value);
                    }
                }
            }

            internal sealed class EnumConverter<T> : JsonConverter<T> where T : struct, Enum
            {
                private static readonly TypeCode s_enumTypeCode = Type.GetTypeCode(typeof(T));

                private static readonly bool s_isSignedEnum = (int)s_enumTypeCode % 2 == 1;

                private const string ValueSeparator = ", ";

                private readonly EnumConverterOptions _converterOptions;

                private readonly JsonNamingPolicy _namingPolicy;

                /// <summary>
                /// Holds a mapping from enum value to text that might be formatted with <see cref="F:System.Text.Json.Serialization.Converters.EnumConverter`1._namingPolicy" />.
                /// <see cref="T:System.UInt64" /> is as the key used rather than <typeparamref name="T" /> given measurements that
                /// show private memory savings when a single type is used https://github.com/dotnet/runtime/pull/36726#discussion_r428868336.
                /// </summary>
                private readonly ConcurrentDictionary<ulong, JsonEncodedText> _nameCacheForWriting;

                /// <summary>
                /// Holds a mapping from text that might be formatted with <see cref="F:System.Text.Json.Serialization.Converters.EnumConverter`1._namingPolicy" /> to enum value.
                /// </summary>
                private readonly ConcurrentDictionary<string, T> _nameCacheForReading;

                private const int NameCacheSizeSoftLimit = 64;

                public override bool CanConvert(Type type)
                {
                    return type.IsEnum;
                }

                public EnumConverter(EnumConverterOptions converterOptions, JsonSerializerOptions serializerOptions)
                    : this(converterOptions, (JsonNamingPolicy)null, serializerOptions)
                {
                }

                public EnumConverter(EnumConverterOptions converterOptions, JsonNamingPolicy namingPolicy, JsonSerializerOptions serializerOptions)
                {
                    _converterOptions = converterOptions;
                    _namingPolicy = namingPolicy;
                    _nameCacheForWriting = new ConcurrentDictionary<ulong, JsonEncodedText>();
                    if (namingPolicy != null)
                    {
                        _nameCacheForReading = new ConcurrentDictionary<string, T>();
                    }
                    string[] names = Enum.GetNames(TypeToConvert);
                    Array values = Enum.GetValues(TypeToConvert);
                    JavaScriptEncoder encoder = serializerOptions.Encoder;
                    for (int i = 0; i < names.Length; i++)
                    {
                        T val = (T)values.GetValue(i);
                        ulong key = ConvertToUInt64(val);
                        string value = names[i];
                        string text = FormatJsonName(value, namingPolicy);
                        _nameCacheForWriting.TryAdd(key, JsonEncodedText.Encode(text, encoder));
                        _nameCacheForReading?.TryAdd(text, val);
                    }
                }

                public override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    switch (reader.TokenType)
                    {
                        case JsonTokenType.String:
                            {
                                if (!_converterOptions.HasFlag(EnumConverterOptions.AllowStrings))
                                {
                                    ThrowHelper.ThrowJsonException();
                                    return default(T);
                                }
                                string @string = reader.GetString();
                                if (TryParseEnumCore(@string, options, out var value9))
                                {
                                    return value9;
                                }
                                return ReadEnumUsingNamingPolicy(@string);
                            }
                        case JsonTokenType.Number:
                            if (_converterOptions.HasFlag(EnumConverterOptions.AllowNumbers))
                            {
                                switch (s_enumTypeCode)
                                {
                                    case TypeCode.Int32:
                                        {
                                            if (reader.TryGetInt32(out var value8))
                                            {
                                                return System.Runtime.CompilerServices.Unsafe.As<int, T>(ref value8);
                                            }
                                            break;
                                        }
                                    case TypeCode.UInt32:
                                        {
                                            if (reader.TryGetUInt32(out var value4))
                                            {
                                                return System.Runtime.CompilerServices.Unsafe.As<uint, T>(ref value4);
                                            }
                                            break;
                                        }
                                    case TypeCode.UInt64:
                                        {
                                            if (reader.TryGetUInt64(out var value6))
                                            {
                                                return System.Runtime.CompilerServices.Unsafe.As<ulong, T>(ref value6);
                                            }
                                            break;
                                        }
                                    case TypeCode.Int64:
                                        {
                                            if (reader.TryGetInt64(out var value2))
                                            {
                                                return System.Runtime.CompilerServices.Unsafe.As<long, T>(ref value2);
                                            }
                                            break;
                                        }
                                    case TypeCode.SByte:
                                        {
                                            if (reader.TryGetSByte(out var value7))
                                            {
                                                return System.Runtime.CompilerServices.Unsafe.As<sbyte, T>(ref value7);
                                            }
                                            break;
                                        }
                                    case TypeCode.Byte:
                                        {
                                            if (reader.TryGetByte(out var value5))
                                            {
                                                return System.Runtime.CompilerServices.Unsafe.As<byte, T>(ref value5);
                                            }
                                            break;
                                        }
                                    case TypeCode.Int16:
                                        {
                                            if (reader.TryGetInt16(out var value3))
                                            {
                                                return System.Runtime.CompilerServices.Unsafe.As<short, T>(ref value3);
                                            }
                                            break;
                                        }
                                    case TypeCode.UInt16:
                                        {
                                            if (reader.TryGetUInt16(out var value))
                                            {
                                                return System.Runtime.CompilerServices.Unsafe.As<ushort, T>(ref value);
                                            }
                                            break;
                                        }
                                }
                                ThrowHelper.ThrowJsonException();
                                return default(T);
                            }
                            goto default;
                        default:
                            ThrowHelper.ThrowJsonException();
                            return default(T);
                    }
                }

                public override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options)
                {
                    if (_converterOptions.HasFlag(EnumConverterOptions.AllowStrings))
                    {
                        ulong key = ConvertToUInt64(value);
                        if (_nameCacheForWriting.TryGetValue(key, out var value2))
                        {
                            writer.WriteStringValue(value2);
                            return;
                        }
                        string value3 = value.ToString();
                        if (IsValidIdentifier(value3))
                        {
                            value3 = FormatJsonName(value3, _namingPolicy);
                            if (_nameCacheForWriting.Count < 64)
                            {
                                value2 = JsonEncodedText.Encode(value3, options.Encoder);
                                writer.WriteStringValue(value2);
                                _nameCacheForWriting.TryAdd(key, value2);
                            }
                            else
                            {
                                writer.WriteStringValue(value3);
                            }
                            return;
                        }
                    }
                    if (!_converterOptions.HasFlag(EnumConverterOptions.AllowNumbers))
                    {
                        ThrowHelper.ThrowJsonException();
                    }
                    switch (s_enumTypeCode)
                    {
                        case TypeCode.Int32:
                            writer.WriteNumberValue(System.Runtime.CompilerServices.Unsafe.As<T, int>(ref value));
                            break;
                        case TypeCode.UInt32:
                            writer.WriteNumberValue(System.Runtime.CompilerServices.Unsafe.As<T, uint>(ref value));
                            break;
                        case TypeCode.UInt64:
                            writer.WriteNumberValue(System.Runtime.CompilerServices.Unsafe.As<T, ulong>(ref value));
                            break;
                        case TypeCode.Int64:
                            writer.WriteNumberValue(System.Runtime.CompilerServices.Unsafe.As<T, long>(ref value));
                            break;
                        case TypeCode.Int16:
                            writer.WriteNumberValue(System.Runtime.CompilerServices.Unsafe.As<T, short>(ref value));
                            break;
                        case TypeCode.UInt16:
                            writer.WriteNumberValue(System.Runtime.CompilerServices.Unsafe.As<T, ushort>(ref value));
                            break;
                        case TypeCode.Byte:
                            writer.WriteNumberValue(System.Runtime.CompilerServices.Unsafe.As<T, byte>(ref value));
                            break;
                        case TypeCode.SByte:
                            writer.WriteNumberValue(System.Runtime.CompilerServices.Unsafe.As<T, sbyte>(ref value));
                            break;
                        default:
                            ThrowHelper.ThrowJsonException();
                            break;
                    }
                }

                internal override T ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    if (!TryParseEnumCore(reader.GetString(), options, out var value))
                    {
                        ThrowHelper.ThrowJsonException();
                    }
                    return value;
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, T value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    ulong key = ConvertToUInt64(value);
                    if (options.DictionaryKeyPolicy == null && _nameCacheForWriting.TryGetValue(key, out var value2))
                    {
                        writer.WritePropertyName(value2);
                        return;
                    }
                    string value3 = value.ToString();
                    if (IsValidIdentifier(value3))
                    {
                        if (options.DictionaryKeyPolicy != null)
                        {
                            value3 = FormatJsonName(value3, options.DictionaryKeyPolicy);
                            writer.WritePropertyName(value3);
                            return;
                        }
                        value3 = FormatJsonName(value3, _namingPolicy);
                        if (_nameCacheForWriting.Count < 64)
                        {
                            value2 = JsonEncodedText.Encode(value3, options.Encoder);
                            writer.WritePropertyName(value2);
                            _nameCacheForWriting.TryAdd(key, value2);
                        }
                        else
                        {
                            writer.WritePropertyName(value3);
                        }
                        return;
                    }
                    switch (s_enumTypeCode)
                    {
                        case TypeCode.Int32:
                            writer.WritePropertyName(System.Runtime.CompilerServices.Unsafe.As<T, int>(ref value));
                            break;
                        case TypeCode.UInt32:
                            writer.WritePropertyName(System.Runtime.CompilerServices.Unsafe.As<T, uint>(ref value));
                            break;
                        case TypeCode.UInt64:
                            writer.WritePropertyName(System.Runtime.CompilerServices.Unsafe.As<T, ulong>(ref value));
                            break;
                        case TypeCode.Int64:
                            writer.WritePropertyName(System.Runtime.CompilerServices.Unsafe.As<T, long>(ref value));
                            break;
                        case TypeCode.Int16:
                            writer.WritePropertyName(System.Runtime.CompilerServices.Unsafe.As<T, short>(ref value));
                            break;
                        case TypeCode.UInt16:
                            writer.WritePropertyName(System.Runtime.CompilerServices.Unsafe.As<T, ushort>(ref value));
                            break;
                        case TypeCode.Byte:
                            writer.WritePropertyName(System.Runtime.CompilerServices.Unsafe.As<T, byte>(ref value));
                            break;
                        case TypeCode.SByte:
                            writer.WritePropertyName(System.Runtime.CompilerServices.Unsafe.As<T, sbyte>(ref value));
                            break;
                        default:
                            ThrowHelper.ThrowJsonException();
                            break;
                    }
                }

                private static bool TryParseEnumCore(string enumString, JsonSerializerOptions options, out T value)
                {
                    T result;
                    bool result2 = Enum.TryParse<T>(enumString, out result) || Enum.TryParse<T>(enumString, ignoreCase: true, out result);
                    value = result;
                    return result2;
                }

                private T ReadEnumUsingNamingPolicy(string enumString)
                {
                    if (_namingPolicy == null)
                    {
                        ThrowHelper.ThrowJsonException();
                    }
                    if (enumString == null)
                    {
                        ThrowHelper.ThrowJsonException();
                    }
                    bool flag;
                    if (!(flag = _nameCacheForReading.TryGetValue(enumString, out var value)) && enumString.Contains(", "))
                    {
                        string[] array = SplitFlagsEnum(enumString);
                        ulong num = 0uL;
                        for (int i = 0; i < array.Length; i++)
                        {
                            flag = _nameCacheForReading.TryGetValue(array[i], out value);
                            if (!flag)
                            {
                                break;
                            }
                            num |= ConvertToUInt64(value);
                        }
                        value = (T)Enum.ToObject(typeof(T), num);
                        if (flag && _nameCacheForReading.Count < 64)
                        {
                            _nameCacheForReading[enumString] = value;
                        }
                    }
                    if (!flag)
                    {
                        ThrowHelper.ThrowJsonException();
                    }
                    return value;
                }

                private static ulong ConvertToUInt64(object value)
                {
                    return s_enumTypeCode switch
                    {
                        TypeCode.Int32 => (ulong)(int)value,
                        TypeCode.UInt32 => (uint)value,
                        TypeCode.UInt64 => (ulong)value,
                        TypeCode.Int64 => (ulong)(long)value,
                        TypeCode.SByte => (ulong)(sbyte)value,
                        TypeCode.Byte => (byte)value,
                        TypeCode.Int16 => (ulong)(short)value,
                        TypeCode.UInt16 => (ushort)value,
                        _ => throw new InvalidOperationException(),
                    };
                }

                private static bool IsValidIdentifier(string value)
                {
                    if (value[0] >= 'A')
                    {
                        if (s_isSignedEnum)
                        {
                            return !value.StartsWith(NumberFormatInfo.CurrentInfo.NegativeSign);
                        }
                        return true;
                    }
                    return false;
                }

                private static string FormatJsonName(string value, JsonNamingPolicy namingPolicy)
                {
                    if (namingPolicy == null)
                    {
                        return value;
                    }
                    if (!value.Contains(", "))
                    {
                        return namingPolicy.ConvertName(value);
                    }
                    string[] array = SplitFlagsEnum(value);
                    for (int i = 0; i < array.Length; i++)
                    {
                        string text = namingPolicy.ConvertName(array[i]);
                        if (text == null)
                        {
                            ThrowHelper.ThrowInvalidOperationException_NamingPolicyReturnNull(namingPolicy);
                        }
                        array[i] = text;
                    }
                    return string.Join(", ", array);
                }

                private static string[] SplitFlagsEnum(string value)
                {
                    return value.Split(new string[1] { ", " }, StringSplitOptions.None);
                }
            }

            [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
            internal sealed class EnumConverterFactory : JsonConverterFactory
            {
                public override bool CanConvert(Type type)
                {
                    return type.IsEnum;
                }

                public override JsonConverter CreateConverter(Type type, JsonSerializerOptions options)
                {
                    return Create(type, EnumConverterOptions.AllowNumbers, null, options);
                }

                internal static JsonConverter Create(Type enumType, EnumConverterOptions converterOptions, JsonNamingPolicy namingPolicy, JsonSerializerOptions options)
                {
                    return (JsonConverter)Activator.CreateInstance(GetEnumConverterType(enumType), converterOptions, namingPolicy, options);
                }

                [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern", Justification = "'EnumConverter<T> where T : struct' implies 'T : new()', so the trimmer is warning calling MakeGenericType here because enumType's constructors are not annotated. But EnumConverter doesn't call new T(), so this is safe.")]
                [return: DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)]
                private static Type GetEnumConverterType(Type enumType)
                {
                    return typeof(EnumConverter<>).MakeGenericType(enumType);
                }
            }

            [Flags]
            internal enum EnumConverterOptions
            {
                /// <summary>
                /// Allow string values.
                /// </summary>
                AllowStrings = 1,
                /// <summary>
                /// Allow number values.
                /// </summary>
                AllowNumbers = 2
            }

            internal sealed class FSharpListConverter<TList, TElement> : IEnumerableDefaultConverter<TList, TElement> where TList : IEnumerable<TElement>
            {
                private readonly Func<IEnumerable<TElement>, TList> _listConstructor;

                internal override bool SupportsCreateObjectDelegate => false;

                [RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
                [RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
                public FSharpListConverter()
                {
                    _listConstructor = FSharpCoreReflectionProxy.Instance.CreateFSharpListConstructor<TList, TElement>();
                }

                protected override void Add(in TElement value, ref ReadStack state)
                {
                    ((List<TElement>)state.Current.ReturnValue).Add(value);
                }

                protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
                {
                    state.Current.ReturnValue = new List<TElement>();
                }

                protected override void ConvertCollection(ref ReadStack state, JsonSerializerOptions options)
                {
                    state.Current.ReturnValue = _listConstructor((List<TElement>)state.Current.ReturnValue);
                }
            }

            internal sealed class FSharpMapConverter<TMap, TKey, TValue> : DictionaryDefaultConverter<TMap, TKey, TValue> where TMap : IEnumerable<KeyValuePair<TKey, TValue>>
            {
                private readonly Func<IEnumerable<Tuple<TKey, TValue>>, TMap> _mapConstructor;

                internal override bool CanHaveMetadata => false;

                internal override bool SupportsCreateObjectDelegate => false;

                [RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
                [RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
                public FSharpMapConverter()
                {
                    _mapConstructor = FSharpCoreReflectionProxy.Instance.CreateFSharpMapConstructor<TMap, TKey, TValue>();
                }

                protected override void Add(TKey key, in TValue value, JsonSerializerOptions options, ref ReadStack state)
                {
                    ((List<Tuple<TKey, TValue>>)state.Current.ReturnValue).Add(new Tuple<TKey, TValue>(key, value));
                }

                protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state)
                {
                    state.Current.ReturnValue = new List<Tuple<TKey, TValue>>();
                }

                protected override void ConvertCollection(ref ReadStack state, JsonSerializerOptions options)
                {
                    state.Current.ReturnValue = _mapConstructor((List<Tuple<TKey, TValue>>)state.Current.ReturnValue);
                }
            }

            internal sealed class FSharpOptionConverter<TOption, TElement> : JsonConverter<TOption> where TOption : class
            {
                private readonly JsonConverter<TElement> _elementConverter;

                private readonly Func<TOption, TElement> _optionValueGetter;

                private readonly Func<TElement, TOption> _optionConstructor;

                private readonly ConverterStrategy _converterStrategy;

                internal override ConverterStrategy ConverterStrategy => _converterStrategy;

                internal override Type ElementType => typeof(TElement);

                public override bool HandleNull => true;

                [RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
                [RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
                public FSharpOptionConverter(JsonConverter<TElement> elementConverter)
                {
                    _elementConverter = elementConverter;
                    _optionValueGetter = FSharpCoreReflectionProxy.Instance.CreateFSharpOptionValueGetter<TOption, TElement>();
                    _optionConstructor = FSharpCoreReflectionProxy.Instance.CreateFSharpOptionSomeConstructor<TOption, TElement>();
                    _converterStrategy = elementConverter.ConverterStrategy;
                    base.CanUseDirectReadOrWrite = elementConverter.CanUseDirectReadOrWrite;
                    base.RequiresReadAhead = elementConverter.RequiresReadAhead;
                }

                internal override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out TOption value)
                {
                    if (!state.IsContinuation && reader.TokenType == JsonTokenType.Null)
                    {
                        value = null;
                        return true;
                    }
                    state.Current.JsonPropertyInfo = state.Current.JsonTypeInfo.ElementTypeInfo.PropertyInfoForTypeInfo;
                    if (_elementConverter.TryRead(ref reader, typeof(TElement), options, ref state, out var value2))
                    {
                        value = _optionConstructor(value2);
                        return true;
                    }
                    value = null;
                    return false;
                }

                internal override bool OnTryWrite(Utf8JsonWriter writer, TOption value, JsonSerializerOptions options, ref WriteStack state)
                {
                    if (value == null)
                    {
                        writer.WriteNullValue();
                        return true;
                    }
                    TElement value2 = _optionValueGetter(value);
                    state.Current.JsonPropertyInfo = state.Current.JsonTypeInfo.ElementTypeInfo.PropertyInfoForTypeInfo;
                    return _elementConverter.TryWrite(writer, in value2, options, ref state);
                }

                public override void Write(Utf8JsonWriter writer, TOption value, JsonSerializerOptions options)
                {
                    if (value == null)
                    {
                        writer.WriteNullValue();
                        return;
                    }
                    TElement value2 = _optionValueGetter(value);
                    _elementConverter.Write(writer, value2, options);
                }

                public override TOption Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    if (reader.TokenType == JsonTokenType.Null)
                    {
                        return null;
                    }
                    TElement arg = _elementConverter.Read(ref reader, typeToConvert, options);
                    return _optionConstructor(arg);
                }
            }

            internal sealed class FSharpSetConverter<TSet, TElement> : IEnumerableDefaultConverter<TSet, TElement> where TSet : IEnumerable<TElement>
            {
                private readonly Func<IEnumerable<TElement>, TSet> _setConstructor;

                internal override bool SupportsCreateObjectDelegate => false;

                [RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
                [RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
                public FSharpSetConverter()
                {
                    _setConstructor = FSharpCoreReflectionProxy.Instance.CreateFSharpSetConstructor<TSet, TElement>();
                }

                protected override void Add(in TElement value, ref ReadStack state)
                {
                    ((List<TElement>)state.Current.ReturnValue).Add(value);
                }

                protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
                {
                    state.Current.ReturnValue = new List<TElement>();
                }

                protected override void ConvertCollection(ref ReadStack state, JsonSerializerOptions options)
                {
                    state.Current.ReturnValue = _setConstructor((List<TElement>)state.Current.ReturnValue);
                }
            }

            [RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
            internal sealed class FSharpTypeConverterFactory : JsonConverterFactory
            {
                private ObjectConverterFactory _recordConverterFactory;

                [RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
                public FSharpTypeConverterFactory()
                {
                }

                [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "The ctor is marked RequiresUnreferencedCode.")]
                public override bool CanConvert(Type typeToConvert)
                {
                    if (FSharpCoreReflectionProxy.IsFSharpType(typeToConvert))
                    {
                        return FSharpCoreReflectionProxy.Instance.DetectFSharpKind(typeToConvert) != FSharpCoreReflectionProxy.FSharpKind.Unrecognized;
                    }
                    return false;
                }

                [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "The ctor is marked RequiresUnreferencedCode.")]
                [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2055:MakeGenericType", Justification = "The ctor is marked RequiresUnreferencedCode.")]
                public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
                {
                    object[] args = null;
                    Type type2;
                    switch (FSharpCoreReflectionProxy.Instance.DetectFSharpKind(typeToConvert))
                    {
                        case FSharpCoreReflectionProxy.FSharpKind.Option:
                            {
                                Type type = typeToConvert.GetGenericArguments()[0];
                                type2 = typeof(FSharpOptionConverter<,>).MakeGenericType(typeToConvert, type);
                                args = new object[1] { options.GetConverterInternal(type) };
                                break;
                            }
                        case FSharpCoreReflectionProxy.FSharpKind.ValueOption:
                            {
                                Type type = typeToConvert.GetGenericArguments()[0];
                                type2 = typeof(FSharpValueOptionConverter<,>).MakeGenericType(typeToConvert, type);
                                args = new object[1] { options.GetConverterInternal(type) };
                                break;
                            }
                        case FSharpCoreReflectionProxy.FSharpKind.List:
                            {
                                Type type = typeToConvert.GetGenericArguments()[0];
                                type2 = typeof(FSharpListConverter<,>).MakeGenericType(typeToConvert, type);
                                break;
                            }
                        case FSharpCoreReflectionProxy.FSharpKind.Set:
                            {
                                Type type = typeToConvert.GetGenericArguments()[0];
                                type2 = typeof(FSharpSetConverter<,>).MakeGenericType(typeToConvert, type);
                                break;
                            }
                        case FSharpCoreReflectionProxy.FSharpKind.Map:
                            {
                                Type[] genericArguments = typeToConvert.GetGenericArguments();
                                Type type3 = genericArguments[0];
                                Type type4 = genericArguments[1];
                                type2 = typeof(FSharpMapConverter<,,>).MakeGenericType(typeToConvert, type3, type4);
                                break;
                            }
                        case FSharpCoreReflectionProxy.FSharpKind.Record:
                            {
                                ObjectConverterFactory objectConverterFactory = _recordConverterFactory ?? (_recordConverterFactory = new ObjectConverterFactory(useDefaultConstructorInUnannotatedStructs: false));
                                return objectConverterFactory.CreateConverter(typeToConvert, options);
                            }
                        case FSharpCoreReflectionProxy.FSharpKind.Union:
                            throw new NotSupportedException(MDCFR.Properties.Resources.FSharpDiscriminatedUnionsNotSupported);
                        default:
                            throw new Exception();
                    }
                    return (JsonConverter)Activator.CreateInstance(type2, args);
                }
            }

            internal sealed class FSharpValueOptionConverter<TValueOption, TElement> : JsonConverter<TValueOption> where TValueOption : struct, IEquatable<TValueOption>
            {
                private readonly JsonConverter<TElement> _elementConverter;

                private readonly FSharpCoreReflectionProxy.StructGetter<TValueOption, TElement> _optionValueGetter;

                private readonly Func<TElement, TValueOption> _optionConstructor;

                private readonly ConverterStrategy _converterStrategy;

                internal override ConverterStrategy ConverterStrategy => _converterStrategy;

                internal override Type ElementType => typeof(TElement);

                public override bool HandleNull => true;

                [RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
                [RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
                public FSharpValueOptionConverter(JsonConverter<TElement> elementConverter)
                {
                    _elementConverter = elementConverter;
                    _optionValueGetter = FSharpCoreReflectionProxy.Instance.CreateFSharpValueOptionValueGetter<TValueOption, TElement>();
                    _optionConstructor = FSharpCoreReflectionProxy.Instance.CreateFSharpValueOptionSomeConstructor<TValueOption, TElement>();
                    _converterStrategy = elementConverter.ConverterStrategy;
                    base.CanUseDirectReadOrWrite = elementConverter.CanUseDirectReadOrWrite;
                    base.RequiresReadAhead = elementConverter.RequiresReadAhead;
                }

                internal override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out TValueOption value)
                {
                    if (!state.IsContinuation && reader.TokenType == JsonTokenType.Null)
                    {
                        value = default(TValueOption);
                        return true;
                    }
                    state.Current.JsonPropertyInfo = state.Current.JsonTypeInfo.ElementTypeInfo.PropertyInfoForTypeInfo;
                    if (_elementConverter.TryRead(ref reader, typeof(TElement), options, ref state, out var value2))
                    {
                        value = _optionConstructor(value2);
                        return true;
                    }
                    value = default(TValueOption);
                    return false;
                }

                internal override bool OnTryWrite(Utf8JsonWriter writer, TValueOption value, JsonSerializerOptions options, ref WriteStack state)
                {
                    if (value.Equals(default(TValueOption)))
                    {
                        writer.WriteNullValue();
                        return true;
                    }
                    TElement value2 = _optionValueGetter(ref value);
                    state.Current.JsonPropertyInfo = state.Current.JsonTypeInfo.ElementTypeInfo.PropertyInfoForTypeInfo;
                    return _elementConverter.TryWrite(writer, in value2, options, ref state);
                }

                public override void Write(Utf8JsonWriter writer, TValueOption value, JsonSerializerOptions options)
                {
                    if (value.Equals(default(TValueOption)))
                    {
                        writer.WriteNullValue();
                        return;
                    }
                    TElement value2 = _optionValueGetter(ref value);
                    _elementConverter.Write(writer, value2, options);
                }

                public override TValueOption Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    if (reader.TokenType == JsonTokenType.Null)
                    {
                        return default(TValueOption);
                    }
                    TElement arg = _elementConverter.Read(ref reader, typeToConvert, options);
                    return _optionConstructor(arg);
                }
            }

            internal sealed class GuidConverter : JsonConverter<Guid>
            {
                public override Guid Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetGuid();
                }

                public override void Write(Utf8JsonWriter writer, Guid value, JsonSerializerOptions options)
                {
                    writer.WriteStringValue(value);
                }

                internal override Guid ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetGuidNoValidation();
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, Guid value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    writer.WritePropertyName(value);
                }
            }

            internal sealed class IAsyncEnumerableOfTConverter<TAsyncEnumerable, TElement> : JsonCollectionConverter<TAsyncEnumerable, TElement> where TAsyncEnumerable : IAsyncEnumerable<TElement>
            {
                private sealed class BufferedAsyncEnumerable : IAsyncEnumerable<TElement>
                {
                    public readonly List<TElement> _buffer = new List<TElement>();

                    public async IAsyncEnumerator<TElement> GetAsyncEnumerator(CancellationToken _)
                    {
                        foreach (TElement item in _buffer)
                        {
                            yield return item;
                        }
                    }
                }

                internal override bool SupportsCreateObjectDelegate => false;

                internal override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out TAsyncEnumerable value)
                {
                    if (!typeToConvert.IsAssignableFrom(typeof(IAsyncEnumerable<TElement>)))
                    {
                        ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(TypeToConvert, ref reader, ref state);
                    }
                    return base.OnTryRead(ref reader, typeToConvert, options, ref state, out value);
                }

                protected override void Add(in TElement value, ref ReadStack state)
                {
                    ((BufferedAsyncEnumerable)state.Current.ReturnValue)._buffer.Add(value);
                }

                protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
                {
                    state.Current.ReturnValue = new BufferedAsyncEnumerable();
                }

                internal override bool OnTryWrite(Utf8JsonWriter writer, TAsyncEnumerable value, JsonSerializerOptions options, ref WriteStack state)
                {
                    if (!state.SupportAsync)
                    {
                        ThrowHelper.ThrowNotSupportedException_TypeRequiresAsyncSerialization(TypeToConvert);
                    }
                    return base.OnTryWrite(writer, value, options, ref state);
                }

                protected override bool OnWriteResume(Utf8JsonWriter writer, TAsyncEnumerable value, JsonSerializerOptions options, ref WriteStack state)
                {
                    IAsyncEnumerator<TElement> asyncEnumerator;
                    ValueTask<bool> valueTask;
                    if (state.Current.AsyncDisposable == null)
                    {
                        asyncEnumerator = value.GetAsyncEnumerator(state.CancellationToken);
                        state.Current.AsyncDisposable = asyncEnumerator;
                        valueTask = asyncEnumerator.MoveNextAsync();
                        if (!valueTask.IsCompleted)
                        {
                            state.SuppressFlush = true;
                            goto IL_0106;
                        }
                    }
                    else
                    {
                        asyncEnumerator = (IAsyncEnumerator<TElement>)state.Current.AsyncDisposable;
                        if (state.Current.AsyncEnumeratorIsPendingCompletion)
                        {
                            valueTask = new ValueTask<bool>((Task<bool>)state.PendingTask);
                            state.Current.AsyncEnumeratorIsPendingCompletion = false;
                            state.PendingTask = null;
                        }
                        else
                        {
                            valueTask = new ValueTask<bool>(result: true);
                        }
                    }
                    JsonConverter<TElement> elementConverter = JsonCollectionConverter<TAsyncEnumerable, TElement>.GetElementConverter(ref state);
                    do
                    {
                        if (!valueTask.Result)
                        {
                            state.Current.AsyncDisposable = null;
                            state.AddCompletedAsyncDisposable(asyncEnumerator);
                            return true;
                        }
                        if (JsonConverter.ShouldFlush(writer, ref state))
                        {
                            return false;
                        }
                        TElement value2 = asyncEnumerator.Current;
                        if (!elementConverter.TryWrite(writer, in value2, options, ref state))
                        {
                            return false;
                        }
                        state.Current.EndCollectionElement();
                        valueTask = asyncEnumerator.MoveNextAsync();
                    }
                    while (valueTask.IsCompleted);
                    goto IL_0106;
                IL_0106:
                    state.PendingTask = valueTask.AsTask();
                    state.Current.AsyncEnumeratorIsPendingCompletion = true;
                    return false;
                }
            }

            /// <summary>
            /// Converter for <cref>System.Collections.Generic.ICollection{TElement}</cref>.
            /// </summary>
            internal sealed class ICollectionOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : ICollection<TElement>
            {
                protected override void Add(in TElement value, ref ReadStack state)
                {
                    TCollection val = (TCollection)state.Current.ReturnValue;
                    val.Add(value);
                    if (base.IsValueType)
                    {
                        state.Current.ReturnValue = val;
                    }
                }

                protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
                {
                    base.CreateCollection(ref reader, ref state, options);
                    if (((TCollection)state.Current.ReturnValue).IsReadOnly)
                    {
                        state.Current.ReturnValue = null;
                        ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(TypeToConvert, ref reader, ref state);
                    }
                }

                internal override void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
                {
                    if (jsonTypeInfo.CreateObject == null && TypeToConvert.IsAssignableFrom(typeof(List<TElement>)))
                    {
                        jsonTypeInfo.CreateObject = () => new List<TElement>();
                    }
                }
            }

            /// <summary>
            /// Converter for <cref>System.Collections.IDictionary</cref> that (de)serializes as a JSON object with properties
            /// representing the dictionary element key and value.
            /// </summary>
            internal sealed class IDictionaryConverter<TDictionary> : JsonDictionaryConverter<TDictionary, string, object> where TDictionary : IDictionary
            {
                protected override void Add(string key, in object value, JsonSerializerOptions options, ref ReadStack state)
                {
                    TDictionary val = (TDictionary)state.Current.ReturnValue;
                    val[key] = value;
                    if (base.IsValueType)
                    {
                        state.Current.ReturnValue = val;
                    }
                }

                protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state)
                {
                    base.CreateCollection(ref reader, ref state);
                    if (((TDictionary)state.Current.ReturnValue).IsReadOnly)
                    {
                        state.Current.ReturnValue = null;
                        ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(TypeToConvert, ref reader, ref state);
                    }
                }

                protected internal override bool OnWriteResume(Utf8JsonWriter writer, TDictionary value, JsonSerializerOptions options, ref WriteStack state)
                {
                    IDictionaryEnumerator dictionaryEnumerator;
                    if (state.Current.CollectionEnumerator == null)
                    {
                        dictionaryEnumerator = value.GetEnumerator();
                        if (!dictionaryEnumerator.MoveNext())
                        {
                            return true;
                        }
                    }
                    else
                    {
                        dictionaryEnumerator = (IDictionaryEnumerator)state.Current.CollectionEnumerator;
                    }
                    JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
                    if (_valueConverter == null)
                    {
                        _valueConverter = JsonDictionaryConverter<TDictionary, string, object>.GetConverter<object>(jsonTypeInfo.ElementTypeInfo);
                    }
                    do
                    {
                        if (JsonConverter.ShouldFlush(writer, ref state))
                        {
                            state.Current.CollectionEnumerator = dictionaryEnumerator;
                            return false;
                        }
                        if ((int)state.Current.PropertyState < 2)
                        {
                            state.Current.PropertyState = StackFramePropertyState.Name;
                            object key = dictionaryEnumerator.Key;
                            if (key is string value2)
                            {
                                if (_keyConverter == null)
                                {
                                    _keyConverter = JsonDictionaryConverter<TDictionary, string, object>.GetConverter<string>(jsonTypeInfo.KeyTypeInfo);
                                }
                                _keyConverter.WriteAsPropertyNameCore(writer, value2, options, state.Current.IsWritingExtensionDataProperty);
                            }
                            else
                            {
                                _valueConverter.WriteAsPropertyNameCore(writer, key, options, state.Current.IsWritingExtensionDataProperty);
                            }
                        }
                        object value3 = dictionaryEnumerator.Value;
                        if (!_valueConverter.TryWrite(writer, in value3, options, ref state))
                        {
                            state.Current.CollectionEnumerator = dictionaryEnumerator;
                            return false;
                        }
                        state.Current.EndDictionaryEntry();
                    }
                    while (dictionaryEnumerator.MoveNext());
                    return true;
                }

                internal override void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
                {
                    if (jsonTypeInfo.CreateObject == null && TypeToConvert.IsAssignableFrom(typeof(Dictionary<string, object>)))
                    {
                        jsonTypeInfo.CreateObject = () => new Dictionary<string, object>();
                    }
                }
            }

            /// <summary>
            /// Converter for <cref>System.Collections.Generic.IDictionary{TKey, TValue}</cref> that
            /// (de)serializes as a JSON object with properties representing the dictionary element key and value.
            /// </summary>
            internal sealed class IDictionaryOfTKeyTValueConverter<TDictionary, TKey, TValue> : DictionaryDefaultConverter<TDictionary, TKey, TValue> where TDictionary : IDictionary<TKey, TValue>
            {
                protected override void Add(TKey key, in TValue value, JsonSerializerOptions options, ref ReadStack state)
                {
                    TDictionary val = (TDictionary)state.Current.ReturnValue;
                    val[key] = value;
                    if (base.IsValueType)
                    {
                        state.Current.ReturnValue = val;
                    }
                }

                protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state)
                {
                    base.CreateCollection(ref reader, ref state);
                    if (((TDictionary)state.Current.ReturnValue).IsReadOnly)
                    {
                        state.Current.ReturnValue = null;
                        ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(TypeToConvert, ref reader, ref state);
                    }
                }

                internal override void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
                {
                    if (jsonTypeInfo.CreateObject == null && TypeToConvert.IsAssignableFrom(typeof(Dictionary<TKey, TValue>)))
                    {
                        jsonTypeInfo.CreateObject = () => new Dictionary<TKey, TValue>();
                    }
                }
            }

            /// <summary>
            /// Converter for <cref>System.Collections.IEnumerable</cref>.
            /// </summary>
            /// <typeparam name="TCollection"></typeparam>
            internal sealed class IEnumerableConverter<TCollection> : JsonCollectionConverter<TCollection, object> where TCollection : IEnumerable
            {
                private readonly bool _isDeserializable = typeof(TCollection).IsAssignableFrom(typeof(List<object>));

                internal override bool SupportsCreateObjectDelegate => false;

                protected override void Add(in object value, ref ReadStack state)
                {
                    ((List<object>)state.Current.ReturnValue).Add(value);
                }

                protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
                {
                    if (!_isDeserializable)
                    {
                        ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(TypeToConvert, ref reader, ref state);
                    }
                    state.Current.ReturnValue = new List<object>();
                }

                protected override bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, ref WriteStack state)
                {
                    IEnumerator enumerator;
                    if (state.Current.CollectionEnumerator == null)
                    {
                        enumerator = value.GetEnumerator();
                        if (!enumerator.MoveNext())
                        {
                            return true;
                        }
                    }
                    else
                    {
                        enumerator = state.Current.CollectionEnumerator;
                    }
                    JsonConverter<object> elementConverter = JsonCollectionConverter<TCollection, object>.GetElementConverter(ref state);
                    do
                    {
                        if (JsonConverter.ShouldFlush(writer, ref state))
                        {
                            state.Current.CollectionEnumerator = enumerator;
                            return false;
                        }
                        object value2 = enumerator.Current;
                        if (!elementConverter.TryWrite(writer, in value2, options, ref state))
                        {
                            state.Current.CollectionEnumerator = enumerator;
                            return false;
                        }
                        state.Current.EndCollectionElement();
                    }
                    while (enumerator.MoveNext());
                    return true;
                }
            }

            /// <summary>
            /// Converter factory for all IEnumerable types.
            /// </summary>
            [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
            internal sealed class IEnumerableConverterFactory : JsonConverterFactory
            {
                private static readonly IDictionaryConverter<IDictionary> s_converterForIDictionary = new IDictionaryConverter<IDictionary>();

                private static readonly IEnumerableConverter<IEnumerable> s_converterForIEnumerable = new IEnumerableConverter<IEnumerable>();

                private static readonly IListConverter<IList> s_converterForIList = new IListConverter<IList>();

                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
                public IEnumerableConverterFactory()
                {
                }

                public override bool CanConvert(Type typeToConvert)
                {
                    return typeof(IEnumerable).IsAssignableFrom(typeToConvert);
                }

                [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "The ctor is marked RequiresUnreferencedCode.")]
                public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
                {
                    Type type = null;
                    Type type2 = null;
                    Type typeFromHandle;
                    Type compatibleGenericBaseClass;
                    if (typeToConvert.IsArray)
                    {
                        if (typeToConvert.GetArrayRank() > 1)
                        {
                            ThrowHelper.ThrowNotSupportedException_SerializationNotSupported(typeToConvert);
                        }
                        typeFromHandle = typeof(ArrayConverter<,>);
                        type = typeToConvert.GetElementType();
                    }
                    else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericBaseClass(typeof(List<>))) != null)
                    {
                        typeFromHandle = typeof(ListOfTConverter<,>);
                        type = compatibleGenericBaseClass.GetGenericArguments()[0];
                    }
                    else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericBaseClass(typeof(Dictionary<,>))) != null)
                    {
                        Type[] genericArguments = compatibleGenericBaseClass.GetGenericArguments();
                        typeFromHandle = typeof(DictionaryOfTKeyTValueConverter<,,>);
                        type2 = genericArguments[0];
                        type = genericArguments[1];
                    }
                    else if (typeToConvert.IsImmutableDictionaryType())
                    {
                        Type[] genericArguments = typeToConvert.GetGenericArguments();
                        typeFromHandle = typeof(ImmutableDictionaryOfTKeyTValueConverterWithReflection<,,>);
                        type2 = genericArguments[0];
                        type = genericArguments[1];
                    }
                    else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericInterface(typeof(IDictionary<,>))) != null)
                    {
                        Type[] genericArguments = compatibleGenericBaseClass.GetGenericArguments();
                        typeFromHandle = typeof(IDictionaryOfTKeyTValueConverter<,,>);
                        type2 = genericArguments[0];
                        type = genericArguments[1];
                    }
                    else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericInterface(typeof(IReadOnlyDictionary<,>))) != null)
                    {
                        Type[] genericArguments = compatibleGenericBaseClass.GetGenericArguments();
                        typeFromHandle = typeof(IReadOnlyDictionaryOfTKeyTValueConverter<,,>);
                        type2 = genericArguments[0];
                        type = genericArguments[1];
                    }
                    else if (typeToConvert.IsImmutableEnumerableType())
                    {
                        typeFromHandle = typeof(ImmutableEnumerableOfTConverterWithReflection<,>);
                        type = typeToConvert.GetGenericArguments()[0];
                    }
                    else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericInterface(typeof(IList<>))) != null)
                    {
                        typeFromHandle = typeof(IListOfTConverter<,>);
                        type = compatibleGenericBaseClass.GetGenericArguments()[0];
                    }
                    else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericInterface(typeof(ISet<>))) != null)
                    {
                        typeFromHandle = typeof(ISetOfTConverter<,>);
                        type = compatibleGenericBaseClass.GetGenericArguments()[0];
                    }
                    else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericInterface(typeof(ICollection<>))) != null)
                    {
                        typeFromHandle = typeof(ICollectionOfTConverter<,>);
                        type = compatibleGenericBaseClass.GetGenericArguments()[0];
                    }
                    else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericBaseClass(typeof(Stack<>))) != null)
                    {
                        typeFromHandle = typeof(StackOfTConverter<,>);
                        type = compatibleGenericBaseClass.GetGenericArguments()[0];
                    }
                    else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericBaseClass(typeof(Queue<>))) != null)
                    {
                        typeFromHandle = typeof(QueueOfTConverter<,>);
                        type = compatibleGenericBaseClass.GetGenericArguments()[0];
                    }
                    else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericBaseClass(typeof(ConcurrentStack<>))) != null)
                    {
                        typeFromHandle = typeof(ConcurrentStackOfTConverter<,>);
                        type = compatibleGenericBaseClass.GetGenericArguments()[0];
                    }
                    else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericBaseClass(typeof(ConcurrentQueue<>))) != null)
                    {
                        typeFromHandle = typeof(ConcurrentQueueOfTConverter<,>);
                        type = compatibleGenericBaseClass.GetGenericArguments()[0];
                    }
                    else if ((compatibleGenericBaseClass = typeToConvert.GetCompatibleGenericInterface(typeof(IEnumerable<>))) != null)
                    {
                        typeFromHandle = typeof(IEnumerableOfTConverter<,>);
                        type = compatibleGenericBaseClass.GetGenericArguments()[0];
                    }
                    else if (typeof(IDictionary).IsAssignableFrom(typeToConvert))
                    {
                        if (typeToConvert == typeof(IDictionary))
                        {
                            return s_converterForIDictionary;
                        }
                        typeFromHandle = typeof(IDictionaryConverter<>);
                    }
                    else if (typeof(IList).IsAssignableFrom(typeToConvert))
                    {
                        if (typeToConvert == typeof(IList))
                        {
                            return s_converterForIList;
                        }
                        typeFromHandle = typeof(IListConverter<>);
                    }
                    else if (typeToConvert.IsNonGenericStackOrQueue())
                    {
                        typeFromHandle = typeof(StackOrQueueConverterWithReflection<>);
                    }
                    else
                    {
                        if (typeToConvert == typeof(IEnumerable))
                        {
                            return s_converterForIEnumerable;
                        }
                        typeFromHandle = typeof(IEnumerableConverter<>);
                    }
                    return (JsonConverter)Activator.CreateInstance(typeFromHandle.GetGenericArguments().Length switch
                    {
                        1 => typeFromHandle.MakeGenericType(typeToConvert),
                        2 => typeFromHandle.MakeGenericType(typeToConvert, type),
                        _ => typeFromHandle.MakeGenericType(typeToConvert, type2, type),
                    }, BindingFlags.Instance | BindingFlags.Public, null, null, null);
                }
            }

            /// <summary>
            /// Default base class implementation of <cref>JsonIEnumerableConverter{TCollection, TElement}</cref>.
            /// </summary>
            internal abstract class IEnumerableDefaultConverter<TCollection, TElement> : JsonCollectionConverter<TCollection, TElement> where TCollection : IEnumerable<TElement>
            {
                internal override bool CanHaveMetadata => true;

                protected override bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, ref WriteStack state)
                {
                    IEnumerator<TElement> enumerator;
                    if (state.Current.CollectionEnumerator == null)
                    {
                        enumerator = value.GetEnumerator();
                        if (!enumerator.MoveNext())
                        {
                            enumerator.Dispose();
                            return true;
                        }
                    }
                    else
                    {
                        enumerator = (IEnumerator<TElement>)state.Current.CollectionEnumerator;
                    }
                    JsonConverter<TElement> elementConverter = JsonCollectionConverter<TCollection, TElement>.GetElementConverter(ref state);
                    do
                    {
                        if (JsonConverter.ShouldFlush(writer, ref state))
                        {
                            state.Current.CollectionEnumerator = enumerator;
                            return false;
                        }
                        TElement value2 = enumerator.Current;
                        if (!elementConverter.TryWrite(writer, in value2, options, ref state))
                        {
                            state.Current.CollectionEnumerator = enumerator;
                            return false;
                        }
                        state.Current.EndCollectionElement();
                    }
                    while (enumerator.MoveNext());
                    enumerator.Dispose();
                    return true;
                }
            }

            /// <summary>
            /// Converter for <cref>System.Collections.Generic.IEnumerable{TElement}</cref>.
            /// </summary>
            internal sealed class IEnumerableOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : IEnumerable<TElement>
            {
                private readonly bool _isDeserializable = typeof(TCollection).IsAssignableFrom(typeof(List<TElement>));

                internal override bool SupportsCreateObjectDelegate => false;

                protected override void Add(in TElement value, ref ReadStack state)
                {
                    ((List<TElement>)state.Current.ReturnValue).Add(value);
                }

                protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
                {
                    if (!_isDeserializable)
                    {
                        ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(TypeToConvert, ref reader, ref state);
                    }
                    state.Current.ReturnValue = new List<TElement>();
                }
            }

            /// Converter for <cref>System.Collections.IList</cref>.
            internal sealed class IListConverter<TCollection> : JsonCollectionConverter<TCollection, object> where TCollection : IList
            {
                protected override void Add(in object value, ref ReadStack state)
                {
                    TCollection val = (TCollection)state.Current.ReturnValue;
                    val.Add(value);
                    if (base.IsValueType)
                    {
                        state.Current.ReturnValue = val;
                    }
                }

                protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
                {
                    base.CreateCollection(ref reader, ref state, options);
                    if (((TCollection)state.Current.ReturnValue).IsReadOnly)
                    {
                        state.Current.ReturnValue = null;
                        ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(TypeToConvert, ref reader, ref state);
                    }
                }

                protected override bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, ref WriteStack state)
                {
                    IList list = value;
                    int i = state.Current.EnumeratorIndex;
                    JsonConverter<object> elementConverter = JsonCollectionConverter<TCollection, object>.GetElementConverter(ref state);
                    if (elementConverter.CanUseDirectReadOrWrite && !state.Current.NumberHandling.HasValue)
                    {
                        for (; i < list.Count; i++)
                        {
                            elementConverter.Write(writer, list[i], options);
                        }
                    }
                    else
                    {
                        for (; i < list.Count; i++)
                        {
                            object value2 = list[i];
                            if (!elementConverter.TryWrite(writer, in value2, options, ref state))
                            {
                                state.Current.EnumeratorIndex = i;
                                return false;
                            }
                            state.Current.EndCollectionElement();
                            if (JsonConverter.ShouldFlush(writer, ref state))
                            {
                                i = (state.Current.EnumeratorIndex = i + 1);
                                return false;
                            }
                        }
                    }
                    return true;
                }

                internal override void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
                {
                    if (jsonTypeInfo.CreateObject == null && TypeToConvert.IsAssignableFrom(typeof(List<object>)))
                    {
                        jsonTypeInfo.CreateObject = () => new List<object>();
                    }
                }
            }

            /// <summary>
            /// Converter for <cref>System.Collections.Generic.IList{TElement}</cref>.
            /// </summary>
            internal sealed class IListOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : IList<TElement>
            {
                protected override void Add(in TElement value, ref ReadStack state)
                {
                    TCollection val = (TCollection)state.Current.ReturnValue;
                    val.Add(value);
                    if (base.IsValueType)
                    {
                        state.Current.ReturnValue = val;
                    }
                }

                protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
                {
                    base.CreateCollection(ref reader, ref state, options);
                    if (((TCollection)state.Current.ReturnValue).IsReadOnly)
                    {
                        state.Current.ReturnValue = null;
                        ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(TypeToConvert, ref reader, ref state);
                    }
                }

                internal override void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
                {
                    if (jsonTypeInfo.CreateObject == null && TypeToConvert.IsAssignableFrom(typeof(List<TElement>)))
                    {
                        jsonTypeInfo.CreateObject = () => new List<TElement>();
                    }
                }
            }

            internal class ImmutableDictionaryOfTKeyTValueConverter<TDictionary, TKey, TValue> : DictionaryDefaultConverter<TDictionary, TKey, TValue> where TDictionary : IReadOnlyDictionary<TKey, TValue>
            {
                internal sealed override bool CanHaveMetadata => false;

                internal override bool SupportsCreateObjectDelegate => false;

                protected sealed override void Add(TKey key, in TValue value, JsonSerializerOptions options, ref ReadStack state)
                {
                    ((Dictionary<TKey, TValue>)state.Current.ReturnValue)[key] = value;
                }

                protected sealed override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state)
                {
                    state.Current.ReturnValue = new Dictionary<TKey, TValue>();
                }

                protected sealed override void ConvertCollection(ref ReadStack state, JsonSerializerOptions options)
                {
                    Func<IEnumerable<KeyValuePair<TKey, TValue>>, TDictionary> func = (Func<IEnumerable<KeyValuePair<TKey, TValue>>, TDictionary>)state.Current.JsonTypeInfo.CreateObjectWithArgs;
                    state.Current.ReturnValue = func((Dictionary<TKey, TValue>)state.Current.ReturnValue);
                }
            }

            internal sealed class ImmutableDictionaryOfTKeyTValueConverterWithReflection<TCollection, TKey, TValue> : ImmutableDictionaryOfTKeyTValueConverter<TCollection, TKey, TValue> where TCollection : IReadOnlyDictionary<TKey, TValue>
            {
                [RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                [RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                public ImmutableDictionaryOfTKeyTValueConverterWithReflection()
                {
                }

                [RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                [RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                internal override void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
                {
                    jsonTypeInfo.CreateObjectWithArgs = options.MemberAccessorStrategy.CreateImmutableDictionaryCreateRangeDelegate<TCollection, TKey, TValue>();
                }
            }

            internal class ImmutableEnumerableOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : IEnumerable<TElement>
            {
                internal sealed override bool CanHaveMetadata => false;

                internal override bool SupportsCreateObjectDelegate => false;

                protected sealed override void Add(in TElement value, ref ReadStack state)
                {
                    ((List<TElement>)state.Current.ReturnValue).Add(value);
                }

                protected sealed override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
                {
                    state.Current.ReturnValue = new List<TElement>();
                }

                protected sealed override void ConvertCollection(ref ReadStack state, JsonSerializerOptions options)
                {
                    JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
                    Func<IEnumerable<TElement>, TCollection> func = (Func<IEnumerable<TElement>, TCollection>)jsonTypeInfo.CreateObjectWithArgs;
                    state.Current.ReturnValue = func((List<TElement>)state.Current.ReturnValue);
                }
            }

            internal sealed class ImmutableEnumerableOfTConverterWithReflection<TCollection, TElement> : ImmutableEnumerableOfTConverter<TCollection, TElement> where TCollection : IEnumerable<TElement>
            {
                [RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                [RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                public ImmutableEnumerableOfTConverterWithReflection()
                {
                }

                [RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                [RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                internal override void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
                {
                    jsonTypeInfo.CreateObjectWithArgs = options.MemberAccessorStrategy.CreateImmutableEnumerableCreateRangeDelegate<TCollection, TElement>();
                }
            }

            internal sealed class Int16Converter : JsonConverter<short>
            {
                public Int16Converter()
                {
                    IsInternalConverterForNumberType = true;
                }

                public override short Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetInt16();
                }

                public override void Write(Utf8JsonWriter writer, short value, JsonSerializerOptions options)
                {
                    writer.WriteNumberValue((long)value);
                }

                internal override short ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetInt16WithQuotes();
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, short value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    writer.WritePropertyName(value);
                }

                internal override short ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
                {
                    if (reader.TokenType == JsonTokenType.String && (JsonNumberHandling.AllowReadingFromString & handling) != 0)
                    {
                        return reader.GetInt16WithQuotes();
                    }
                    return reader.GetInt16();
                }

                internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, short value, JsonNumberHandling handling)
                {
                    if ((JsonNumberHandling.WriteAsString & handling) != 0)
                    {
                        writer.WriteNumberValueAsString(value);
                    }
                    else
                    {
                        writer.WriteNumberValue((long)value);
                    }
                }
            }

            internal sealed class Int32Converter : JsonConverter<int>
            {
                public Int32Converter()
                {
                    IsInternalConverterForNumberType = true;
                }

                public override int Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetInt32();
                }

                public override void Write(Utf8JsonWriter writer, int value, JsonSerializerOptions options)
                {
                    writer.WriteNumberValue((long)value);
                }

                internal override int ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetInt32WithQuotes();
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, int value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    writer.WritePropertyName(value);
                }

                internal override int ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
                {
                    if (reader.TokenType == JsonTokenType.String && (JsonNumberHandling.AllowReadingFromString & handling) != 0)
                    {
                        return reader.GetInt32WithQuotes();
                    }
                    return reader.GetInt32();
                }

                internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, int value, JsonNumberHandling handling)
                {
                    if ((JsonNumberHandling.WriteAsString & handling) != 0)
                    {
                        writer.WriteNumberValueAsString(value);
                    }
                    else
                    {
                        writer.WriteNumberValue((long)value);
                    }
                }
            }

            internal sealed class Int64Converter : JsonConverter<long>
            {
                public Int64Converter()
                {
                    IsInternalConverterForNumberType = true;
                }

                public override long Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetInt64();
                }

                public override void Write(Utf8JsonWriter writer, long value, JsonSerializerOptions options)
                {
                    writer.WriteNumberValue(value);
                }

                internal override long ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetInt64WithQuotes();
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, long value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    writer.WritePropertyName(value);
                }

                internal override long ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
                {
                    if (reader.TokenType == JsonTokenType.String && (JsonNumberHandling.AllowReadingFromString & handling) != 0)
                    {
                        return reader.GetInt64WithQuotes();
                    }
                    return reader.GetInt64();
                }

                internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, long value, JsonNumberHandling handling)
                {
                    if ((JsonNumberHandling.WriteAsString & handling) != 0)
                    {
                        writer.WriteNumberValueAsString(value);
                    }
                    else
                    {
                        writer.WriteNumberValue(value);
                    }
                }
            }

            internal sealed class IReadOnlyDictionaryOfTKeyTValueConverter<TDictionary, TKey, TValue> : DictionaryDefaultConverter<TDictionary, TKey, TValue> where TDictionary : IReadOnlyDictionary<TKey, TValue>
            {
                private readonly bool _isDeserializable = typeof(TDictionary).IsAssignableFrom(typeof(Dictionary<TKey, TValue>));

                internal override bool SupportsCreateObjectDelegate => false;

                protected override void Add(TKey key, in TValue value, JsonSerializerOptions options, ref ReadStack state)
                {
                    ((Dictionary<TKey, TValue>)state.Current.ReturnValue)[key] = value;
                }

                protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state)
                {
                    if (!_isDeserializable)
                    {
                        ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(TypeToConvert, ref reader, ref state);
                    }
                    state.Current.ReturnValue = new Dictionary<TKey, TValue>();
                }
            }

            internal sealed class ISetOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : ISet<TElement>
            {
                protected override void Add(in TElement value, ref ReadStack state)
                {
                    TCollection val = (TCollection)state.Current.ReturnValue;
                    val.Add(value);
                    if (base.IsValueType)
                    {
                        state.Current.ReturnValue = val;
                    }
                }

                protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
                {
                    base.CreateCollection(ref reader, ref state, options);
                    if (((TCollection)state.Current.ReturnValue).IsReadOnly)
                    {
                        state.Current.ReturnValue = null;
                        ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(TypeToConvert, ref reader, ref state);
                    }
                }

                internal override void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
                {
                    if (jsonTypeInfo.CreateObject == null && TypeToConvert.IsAssignableFrom(typeof(HashSet<TElement>)))
                    {
                        jsonTypeInfo.CreateObject = () => new HashSet<TElement>();
                    }
                }
            }

            internal sealed class JsonArrayConverter : JsonConverter<JsonArray>
            {
                public override void Write(Utf8JsonWriter writer, JsonArray value, JsonSerializerOptions options)
                {
                    value.WriteTo(writer, options);
                }

                public override JsonArray Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    JsonTokenType tokenType = reader.TokenType;
                    if (tokenType == JsonTokenType.StartArray)
                    {
                        return ReadList(ref reader, options.GetNodeOptions());
                    }
                    throw ThrowHelper.GetInvalidOperationException_ExpectedArray(reader.TokenType);
                }

                public static JsonArray ReadList(ref Utf8JsonReader reader, JsonNodeOptions? options = null)
                {
                    JsonElement element = JsonElement.ParseValue(ref reader);
                    return new JsonArray(element, options);
                }
            }

            internal sealed class JsonDocumentConverter : JsonConverter<JsonDocument>
            {
                public override JsonDocument Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return JsonDocument.ParseValue(ref reader);
                }

                public override void Write(Utf8JsonWriter writer, JsonDocument value, JsonSerializerOptions options)
                {
                    value.WriteTo(writer);
                }
            }

            internal sealed class JsonElementConverter : JsonConverter<JsonElement>
            {
                public override JsonElement Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return JsonElement.ParseValue(ref reader);
                }

                public override void Write(Utf8JsonWriter writer, JsonElement value, JsonSerializerOptions options)
                {
                    value.WriteTo(writer);
                }
            }

            /// <summary>
            /// Provides a mechanism to invoke "fast-path" serialization logic via
            /// <see cref="P:System.Text.Json.Serialization.Metadata.JsonTypeInfo`1.SerializeHandler" />. This type holds an optional
            /// reference to an actual <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> for the type
            /// <typeparamref name="T" />, to provide a fallback when the fast path cannot be used.
            /// </summary>
            /// <typeparam name="T">The type to converter</typeparam>
            internal sealed class JsonMetadataServicesConverter<T> : JsonResumableConverter<T>
            {
                private readonly Func<JsonConverter<T>> _converterCreator;

                private readonly ConverterStrategy _converterStrategy;

                private JsonConverter<T> _converter;

                internal JsonConverter<T> Converter
                {
                    get
                    {
                        if (_converter == null)
                        {
                            _converter = _converterCreator();
                        }
                        return _converter;
                    }
                }

                internal override ConverterStrategy ConverterStrategy => _converterStrategy;

                internal override Type KeyType => Converter.KeyType;

                internal override Type ElementType => Converter.ElementType;

                internal override bool ConstructorIsParameterized => Converter.ConstructorIsParameterized;

                internal override bool SupportsCreateObjectDelegate => Converter.SupportsCreateObjectDelegate;

                internal override bool CanHaveMetadata => Converter.CanHaveMetadata;

                public JsonMetadataServicesConverter(Func<JsonConverter<T>> converterCreator, ConverterStrategy converterStrategy)
                {
                    if (converterCreator == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("converterCreator");
                    }
                    _converterCreator = converterCreator;
                    _converterStrategy = converterStrategy;
                }

                public JsonMetadataServicesConverter(JsonConverter<T> converter)
                {
                    _converter = converter;
                    _converterStrategy = converter.ConverterStrategy;
                }

                internal override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out T value)
                {
                    return Converter.OnTryRead(ref reader, typeToConvert, options, ref state, out value);
                }

                internal override bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, ref WriteStack state)
                {
                    JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
                    if (!state.SupportContinuation && jsonTypeInfo.CanUseSerializeHandler && !state.CurrentContainsMetadata)
                    {
                        ((JsonTypeInfo<T>)jsonTypeInfo).SerializeHandler(writer, value);
                        return true;
                    }
                    jsonTypeInfo.ValidateCanBeUsedForMetadataSerialization();
                    return Converter.OnTryWrite(writer, value, options, ref state);
                }

                internal override void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
                {
                    Converter.ConfigureJsonTypeInfo(jsonTypeInfo, options);
                }
            }

            /// <summary>
            /// Converter for JsonNode-derived types. The {T} value must be Object and not JsonNode
            /// since we allow Object-declared members\variables to deserialize as {JsonNode}.
            /// </summary>
            internal sealed class JsonNodeConverter : JsonConverter<JsonNode>
            {
                private static JsonNodeConverter s_nodeConverter;

                private static JsonArrayConverter s_arrayConverter;

                private static JsonObjectConverter s_objectConverter;

                private static JsonValueConverter s_valueConverter;

                public static JsonNodeConverter Instance => s_nodeConverter ?? (s_nodeConverter = new JsonNodeConverter());

                public static JsonArrayConverter ArrayConverter => s_arrayConverter ?? (s_arrayConverter = new JsonArrayConverter());

                public static JsonObjectConverter ObjectConverter => s_objectConverter ?? (s_objectConverter = new JsonObjectConverter());

                public static JsonValueConverter ValueConverter => s_valueConverter ?? (s_valueConverter = new JsonValueConverter());

                public override void Write(Utf8JsonWriter writer, JsonNode value, JsonSerializerOptions options)
                {
                    if (value == null)
                    {
                        writer.WriteNullValue();
                    }
                    else if (value is JsonValue value2)
                    {
                        ValueConverter.Write(writer, value2, options);
                    }
                    else if (value is JsonObject value3)
                    {
                        ObjectConverter.Write(writer, value3, options);
                    }
                    else
                    {
                        ArrayConverter.Write(writer, (JsonArray)value, options);
                    }
                }

                public override JsonNode Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    switch (reader.TokenType)
                    {
                        case JsonTokenType.String:
                        case JsonTokenType.Number:
                        case JsonTokenType.True:
                        case JsonTokenType.False:
                            return ValueConverter.Read(ref reader, typeToConvert, options);
                        case JsonTokenType.StartObject:
                            return ObjectConverter.Read(ref reader, typeToConvert, options);
                        case JsonTokenType.StartArray:
                            return ArrayConverter.Read(ref reader, typeToConvert, options);
                        default:
                            throw new JsonException();
                    }
                }

                public static JsonNode Create(JsonElement element, JsonNodeOptions? options)
                {
                    return element.ValueKind switch
                    {
                        JsonValueKind.Null => null,
                        JsonValueKind.Object => new JsonObject(element, options),
                        JsonValueKind.Array => new JsonArray(element, options),
                        _ => new JsonValueTrimmable<JsonElement>(element, JsonMetadataServices.JsonElementConverter, options),
                    };
                }
            }

            internal sealed class JsonNodeConverterFactory : JsonConverterFactory
            {
                public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
                {
                    if (typeof(JsonValue).IsAssignableFrom(typeToConvert))
                    {
                        return JsonNodeConverter.ValueConverter;
                    }
                    if (typeof(JsonObject) == typeToConvert)
                    {
                        return JsonNodeConverter.ObjectConverter;
                    }
                    if (typeof(JsonArray) == typeToConvert)
                    {
                        return JsonNodeConverter.ArrayConverter;
                    }
                    return JsonNodeConverter.Instance;
                }

                public override bool CanConvert(Type typeToConvert)
                {
                    if (typeToConvert != JsonTypeInfo.ObjectType)
                    {
                        return typeof(JsonNode).IsAssignableFrom(typeToConvert);
                    }
                    return false;
                }
            }

            internal sealed class JsonObjectConverter : JsonConverter<JsonObject>
            {
                internal override void ConfigureJsonTypeInfo(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
                {
                    jsonTypeInfo.CreateObjectForExtensionDataProperty = () => new JsonObject(options.GetNodeOptions());
                }

                internal override void ReadElementAndSetProperty(object obj, string propertyName, ref Utf8JsonReader reader, JsonSerializerOptions options, scoped ref ReadStack state)
                {
                    JsonNode value;
                    bool flag = JsonNodeConverter.Instance.TryRead(ref reader, typeof(JsonNode), options, ref state, out value);
                    JsonObject jsonObject = (JsonObject)obj;
                    JsonNode value2 = value;
                    jsonObject[propertyName] = value2;
                }

                public override void Write(Utf8JsonWriter writer, JsonObject value, JsonSerializerOptions options)
                {
                    value.WriteTo(writer, options);
                }

                public override JsonObject Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    JsonTokenType tokenType = reader.TokenType;
                    if (tokenType == JsonTokenType.StartObject)
                    {
                        return ReadObject(ref reader, options.GetNodeOptions());
                    }
                    throw ThrowHelper.GetInvalidOperationException_ExpectedObject(reader.TokenType);
                }

                public static JsonObject ReadObject(ref Utf8JsonReader reader, JsonNodeOptions? options)
                {
                    JsonElement element = JsonElement.ParseValue(ref reader);
                    return new JsonObject(element, options);
                }
            }

            internal sealed class JsonValueConverter : JsonConverter<JsonValue>
            {
                public override void Write(Utf8JsonWriter writer, JsonValue value, JsonSerializerOptions options)
                {
                    value.WriteTo(writer, options);
                }

                public override JsonValue Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    JsonElement value = JsonElement.ParseValue(ref reader);
                    return new JsonValueTrimmable<JsonElement>(value, JsonMetadataServices.JsonElementConverter, options.GetNodeOptions());
                }
            }

            internal sealed class KeyValuePairConverter<TKey, TValue> : SmallObjectWithParameterizedConstructorConverter<KeyValuePair<TKey, TValue>, TKey, TValue, object, object>
            {
                private static readonly ConstructorInfo s_constructorInfo = typeof(KeyValuePair<TKey, TValue>).GetConstructor(new Type[2] { typeof(TKey), typeof(TValue) });

                public KeyValuePairConverter() { base.ConstructorInfo = s_constructorInfo; }
            }

            /// <summary>
            /// Implementation of <cref>JsonObjectConverter{T}</cref> that supports the deserialization
            /// of JSON objects using parameterized constructors.
            /// </summary>
            internal class LargeObjectWithParameterizedConstructorConverter<T> : ObjectWithParameterizedConstructorConverter<T>
            {
                protected sealed override bool ReadAndCacheConstructorArgument(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonParameterInfo jsonParameterInfo)
                {
                    object value;
                    bool flag = jsonParameterInfo.ConverterBase.TryReadAsObject(ref reader, jsonParameterInfo.Options, ref state, out value);
                    if (flag && (value != null || !jsonParameterInfo.IgnoreNullTokensOnRead))
                    {
                        ((object[])state.Current.CtorArgumentState.Arguments)[jsonParameterInfo.ClrInfo.Position] = value;
                        state.Current.MarkRequiredPropertyAsRead(jsonParameterInfo.MatchingProperty);
                    }
                    return flag;
                }

                protected sealed override object CreateObject(ref ReadStackFrame frame)
                {
                    object[] array = (object[])frame.CtorArgumentState.Arguments;
                    frame.CtorArgumentState.Arguments = null;
                    Func<object[], T> func = (Func<object[], T>)frame.JsonTypeInfo.CreateObjectWithArgs;
                    if (func == null)
                    {
                        ThrowHelper.ThrowNotSupportedException_ConstructorMaxOf64Parameters(TypeToConvert);
                    }
                    object result = func(array);
                    ArrayPool<object>.Shared.Return(array, clearArray: true);
                    return result;
                }

                protected sealed override void InitializeConstructorArgumentCaches(ref ReadStack state, JsonSerializerOptions options)
                {
                    JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
                    List<KeyValuePair<string, JsonParameterInfo>> list = jsonTypeInfo.ParameterCache.List;
                    object[] array = ArrayPool<object>.Shared.Rent(list.Count);
                    for (int i = 0; i < jsonTypeInfo.ParameterCount; i++)
                    {
                        JsonParameterInfo value = list[i].Value;
                        array[value.ClrInfo.Position] = value.DefaultValue;
                    }
                    state.Current.CtorArgumentState.Arguments = array;
                }
            }

            /// <summary>
            /// Implementation of <cref>JsonObjectConverter{T}</cref> that supports the deserialization
            /// of JSON objects using parameterized constructors.
            /// </summary>
            internal sealed class LargeObjectWithParameterizedConstructorConverterWithReflection<T> : LargeObjectWithParameterizedConstructorConverter<T>
            {
                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
                [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                public LargeObjectWithParameterizedConstructorConverterWithReflection()
                {
                }

                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
                [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                internal override void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
                {
                    jsonTypeInfo.CreateObjectWithArgs = options.MemberAccessorStrategy.CreateParameterizedConstructor<T>(base.ConstructorInfo);
                }
            }

            /// Converter for <cref>System.Collections.Generic.List{TElement}</cref>.
            internal sealed class ListOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : List<TElement>
            {
                protected override void Add(in TElement value, ref ReadStack state)
                {
                    ((TCollection)state.Current.ReturnValue).Add(value);
                }

                protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
                {
                    if (state.Current.JsonTypeInfo.CreateObject == null)
                    {
                        ThrowHelper.ThrowNotSupportedException_SerializationNotSupported(state.Current.JsonTypeInfo.Type);
                    }
                    state.Current.ReturnValue = state.Current.JsonTypeInfo.CreateObject();
                }

                protected override bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, ref WriteStack state)
                {
                    int i = state.Current.EnumeratorIndex;
                    JsonConverter<TElement> elementConverter = JsonCollectionConverter<TCollection, TElement>.GetElementConverter(ref state);
                    if (elementConverter.CanUseDirectReadOrWrite && !state.Current.NumberHandling.HasValue)
                    {
                        for (; i < value.Count; i++)
                        {
                            elementConverter.Write(writer, value[i], options);
                        }
                    }
                    else
                    {
                        for (; i < value.Count; i++)
                        {
                            TElement value2 = value[i];
                            if (!elementConverter.TryWrite(writer, in value2, options, ref state))
                            {
                                state.Current.EnumeratorIndex = i;
                                return false;
                            }
                            state.Current.EndCollectionElement();
                            if (JsonConverter.ShouldFlush(writer, ref state))
                            {
                                i = (state.Current.EnumeratorIndex = i + 1);
                                return false;
                            }
                        }
                    }
                    return true;
                }
            }

            internal sealed class NullableConverter<T> : JsonConverter<T?> where T : struct
            {
                private readonly JsonConverter<T> _elementConverter;

                internal override ConverterStrategy ConverterStrategy { get; }

                internal override Type ElementType => typeof(T);

                public override bool HandleNull => true;

                public NullableConverter(JsonConverter<T> elementConverter)
                {
                    _elementConverter = elementConverter;
                    IsInternalConverterForNumberType = elementConverter.IsInternalConverterForNumberType;
                    ConverterStrategy = elementConverter.ConverterStrategy;
                    base.CanUseDirectReadOrWrite = elementConverter.CanUseDirectReadOrWrite;
                    base.RequiresReadAhead = elementConverter.RequiresReadAhead;
                }

                internal override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out T? value)
                {
                    if (!state.IsContinuation && reader.TokenType == JsonTokenType.Null)
                    {
                        value = null;
                        return true;
                    }
                    state.Current.JsonPropertyInfo = state.Current.JsonTypeInfo.ElementTypeInfo.PropertyInfoForTypeInfo;
                    if (_elementConverter.TryRead(ref reader, typeof(T), options, ref state, out var value2))
                    {
                        value = value2;
                        return true;
                    }
                    value = null;
                    return false;
                }

                internal override bool OnTryWrite(Utf8JsonWriter writer, T? value, JsonSerializerOptions options, ref WriteStack state)
                {
                    if (!value.HasValue)
                    {
                        writer.WriteNullValue();
                        return true;
                    }
                    state.Current.JsonPropertyInfo = state.Current.JsonTypeInfo.ElementTypeInfo.PropertyInfoForTypeInfo;
                    JsonConverter<T> elementConverter = _elementConverter;
                    T value2 = value.Value;
                    return elementConverter.TryWrite(writer, in value2, options, ref state);
                }

                public override T? Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    if (reader.TokenType == JsonTokenType.Null)
                    {
                        return null;
                    }
                    return _elementConverter.Read(ref reader, typeof(T), options);
                }

                public override void Write(Utf8JsonWriter writer, T? value, JsonSerializerOptions options)
                {
                    if (!value.HasValue)
                    {
                        writer.WriteNullValue();
                    }
                    else
                    {
                        _elementConverter.Write(writer, value.Value, options);
                    }
                }

                internal override T? ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling numberHandling, JsonSerializerOptions options)
                {
                    if (reader.TokenType == JsonTokenType.Null)
                    {
                        return null;
                    }
                    return _elementConverter.ReadNumberWithCustomHandling(ref reader, numberHandling, options);
                }

                internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, T? value, JsonNumberHandling handling)
                {
                    if (!value.HasValue)
                    {
                        writer.WriteNullValue();
                    }
                    else
                    {
                        _elementConverter.WriteNumberWithCustomHandling(writer, value.Value, handling);
                    }
                }
            }

            [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
            internal sealed class NullableConverterFactory : JsonConverterFactory
            {
                public override bool CanConvert(Type typeToConvert)
                {
                    return typeToConvert.IsNullableOfT();
                }

                public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
                {
                    Type type = typeToConvert.GetGenericArguments()[0];
                    JsonConverter converterInternal = options.GetConverterInternal(type);
                    if (!converterInternal.TypeToConvert.IsValueType && type.IsValueType)
                    {
                        return converterInternal;
                    }
                    return CreateValueConverter(type, converterInternal);
                }

                public static JsonConverter CreateValueConverter(Type valueTypeToConvert, JsonConverter valueConverter)
                {
                    return (JsonConverter)Activator.CreateInstance(GetNullableConverterType(valueTypeToConvert), BindingFlags.Instance | BindingFlags.Public, null, new object[1] { valueConverter }, null);
                }

                [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern", Justification = "'NullableConverter<T> where T : struct' implies 'T : new()', so the trimmer is warning calling MakeGenericType here because valueTypeToConvert's constructors are not annotated. But NullableConverter doesn't call new T(), so this is safe.")]
                [return: DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)]
                private static Type GetNullableConverterType(Type valueTypeToConvert)
                {
                    return typeof(NullableConverter<>).MakeGenericType(valueTypeToConvert);
                }
            }

            internal sealed class ObjectConverter : JsonConverter<object>
            {
                internal override ConverterStrategy ConverterStrategy => ConverterStrategy.Object;

                public ObjectConverter()
                {
                    base.CanBePolymorphic = true;
                    base.RequiresReadAhead = true;
                }

                public override object Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    if (options.UnknownTypeHandling == JsonUnknownTypeHandling.JsonElement)
                    {
                        return JsonElement.ParseValue(ref reader);
                    }
                    return JsonNodeConverter.Instance.Read(ref reader, typeToConvert, options);
                }

                public override void Write(Utf8JsonWriter writer, object value, JsonSerializerOptions options)
                {
                    writer.WriteStartObject();
                    writer.WriteEndObject();
                }

                internal override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, out object value)
                {
                    object referenceValue;
                    if (options.UnknownTypeHandling == JsonUnknownTypeHandling.JsonElement)
                    {
                        JsonElement jsonElement = JsonElement.ParseValue(ref reader);
                        if (options.ReferenceHandlingStrategy == ReferenceHandlingStrategy.Preserve && JsonSerializer.TryHandleReferenceFromJsonElement(ref reader, ref state, jsonElement, out referenceValue))
                        {
                            value = referenceValue;
                        }
                        else
                        {
                            value = jsonElement;
                        }
                        return true;
                    }
                    JsonNode jsonNode = JsonNodeConverter.Instance.Read(ref reader, typeToConvert, options);
                    if (options.ReferenceHandlingStrategy == ReferenceHandlingStrategy.Preserve && JsonSerializer.TryHandleReferenceFromJsonNode(ref reader, ref state, jsonNode, out referenceValue))
                    {
                        value = referenceValue;
                    }
                    else
                    {
                        value = jsonNode;
                    }
                    return true;
                }

                internal override object ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    ThrowHelper.ThrowNotSupportedException_DictionaryKeyTypeNotSupported(TypeToConvert, this);
                    return null;
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, object value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    Type type = value.GetType();
                    JsonConverter converterInternal = options.GetConverterInternal(type);
                    if (converterInternal == this)
                    {
                        ThrowHelper.ThrowNotSupportedException_DictionaryKeyTypeNotSupported(type, this);
                    }
                    converterInternal.WriteAsPropertyNameCoreAsObject(writer, value, options, isWritingExtensionDataProperty);
                }
            }

            /// <summary>
            /// Converter factory for all object-based types (non-enumerable and non-primitive).
            /// </summary>
            [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
            internal sealed class ObjectConverterFactory : JsonConverterFactory
            {
                private readonly bool _useDefaultConstructorInUnannotatedStructs;

                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
                public ObjectConverterFactory(bool useDefaultConstructorInUnannotatedStructs = true)
                {
                    _useDefaultConstructorInUnannotatedStructs = useDefaultConstructorInUnannotatedStructs;
                }

                public override bool CanConvert(Type typeToConvert)
                {
                    return true;
                }

                [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "The ctor is marked RequiresUnreferencedCode.")]
                [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2067:UnrecognizedReflectionPattern", Justification = "The ctor is marked RequiresUnreferencedCode.")]
                public override JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options)
                {
                    if (typeToConvert.IsKeyValuePair())
                    {
                        return CreateKeyValuePairConverter(typeToConvert);
                    }
                    if (!typeToConvert.TryGetDeserializationConstructor(_useDefaultConstructorInUnannotatedStructs, out var deserializationCtor))
                    {
                        ThrowHelper.ThrowInvalidOperationException_SerializationDuplicateTypeAttribute<JsonConstructorAttribute>(typeToConvert);
                    }
                    ParameterInfo[] array = deserializationCtor?.GetParameters();
                    Type type;
                    if (deserializationCtor == null || typeToConvert.IsAbstract || array.Length == 0)
                    {
                        type = typeof(ObjectDefaultConverter<>).MakeGenericType(typeToConvert);
                    }
                    else
                    {
                        int num = array.Length;
                        if (num <= 4)
                        {
                            Type objectType = JsonTypeInfo.ObjectType;
                            Type[] array2 = new Type[5] { typeToConvert, null, null, null, null };
                            for (int i = 0; i < 4; i++)
                            {
                                if (i < num)
                                {
                                    array2[i + 1] = array[i].ParameterType;
                                }
                                else
                                {
                                    array2[i + 1] = objectType;
                                }
                            }
                            type = typeof(SmallObjectWithParameterizedConstructorConverter<,,,,>).MakeGenericType(array2);
                        }
                        else
                        {
                            type = typeof(LargeObjectWithParameterizedConstructorConverterWithReflection<>).MakeGenericType(typeToConvert);
                        }
                    }
                    JsonConverter jsonConverter = (JsonConverter)Activator.CreateInstance(type, BindingFlags.Instance | BindingFlags.Public, null, null, null);
                    jsonConverter.ConstructorInfo = deserializationCtor;
                    return jsonConverter;
                }

                private static JsonConverter CreateKeyValuePairConverter(Type type)
                {
                    Type type2 = type.GetGenericArguments()[0];
                    Type type3 = type.GetGenericArguments()[1];
                    return (JsonConverter)Activator.CreateInstance(typeof(KeyValuePairConverter<,>).MakeGenericType(type2, type3), BindingFlags.Instance | BindingFlags.Public, null, null, null);
                }
            }

            /// <summary>
            /// Default base class implementation of <cref>JsonObjectConverter{T}</cref>.
            /// </summary>
            internal class ObjectDefaultConverter<T> : JsonObjectConverter<T>
            {
                internal override bool CanHaveMetadata => true;

                internal override bool SupportsCreateObjectDelegate => true;

                internal override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, [System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out T value)
                {
                    JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
                    object obj;
                    if (!state.SupportContinuation && !state.Current.CanContainMetadata)
                    {
                        if (reader.TokenType != JsonTokenType.StartObject)
                        {
                            ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(TypeToConvert);
                        }
                        if (jsonTypeInfo.CreateObject == null)
                        {
                            ThrowHelper.ThrowNotSupportedException_DeserializeNoConstructor(jsonTypeInfo.Type, ref reader, ref state);
                        }
                        obj = jsonTypeInfo.CreateObject();
                        jsonTypeInfo.OnDeserializing?.Invoke(obj);
                        state.Current.InitializeRequiredPropertiesValidationState(jsonTypeInfo);
                        while (true)
                        {
                            reader.ReadWithVerify();
                            JsonTokenType tokenType = reader.TokenType;
                            if (tokenType == JsonTokenType.EndObject)
                            {
                                break;
                            }
                            ReadOnlySpan<byte> propertyName = JsonSerializer.GetPropertyName(ref state, ref reader, options);
                            bool useExtensionProperty;
                            JsonPropertyInfo jsonPropertyInfo = JsonSerializer.LookupProperty(obj, propertyName, ref state, options, out useExtensionProperty);
                            ReadPropertyValue(obj, ref state, ref reader, jsonPropertyInfo, useExtensionProperty);
                        }
                    }
                    else
                    {
                        if (state.Current.ObjectState == StackFrameObjectState.None)
                        {
                            if (reader.TokenType != JsonTokenType.StartObject)
                            {
                                ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(TypeToConvert);
                            }
                            state.Current.ObjectState = StackFrameObjectState.StartToken;
                        }
                        if (state.Current.CanContainMetadata && (int)state.Current.ObjectState < 2)
                        {
                            if (!JsonSerializer.TryReadMetadata(this, jsonTypeInfo, ref reader, ref state))
                            {
                                value = default(T);
                                return false;
                            }
                            if (state.Current.MetadataPropertyNames == MetadataPropertyName.Ref)
                            {
                                value = JsonSerializer.ResolveReferenceId<T>(ref state);
                                return true;
                            }
                            state.Current.ObjectState = StackFrameObjectState.ReadMetadata;
                        }
                        if (state.Current.MetadataPropertyNames.HasFlag(MetadataPropertyName.Type) && state.Current.PolymorphicSerializationState != PolymorphicSerializationState.PolymorphicReEntryStarted)
                        {
                            JsonConverter jsonConverter = ResolvePolymorphicConverter(jsonTypeInfo, options, ref state);
                            if (jsonConverter != null)
                            {
                                object value2;
                                bool flag = jsonConverter.OnTryReadAsObject(ref reader, options, ref state, out value2);
                                value = (T)value2;
                                state.ExitPolymorphicConverter(flag);
                                return flag;
                            }
                        }
                        if ((int)state.Current.ObjectState < 4)
                        {
                            if (state.Current.CanContainMetadata)
                            {
                                JsonSerializer.ValidateMetadataForObjectConverter(this, ref reader, ref state);
                            }
                            if (state.Current.MetadataPropertyNames == MetadataPropertyName.Ref)
                            {
                                value = JsonSerializer.ResolveReferenceId<T>(ref state);
                                return true;
                            }
                            if (jsonTypeInfo.CreateObject == null)
                            {
                                ThrowHelper.ThrowNotSupportedException_DeserializeNoConstructor(jsonTypeInfo.Type, ref reader, ref state);
                            }
                            obj = jsonTypeInfo.CreateObject();
                            if (state.Current.MetadataPropertyNames.HasFlag(MetadataPropertyName.Id))
                            {
                                state.ReferenceResolver.AddReference(state.ReferenceId, obj);
                                state.ReferenceId = null;
                            }
                            jsonTypeInfo.OnDeserializing?.Invoke(obj);
                            state.Current.ReturnValue = obj;
                            state.Current.ObjectState = StackFrameObjectState.CreatedObject;
                            state.Current.InitializeRequiredPropertiesValidationState(jsonTypeInfo);
                        }
                        else
                        {
                            obj = state.Current.ReturnValue;
                        }
                        while (true)
                        {
                            if (state.Current.PropertyState == StackFramePropertyState.None)
                            {
                                state.Current.PropertyState = StackFramePropertyState.ReadName;
                                if (!reader.Read())
                                {
                                    state.Current.ReturnValue = obj;
                                    value = default(T);
                                    return false;
                                }
                            }
                            JsonPropertyInfo jsonPropertyInfo2;
                            if ((int)state.Current.PropertyState < 2)
                            {
                                state.Current.PropertyState = StackFramePropertyState.Name;
                                JsonTokenType tokenType2 = reader.TokenType;
                                if (tokenType2 == JsonTokenType.EndObject)
                                {
                                    break;
                                }
                                ReadOnlySpan<byte> propertyName2 = JsonSerializer.GetPropertyName(ref state, ref reader, options);
                                jsonPropertyInfo2 = JsonSerializer.LookupProperty(obj, propertyName2, ref state, options, out var useExtensionProperty2);
                                state.Current.UseExtensionProperty = useExtensionProperty2;
                            }
                            else
                            {
                                jsonPropertyInfo2 = state.Current.JsonPropertyInfo;
                            }
                            if ((int)state.Current.PropertyState < 3)
                            {
                                if (!jsonPropertyInfo2.CanDeserialize)
                                {
                                    if (!reader.TrySkip())
                                    {
                                        state.Current.ReturnValue = obj;
                                        value = default(T);
                                        return false;
                                    }
                                    state.Current.EndProperty();
                                    continue;
                                }
                                if (!ReadAheadPropertyValue(ref state, ref reader, jsonPropertyInfo2))
                                {
                                    state.Current.ReturnValue = obj;
                                    value = default(T);
                                    return false;
                                }
                            }
                            if ((int)state.Current.PropertyState >= 5)
                            {
                                continue;
                            }
                            if (!state.Current.UseExtensionProperty)
                            {
                                if (!jsonPropertyInfo2.ReadJsonAndSetMember(obj, ref state, ref reader))
                                {
                                    state.Current.ReturnValue = obj;
                                    value = default(T);
                                    return false;
                                }
                            }
                            else if (!jsonPropertyInfo2.ReadJsonAndAddExtensionProperty(obj, ref state, ref reader))
                            {
                                state.Current.ReturnValue = obj;
                                value = default(T);
                                return false;
                            }
                            state.Current.EndProperty();
                        }
                    }
                    jsonTypeInfo.OnDeserialized?.Invoke(obj);
                    state.Current.ValidateAllRequiredPropertiesAreRead(jsonTypeInfo);
                    value = (T)obj;
                    if (state.Current.PropertyRefCache != null)
                    {
                        jsonTypeInfo.UpdateSortedPropertyCache(ref state.Current);
                    }
                    return true;
                }

                internal sealed override bool OnTryWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options, ref WriteStack state)
                {
                    JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
                    object obj = value;
                    if (!state.SupportContinuation)
                    {
                        writer.WriteStartObject();
                        if (state.CurrentContainsMetadata && CanHaveMetadata)
                        {
                            JsonSerializer.WriteMetadataForObject(this, ref state, writer);
                        }
                        jsonTypeInfo.OnSerializing?.Invoke(obj);
                        List<KeyValuePair<string, JsonPropertyInfo>> list = jsonTypeInfo.PropertyCache.List;
                        for (int i = 0; i < list.Count; i++)
                        {
                            JsonPropertyInfo value2 = list[i].Value;
                            if (value2.CanSerialize)
                            {
                                state.Current.JsonPropertyInfo = value2;
                                state.Current.NumberHandling = value2.EffectiveNumberHandling;
                                bool memberAndWriteJson = value2.GetMemberAndWriteJson(obj, ref state, writer);
                                state.Current.EndProperty();
                            }
                        }
                        JsonPropertyInfo extensionDataProperty = jsonTypeInfo.ExtensionDataProperty;
                        if (extensionDataProperty != null && extensionDataProperty.CanSerialize)
                        {
                            state.Current.JsonPropertyInfo = extensionDataProperty;
                            state.Current.NumberHandling = extensionDataProperty.EffectiveNumberHandling;
                            bool memberAndWriteJsonExtensionData = extensionDataProperty.GetMemberAndWriteJsonExtensionData(obj, ref state, writer);
                            state.Current.EndProperty();
                        }
                        writer.WriteEndObject();
                    }
                    else
                    {
                        if (!state.Current.ProcessedStartToken)
                        {
                            writer.WriteStartObject();
                            if (state.CurrentContainsMetadata && CanHaveMetadata)
                            {
                                JsonSerializer.WriteMetadataForObject(this, ref state, writer);
                            }
                            jsonTypeInfo.OnSerializing?.Invoke(obj);
                            state.Current.ProcessedStartToken = true;
                        }
                        List<KeyValuePair<string, JsonPropertyInfo>> list2 = jsonTypeInfo.PropertyCache.List;
                        while (state.Current.EnumeratorIndex < list2.Count)
                        {
                            JsonPropertyInfo value3 = list2[state.Current.EnumeratorIndex].Value;
                            if (value3.CanSerialize)
                            {
                                state.Current.JsonPropertyInfo = value3;
                                state.Current.NumberHandling = value3.EffectiveNumberHandling;
                                if (!value3.GetMemberAndWriteJson(obj, ref state, writer))
                                {
                                    return false;
                                }
                                state.Current.EndProperty();
                                state.Current.EnumeratorIndex++;
                                if (JsonConverter.ShouldFlush(writer, ref state))
                                {
                                    return false;
                                }
                            }
                            else
                            {
                                state.Current.EnumeratorIndex++;
                            }
                        }
                        if (state.Current.EnumeratorIndex == list2.Count)
                        {
                            JsonPropertyInfo extensionDataProperty2 = jsonTypeInfo.ExtensionDataProperty;
                            if (extensionDataProperty2 != null && extensionDataProperty2.CanSerialize)
                            {
                                state.Current.JsonPropertyInfo = extensionDataProperty2;
                                state.Current.NumberHandling = extensionDataProperty2.EffectiveNumberHandling;
                                if (!extensionDataProperty2.GetMemberAndWriteJsonExtensionData(obj, ref state, writer))
                                {
                                    return false;
                                }
                                state.Current.EndProperty();
                                state.Current.EnumeratorIndex++;
                                if (JsonConverter.ShouldFlush(writer, ref state))
                                {
                                    return false;
                                }
                            }
                            else
                            {
                                state.Current.EnumeratorIndex++;
                            }
                        }
                        if (!state.Current.ProcessedEndToken)
                        {
                            state.Current.ProcessedEndToken = true;
                            writer.WriteEndObject();
                        }
                    }
                    jsonTypeInfo.OnSerialized?.Invoke(obj);
                    return true;
                }

                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                protected static void ReadPropertyValue(object obj, scoped ref ReadStack state, ref Utf8JsonReader reader, JsonPropertyInfo jsonPropertyInfo, bool useExtensionProperty)
                {
                    if (!jsonPropertyInfo.CanDeserialize)
                    {
                        reader.Skip();
                    }
                    else
                    {
                        reader.ReadWithVerify();
                        if (!useExtensionProperty)
                        {
                            jsonPropertyInfo.ReadJsonAndSetMember(obj, ref state, ref reader);
                        }
                        else
                        {
                            jsonPropertyInfo.ReadJsonAndAddExtensionProperty(obj, ref state, ref reader);
                        }
                    }
                    state.Current.EndProperty();
                }

                protected static bool ReadAheadPropertyValue(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonPropertyInfo jsonPropertyInfo)
                {
                    state.Current.PropertyState = StackFramePropertyState.ReadValue;
                    if (!state.Current.UseExtensionProperty)
                    {
                        if (!JsonConverter.SingleValueReadWithReadAhead(jsonPropertyInfo.EffectiveConverter.RequiresReadAhead, ref reader, ref state))
                        {
                            return false;
                        }
                    }
                    else if (!JsonConverter.SingleValueReadWithReadAhead(requiresReadAhead: true, ref reader, ref state))
                    {
                        return false;
                    }
                    return true;
                }
            }

            /// <summary>
            /// Implementation of <cref>JsonObjectConverter{T}</cref> that supports the deserialization
            /// of JSON objects using parameterized constructors.
            /// </summary>
            internal abstract class ObjectWithParameterizedConstructorConverter<T> : ObjectDefaultConverter<T>
            {
                internal sealed override bool ConstructorIsParameterized => true;

                internal sealed override bool OnTryRead(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options, scoped ref ReadStack state, [System.Diagnostics.CodeAnalysis.MaybeNullWhen(false)] out T value)
                {
                    JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
                    if (jsonTypeInfo.CreateObject != null)
                    {
                        return base.OnTryRead(ref reader, typeToConvert, options, ref state, out value);
                    }
                    ArgumentState ctorArgumentState = state.Current.CtorArgumentState;
                    object obj;
                    if (!state.SupportContinuation && !state.Current.CanContainMetadata)
                    {
                        if (reader.TokenType != JsonTokenType.StartObject)
                        {
                            ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(TypeToConvert);
                        }
                        ReadOnlySpan<byte> originalSpan = reader.OriginalSpan;
                        ReadOnlySequence<byte> originalSequence = reader.OriginalSequence;
                        ReadConstructorArguments(ref state, ref reader, options);
                        obj = (T)CreateObject(ref state.Current);
                        jsonTypeInfo.OnDeserializing?.Invoke(obj);
                        if (ctorArgumentState.FoundPropertyCount > 0)
                        {
                            (JsonPropertyInfo, JsonReaderState, long, byte[], string)[] foundProperties = ctorArgumentState.FoundProperties;
                            for (int i = 0; i < ctorArgumentState.FoundPropertyCount; i++)
                            {
                                JsonPropertyInfo item = foundProperties[i].Item1;
                                long item2 = foundProperties[i].Item3;
                                byte[] item3 = foundProperties[i].Item4;
                                string item4 = foundProperties[i].Item5;
                                Utf8JsonReader reader2 = (originalSequence.IsEmpty ? new Utf8JsonReader(originalSpan.Slice(checked((int)item2)), isFinalBlock: true, foundProperties[i].Item2) : new Utf8JsonReader(originalSequence.Slice(item2), isFinalBlock: true, foundProperties[i].Item2));
                                state.Current.JsonPropertyName = item3;
                                state.Current.JsonPropertyInfo = item;
                                state.Current.NumberHandling = item.EffectiveNumberHandling;
                                bool flag = item4 != null;
                                if (flag)
                                {
                                    state.Current.JsonPropertyNameAsString = item4;
                                    JsonSerializer.CreateExtensionDataProperty(obj, item, options);
                                }
                                ObjectDefaultConverter<T>.ReadPropertyValue(obj, ref state, ref reader2, item, flag);
                            }
                            (JsonPropertyInfo, JsonReaderState, long, byte[], string)[] foundProperties2 = ctorArgumentState.FoundProperties;
                            ctorArgumentState.FoundProperties = null;
                            ArrayPool<(JsonPropertyInfo, JsonReaderState, long, byte[], string)>.Shared.Return(foundProperties2, clearArray: true);
                        }
                    }
                    else
                    {
                        if (state.Current.ObjectState == StackFrameObjectState.None)
                        {
                            if (reader.TokenType != JsonTokenType.StartObject)
                            {
                                ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(TypeToConvert);
                            }
                            state.Current.ObjectState = StackFrameObjectState.StartToken;
                        }
                        if (state.Current.CanContainMetadata && (int)state.Current.ObjectState < 2)
                        {
                            if (!JsonSerializer.TryReadMetadata(this, jsonTypeInfo, ref reader, ref state))
                            {
                                value = default(T);
                                return false;
                            }
                            if (state.Current.MetadataPropertyNames == MetadataPropertyName.Ref)
                            {
                                value = JsonSerializer.ResolveReferenceId<T>(ref state);
                                return true;
                            }
                            state.Current.ObjectState = StackFrameObjectState.ReadMetadata;
                        }
                        if (state.Current.MetadataPropertyNames.HasFlag(MetadataPropertyName.Type) && state.Current.PolymorphicSerializationState != PolymorphicSerializationState.PolymorphicReEntryStarted)
                        {
                            JsonConverter jsonConverter = ResolvePolymorphicConverter(jsonTypeInfo, options, ref state);
                            if (jsonConverter != null)
                            {
                                object value2;
                                bool flag2 = jsonConverter.OnTryReadAsObject(ref reader, options, ref state, out value2);
                                value = (T)value2;
                                state.ExitPolymorphicConverter(flag2);
                                return flag2;
                            }
                        }
                        if ((int)state.Current.ObjectState < 3)
                        {
                            if (state.Current.CanContainMetadata)
                            {
                                JsonSerializer.ValidateMetadataForObjectConverter(this, ref reader, ref state);
                            }
                            if (state.Current.MetadataPropertyNames == MetadataPropertyName.Ref)
                            {
                                value = JsonSerializer.ResolveReferenceId<T>(ref state);
                                return true;
                            }
                            BeginRead(ref state, ref reader, options);
                            state.Current.ObjectState = StackFrameObjectState.ConstructorArguments;
                        }
                        if (!ReadConstructorArgumentsWithContinuation(ref state, ref reader, options))
                        {
                            value = default(T);
                            return false;
                        }
                        obj = (T)CreateObject(ref state.Current);
                        if (state.Current.MetadataPropertyNames.HasFlag(MetadataPropertyName.Id))
                        {
                            state.ReferenceResolver.AddReference(state.ReferenceId, obj);
                            state.ReferenceId = null;
                        }
                        jsonTypeInfo.OnDeserializing?.Invoke(obj);
                        if (ctorArgumentState.FoundPropertyCount > 0)
                        {
                            for (int j = 0; j < ctorArgumentState.FoundPropertyCount; j++)
                            {
                                JsonPropertyInfo item5 = ctorArgumentState.FoundPropertiesAsync[j].Item1;
                                object item6 = ctorArgumentState.FoundPropertiesAsync[j].Item2;
                                string item7 = ctorArgumentState.FoundPropertiesAsync[j].Item3;
                                if (item7 == null)
                                {
                                    if (item6 != null || !item5.IgnoreNullTokensOnRead || default(T) != null)
                                    {
                                        item5.Set(obj, item6);
                                        state.Current.MarkRequiredPropertyAsRead(item5);
                                    }
                                    continue;
                                }
                                JsonSerializer.CreateExtensionDataProperty(obj, item5, options);
                                object valueAsObject = item5.GetValueAsObject(obj);
                                if (valueAsObject is IDictionary<string, JsonElement> dictionary)
                                {
                                    dictionary[item7] = (JsonElement)item6;
                                }
                                else
                                {
                                    ((IDictionary<string, object>)valueAsObject)[item7] = item6;
                                }
                            }
                            (JsonPropertyInfo, object, string)[] foundPropertiesAsync = ctorArgumentState.FoundPropertiesAsync;
                            ctorArgumentState.FoundPropertiesAsync = null;
                            ArrayPool<(JsonPropertyInfo, object, string)>.Shared.Return(foundPropertiesAsync, clearArray: true);
                        }
                    }
                    jsonTypeInfo.OnDeserialized?.Invoke(obj);
                    state.Current.ValidateAllRequiredPropertiesAreRead(jsonTypeInfo);
                    value = (T)obj;
                    if (state.Current.PropertyRefCache != null)
                    {
                        state.Current.JsonTypeInfo.UpdateSortedPropertyCache(ref state.Current);
                    }
                    if (ctorArgumentState.ParameterRefCache != null)
                    {
                        state.Current.JsonTypeInfo.UpdateSortedParameterCache(ref state.Current);
                    }
                    return true;
                }

                protected abstract void InitializeConstructorArgumentCaches(ref ReadStack state, JsonSerializerOptions options);

                protected abstract bool ReadAndCacheConstructorArgument(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonParameterInfo jsonParameterInfo);

                protected abstract object CreateObject(ref ReadStackFrame frame);

                /// <summary>
                /// Performs a full first pass of the JSON input and deserializes the ctor args.
                /// </summary>
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                private void ReadConstructorArguments(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonSerializerOptions options)
                {
                    BeginRead(ref state, ref reader, options);
                    while (true)
                    {
                        reader.ReadWithVerify();
                        JsonTokenType tokenType = reader.TokenType;
                        if (tokenType == JsonTokenType.EndObject)
                        {
                            break;
                        }
                        if (TryLookupConstructorParameter(ref state, ref reader, options, out var jsonParameterInfo))
                        {
                            reader.ReadWithVerify();
                            if (!jsonParameterInfo.ShouldDeserialize)
                            {
                                reader.Skip();
                                state.Current.EndConstructorParameter();
                            }
                            else
                            {
                                ReadAndCacheConstructorArgument(ref state, ref reader, jsonParameterInfo);
                                state.Current.EndConstructorParameter();
                            }
                            continue;
                        }
                        ReadOnlySpan<byte> propertyName = JsonSerializer.GetPropertyName(ref state, ref reader, options);
                        bool useExtensionProperty;
                        JsonPropertyInfo jsonPropertyInfo = JsonSerializer.LookupProperty(null, propertyName, ref state, options, out useExtensionProperty, createExtensionProperty: false);
                        if (jsonPropertyInfo.CanDeserialize)
                        {
                            ArgumentState ctorArgumentState = state.Current.CtorArgumentState;
                            if (ctorArgumentState.FoundProperties == null)
                            {
                                ctorArgumentState.FoundProperties = ArrayPool<(JsonPropertyInfo, JsonReaderState, long, byte[], string)>.Shared.Rent(Math.Max(1, state.Current.JsonTypeInfo.PropertyCache.Count));
                            }
                            else if (ctorArgumentState.FoundPropertyCount == ctorArgumentState.FoundProperties.Length)
                            {
                                (JsonPropertyInfo, JsonReaderState, long, byte[], string)[] array = ArrayPool<(JsonPropertyInfo, JsonReaderState, long, byte[], string)>.Shared.Rent(ctorArgumentState.FoundProperties.Length * 2);
                                ctorArgumentState.FoundProperties.CopyTo(array, 0);
                                (JsonPropertyInfo, JsonReaderState, long, byte[], string)[] foundProperties = ctorArgumentState.FoundProperties;
                                ctorArgumentState.FoundProperties = array;
                                ArrayPool<(JsonPropertyInfo, JsonReaderState, long, byte[], string)>.Shared.Return(foundProperties, clearArray: true);
                            }
                            ctorArgumentState.FoundProperties[ctorArgumentState.FoundPropertyCount++] = (jsonPropertyInfo, reader.CurrentState, reader.BytesConsumed, state.Current.JsonPropertyName, state.Current.JsonPropertyNameAsString);
                        }
                        reader.Skip();
                        state.Current.EndProperty();
                    }
                }

                private bool ReadConstructorArgumentsWithContinuation(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonSerializerOptions options)
                {
                    while (true)
                    {
                        if (state.Current.PropertyState == StackFramePropertyState.None)
                        {
                            state.Current.PropertyState = StackFramePropertyState.ReadName;
                            if (!reader.Read())
                            {
                                return false;
                            }
                        }
                        JsonParameterInfo jsonParameterInfo;
                        JsonPropertyInfo jsonPropertyInfo;
                        if ((int)state.Current.PropertyState < 2)
                        {
                            state.Current.PropertyState = StackFramePropertyState.Name;
                            JsonTokenType tokenType = reader.TokenType;
                            if (tokenType == JsonTokenType.EndObject)
                            {
                                return true;
                            }
                            if (TryLookupConstructorParameter(ref state, ref reader, options, out jsonParameterInfo))
                            {
                                jsonPropertyInfo = null;
                            }
                            else
                            {
                                ReadOnlySpan<byte> propertyName = JsonSerializer.GetPropertyName(ref state, ref reader, options);
                                jsonPropertyInfo = JsonSerializer.LookupProperty(null, propertyName, ref state, options, out var useExtensionProperty, createExtensionProperty: false);
                                state.Current.UseExtensionProperty = useExtensionProperty;
                            }
                        }
                        else
                        {
                            jsonParameterInfo = state.Current.CtorArgumentState.JsonParameterInfo;
                            jsonPropertyInfo = state.Current.JsonPropertyInfo;
                        }
                        if (jsonParameterInfo != null)
                        {
                            if (!HandleConstructorArgumentWithContinuation(ref state, ref reader, jsonParameterInfo))
                            {
                                return false;
                            }
                        }
                        else if (!HandlePropertyWithContinuation(ref state, ref reader, jsonPropertyInfo))
                        {
                            break;
                        }
                    }
                    return false;
                }

                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                private bool HandleConstructorArgumentWithContinuation(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonParameterInfo jsonParameterInfo)
                {
                    if ((int)state.Current.PropertyState < 3)
                    {
                        if (!jsonParameterInfo.ShouldDeserialize)
                        {
                            if (!reader.TrySkip())
                            {
                                return false;
                            }
                            state.Current.EndConstructorParameter();
                            return true;
                        }
                        state.Current.PropertyState = StackFramePropertyState.ReadValue;
                        if (!JsonConverter.SingleValueReadWithReadAhead(jsonParameterInfo.ConverterBase.RequiresReadAhead, ref reader, ref state))
                        {
                            return false;
                        }
                    }
                    if (!ReadAndCacheConstructorArgument(ref state, ref reader, jsonParameterInfo))
                    {
                        return false;
                    }
                    state.Current.EndConstructorParameter();
                    return true;
                }

                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                private static bool HandlePropertyWithContinuation(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonPropertyInfo jsonPropertyInfo)
                {
                    if ((int)state.Current.PropertyState < 3)
                    {
                        if (!jsonPropertyInfo.CanDeserialize)
                        {
                            if (!reader.TrySkip())
                            {
                                return false;
                            }
                            state.Current.EndProperty();
                            return true;
                        }
                        if (!ObjectDefaultConverter<T>.ReadAheadPropertyValue(ref state, ref reader, jsonPropertyInfo))
                        {
                            return false;
                        }
                    }
                    object value;
                    if (state.Current.UseExtensionProperty)
                    {
                        if (!jsonPropertyInfo.ReadJsonExtensionDataValue(ref state, ref reader, out value))
                        {
                            return false;
                        }
                    }
                    else if (!jsonPropertyInfo.ReadJsonAsObject(ref state, ref reader, out value))
                    {
                        return false;
                    }
                    ArgumentState ctorArgumentState = state.Current.CtorArgumentState;
                    if (ctorArgumentState.FoundPropertiesAsync == null)
                    {
                        ctorArgumentState.FoundPropertiesAsync = ArrayPool<(JsonPropertyInfo, object, string)>.Shared.Rent(Math.Max(1, state.Current.JsonTypeInfo.PropertyCache.Count));
                    }
                    else if (ctorArgumentState.FoundPropertyCount == ctorArgumentState.FoundPropertiesAsync.Length)
                    {
                        (JsonPropertyInfo, object, string)[] array = ArrayPool<(JsonPropertyInfo, object, string)>.Shared.Rent(ctorArgumentState.FoundPropertiesAsync.Length * 2);
                        ctorArgumentState.FoundPropertiesAsync.CopyTo(array, 0);
                        (JsonPropertyInfo, object, string)[] foundPropertiesAsync = ctorArgumentState.FoundPropertiesAsync;
                        ctorArgumentState.FoundPropertiesAsync = array;
                        ArrayPool<(JsonPropertyInfo, object, string)>.Shared.Return(foundPropertiesAsync, clearArray: true);
                    }
                    ctorArgumentState.FoundPropertiesAsync[ctorArgumentState.FoundPropertyCount++] = (jsonPropertyInfo, value, state.Current.JsonPropertyNameAsString);
                    state.Current.EndProperty();
                    return true;
                }

                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                private void BeginRead(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonSerializerOptions options)
                {
                    JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
                    jsonTypeInfo.ValidateCanBeUsedForMetadataSerialization();
                    if (jsonTypeInfo.ParameterCount != jsonTypeInfo.ParameterCache.Count)
                    {
                        ThrowHelper.ThrowInvalidOperationException_ConstructorParameterIncompleteBinding(TypeToConvert);
                    }
                    state.Current.InitializeRequiredPropertiesValidationState(jsonTypeInfo);
                    state.Current.JsonPropertyInfo = null;
                    InitializeConstructorArgumentCaches(ref state, options);
                }

                /// <summary>
                /// Lookup the constructor parameter given its name in the reader.
                /// </summary>
                protected virtual bool TryLookupConstructorParameter(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonSerializerOptions options, out JsonParameterInfo jsonParameterInfo)
                {
                    ReadOnlySpan<byte> propertyName = JsonSerializer.GetPropertyName(ref state, ref reader, options);
                    jsonParameterInfo = state.Current.JsonTypeInfo.GetParameter(propertyName, ref state.Current, out var utf8PropertyName);
                    state.Current.CtorArgumentState.ParameterIndex++;
                    state.Current.JsonPropertyName = utf8PropertyName;
                    state.Current.CtorArgumentState.JsonParameterInfo = jsonParameterInfo;
                    state.Current.NumberHandling = jsonParameterInfo?.NumberHandling;
                    return jsonParameterInfo != null;
                }
            }

            internal sealed class QueueOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : Queue<TElement>
            {
                protected override void Add(in TElement value, ref ReadStack state)
                {
                    ((TCollection)state.Current.ReturnValue).Enqueue(value);
                }

                protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
                {
                    if (state.Current.JsonTypeInfo.CreateObject == null)
                    {
                        ThrowHelper.ThrowNotSupportedException_SerializationNotSupported(state.Current.JsonTypeInfo.Type);
                    }
                    state.Current.ReturnValue = state.Current.JsonTypeInfo.CreateObject();
                }
            }

            internal sealed class SByteConverter : JsonConverter<sbyte>
            {
                public SByteConverter()
                {
                    IsInternalConverterForNumberType = true;
                }

                public override sbyte Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetSByte();
                }

                public override void Write(Utf8JsonWriter writer, sbyte value, JsonSerializerOptions options)
                {
                    writer.WriteNumberValue(value);
                }

                internal override sbyte ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetSByteWithQuotes();
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, sbyte value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    writer.WritePropertyName(value);
                }

                internal override sbyte ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
                {
                    if (reader.TokenType == JsonTokenType.String && (JsonNumberHandling.AllowReadingFromString & handling) != 0)
                    {
                        return reader.GetSByteWithQuotes();
                    }
                    return reader.GetSByte();
                }

                internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, sbyte value, JsonNumberHandling handling)
                {
                    if ((JsonNumberHandling.WriteAsString & handling) != 0)
                    {
                        writer.WriteNumberValueAsString(value);
                    }
                    else
                    {
                        writer.WriteNumberValue(value);
                    }
                }
            }

            internal sealed class SingleConverter : JsonConverter<float>
            {
                public SingleConverter()
                {
                    IsInternalConverterForNumberType = true;
                }

                public override float Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetSingle();
                }

                public override void Write(Utf8JsonWriter writer, float value, JsonSerializerOptions options)
                {
                    writer.WriteNumberValue(value);
                }

                internal override float ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetSingleWithQuotes();
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, float value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    writer.WritePropertyName(value);
                }

                internal override float ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
                {
                    if (reader.TokenType == JsonTokenType.String)
                    {
                        if ((JsonNumberHandling.AllowReadingFromString & handling) != 0)
                        {
                            return reader.GetSingleWithQuotes();
                        }
                        if ((JsonNumberHandling.AllowNamedFloatingPointLiterals & handling) != 0)
                        {
                            return reader.GetSingleFloatingPointConstant();
                        }
                    }
                    return reader.GetSingle();
                }

                internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, float value, JsonNumberHandling handling)
                {
                    if ((JsonNumberHandling.WriteAsString & handling) != 0)
                    {
                        writer.WriteNumberValueAsString(value);
                    }
                    else if ((JsonNumberHandling.AllowNamedFloatingPointLiterals & handling) != 0)
                    {
                        writer.WriteFloatingPointConstant(value);
                    }
                    else
                    {
                        writer.WriteNumberValue(value);
                    }
                }
            }

            /// <summary>
            /// Implementation of <cref>JsonObjectConverter{T}</cref> that supports the deserialization
            /// of JSON objects using parameterized constructors.
            /// </summary>
            internal class SmallObjectWithParameterizedConstructorConverter<T, TArg0, TArg1, TArg2, TArg3> : ObjectWithParameterizedConstructorConverter<T>
            {
                protected override object CreateObject(ref ReadStackFrame frame)
                {
                    JsonTypeInfo.ParameterizedConstructorDelegate<T, TArg0, TArg1, TArg2, TArg3> parameterizedConstructorDelegate = (JsonTypeInfo.ParameterizedConstructorDelegate<T, TArg0, TArg1, TArg2, TArg3>)frame.JsonTypeInfo.CreateObjectWithArgs;
                    Arguments<TArg0, TArg1, TArg2, TArg3> arguments = (Arguments<TArg0, TArg1, TArg2, TArg3>)frame.CtorArgumentState.Arguments;
                    return parameterizedConstructorDelegate(arguments.Arg0, arguments.Arg1, arguments.Arg2, arguments.Arg3);
                }

                protected override bool ReadAndCacheConstructorArgument(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonParameterInfo jsonParameterInfo)
                {
                    Arguments<TArg0, TArg1, TArg2, TArg3> arguments = (Arguments<TArg0, TArg1, TArg2, TArg3>)state.Current.CtorArgumentState.Arguments;
                    return jsonParameterInfo.ClrInfo.Position switch
                    {
                        0 => TryRead<TArg0>(ref state, ref reader, jsonParameterInfo, out arguments.Arg0),
                        1 => TryRead<TArg1>(ref state, ref reader, jsonParameterInfo, out arguments.Arg1),
                        2 => TryRead<TArg2>(ref state, ref reader, jsonParameterInfo, out arguments.Arg2),
                        3 => TryRead<TArg3>(ref state, ref reader, jsonParameterInfo, out arguments.Arg3),
                        _ => throw new InvalidOperationException(),
                    };
                }

                private static bool TryRead<TArg>(scoped ref ReadStack state, ref Utf8JsonReader reader, JsonParameterInfo jsonParameterInfo, out TArg arg)
                {
                    JsonParameterInfo<TArg> jsonParameterInfo2 = (JsonParameterInfo<TArg>)jsonParameterInfo;
                    JsonConverter<TArg> jsonConverter = (JsonConverter<TArg>)jsonParameterInfo.ConverterBase;
                    TArg value;
                    bool flag = jsonConverter.TryRead(ref reader, jsonParameterInfo2.PropertyType, jsonParameterInfo2.Options, ref state, out value);
                    arg = ((value == null && jsonParameterInfo.IgnoreNullTokensOnRead) ? ((TArg)jsonParameterInfo2.DefaultValue) : value);
                    if (flag)
                    {
                        state.Current.MarkRequiredPropertyAsRead(jsonParameterInfo.MatchingProperty);
                    }
                    return flag;
                }

                protected override void InitializeConstructorArgumentCaches(ref ReadStack state, JsonSerializerOptions options)
                {
                    JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
                    JsonTypeInfo jsonTypeInfo2 = jsonTypeInfo;
                    if (jsonTypeInfo2.CreateObjectWithArgs == null)
                    {
                        object obj = (jsonTypeInfo2.CreateObjectWithArgs = options.MemberAccessorStrategy.CreateParameterizedConstructor<T, TArg0, TArg1, TArg2, TArg3>(base.ConstructorInfo));
                    }
                    Arguments<TArg0, TArg1, TArg2, TArg3> arguments = new Arguments<TArg0, TArg1, TArg2, TArg3>();
                    List<KeyValuePair<string, JsonParameterInfo>> list = jsonTypeInfo.ParameterCache.List;
                    for (int i = 0; i < jsonTypeInfo.ParameterCount; i++)
                    {
                        JsonParameterInfo value = list[i].Value;
                        if (value.ShouldDeserialize)
                        {
                            switch (value.ClrInfo.Position)
                            {
                                case 0:
                                    arguments.Arg0 = ((JsonParameterInfo<TArg0>)value).TypedDefaultValue;
                                    break;
                                case 1:
                                    arguments.Arg1 = ((JsonParameterInfo<TArg1>)value).TypedDefaultValue;
                                    break;
                                case 2:
                                    arguments.Arg2 = ((JsonParameterInfo<TArg2>)value).TypedDefaultValue;
                                    break;
                                case 3:
                                    arguments.Arg3 = ((JsonParameterInfo<TArg3>)value).TypedDefaultValue;
                                    break;
                                default:
                                    throw new InvalidOperationException();
                            }
                        }
                    }
                    state.Current.CtorArgumentState.Arguments = arguments;
                }
            }

            internal sealed class StackOfTConverter<TCollection, TElement> : IEnumerableDefaultConverter<TCollection, TElement> where TCollection : Stack<TElement>
            {
                protected override void Add(in TElement value, ref ReadStack state)
                {
                    ((TCollection)state.Current.ReturnValue).Push(value);
                }

                protected override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
                {
                    if (state.Current.JsonTypeInfo.CreateObject == null)
                    {
                        ThrowHelper.ThrowNotSupportedException_SerializationNotSupported(state.Current.JsonTypeInfo.Type);
                    }
                    state.Current.ReturnValue = state.Current.JsonTypeInfo.CreateObject();
                }
            }

            internal class StackOrQueueConverter<TCollection> : JsonCollectionConverter<TCollection, object> where TCollection : IEnumerable
            {
                protected sealed override void Add(in object value, ref ReadStack state)
                {
                    Action<TCollection, object> action = (Action<TCollection, object>)state.Current.JsonTypeInfo.AddMethodDelegate;
                    action((TCollection)state.Current.ReturnValue, value);
                }

                protected sealed override void CreateCollection(ref Utf8JsonReader reader, scoped ref ReadStack state, JsonSerializerOptions options)
                {
                    JsonTypeInfo jsonTypeInfo = state.Current.JsonTypeInfo;
                    Func<object> createObject = jsonTypeInfo.CreateObject;
                    if (createObject == null)
                    {
                        ThrowHelper.ThrowNotSupportedException_CannotPopulateCollection(TypeToConvert, ref reader, ref state);
                    }
                    state.Current.ReturnValue = createObject();
                }

                protected sealed override bool OnWriteResume(Utf8JsonWriter writer, TCollection value, JsonSerializerOptions options, ref WriteStack state)
                {
                    IEnumerator enumerator;
                    if (state.Current.CollectionEnumerator == null)
                    {
                        enumerator = value.GetEnumerator();
                        if (!enumerator.MoveNext())
                        {
                            return true;
                        }
                    }
                    else
                    {
                        enumerator = state.Current.CollectionEnumerator;
                    }
                    JsonConverter<object> elementConverter = JsonCollectionConverter<TCollection, object>.GetElementConverter(ref state);
                    do
                    {
                        if (JsonConverter.ShouldFlush(writer, ref state))
                        {
                            state.Current.CollectionEnumerator = enumerator;
                            return false;
                        }
                        object value2 = enumerator.Current;
                        if (!elementConverter.TryWrite(writer, in value2, options, ref state))
                        {
                            state.Current.CollectionEnumerator = enumerator;
                            return false;
                        }
                        state.Current.EndCollectionElement();
                    }
                    while (enumerator.MoveNext());
                    return true;
                }
            }

            internal sealed class StackOrQueueConverterWithReflection<TCollection> : StackOrQueueConverter<TCollection> where TCollection : IEnumerable
            {
                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
                [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                public StackOrQueueConverterWithReflection()
                {
                }

                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
                [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                internal override void ConfigureJsonTypeInfoUsingReflection(JsonTypeInfo jsonTypeInfo, JsonSerializerOptions options)
                {
                    jsonTypeInfo.AddMethodDelegate = options.MemberAccessorStrategy.CreateAddMethodDelegate<TCollection>();
                }
            }

            internal sealed class StringConverter : JsonConverter<string>
            {
                public override string Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetString();
                }

                public override void Write(Utf8JsonWriter writer, string value, JsonSerializerOptions options)
                {
                    if (value == null)
                    {
                        writer.WriteNullValue();
                    }
                    else
                    {
                        writer.WriteStringValue(value.AsSpan());
                    }
                }

                internal override string ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetString();
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, string value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    if (options.DictionaryKeyPolicy != null && !isWritingExtensionDataProperty)
                    {
                        value = options.DictionaryKeyPolicy.ConvertName(value);
                        if (value == null)
                        {
                            ThrowHelper.ThrowInvalidOperationException_NamingPolicyReturnNull(options.DictionaryKeyPolicy);
                        }
                    }
                    writer.WritePropertyName(value);
                }
            }

            internal sealed class TimeSpanConverter : JsonConverter<TimeSpan>
            {
                private const int MinimumTimeSpanFormatLength = 8;

                private const int MaximumTimeSpanFormatLength = 26;

                private const int MaximumEscapedTimeSpanFormatLength = 156;

                public override TimeSpan Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    if (reader.TokenType != JsonTokenType.String)
                    {
                        ThrowHelper.ThrowInvalidOperationException_ExpectedString(reader.TokenType);
                    }

                    if (!JsonHelpers.IsInRangeInclusive(reader.ValueLength, MinimumTimeSpanFormatLength, MaximumEscapedTimeSpanFormatLength))
                    {
                        ThrowHelper.ThrowFormatException(DataType.TimeSpan);
                    }

                    scoped ReadOnlySpan<byte> source;
                    if (!reader.HasValueSequence && !reader.ValueIsEscaped)
                    {
                        source = reader.ValueSpan;
                    }
                    else
                    {
                        Span<byte> stackSpan = stackalloc byte[MaximumEscapedTimeSpanFormatLength];
                        int bytesWritten = reader.CopyString(stackSpan);
                        source = stackSpan.Slice(0, bytesWritten);
                    }

                    byte firstChar = source[0];
                    if (!JsonHelpers.IsDigit(firstChar) && firstChar != '-')
                    {
                        // Note: Utf8Parser.TryParse allows for leading whitespace so we
                        // need to exclude that case here.
                        ThrowHelper.ThrowFormatException(DataType.TimeSpan);
                    }

                    bool result = Utf8Parser.TryParse(source, out TimeSpan tmpValue, out int bytesConsumed, 'c');

                    // Note: Utf8Parser.TryParse will return true for invalid input so
                    // long as it starts with an integer. Example: "2021-06-18" or
                    // "1$$$$$$$$$$". We need to check bytesConsumed to know if the
                    // entire source was actually valid.

                    if (!result || source.Length != bytesConsumed)
                    {
                        ThrowHelper.ThrowFormatException(DataType.TimeSpan);
                    }

                    return tmpValue;
                }

                public override void Write(Utf8JsonWriter writer, TimeSpan value, JsonSerializerOptions options)
                {
                    Span<byte> destination = stackalloc byte[26];
                    int bytesWritten;
                    bool flag = Utf8Formatter.TryFormat(value, destination, out bytesWritten, 'c');
                    writer.WriteStringValue(destination.Slice(0, bytesWritten));
                }
            }

            internal sealed class UInt16Converter : JsonConverter<ushort>
            {
                public UInt16Converter()
                {
                    IsInternalConverterForNumberType = true;
                }

                public override ushort Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetUInt16();
                }

                public override void Write(Utf8JsonWriter writer, ushort value, JsonSerializerOptions options)
                {
                    writer.WriteNumberValue((long)value);
                }

                internal override ushort ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetUInt16WithQuotes();
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, ushort value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    writer.WritePropertyName(value);
                }

                internal override ushort ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
                {
                    if (reader.TokenType == JsonTokenType.String && (JsonNumberHandling.AllowReadingFromString & handling) != 0)
                    {
                        return reader.GetUInt16WithQuotes();
                    }
                    return reader.GetUInt16();
                }

                internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, ushort value, JsonNumberHandling handling)
                {
                    if ((JsonNumberHandling.WriteAsString & handling) != 0)
                    {
                        writer.WriteNumberValueAsString(value);
                    }
                    else
                    {
                        writer.WriteNumberValue((long)value);
                    }
                }
            }

            internal sealed class UInt32Converter : JsonConverter<uint>
            {
                public UInt32Converter()
                {
                    IsInternalConverterForNumberType = true;
                }

                public override uint Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetUInt32();
                }

                public override void Write(Utf8JsonWriter writer, uint value, JsonSerializerOptions options)
                {
                    writer.WriteNumberValue((ulong)value);
                }

                internal override uint ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetUInt32WithQuotes();
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, uint value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    writer.WritePropertyName(value);
                }

                internal override uint ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
                {
                    if (reader.TokenType == JsonTokenType.String && (JsonNumberHandling.AllowReadingFromString & handling) != 0)
                    {
                        return reader.GetUInt32WithQuotes();
                    }
                    return reader.GetUInt32();
                }

                internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, uint value, JsonNumberHandling handling)
                {
                    if ((JsonNumberHandling.WriteAsString & handling) != 0)
                    {
                        writer.WriteNumberValueAsString(value);
                    }
                    else
                    {
                        writer.WriteNumberValue((ulong)value);
                    }
                }
            }

            internal sealed class UInt64Converter : JsonConverter<ulong>
            {
                public UInt64Converter()
                {
                    IsInternalConverterForNumberType = true;
                }

                public override ulong Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetUInt64();
                }

                public override void Write(Utf8JsonWriter writer, ulong value, JsonSerializerOptions options)
                {
                    writer.WriteNumberValue(value);
                }

                internal override ulong ReadAsPropertyNameCore(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    return reader.GetUInt64WithQuotes();
                }

                internal override void WriteAsPropertyNameCore(Utf8JsonWriter writer, ulong value, JsonSerializerOptions options, bool isWritingExtensionDataProperty)
                {
                    writer.WritePropertyName(value);
                }

                internal override ulong ReadNumberWithCustomHandling(ref Utf8JsonReader reader, JsonNumberHandling handling, JsonSerializerOptions options)
                {
                    if (reader.TokenType == JsonTokenType.String && (JsonNumberHandling.AllowReadingFromString & handling) != 0)
                    {
                        return reader.GetUInt64WithQuotes();
                    }
                    return reader.GetUInt64();
                }

                internal override void WriteNumberWithCustomHandling(Utf8JsonWriter writer, ulong value, JsonNumberHandling handling)
                {
                    if ((JsonNumberHandling.WriteAsString & handling) != 0)
                    {
                        writer.WriteNumberValueAsString(value);
                    }
                    else
                    {
                        writer.WriteNumberValue(value);
                    }
                }
            }

            internal sealed class UnsupportedTypeConverter<T> : JsonConverter<T>
            {
                public override T Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    throw new NotSupportedException(System.SR.Format(MDCFR.Properties.Resources.SerializeTypeInstanceNotSupported, typeof(T).FullName));
                }

                public override void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options)
                {
                    throw new NotSupportedException(System.SR.Format(MDCFR.Properties.Resources.SerializeTypeInstanceNotSupported, typeof(T).FullName));
                }
            }

            [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
            internal sealed class UnsupportedTypeConverterFactory : JsonConverterFactory
            {
                public override bool CanConvert(Type type)
                {
                    if (!typeof(MemberInfo).IsAssignableFrom(type) && !(type == typeof(SerializationInfo)) && !(type == typeof(IntPtr)) && !(type == typeof(UIntPtr)))
                    {
                        return typeof(Delegate).IsAssignableFrom(type);
                    }
                    return true;
                }

                public override JsonConverter CreateConverter(Type type, JsonSerializerOptions options)
                {
                    return (JsonConverter)Activator.CreateInstance(typeof(UnsupportedTypeConverter<>).MakeGenericType(type), BindingFlags.Instance | BindingFlags.Public, null, null, null);
                }
            }

            internal sealed class UriConverter : JsonConverter<Uri>
            {
                public override Uri Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    string @string = reader.GetString();
                    if (Uri.TryCreate(@string, UriKind.RelativeOrAbsolute, out var result))
                    {
                        return result;
                    }
                    ThrowHelper.ThrowJsonException();
                    return null;
                }

                public override void Write(Utf8JsonWriter writer, Uri value, JsonSerializerOptions options)
                {
                    writer.WriteStringValue(value.OriginalString);
                }
            }

            internal sealed class VersionConverter : JsonConverter<Version>
            {
                public override Version Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
                {
                    if (reader.TokenType != JsonTokenType.String)
                    {
                        ThrowHelper.ThrowInvalidOperationException_ExpectedString(reader.TokenType);
                    }
                    string @string = reader.GetString();
                    if (!string.IsNullOrEmpty(@string) && (!char.IsDigit(@string[0]) || !char.IsDigit(@string[@string.Length - 1])))
                    {
                        ThrowHelper.ThrowFormatException(DataType.Version);
                    }
                    if (Version.TryParse(@string, out var result))
                    {
                        return result;
                    }
                    ThrowHelper.ThrowJsonException();
                    return null;
                }

                public override void Write(Utf8JsonWriter writer, Version value, JsonSerializerOptions options)
                {
                    writer.WriteStringValue(value.ToString());
                }
            }

        }

        namespace Metadata
        {
            using System.Reflection.Emit;
            using System.Runtime.ExceptionServices;
            using System.Text.Json.Reflection;
            using System.Text.Json.Serialization.Converters;

            /// <summary>
            /// Creates and initializes serialization metadata for a type.
            /// </summary>
            /// <typeparam name="T"></typeparam>
            internal sealed class CustomJsonTypeInfo<T> : JsonTypeInfo<T>
            {
                /// <summary>
                /// Creates serialization metadata for a type using a simple converter.
                /// </summary>
                internal CustomJsonTypeInfo(JsonConverter converter, JsonSerializerOptions options)
                    : base(converter, options)
                {
                }

                internal override JsonParameterInfoValues[] GetParameterInfoValues()
                {
                    return Array.Empty<JsonParameterInfoValues>();
                }
            }

            /// <summary>
            /// Defines the default, reflection-based JSON contract resolver used by System.Text.Json.
            /// </summary>
            /// <remarks>
            /// The contract resolver used by <see cref="P:System.Text.Json.JsonSerializerOptions.Default" />.
            /// </remarks>
            public class DefaultJsonTypeInfoResolver : IJsonTypeInfoResolver
            {
                private sealed class ModifierCollection : ConfigurationList<Action<JsonTypeInfo>>
                {
                    private readonly DefaultJsonTypeInfoResolver _resolver;

                    protected override bool IsImmutable => !_resolver._mutable;

                    public ModifierCollection(DefaultJsonTypeInfoResolver resolver)
                        : base((IList<Action<JsonTypeInfo>>)null)
                    {
                        _resolver = resolver;
                    }

                    protected override void VerifyMutable()
                    {
                        if (!_resolver._mutable)
                        {
                            ThrowHelper.ThrowInvalidOperationException_TypeInfoResolverImmutable();
                        }
                    }
                }

                private static Dictionary<Type, JsonConverter> s_defaultSimpleConverters;

                private static JsonConverterFactory[] s_defaultFactoryConverters;

                private bool _mutable;

                private ModifierCollection _modifiers;

                private static DefaultJsonTypeInfoResolver s_defaultInstance;

                /// <summary>
                /// Gets a list of user-defined callbacks that can be used to modify the initial contract.
                /// </summary>
                /// <remarks>
                /// The modifier list will be rendered immutable after the first <see cref="M:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.GetTypeInfo(System.Type,System.Text.Json.JsonSerializerOptions)" /> invocation.
                ///
                /// Modifier callbacks are called consecutively in the order in which they are specified in the list.
                /// </remarks>
                public IList<Action<JsonTypeInfo>> Modifiers => _modifiers ?? (_modifiers = new ModifierCollection(this));

                internal static bool IsDefaultInstanceRooted => s_defaultInstance != null;

                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
                [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                private static JsonConverterFactory[] GetDefaultFactoryConverters()
                {
                    return new JsonConverterFactory[8]
                    {
                new UnsupportedTypeConverterFactory(),
                new NullableConverterFactory(),
                new EnumConverterFactory(),
                new JsonNodeConverterFactory(),
                new FSharpTypeConverterFactory(),
                new IAsyncEnumerableConverterFactory(),
                new IEnumerableConverterFactory(),
                new ObjectConverterFactory()
                    };
                }

                private static Dictionary<Type, JsonConverter> GetDefaultSimpleConverters()
                {
                    Dictionary<Type, JsonConverter> converters = new Dictionary<Type, JsonConverter>(26);
                    Add(JsonMetadataServices.BooleanConverter);
                    Add(JsonMetadataServices.ByteConverter);
                    Add(JsonMetadataServices.ByteArrayConverter);
                    Add(JsonMetadataServices.CharConverter);
                    Add(JsonMetadataServices.DateTimeConverter);
                    Add(JsonMetadataServices.DateTimeOffsetConverter);
                    Add(JsonMetadataServices.DoubleConverter);
                    Add(JsonMetadataServices.DecimalConverter);
                    Add(JsonMetadataServices.GuidConverter);
                    Add(JsonMetadataServices.Int16Converter);
                    Add(JsonMetadataServices.Int32Converter);
                    Add(JsonMetadataServices.Int64Converter);
                    Add(JsonMetadataServices.JsonElementConverter);
                    Add(JsonMetadataServices.JsonDocumentConverter);
                    Add(JsonMetadataServices.ObjectConverter);
                    Add(JsonMetadataServices.SByteConverter);
                    Add(JsonMetadataServices.SingleConverter);
                    Add(JsonMetadataServices.StringConverter);
                    Add(JsonMetadataServices.TimeSpanConverter);
                    Add(JsonMetadataServices.UInt16Converter);
                    Add(JsonMetadataServices.UInt32Converter);
                    Add(JsonMetadataServices.UInt64Converter);
                    Add(JsonMetadataServices.UriConverter);
                    Add(JsonMetadataServices.VersionConverter);
                    return converters;
                    void Add(JsonConverter converter)
                    {
                        converters.Add(converter.TypeToConvert, converter);
                    }
                }

                private static JsonConverter GetBuiltInConverter(Type typeToConvert)
                {
                    if (s_defaultSimpleConverters.TryGetValue(typeToConvert, out var value))
                    {
                        return value;
                    }
                    JsonConverterFactory[] array = s_defaultFactoryConverters;
                    foreach (JsonConverterFactory jsonConverterFactory in array)
                    {
                        if (jsonConverterFactory.CanConvert(typeToConvert))
                        {
                            return jsonConverterFactory;
                        }
                    }
                    return value;
                }

                internal static bool TryGetDefaultSimpleConverter(Type typeToConvert, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out JsonConverter converter)
                {
                    if (s_defaultSimpleConverters == null)
                    {
                        converter = null;
                        return false;
                    }
                    return s_defaultSimpleConverters.TryGetValue(typeToConvert, out converter);
                }

                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
                [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                internal static JsonConverter GetCustomConverterForMember(Type typeToConvert, MemberInfo memberInfo, JsonSerializerOptions options)
                {
                    JsonConverterAttribute uniqueCustomAttribute = memberInfo.GetUniqueCustomAttribute<JsonConverterAttribute>(inherit: false);
                    if (uniqueCustomAttribute != null)
                    {
                        return GetConverterFromAttribute(uniqueCustomAttribute, typeToConvert, memberInfo, options);
                    }
                    return null;
                }

                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
                [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                internal static JsonConverter GetConverterForType(Type typeToConvert, JsonSerializerOptions options, bool resolveJsonConverterAttribute = true)
                {
                    RootDefaultInstance();
                    JsonConverter jsonConverter = options.GetConverterFromList(typeToConvert);
                    if (resolveJsonConverterAttribute && jsonConverter == null)
                    {
                        JsonConverterAttribute uniqueCustomAttribute = typeToConvert.GetUniqueCustomAttribute<JsonConverterAttribute>(inherit: false);
                        if (uniqueCustomAttribute != null)
                        {
                            jsonConverter = GetConverterFromAttribute(uniqueCustomAttribute, typeToConvert, null, options);
                        }
                    }
                    if (jsonConverter == null)
                    {
                        jsonConverter = GetBuiltInConverter(typeToConvert);
                    }
                    jsonConverter = options.ExpandConverterFactory(jsonConverter, typeToConvert);
                    if (!jsonConverter.TypeToConvert.IsInSubtypeRelationshipWith(typeToConvert))
                    {
                        ThrowHelper.ThrowInvalidOperationException_SerializationConverterNotCompatible(jsonConverter.GetType(), jsonConverter.TypeToConvert);
                    }
                    JsonSerializerOptions.CheckConverterNullabilityIsSameAsPropertyType(jsonConverter, typeToConvert);
                    return jsonConverter;
                }

                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
                [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                private static JsonConverter GetConverterFromAttribute(JsonConverterAttribute converterAttribute, Type typeToConvert, MemberInfo memberInfo, JsonSerializerOptions options)
                {
                    Type type = memberInfo?.DeclaringType ?? typeToConvert;
                    Type converterType = converterAttribute.ConverterType;
                    JsonConverter jsonConverter;
                    if (converterType == null)
                    {
                        jsonConverter = converterAttribute.CreateConverter(typeToConvert);
                        if (jsonConverter == null)
                        {
                            ThrowHelper.ThrowInvalidOperationException_SerializationConverterOnAttributeNotCompatible(type, memberInfo, typeToConvert);
                        }
                    }
                    else
                    {
                        ConstructorInfo constructor = converterType.GetConstructor(Type.EmptyTypes);
                        if (!typeof(JsonConverter).IsAssignableFrom(converterType) || constructor == null || !constructor.IsPublic)
                        {
                            ThrowHelper.ThrowInvalidOperationException_SerializationConverterOnAttributeInvalid(type, memberInfo);
                        }
                        jsonConverter = (JsonConverter)Activator.CreateInstance(converterType);
                    }
                    if (!jsonConverter.CanConvert(typeToConvert))
                    {
                        Type underlyingType = Nullable.GetUnderlyingType(typeToConvert);
                        if (underlyingType != null && jsonConverter.CanConvert(underlyingType))
                        {
                            if (jsonConverter is JsonConverterFactory jsonConverterFactory)
                            {
                                jsonConverter = jsonConverterFactory.GetConverterInternal(underlyingType, options);
                            }
                            return NullableConverterFactory.CreateValueConverter(underlyingType, jsonConverter);
                        }
                        ThrowHelper.ThrowInvalidOperationException_SerializationConverterOnAttributeNotCompatible(type, memberInfo, typeToConvert);
                    }
                    return jsonConverter;
                }

                /// <summary>
                /// Creates a mutable <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" /> instance.
                /// </summary>
                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
                [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                public DefaultJsonTypeInfoResolver()
                    : this(mutable: true)
                {
                }

                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
                [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                private DefaultJsonTypeInfoResolver(bool mutable)
                {
                    _mutable = mutable;
                    if (s_defaultFactoryConverters == null)
                    {
                        s_defaultFactoryConverters = GetDefaultFactoryConverters();
                    }
                    if (s_defaultSimpleConverters == null)
                    {
                        s_defaultSimpleConverters = GetDefaultSimpleConverters();
                    }
                }

                /// <summary>
                /// Resolves a JSON contract for a given <paramref name="type" /> and <paramref name="options" /> configuration.
                /// </summary>
                /// <param name="type">The type for which to resolve a JSON contract.</param>
                /// <param name="options">A <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance used to determine contract configuration.</param>
                /// <returns>A <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> defining a reflection-derived JSON contract for <paramref name="type" />.</returns>
                /// <exception cref="T:System.ArgumentNullException"><paramref name="type" /> or <paramref name="options" /> is <see langword="null" />.</exception>
                /// <remarks>
                /// The base implementation of this method will produce a reflection-derived contract
                /// and apply any callbacks from the <see cref="P:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver.Modifiers" /> list.
                /// </remarks>
                [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "The ctor is marked RequiresUnreferencedCode.")]
                [UnconditionalSuppressMessage("AotAnalysis", "IL3050:RequiresDynamicCode", Justification = "The ctor is marked RequiresDynamicCode.")]
                public virtual JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options)
                {
                    if (type == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("type");
                    }
                    if (options == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("options");
                    }
                    _mutable = false;
                    JsonTypeInfo.ValidateType(type);
                    JsonTypeInfo jsonTypeInfo = CreateJsonTypeInfo(type, options);
                    if (_modifiers != null)
                    {
                        foreach (Action<JsonTypeInfo> modifier in _modifiers)
                        {
                            modifier(jsonTypeInfo);
                        }
                    }
                    return jsonTypeInfo;
                }

                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
                [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                private static JsonTypeInfo CreateJsonTypeInfo(Type type, JsonSerializerOptions options)
                {
                    JsonConverter converterForType = GetConverterForType(type, options);
                    if (converterForType.TypeToConvert == type)
                    {
                        return converterForType.CreateReflectionJsonTypeInfo(options);
                    }
                    Type type2 = typeof(ReflectionJsonTypeInfo<>).MakeGenericType(type);
                    return (JsonTypeInfo)type2.CreateInstanceNoWrapExceptions(new Type[2]
                    {
                typeof(JsonConverter),
                typeof(JsonSerializerOptions)
                    }, new object[2] { converterForType, options });
                }

                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
                [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                internal static DefaultJsonTypeInfoResolver RootDefaultInstance()
                {
                    DefaultJsonTypeInfoResolver defaultJsonTypeInfoResolver = s_defaultInstance;
                    if (defaultJsonTypeInfoResolver != null)
                    {
                        return defaultJsonTypeInfoResolver;
                    }
                    DefaultJsonTypeInfoResolver defaultJsonTypeInfoResolver2 = new DefaultJsonTypeInfoResolver(mutable: false);
                    DefaultJsonTypeInfoResolver defaultJsonTypeInfoResolver3 = Interlocked.CompareExchange(ref s_defaultInstance, defaultJsonTypeInfoResolver2, null);
                    return defaultJsonTypeInfoResolver3 ?? defaultJsonTypeInfoResolver2;
                }
            }

            /// <summary>
            /// Helper class used for calculating the default value for a given System.Type instance.
            /// </summary>
            internal sealed class DefaultValueHolder
            {
                /// <summary>
                /// Returns the default value for the specified type.
                /// </summary>
                public object DefaultValue { get; }

                [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2067:UnrecognizedReflectionPattern", Justification = "GetUninitializedObject is only called on a struct. You can always create an instance of a struct.")]
                private DefaultValueHolder(Type type)
                {
                    if (type.IsValueType && Nullable.GetUnderlyingType(type) == null)
                    {
                        DefaultValue = FormatterServices.GetUninitializedObject(type);
                    }
                }

                /// <summary>
                /// Returns true if <param name="value" /> contains only default values.
                /// </summary>
                public bool IsDefaultValue(object value)
                {
                    if (DefaultValue != null)
                    {
                        return DefaultValue.Equals(value);
                    }
                    return value == null;
                }

                /// <summary>
                /// Creates a holder instance representing a type.
                /// </summary>
                public static DefaultValueHolder CreateHolder(Type type)
                {
                    return new DefaultValueHolder(type);
                }
            }

            /// <summary>
            /// Proxy class used to access FSharp.Core metadata and reflection APIs that are not statically available to System.Text.Json.
            /// </summary>
            internal sealed class FSharpCoreReflectionProxy
            {
                /// <summary>
                /// The various categories of F# types that System.Text.Json supports.
                /// </summary>
                public enum FSharpKind
                {
                    Unrecognized,
                    Option,
                    ValueOption,
                    List,
                    Set,
                    Map,
                    Record,
                    Union
                }

                public delegate TResult StructGetter<TStruct, TResult>(ref TStruct @this) where TStruct : struct;

                private enum SourceConstructFlags
                {
                    None = 0,
                    SumType = 1,
                    RecordType = 2,
                    ObjectType = 3,
                    Field = 4,
                    Exception = 5,
                    Closure = 6,
                    Module = 7,
                    UnionCase = 8,
                    Value = 9,
                    KindMask = 31,
                    NonPublicRepresentation = 32
                }

                public const string FSharpCoreUnreferencedCodeMessage = "Uses Reflection to access FSharp.Core components at runtime.";

                private static FSharpCoreReflectionProxy s_singletonInstance;

                private const string CompilationMappingAttributeTypeName = "Microsoft.FSharp.Core.CompilationMappingAttribute";

                private readonly Type _compilationMappingAttributeType;

                private readonly MethodInfo _sourceConstructFlagsGetter;

                private readonly Type _fsharpOptionType;

                private readonly Type _fsharpValueOptionType;

                private readonly Type _fsharpListType;

                private readonly Type _fsharpSetType;

                private readonly Type _fsharpMapType;

                private readonly MethodInfo _fsharpListCtor;

                private readonly MethodInfo _fsharpSetCtor;

                private readonly MethodInfo _fsharpMapCtor;

                /// <summary>
                /// Gets the singleton proxy instance; prerequires a successful IsFSharpType call for proxy initialization.
                /// </summary>
                public static FSharpCoreReflectionProxy Instance => s_singletonInstance;

                /// <summary>
                /// Checks if the provided System.Type instance is emitted by the F# compiler.
                /// If true, also initializes the proxy singleton for future by other F# types.
                /// </summary>
                [RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
                [RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
                public static bool IsFSharpType(Type type)
                {
                    if (s_singletonInstance == null)
                    {
                        Assembly fSharpCoreAssembly = GetFSharpCoreAssembly(type);
                        if ((object)fSharpCoreAssembly != null)
                        {
                            if (s_singletonInstance == null)
                            {
                                s_singletonInstance = new FSharpCoreReflectionProxy(fSharpCoreAssembly);
                            }
                            return true;
                        }
                        return false;
                    }
                    return s_singletonInstance.GetFSharpCompilationMappingAttribute(type) != null;
                }

                [RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
                [RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
                private FSharpCoreReflectionProxy(Assembly fsharpCoreAssembly)
                {
                    Type type = fsharpCoreAssembly.GetType("Microsoft.FSharp.Core.CompilationMappingAttribute");
                    _sourceConstructFlagsGetter = type.GetMethod("get_SourceConstructFlags", BindingFlags.Instance | BindingFlags.Public);
                    _compilationMappingAttributeType = type;
                    _fsharpOptionType = fsharpCoreAssembly.GetType("Microsoft.FSharp.Core.FSharpOption`1");
                    _fsharpValueOptionType = fsharpCoreAssembly.GetType("Microsoft.FSharp.Core.FSharpValueOption`1");
                    _fsharpListType = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.FSharpList`1");
                    _fsharpSetType = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.FSharpSet`1");
                    _fsharpMapType = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.FSharpMap`2");
                    _fsharpListCtor = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.ListModule")?.GetMethod("OfSeq", BindingFlags.Static | BindingFlags.Public);
                    _fsharpSetCtor = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.SetModule")?.GetMethod("OfSeq", BindingFlags.Static | BindingFlags.Public);
                    _fsharpMapCtor = fsharpCoreAssembly.GetType("Microsoft.FSharp.Collections.MapModule")?.GetMethod("OfSeq", BindingFlags.Static | BindingFlags.Public);
                }

                [RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
                [RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
                public FSharpKind DetectFSharpKind(Type type)
                {
                    Attribute fSharpCompilationMappingAttribute = GetFSharpCompilationMappingAttribute(type);
                    if (fSharpCompilationMappingAttribute == null)
                    {
                        return FSharpKind.Unrecognized;
                    }
                    if (type.IsGenericType)
                    {
                        Type genericTypeDefinition = type.GetGenericTypeDefinition();
                        if (genericTypeDefinition == _fsharpOptionType)
                        {
                            return FSharpKind.Option;
                        }
                        if (genericTypeDefinition == _fsharpValueOptionType)
                        {
                            return FSharpKind.ValueOption;
                        }
                        if (genericTypeDefinition == _fsharpListType)
                        {
                            return FSharpKind.List;
                        }
                        if (genericTypeDefinition == _fsharpSetType)
                        {
                            return FSharpKind.Set;
                        }
                        if (genericTypeDefinition == _fsharpMapType)
                        {
                            return FSharpKind.Map;
                        }
                    }
                    return (GetSourceConstructFlags(fSharpCompilationMappingAttribute) & SourceConstructFlags.KindMask) switch
                    {
                        SourceConstructFlags.RecordType => FSharpKind.Record,
                        SourceConstructFlags.SumType => FSharpKind.Union,
                        _ => FSharpKind.Unrecognized,
                    };
                }

                [RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
                [RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
                public Func<TFSharpOption, T> CreateFSharpOptionValueGetter<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] TFSharpOption, T>()
                {
                    MethodInfo methodInfo = EnsureMemberExists(typeof(TFSharpOption).GetMethod("get_Value", BindingFlags.Instance | BindingFlags.Public), "Microsoft.FSharp.Core.FSharpOption<T>.get_Value()");
                    return CreateDelegate<Func<TFSharpOption, T>>(methodInfo);
                }

                [RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
                [RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
                public Func<TElement, TFSharpOption> CreateFSharpOptionSomeConstructor<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] TFSharpOption, TElement>()
                {
                    MethodInfo methodInfo = EnsureMemberExists(typeof(TFSharpOption).GetMethod("Some", BindingFlags.Static | BindingFlags.Public), "Microsoft.FSharp.Core.FSharpOption<T>.Some(T value)");
                    return CreateDelegate<Func<TElement, TFSharpOption>>(methodInfo);
                }

                [RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
                [RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
                public StructGetter<TFSharpValueOption, TElement> CreateFSharpValueOptionValueGetter<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] TFSharpValueOption, TElement>() where TFSharpValueOption : struct
                {
                    MethodInfo methodInfo = EnsureMemberExists(typeof(TFSharpValueOption).GetMethod("get_Value", BindingFlags.Instance | BindingFlags.Public), "Microsoft.FSharp.Core.FSharpValueOption<T>.get_Value()");
                    return CreateDelegate<StructGetter<TFSharpValueOption, TElement>>(methodInfo);
                }

                [RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
                [RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
                public Func<TElement, TFSharpOption> CreateFSharpValueOptionSomeConstructor<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] TFSharpOption, TElement>()
                {
                    MethodInfo methodInfo = EnsureMemberExists(typeof(TFSharpOption).GetMethod("Some", BindingFlags.Static | BindingFlags.Public), "Microsoft.FSharp.Core.FSharpValueOption<T>.ValueSome(T value)");
                    return CreateDelegate<Func<TElement, TFSharpOption>>(methodInfo);
                }

                [RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
                [RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
                public Func<IEnumerable<TElement>, TFSharpList> CreateFSharpListConstructor<TFSharpList, TElement>()
                {
                    return CreateDelegate<Func<IEnumerable<TElement>, TFSharpList>>(EnsureMemberExists(_fsharpListCtor, "Microsoft.FSharp.Collections.ListModule.OfSeq<T>(IEnumerable<T> source)").MakeGenericMethod(typeof(TElement)));
                }

                [RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
                [RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
                public Func<IEnumerable<TElement>, TFSharpSet> CreateFSharpSetConstructor<TFSharpSet, TElement>()
                {
                    return CreateDelegate<Func<IEnumerable<TElement>, TFSharpSet>>(EnsureMemberExists(_fsharpSetCtor, "Microsoft.FSharp.Collections.SetModule.OfSeq<T>(IEnumerable<T> source)").MakeGenericMethod(typeof(TElement)));
                }

                [RequiresUnreferencedCode("Uses Reflection to access FSharp.Core components at runtime.")]
                [RequiresDynamicCode("Uses Reflection to access FSharp.Core components at runtime.")]
                public Func<IEnumerable<Tuple<TKey, TValue>>, TFSharpMap> CreateFSharpMapConstructor<TFSharpMap, TKey, TValue>()
                {
                    return CreateDelegate<Func<IEnumerable<Tuple<TKey, TValue>>, TFSharpMap>>(EnsureMemberExists(_fsharpMapCtor, "Microsoft.FSharp.Collections.MapModule.OfSeq<TKey, TValue>(IEnumerable<Tuple<TKey, TValue>> source)").MakeGenericMethod(typeof(TKey), typeof(TValue)));
                }

                private Attribute GetFSharpCompilationMappingAttribute(Type type)
                {
                    return type.GetCustomAttribute(_compilationMappingAttributeType, inherit: true);
                }

                private SourceConstructFlags GetSourceConstructFlags(Attribute compilationMappingAttribute)
                {
                    if ((object)_sourceConstructFlagsGetter != null)
                    {
                        return (SourceConstructFlags)_sourceConstructFlagsGetter.Invoke(compilationMappingAttribute, null);
                    }
                    return SourceConstructFlags.None;
                }

                private static Assembly GetFSharpCoreAssembly(Type type)
                {
                    object[] customAttributes = type.GetCustomAttributes(inherit: true);
                    for (int i = 0; i < customAttributes.Length; i++)
                    {
                        Attribute attribute = (Attribute)customAttributes[i];
                        Type type2 = attribute.GetType();
                        if (type2.FullName == "Microsoft.FSharp.Core.CompilationMappingAttribute")
                        {
                            return type2.Assembly;
                        }
                    }
                    return null;
                }

                private static TDelegate CreateDelegate<TDelegate>(MethodInfo methodInfo) where TDelegate : Delegate
                {
                    return (TDelegate)Delegate.CreateDelegate(typeof(TDelegate), methodInfo, throwOnBindFailure: true);
                }

                private static TMemberInfo EnsureMemberExists<TMemberInfo>(TMemberInfo memberInfo, string memberName) where TMemberInfo : MemberInfo
                {
                    if (memberInfo == null)
                    {
                        ThrowHelper.ThrowMissingMemberException_MissingFSharpCoreMember(memberName);
                    }
                    return memberInfo;
                }
            }

            /// <summary>
            /// Used to resolve the JSON serialization contract for requested types.
            /// </summary>
            public interface IJsonTypeInfoResolver
            {
                /// <summary>
                /// Resolves a <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> contract for the requested type and options.
                /// </summary>
                /// <param name="type">Type to be resolved.</param>
                /// <param name="options">Configuration used when resolving the metadata.</param>
                /// <returns>
                /// A <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance matching the requested type,
                /// or <see langword="null" /> if no contract could be resolved.
                /// </returns>
                JsonTypeInfo? GetTypeInfo(Type type, JsonSerializerOptions options);
            }

            /// <summary>
            /// Provides serialization metadata about a collection type.
            /// </summary>
            /// <typeparam name="TCollection">The collection type.</typeparam>
            /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
            [EditorBrowsable(EditorBrowsableState.Never)]
            public sealed class JsonCollectionInfoValues<TCollection>
            {
                /// <summary>
                /// A <see cref="T:System.Func`1" /> to create an instance of the collection when deserializing.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public Func<TCollection>? ObjectCreator { get; init; }

                /// <summary>
                /// If a dictionary type, the <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance representing the key type.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public JsonTypeInfo? KeyInfo { get; init; }

                /// <summary>
                /// A <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance representing the element type.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public JsonTypeInfo ElementInfo { get; init; }

                /// <summary>
                /// The <see cref="T:System.Text.Json.Serialization.JsonNumberHandling" /> option to apply to number collection elements.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public JsonNumberHandling NumberHandling { get; init; }

                /// <summary>
                /// An optimized serialization implementation assuming pre-determined <see cref="T:System.Text.Json.Serialization.JsonSourceGenerationOptionsAttribute" /> defaults.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public Action<Utf8JsonWriter, TCollection>? SerializeHandler { get; init; }
            }

            /// <summary>
            /// Represents a supported derived type defined in the metadata of a polymorphic type.
            /// </summary>
            public readonly struct JsonDerivedType
            {
                /// <summary>
                /// A derived type that should be supported in polymorphic serialization of the declared base type.
                /// </summary>
                public Type DerivedType { get; }

                /// <summary>
                /// The type discriminator identifier to be used for the serialization of the subtype.
                /// </summary>
                public object? TypeDiscriminator { get; }

                /// <summary>
                /// Specifies a supported derived type without a type discriminator.
                /// </summary>
                /// <param name="derivedType">The derived type to be supported by the polymorphic type metadata.</param>
                public JsonDerivedType(Type derivedType)
                {
                    DerivedType = derivedType;
                    TypeDiscriminator = null;
                }

                /// <summary>
                /// Specifies a supported derived type with an integer type discriminator.
                /// </summary>
                /// <param name="derivedType">The derived type to be supported by the polymorphic type metadata.</param>
                /// <param name="typeDiscriminator">The type discriminator to be associated with the derived type.</param>
                public JsonDerivedType(Type derivedType, int typeDiscriminator)
                {
                    DerivedType = derivedType;
                    TypeDiscriminator = typeDiscriminator;
                }

                /// <summary>
                /// Specifies a supported derived type with a string type discriminator.
                /// </summary>
                /// <param name="derivedType">The derived type to be supported by the polymorphic type metadata.</param>
                /// <param name="typeDiscriminator">The type discriminator to be associated with the derived type.</param>
                public JsonDerivedType(Type derivedType, string typeDiscriminator)
                {
                    DerivedType = derivedType;
                    TypeDiscriminator = typeDiscriminator;
                }

                internal JsonDerivedType(Type derivedType, object typeDiscriminator)
                {
                    DerivedType = derivedType;
                    TypeDiscriminator = typeDiscriminator;
                }

                internal void Deconstruct(out Type derivedType, out object typeDiscriminator)
                {
                    derivedType = DerivedType;
                    typeDiscriminator = TypeDiscriminator;
                }
            }

            /// <summary>
            /// Provides helpers to create and initialize metadata for JSON-serializable types.
            /// </summary>
            /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
            [EditorBrowsable(EditorBrowsableState.Never)]
            public static class JsonMetadataServices
            {
                private static JsonConverter<bool> s_booleanConverter;

                private static JsonConverter<byte[]> s_byteArrayConverter;

                private static JsonConverter<byte> s_byteConverter;

                private static JsonConverter<char> s_charConverter;

                private static JsonConverter<DateTime> s_dateTimeConverter;

                private static JsonConverter<DateTimeOffset> s_dateTimeOffsetConverter;

                private static JsonConverter<decimal> s_decimalConverter;

                private static JsonConverter<double> s_doubleConverter;

                private static JsonConverter<Guid> s_guidConverter;

                private static JsonConverter<short> s_int16Converter;

                private static JsonConverter<int> s_int32Converter;

                private static JsonConverter<long> s_int64Converter;

                private static JsonConverter<JsonArray> s_jsonArrayConverter;

                private static JsonConverter<JsonElement> s_jsonElementConverter;

                private static JsonConverter<JsonNode> s_jsonNodeConverter;

                private static JsonConverter<JsonObject> s_jsonObjectConverter;

                private static JsonConverter<JsonValue> s_jsonValueConverter;

                private static JsonConverter<JsonDocument> s_jsonDocumentConverter;

                private static JsonConverter<object> s_objectConverter;

                private static JsonConverter<float> s_singleConverter;

                private static JsonConverter<sbyte> s_sbyteConverter;

                private static JsonConverter<string> s_stringConverter;

                private static JsonConverter<TimeSpan> s_timeSpanConverter;

                private static JsonConverter<ushort> s_uint16Converter;

                private static JsonConverter<uint> s_uint32Converter;

                private static JsonConverter<ulong> s_uint64Converter;

                private static JsonConverter<Uri> s_uriConverter;

                private static JsonConverter<Version> s_versionConverter;

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Boolean" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<bool> BooleanConverter => s_booleanConverter ?? (s_booleanConverter = new System.Text.Json.Serialization.Converters.BooleanConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts byte array values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<byte[]> ByteArrayConverter => s_byteArrayConverter ?? (s_byteArrayConverter = new ByteArrayConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Byte" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<byte> ByteConverter => s_byteConverter ?? (s_byteConverter = new System.Text.Json.Serialization.Converters.ByteConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Char" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<char> CharConverter => s_charConverter ?? (s_charConverter = new System.Text.Json.Serialization.Converters.CharConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.DateTime" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<DateTime> DateTimeConverter => s_dateTimeConverter ?? (s_dateTimeConverter = new System.Text.Json.Serialization.Converters.DateTimeConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.DateTimeOffset" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<DateTimeOffset> DateTimeOffsetConverter => s_dateTimeOffsetConverter ?? (s_dateTimeOffsetConverter = new System.Text.Json.Serialization.Converters.DateTimeOffsetConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Decimal" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<decimal> DecimalConverter => s_decimalConverter ?? (s_decimalConverter = new System.Text.Json.Serialization.Converters.DecimalConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Double" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<double> DoubleConverter => s_doubleConverter ?? (s_doubleConverter = new System.Text.Json.Serialization.Converters.DoubleConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Guid" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<Guid> GuidConverter => s_guidConverter ?? (s_guidConverter = new System.Text.Json.Serialization.Converters.GuidConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Int16" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<short> Int16Converter => s_int16Converter ?? (s_int16Converter = new System.Text.Json.Serialization.Converters.Int16Converter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Int32" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<int> Int32Converter => s_int32Converter ?? (s_int32Converter = new System.Text.Json.Serialization.Converters.Int32Converter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Int64" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<long> Int64Converter => s_int64Converter ?? (s_int64Converter = new System.Text.Json.Serialization.Converters.Int64Converter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Text.Json.Nodes.JsonArray" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<JsonArray> JsonArrayConverter => s_jsonArrayConverter ?? (s_jsonArrayConverter = new JsonArrayConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Text.Json.JsonElement" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<JsonElement> JsonElementConverter => s_jsonElementConverter ?? (s_jsonElementConverter = new JsonElementConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Text.Json.Nodes.JsonNode" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<JsonNode> JsonNodeConverter => s_jsonNodeConverter ?? (s_jsonNodeConverter = new JsonNodeConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Text.Json.Nodes.JsonObject" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<JsonObject> JsonObjectConverter => s_jsonObjectConverter ?? (s_jsonObjectConverter = new JsonObjectConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Text.Json.Nodes.JsonArray" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<JsonValue> JsonValueConverter => s_jsonValueConverter ?? (s_jsonValueConverter = new JsonValueConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Text.Json.JsonDocument" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<JsonDocument> JsonDocumentConverter => s_jsonDocumentConverter ?? (s_jsonDocumentConverter = new JsonDocumentConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Object" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<object?> ObjectConverter => s_objectConverter ?? (s_objectConverter = new ObjectConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Single" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<float> SingleConverter => s_singleConverter ?? (s_singleConverter = new System.Text.Json.Serialization.Converters.SingleConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.SByte" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                [CLSCompliant(false)]
                public static JsonConverter<sbyte> SByteConverter => s_sbyteConverter ?? (s_sbyteConverter = new System.Text.Json.Serialization.Converters.SByteConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.String" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<string> StringConverter => s_stringConverter ?? (s_stringConverter = new System.Text.Json.Serialization.Converters.StringConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.TimeSpan" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<TimeSpan> TimeSpanConverter => s_timeSpanConverter ?? (s_timeSpanConverter = new System.Text.Json.Serialization.Converters.TimeSpanConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.UInt16" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                [CLSCompliant(false)]
                public static JsonConverter<ushort> UInt16Converter => s_uint16Converter ?? (s_uint16Converter = new System.Text.Json.Serialization.Converters.UInt16Converter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.UInt32" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                [CLSCompliant(false)]
                public static JsonConverter<uint> UInt32Converter => s_uint32Converter ?? (s_uint32Converter = new System.Text.Json.Serialization.Converters.UInt32Converter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.UInt64" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                [CLSCompliant(false)]
                public static JsonConverter<ulong> UInt64Converter => s_uint64Converter ?? (s_uint64Converter = new System.Text.Json.Serialization.Converters.UInt64Converter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Uri" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<Uri> UriConverter => s_uriConverter ?? (s_uriConverter = new UriConverter());

                /// <summary>
                /// Returns a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <see cref="T:System.Version" /> values.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<Version> VersionConverter => s_versionConverter ?? (s_versionConverter = new VersionConverter());

                /// <summary>
                /// Creates serialization metadata for an array.
                /// </summary>
                /// <typeparam name="TElement">The generic definition of the element type.</typeparam>
                /// <param name="options">The <see cref="T:System.Text.Json.JsonSerializerOptions" /> to use.</param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TElement[]> CreateArrayInfo<TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TElement[]> collectionInfo)
                {
                    return new SourceGenJsonTypeInfo<TElement[]>(options, collectionInfo, () => new ArrayConverter<TElement[], TElement>());
                }

                /// <summary>
                /// Creates serialization metadata for types assignable to <see cref="T:System.Collections.Generic.List`1" />.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <typeparam name="TElement">The generic definition of the element type.</typeparam>
                /// <param name="options">The <see cref="T:System.Text.Json.JsonSerializerOptions" /> to use.</param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateListInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : List<TElement>
                {
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new ListOfTConverter<TCollection, TElement>());
                }

                /// <summary>
                /// Creates serialization metadata for types assignable to <see cref="T:System.Collections.Generic.Dictionary`2" />.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <typeparam name="TKey">The generic definition of the key type.</typeparam>
                /// <typeparam name="TValue">The generic definition of the value type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateDictionaryInfo<TCollection, TKey, TValue>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : Dictionary<TKey, TValue> where TKey : notnull
                {
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new DictionaryOfTKeyTValueConverter<TCollection, TKey, TValue>());
                }

                /// <summary>
                /// Creates serialization metadata for <see cref="!:System.Collections.Immutable.ImmutableDictionary&lt;TKey, TValue&gt;" /> and
                /// types assignable to <see cref="!:System.Collections.Immutable.IImmutableDictionary&lt;TKey, TValue&gt;" />.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <typeparam name="TKey">The generic definition of the key type.</typeparam>
                /// <typeparam name="TValue">The generic definition of the value type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <param name="createRangeFunc">A method to create an immutable dictionary instance.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateImmutableDictionaryInfo<TCollection, TKey, TValue>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo, Func<IEnumerable<KeyValuePair<TKey, TValue>>, TCollection> createRangeFunc) where TCollection : IReadOnlyDictionary<TKey, TValue> where TKey : notnull
                {
                    if (createRangeFunc == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("createRangeFunc");
                    }
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new ImmutableDictionaryOfTKeyTValueConverter<TCollection, TKey, TValue>(), createRangeFunc);
                }

                /// <summary>
                /// Creates serialization metadata for types assignable to <see cref="T:System.Collections.Generic.IDictionary`2" />.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <typeparam name="TKey">The generic definition of the key type.</typeparam>
                /// <typeparam name="TValue">The generic definition of the value type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateIDictionaryInfo<TCollection, TKey, TValue>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : IDictionary<TKey, TValue> where TKey : notnull
                {
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new IDictionaryOfTKeyTValueConverter<TCollection, TKey, TValue>());
                }

                /// <summary>
                /// Creates serialization metadata for types assignable to <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2" />.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <typeparam name="TKey">The generic definition of the key type.</typeparam>
                /// <typeparam name="TValue">The generic definition of the value type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateIReadOnlyDictionaryInfo<TCollection, TKey, TValue>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : IReadOnlyDictionary<TKey, TValue> where TKey : notnull
                {
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new IReadOnlyDictionaryOfTKeyTValueConverter<TCollection, TKey, TValue>());
                }

                /// <summary>
                /// Creates serialization metadata for non-dictionary immutable collection types.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <typeparam name="TElement">The generic definition of the element type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <param name="createRangeFunc">A method to create an immutable dictionary instance.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateImmutableEnumerableInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo, Func<IEnumerable<TElement>, TCollection> createRangeFunc) where TCollection : IEnumerable<TElement>
                {
                    if (createRangeFunc == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("createRangeFunc");
                    }
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new ImmutableEnumerableOfTConverter<TCollection, TElement>(), createRangeFunc);
                }

                /// <summary>
                /// Creates serialization metadata for types assignable to <see cref="T:System.Collections.IList" />.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateIListInfo<TCollection>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : IList
                {
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new IListConverter<TCollection>());
                }

                /// <summary>
                /// Creates serialization metadata for types assignable to <see cref="T:System.Collections.Generic.IList`1" />.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <typeparam name="TElement">The generic definition of the element type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateIListInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : IList<TElement>
                {
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new IListOfTConverter<TCollection, TElement>());
                }

                /// <summary>
                /// Creates serialization metadata for types assignable to <see cref="T:System.Collections.Generic.ISet`1" />.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <typeparam name="TElement">The generic definition of the element type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateISetInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : ISet<TElement>
                {
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new ISetOfTConverter<TCollection, TElement>());
                }

                /// <summary>
                /// Creates serialization metadata for types assignable to <see cref="T:System.Collections.Generic.ICollection`1" />.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <typeparam name="TElement">The generic definition of the element type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateICollectionInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : ICollection<TElement>
                {
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new ICollectionOfTConverter<TCollection, TElement>());
                }

                /// <summary>
                /// Creates serialization metadata for types assignable to <see cref="T:System.Collections.Generic.Stack`1" />.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <typeparam name="TElement">The generic definition of the element type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateStackInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : Stack<TElement>
                {
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new StackOfTConverter<TCollection, TElement>());
                }

                /// <summary>
                /// Creates serialization metadata for types assignable to <see cref="T:System.Collections.Generic.Queue`1" />.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <typeparam name="TElement">The generic definition of the element type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateQueueInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : Queue<TElement>
                {
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new QueueOfTConverter<TCollection, TElement>());
                }

                /// <summary>
                /// Creates serialization metadata for types assignable to <see cref="T:System.Collections.Concurrent.ConcurrentStack`1" />.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <typeparam name="TElement">The generic definition of the element type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateConcurrentStackInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : ConcurrentStack<TElement>
                {
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new ConcurrentStackOfTConverter<TCollection, TElement>());
                }

                /// <summary>
                /// Creates serialization metadata for types assignable to <see cref="T:System.Collections.Generic.Queue`1" />.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <typeparam name="TElement">The generic definition of the element type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateConcurrentQueueInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : ConcurrentQueue<TElement>
                {
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new ConcurrentQueueOfTConverter<TCollection, TElement>());
                }

                /// <summary>
                /// Creates serialization metadata for types assignable to <see cref="T:System.Collections.Generic.IEnumerable`1" />.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <typeparam name="TElement">The generic definition of the element type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateIEnumerableInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : IEnumerable<TElement>
                {
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new IEnumerableOfTConverter<TCollection, TElement>());
                }

                /// <summary>
                /// Creates serialization metadata for types assignable to <see cref="T:System.Collections.Generic.IAsyncEnumerable`1" />.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <typeparam name="TElement">The generic definition of the element type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateIAsyncEnumerableInfo<TCollection, TElement>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : IAsyncEnumerable<TElement>
                {
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new IAsyncEnumerableOfTConverter<TCollection, TElement>());
                }

                /// <summary>
                /// Creates serialization metadata for types assignable to <see cref="T:System.Collections.IDictionary" />.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateIDictionaryInfo<TCollection>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : IDictionary
                {
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new IDictionaryConverter<TCollection>());
                }

                /// <summary>
                /// Creates serialization metadata for <see cref="T:System.Collections.Stack" /> types.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <param name="addFunc">A method for adding elements to the collection when using the serializer's code-paths.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateStackInfo<TCollection>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo, Action<TCollection, object?> addFunc) where TCollection : IEnumerable
                {
                    return CreateStackOrQueueInfo(options, collectionInfo, addFunc);
                }

                /// <summary>
                /// Creates serialization metadata for <see cref="T:System.Collections.Queue" /> types.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <param name="addFunc">A method for adding elements to the collection when using the serializer's code-paths.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateQueueInfo<TCollection>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo, Action<TCollection, object?> addFunc) where TCollection : IEnumerable
                {
                    return CreateStackOrQueueInfo(options, collectionInfo, addFunc);
                }

                private static JsonTypeInfo<TCollection> CreateStackOrQueueInfo<TCollection>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo, Action<TCollection, object> addFunc) where TCollection : IEnumerable
                {
                    if (addFunc == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("addFunc");
                    }
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new StackOrQueueConverter<TCollection>(), null, addFunc);
                }

                /// <summary>
                /// Creates serialization metadata for types assignable to <see cref="T:System.Collections.IList" />.
                /// </summary>
                /// <typeparam name="TCollection">The generic definition of the type.</typeparam>
                /// <param name="options"></param>
                /// <param name="collectionInfo">Provides serialization metadata about the collection type.</param>
                /// <returns>Serialization metadata for the given type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<TCollection> CreateIEnumerableInfo<TCollection>(JsonSerializerOptions options, JsonCollectionInfoValues<TCollection> collectionInfo) where TCollection : IEnumerable
                {
                    return new SourceGenJsonTypeInfo<TCollection>(options, collectionInfo, () => new IEnumerableConverter<TCollection>());
                }

                /// <summary>
                /// Creates a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that throws <see cref="T:System.NotSupportedException" />.
                /// </summary>
                /// <typeparam name="T">The generic definition for the type.</typeparam>
                /// <returns>A <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that throws <see cref="T:System.NotSupportedException" /></returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<T> GetUnsupportedTypeConverter<T>()
                {
                    return new UnsupportedTypeConverter<T>();
                }

                /// <summary>
                /// Creates a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <typeparamref name="T" /> values.
                /// </summary>
                /// <typeparam name="T">The generic definition for the enum type.</typeparam>
                /// <param name="options">The <see cref="T:System.Text.Json.JsonSerializerOptions" /> to use for serialization and deserialization.</param>
                /// <returns>A <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <typeparamref name="T" /> values.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<T> GetEnumConverter<T>(JsonSerializerOptions options) where T : struct, Enum
                {
                    if (options == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("options");
                    }
                    return new EnumConverter<T>(EnumConverterOptions.AllowNumbers, options);
                }

                /// <summary>
                /// Creates a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <typeparamref name="T??" /> values.
                /// </summary>
                /// <typeparam name="T">The generic definition for the underlying nullable type.</typeparam>
                /// <param name="underlyingTypeInfo">Serialization metadata for the underlying nullable type.</param>
                /// <returns>A <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <typeparamref name="T??" /> values</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<T?> GetNullableConverter<T>(JsonTypeInfo<T> underlyingTypeInfo) where T : struct
                {
                    if (underlyingTypeInfo == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("underlyingTypeInfo");
                    }
                    JsonConverter<T> typedConverter = GetTypedConverter<T>(underlyingTypeInfo.Converter);
                    return new NullableConverter<T>(typedConverter);
                }

                /// <summary>
                /// Creates a <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <typeparamref name="T??" /> values.
                /// </summary>
                /// <typeparam name="T">The generic definition for the underlying nullable type.</typeparam>
                /// <param name="options">The <see cref="T:System.Text.Json.JsonSerializerOptions" /> to use for serialization and deserialization.</param>
                /// <returns>A <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> instance that converts <typeparamref name="T??" /> values</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonConverter<T?> GetNullableConverter<T>(JsonSerializerOptions options) where T : struct
                {
                    if (options == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("options");
                    }
                    JsonConverter<T> typedConverter = GetTypedConverter<T>(options.GetConverterInternal(typeof(T)));
                    return new NullableConverter<T>(typedConverter);
                }

                internal static JsonConverter<T> GetTypedConverter<T>(JsonConverter converter)
                {
                    JsonConverter<T> jsonConverter = converter as JsonConverter<T>;
                    if (jsonConverter == null)
                    {
                        throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.SerializationConverterNotCompatible, jsonConverter, typeof(T)));
                    }
                    return jsonConverter;
                }

                /// <summary>
                /// Creates metadata for a property or field.
                /// </summary>
                /// <typeparam name="T">The type that the converter for the property returns or accepts when converting JSON data.</typeparam>
                /// <param name="options">The <see cref="T:System.Text.Json.JsonSerializerOptions" /> to initialize the metadata with.</param>
                /// <param name="propertyInfo">Provides serialization metadata about the property or field.</param>
                /// <returns>A <see cref="T:System.Text.Json.Serialization.Metadata.JsonPropertyInfo" /> instance initialized with the provided metadata.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonPropertyInfo CreatePropertyInfo<T>(JsonSerializerOptions options, JsonPropertyInfoValues<T> propertyInfo)
                {
                    if (options == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("options");
                    }
                    if (propertyInfo == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("propertyInfo");
                    }
                    Type declaringType = propertyInfo.DeclaringType;
                    if (declaringType == null)
                    {
                        throw new ArgumentException("DeclaringType");
                    }
                    string propertyName = propertyInfo.PropertyName;
                    if (propertyName == null)
                    {
                        throw new ArgumentException("PropertyName");
                    }
                    if (!propertyInfo.IsProperty && propertyInfo.IsVirtual)
                    {
                        throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.FieldCannotBeVirtual, "IsProperty", "IsVirtual"));
                    }
                    return new JsonPropertyInfo<T>(propertyInfo, options);
                }

                /// <summary>
                /// Creates metadata for a complex class or struct.
                /// </summary>
                /// <param name="options">The <see cref="T:System.Text.Json.JsonSerializerOptions" /> to initialize the metadata with.</param>
                /// <param name="objectInfo">Provides serialization metadata about an object type with constructors, properties, and fields.</param>
                /// <typeparam name="T">The type of the class or struct.</typeparam>
                /// <exception cref="T:System.ArgumentNullException">Thrown when <paramref name="options" /> or <paramref name="objectInfo" /> is null.</exception>
                /// <returns>A <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo`1" /> instance representing the class or struct.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<T> CreateObjectInfo<T>(JsonSerializerOptions options, JsonObjectInfoValues<T> objectInfo) where T : notnull
                {
                    if (options == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("options");
                    }
                    if (objectInfo == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("objectInfo");
                    }
                    return new SourceGenJsonTypeInfo<T>(options, objectInfo);
                }

                /// <summary>
                /// Creates metadata for a primitive or a type with a custom converter.
                /// </summary>
                /// <typeparam name="T">The generic type definition.</typeparam>
                /// <returns>A <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo`1" /> instance representing the type.</returns>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public static JsonTypeInfo<T> CreateValueInfo<T>(JsonSerializerOptions options, JsonConverter converter)
                {
                    if (options == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("options");
                    }
                    if (converter == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("converter");
                    }
                    return new SourceGenJsonTypeInfo<T>(converter, options);
                }
            }

            /// <summary>
            /// Provides serialization metadata about an object type with constructors, properties, and fields.
            /// </summary>
            /// <typeparam name="T">The object type to serialize or deserialize.</typeparam>
            /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
            [EditorBrowsable(EditorBrowsableState.Never)]
            public sealed class JsonObjectInfoValues<T>
            {
                /// <summary>
                /// Provides a mechanism to create an instance of the class or struct when deserializing, using a parameterless constructor.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public Func<T>? ObjectCreator { get; init; }

                /// <summary>
                /// Provides a mechanism to create an instance of the class or struct when deserializing, using a parameterized constructor.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public Func<object[], T>? ObjectWithParameterizedConstructorCreator { get; init; }

                /// <summary>
                /// Provides a mechanism to initialize metadata for properties and fields of the class or struct.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public Func<JsonSerializerContext, JsonPropertyInfo[]>? PropertyMetadataInitializer { get; init; }

                /// <summary>
                /// Provides a mechanism to initialize metadata for a parameterized constructor of the class or struct to be used when deserializing.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public Func<JsonParameterInfoValues[]>? ConstructorParameterMetadataInitializer { get; init; }

                /// <summary>
                /// Specifies how number properties and fields should be processed when serializing and deserializing.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public JsonNumberHandling NumberHandling { get; init; }

                /// <summary>
                /// Provides a serialization implementation for instances of the class or struct which assumes options specified by <see cref="T:System.Text.Json.Serialization.JsonSourceGenerationOptionsAttribute" />.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public Action<Utf8JsonWriter, T>? SerializeHandler { get; init; }
            }

            /// <summary>
            /// Holds relevant state about a method parameter, like the default value of
            /// the parameter, and the position in the method's parameter list.
            /// </summary>
            internal abstract class JsonParameterInfo
            {
                private JsonTypeInfo _jsonTypeInfo;

                public JsonParameterInfoValues ClrInfo;

                public JsonConverter ConverterBase { get; private set; }

                private protected bool MatchingPropertyCanBeNull { get; private set; }

                public object DefaultValue { get; private protected set; }

                public bool IgnoreNullTokensOnRead { get; private set; }

                public JsonSerializerOptions Options { get; set; }

                public byte[] NameAsUtf8Bytes { get; private set; }

                public JsonNumberHandling? NumberHandling { get; private set; }

                public JsonTypeInfo JsonTypeInfo
                {
                    get
                    {
                        return _jsonTypeInfo ?? (_jsonTypeInfo = Options.GetTypeInfoInternal(PropertyType));
                    }
                    set
                    {
                        _jsonTypeInfo = value;
                    }
                }

                public Type PropertyType { get; set; }

                public bool ShouldDeserialize { get; private set; }

                public JsonPropertyInfo MatchingProperty { get; private set; }

                public virtual void Initialize(JsonParameterInfoValues parameterInfo, JsonPropertyInfo matchingProperty, JsonSerializerOptions options)
                {
                    MatchingProperty = matchingProperty;
                    ClrInfo = parameterInfo;
                    Options = options;
                    ShouldDeserialize = true;
                    PropertyType = matchingProperty.PropertyType;
                    NameAsUtf8Bytes = matchingProperty.NameAsUtf8Bytes;
                    ConverterBase = matchingProperty.EffectiveConverter;
                    IgnoreNullTokensOnRead = matchingProperty.IgnoreNullTokensOnRead;
                    NumberHandling = matchingProperty.EffectiveNumberHandling;
                    MatchingPropertyCanBeNull = matchingProperty.PropertyTypeCanBeNull;
                }

                /// <summary>
                /// Create a parameter that is ignored at run time. It uses the same type (typeof(sbyte)) to help
                /// prevent issues with unsupported types and helps ensure we don't accidently (de)serialize it.
                /// </summary>
                public static JsonParameterInfo CreateIgnoredParameterPlaceholder(JsonParameterInfoValues parameterInfo, JsonPropertyInfo matchingProperty, bool sourceGenMode)
                {
                    JsonParameterInfo jsonParameterInfo = new JsonParameterInfo<sbyte>();
                    jsonParameterInfo.ClrInfo = parameterInfo;
                    jsonParameterInfo.PropertyType = matchingProperty.PropertyType;
                    jsonParameterInfo.NameAsUtf8Bytes = matchingProperty.NameAsUtf8Bytes;
                    if (sourceGenMode)
                    {
                        jsonParameterInfo.DefaultValue = matchingProperty.DefaultValue;
                    }
                    else
                    {
                        Type parameterType = parameterInfo.ParameterType;
                        JsonTypeInfo typeInfo;
                        DefaultValueHolder defaultValueHolder = ((!matchingProperty.Options.TryGetTypeInfoCached(parameterType, out typeInfo)) ? DefaultValueHolder.CreateHolder(parameterInfo.ParameterType) : typeInfo.DefaultValueHolder);
                        jsonParameterInfo.DefaultValue = defaultValueHolder.DefaultValue;
                    }
                    return jsonParameterInfo;
                }
            }
            
            /// <summary>
            /// Represents a strongly-typed parameter to prevent boxing where have less than 4 parameters.
            /// Holds relevant state like the default value of the parameter, and the position in the method's parameter list.
            /// </summary>
            internal sealed class JsonParameterInfo<T> : JsonParameterInfo
            {
                public T TypedDefaultValue { get; private set; }

                public override void Initialize(JsonParameterInfoValues parameterInfo, JsonPropertyInfo matchingProperty, JsonSerializerOptions options)
                {
                    base.Initialize(parameterInfo, matchingProperty, options);
                    InitializeDefaultValue(matchingProperty);
                }

                private void InitializeDefaultValue(JsonPropertyInfo matchingProperty)
                {
                    if (ClrInfo.HasDefaultValue)
                    {
                        object defaultValue = ClrInfo.DefaultValue;
                        if (defaultValue == null && !matchingProperty.PropertyTypeCanBeNull)
                        {
                            base.DefaultValue = TypedDefaultValue;
                            return;
                        }
                        base.DefaultValue = defaultValue;
                        TypedDefaultValue = (T)defaultValue;
                    }
                    else
                    {
                        base.DefaultValue = TypedDefaultValue;
                    }
                }
            }

            /// <summary>
            /// Provides information about a constructor parameter required for JSON deserialization.
            /// </summary>
            /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
            [EditorBrowsable(EditorBrowsableState.Never)]
            public sealed class JsonParameterInfoValues
            {
                /// <summary>
                /// The name of the parameter.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public string Name { get; init; }

                /// <summary>
                /// The type of the parameter.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public Type ParameterType { get; init; }

                /// <summary>
                /// The zero-based position of the parameter in the formal parameter list.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public int Position { get; init; }

                /// <summary>
                /// Whether a default value was specified for the parameter.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public bool HasDefaultValue { get; init; }

                /// <summary>
                /// The default value of the parameter.
                /// </summary>
                /// <remarks>This API is for use by the output of the System.Text.Json source generator and should not be called directly.</remarks>
                public object? DefaultValue { get; init; }
            }

            /// <summary>
            /// Defines polymorphic configuration for a specified base type.
            /// </summary>
            public class JsonPolymorphismOptions
            {
                private sealed class DerivedTypeList : ConfigurationList<JsonDerivedType>
                {
                    private readonly JsonPolymorphismOptions _parent;

                    protected override bool IsImmutable => _parent.DeclaringTypeInfo?.IsConfigured ?? false;

                    public DerivedTypeList(JsonPolymorphismOptions parent)
                        : base((IList<JsonDerivedType>)null)
                    {
                        _parent = parent;
                    }

                    protected override void VerifyMutable()
                    {
                        _parent.DeclaringTypeInfo?.VerifyMutable();
                    }
                }

                private DerivedTypeList _derivedTypes;

                private bool _ignoreUnrecognizedTypeDiscriminators;

                private JsonUnknownDerivedTypeHandling _unknownDerivedTypeHandling;

                private string _typeDiscriminatorPropertyName;

                /// <summary>
                /// Gets the list of derived types supported in the current polymorphic type configuration.
                /// </summary>
                public IList<JsonDerivedType> DerivedTypes => _derivedTypes ?? (_derivedTypes = new DerivedTypeList(this));

                /// <summary>
                /// When set to <see langword="true" />, instructs the serializer to ignore any
                /// unrecognized type discriminator id's and reverts to the contract of the base type.
                /// Otherwise, it will fail the deserialization.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The parent <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance has been locked for further modification.
                /// </exception>
                public bool IgnoreUnrecognizedTypeDiscriminators
                {
                    get
                    {
                        return _ignoreUnrecognizedTypeDiscriminators;
                    }
                    set
                    {
                        VerifyMutable();
                        _ignoreUnrecognizedTypeDiscriminators = value;
                    }
                }

                /// <summary>
                /// Gets or sets the behavior when serializing an undeclared derived runtime type.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The parent <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance has been locked for further modification.
                /// </exception>
                public JsonUnknownDerivedTypeHandling UnknownDerivedTypeHandling
                {
                    get
                    {
                        return _unknownDerivedTypeHandling;
                    }
                    set
                    {
                        VerifyMutable();
                        _unknownDerivedTypeHandling = value;
                    }
                }

                /// <summary>
                /// Gets or sets a custom type discriminator property name for the polymorhic type.
                /// Uses the default '$type' property name if left unset.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The parent <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance has been locked for further modification.
                /// </exception>
                public string TypeDiscriminatorPropertyName
                {
                    get
                    {
                        return _typeDiscriminatorPropertyName ?? "$type";
                    }
                    [param: System.Diagnostics.CodeAnalysis.AllowNull]
                    set
                    {
                        VerifyMutable();
                        _typeDiscriminatorPropertyName = value;
                    }
                }

                internal JsonTypeInfo? DeclaringTypeInfo { get; set; }

                private void VerifyMutable()
                {
                    DeclaringTypeInfo?.VerifyMutable();
                }

                internal static JsonPolymorphismOptions CreateFromAttributeDeclarations(Type baseType)
                {
                    JsonPolymorphismOptions jsonPolymorphismOptions = null;
                    JsonPolymorphicAttribute customAttribute = baseType.GetCustomAttribute<JsonPolymorphicAttribute>(inherit: false);
                    if (customAttribute != null)
                    {
                        jsonPolymorphismOptions = new JsonPolymorphismOptions
                        {
                            IgnoreUnrecognizedTypeDiscriminators = customAttribute.IgnoreUnrecognizedTypeDiscriminators,
                            UnknownDerivedTypeHandling = customAttribute.UnknownDerivedTypeHandling,
                            TypeDiscriminatorPropertyName = customAttribute.TypeDiscriminatorPropertyName
                        };
                    }
                    foreach (JsonDerivedTypeAttribute customAttribute2 in baseType.GetCustomAttributes<JsonDerivedTypeAttribute>(inherit: false))
                    {
                        (jsonPolymorphismOptions ?? (jsonPolymorphismOptions = new JsonPolymorphismOptions())).DerivedTypes.Add(new JsonDerivedType(customAttribute2.DerivedType, customAttribute2.TypeDiscriminator));
                    }
                    return jsonPolymorphismOptions;
                }
            }

            /// <summary>
            /// Provides JSON serialization-related metadata about a property or field defined in an object.
            /// </summary>
            [DebuggerDisplay("{DebuggerDisplay,nq}")]
            public abstract class JsonPropertyInfo
            {
                internal static readonly JsonPropertyInfo s_missingProperty = GetPropertyPlaceholder();

                private JsonTypeInfo _jsonTypeInfo;

                private protected JsonConverter _effectiveConverter;

                private JsonConverter _customConverter;

                private protected Func<object, object> _untypedGet;

                private protected Action<object, object> _untypedSet;

                private bool _isUserSpecifiedSetter;

                private protected Func<object, object, bool> _shouldSerialize;

                private bool _isUserSpecifiedShouldSerialize;

                private JsonIgnoreCondition? _ignoreCondition;

                private ICustomAttributeProvider _attributeProvider;

                private bool _isExtensionDataProperty;

                private bool _isRequired;

                private volatile bool _isConfigured;

                private string _name;

                private int _order;

                private JsonNumberHandling? _numberHandling;

                private int _index;

                internal JsonTypeInfo? ParentTypeInfo { get; private set; }

                internal ConverterStrategy ConverterStrategy { get; private protected set; }

                /// <summary>
                /// Converter after applying CustomConverter (i.e. JsonConverterAttribute)
                /// </summary>
                internal JsonConverter EffectiveConverter => _effectiveConverter;

                /// <summary>
                /// Gets or sets a custom converter override for the current property.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonPropertyInfo" /> instance has been locked for further modification.
                /// </exception>
                /// <remarks>
                /// It is possible to use <see cref="T:System.Text.Json.Serialization.JsonConverterFactory" /> instances with this property.
                ///
                /// For contracts originating from <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" />, the value of
                /// <see cref="P:System.Text.Json.Serialization.Metadata.JsonPropertyInfo.CustomConverter" /> will be mapped from <see cref="T:System.Text.Json.Serialization.JsonConverterAttribute" /> annotations.
                /// </remarks>
                public JsonConverter? CustomConverter
                {
                    get
                    {
                        return _customConverter;
                    }
                    set
                    {
                        VerifyMutable();
                        _customConverter = value;
                    }
                }

                /// <summary>
                /// Gets or sets a getter delegate for the property.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonPropertyInfo" /> instance has been locked for further modification.
                /// </exception>
                /// <remarks>
                /// Setting to <see langword="null" /> will result in the property being skipped on serialization.
                /// </remarks>
                public Func<object, object?>? Get
                {
                    get
                    {
                        return _untypedGet;
                    }
                    set
                    {
                        VerifyMutable();
                        SetGetter(value);
                    }
                }

                /// <summary>
                /// Gets or sets a setter delegate for the property.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonPropertyInfo" /> instance has been locked for further modification.
                /// </exception>
                /// <remarks>
                /// Setting to <see langword="null" /> will result in the property being skipped on deserialization.
                /// </remarks>
                public Action<object, object?>? Set
                {
                    get
                    {
                        return _untypedSet;
                    }
                    set
                    {
                        VerifyMutable();
                        SetSetter(value);
                        _isUserSpecifiedSetter = true;
                    }
                }

                /// <summary>
                /// Gets or sets a predicate deciding whether the current property value should be serialized.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonPropertyInfo" /> instance has been locked for further modification.
                /// </exception>
                /// <remarks>
                /// The first parameter denotes the parent object, the second parameter denotes the property value.
                ///
                /// Setting the predicate to <see langword="null" /> is equivalent to always serializing the property value.
                ///
                /// For contracts originating from <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" />,
                /// the value of <see cref="P:System.Text.Json.Serialization.JsonIgnoreAttribute.Condition" /> will map to this predicate.
                /// </remarks>
                public Func<object, object?, bool>? ShouldSerialize
                {
                    get
                    {
                        return _shouldSerialize;
                    }
                    set
                    {
                        VerifyMutable();
                        SetShouldSerialize(value);
                        _isUserSpecifiedShouldSerialize = true;
                        IgnoreDefaultValuesOnWrite = false;
                    }
                }

                internal JsonIgnoreCondition? IgnoreCondition
                {
                    get
                    {
                        return _ignoreCondition;
                    }
                    set
                    {
                        ConfigureIgnoreCondition(value);
                        _ignoreCondition = value;
                    }
                }

                /// <summary>
                /// Gets or sets a custom attribute provider for the current property.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonPropertyInfo" /> instance has been locked for further modification.
                /// </exception>
                /// <remarks>
                /// When resolving metadata via <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" /> this
                /// will be populated with the underlying <see cref="T:System.Reflection.MemberInfo" /> of the serialized property or field.
                ///
                /// Setting a custom attribute provider will have no impact on the contract model,
                /// but serves as metadata for downstream contract modifiers.
                /// </remarks>
                public ICustomAttributeProvider? AttributeProvider
                {
                    get
                    {
                        return _attributeProvider;
                    }
                    set
                    {
                        VerifyMutable();
                        _attributeProvider = value;
                    }
                }

                internal string? MemberName { get; private protected set; }

                internal MemberTypes MemberType { get; private protected set; }

                internal bool IsVirtual { get; private set; }

                /// <summary>
                /// Specifies whether the current property is a special extension data property.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonPropertyInfo" /> instance has been locked for further modification.
                ///
                /// -or-
                ///
                /// The current <see cref="P:System.Text.Json.Serialization.Metadata.JsonPropertyInfo.PropertyType" /> is not valid for use with extension data.
                /// </exception>
                /// <remarks>
                /// For contracts originating from <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" /> or <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" />,
                /// the value of this property will be mapped from <see cref="T:System.Text.Json.Serialization.JsonExtensionDataAttribute" /> annotations.
                /// </remarks>
                public bool IsExtensionData
                {
                    get
                    {
                        return _isExtensionDataProperty;
                    }
                    set
                    {
                        VerifyMutable();
                        if (value && !System.Text.Json.Serialization.Metadata.JsonTypeInfo.IsValidExtensionDataProperty(PropertyType))
                        {
                            ThrowHelper.ThrowInvalidOperationException_SerializationDataExtensionPropertyInvalid(this);
                        }
                        _isExtensionDataProperty = value;
                    }
                }

                /// <summary>
                /// Specifies whether the current property is required for deserialization to be successful.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonPropertyInfo" /> instance has been locked for further modification.
                /// </exception>
                /// <remarks>
                /// For contracts originating from <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" /> or <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" />,
                /// the value of this property will be mapped from <see cref="T:System.Text.Json.Serialization.JsonRequiredAttribute" /> annotations.
                ///
                /// For contracts using <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" />, properties using the <see langword="required" /> keyword
                /// will also map to this setting, unless deserialization uses a SetsRequiredMembersAttribute on a constructor that populates all required properties.
                /// <see langword="required" /> keyword is currently not supported in <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" /> contracts.
                /// </remarks>
                public bool IsRequired
                {
                    get
                    {
                        return _isRequired;
                    }
                    set
                    {
                        VerifyMutable();
                        _isRequired = value;
                    }
                }

                /// <summary>
                /// Gets the type of the current property.
                /// </summary>
                public Type PropertyType { get; }

                internal bool IsConfigured => _isConfigured;

                internal bool HasGetter => _untypedGet != null;

                internal bool HasSetter => _untypedSet != null;

                internal bool IgnoreNullTokensOnRead { get; private protected set; }

                internal bool IgnoreDefaultValuesOnWrite { get; private protected set; }

                internal bool IgnoreReadOnlyMember => MemberType switch
                {
                    MemberTypes.Property => Options.IgnoreReadOnlyProperties,
                    MemberTypes.Field => Options.IgnoreReadOnlyFields,
                    _ => false,
                };

                /// <summary>
                /// True if the corresponding cref="JsonTypeInfo.PropertyInfoForTypeInfo"/&gt; is this instance.
                /// </summary>
                internal bool IsForTypeInfo { get; set; }

                /// <summary>
                /// Gets or sets the JSON property name used when serializing the property.
                /// </summary>
                /// <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is null.</exception>
                /// <exception cref="T:System.InvalidOperationException">
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonPropertyInfo" /> instance has been locked for further modification.
                /// </exception>
                /// <remarks>
                /// The value of <see cref="P:System.Text.Json.Serialization.Metadata.JsonPropertyInfo.Name" /> cannot conflict with that of other <see cref="T:System.Text.Json.Serialization.Metadata.JsonPropertyInfo" /> defined in the declaring <see cref="P:System.Text.Json.Serialization.Metadata.JsonPropertyInfo.JsonTypeInfo" />.
                ///
                /// For contracts originating from <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" /> or <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" />,
                /// the value typically reflects the underlying .NET member name, the name derived from <see cref="P:System.Text.Json.JsonSerializerOptions.PropertyNamingPolicy" />,
                /// or the value specified in <see cref="T:System.Text.Json.Serialization.JsonPropertyNameAttribute" />.
                /// </remarks>
                public string Name
                {
                    get
                    {
                        return _name;
                    }
                    set
                    {
                        VerifyMutable();
                        if (value == null)
                        {
                            ThrowHelper.ThrowArgumentNullException("value");
                        }
                        _name = value;
                    }
                }

                /// <summary>
                /// Utf8 version of Name.
                /// </summary>
                internal byte[] NameAsUtf8Bytes { get; set; }

                /// <summary>
                /// The escaped name passed to the writer.
                /// </summary>
                internal byte[] EscapedNameSection { get; set; }

                /// <summary>
                /// Gets the <see cref="T:System.Text.Json.JsonSerializerOptions" /> value associated with the current contract instance.
                /// </summary>
                public JsonSerializerOptions Options { get; }

                /// <summary>
                /// Gets or sets the serialization order for the current property.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonPropertyInfo" /> instance has been locked for further modification.
                /// </exception>
                /// <remarks>
                /// For contracts originating from <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" /> or <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" />,
                /// the value of this property will be mapped from <see cref="T:System.Text.Json.Serialization.JsonPropertyOrderAttribute" /> annotations.
                /// </remarks>
                public int Order
                {
                    get
                    {
                        return _order;
                    }
                    set
                    {
                        VerifyMutable();
                        _order = value;
                    }
                }

                internal Type DeclaringType { get; }

                internal JsonTypeInfo JsonTypeInfo
                {
                    get
                    {
                        _jsonTypeInfo.EnsureConfigured();
                        return _jsonTypeInfo;
                    }
                    [param: System.Diagnostics.CodeAnalysis.AllowNull]
                    set
                    {
                        ConverterStrategy = value?.Converter.ConverterStrategy ?? ConverterStrategy.None;
                        _jsonTypeInfo = value;
                    }
                }

                internal bool IsIgnored => _ignoreCondition == JsonIgnoreCondition.Always;

                /// <summary>
                /// Reflects the value of <see cref="P:System.Text.Json.Serialization.Metadata.JsonPropertyInfo.HasGetter" /> combined with any additional global ignore policies.
                /// </summary>
                internal bool CanSerialize { get; private set; }

                /// <summary>
                /// Reflects the value of <see cref="P:System.Text.Json.Serialization.Metadata.JsonPropertyInfo.HasSetter" /> combined with any additional global ignore policies.
                /// </summary>
                internal bool CanDeserialize { get; private set; }

                /// <summary>
                /// Relevant to source generated metadata: did the property have the <see cref="T:System.Text.Json.Serialization.JsonIncludeAttribute" />?
                /// </summary>
                internal bool SrcGen_HasJsonInclude { get; set; }

                /// <summary>
                /// Relevant to source generated metadata: is the property public?
                /// </summary>
                internal bool SrcGen_IsPublic { get; set; }

                /// <summary>
                /// Number handling for declaring type
                /// </summary>
                internal JsonNumberHandling? DeclaringTypeNumberHandling { get; set; }

                /// <summary>
                /// Gets or sets the <see cref="T:System.Text.Json.Serialization.JsonNumberHandling" /> applied to the current property.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonPropertyInfo" /> instance has been locked for further modification.
                /// </exception>
                /// <remarks>
                /// For contracts originating from <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" /> or <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" />,
                /// the value of this property will be mapped from <see cref="T:System.Text.Json.Serialization.JsonNumberHandlingAttribute" /> annotations.
                /// </remarks>
                public JsonNumberHandling? NumberHandling
                {
                    get
                    {
                        return _numberHandling;
                    }
                    set
                    {
                        VerifyMutable();
                        _numberHandling = value;
                    }
                }

                /// <summary>
                /// Number handling after considering options and declaring type number handling
                /// </summary>
                internal JsonNumberHandling? EffectiveNumberHandling { get; set; }

                internal abstract bool PropertyTypeCanBeNull { get; }

                /// <summary>
                /// Default value used for parameterized ctor invocation.
                /// </summary>
                internal abstract object? DefaultValue { get; }

                /// <summary>
                /// Required property index on the list of JsonTypeInfo properties.
                /// It is used as a unique identifier for required properties.
                /// It is set just before property is configured and does not change afterward.
                /// It is not equivalent to index on the properties list
                /// </summary>
                internal int RequiredPropertyIndex
                {
                    get
                    {
                        return _index;
                    }
                    set
                    {
                        _index = value;
                    }
                }

                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private string DebuggerDisplay => $"PropertyType = {PropertyType}, Name = {Name}, DeclaringType = {DeclaringType}";

                private protected abstract void SetGetter(Delegate getter);

                private protected abstract void SetSetter(Delegate setter);

                private protected abstract void SetShouldSerialize(Delegate predicate);

                private protected abstract void ConfigureIgnoreCondition(JsonIgnoreCondition? ignoreCondition);

                internal JsonPropertyInfo(Type declaringType, Type propertyType, JsonTypeInfo declaringTypeInfo, JsonSerializerOptions options)
                {
                    DeclaringType = declaringType;
                    PropertyType = propertyType;
                    ParentTypeInfo = declaringTypeInfo;
                    Options = options;
                }

                internal static JsonPropertyInfo GetPropertyPlaceholder()
                {
                    JsonPropertyInfo jsonPropertyInfo = new JsonPropertyInfo<object>(typeof(object), null, null);
                    jsonPropertyInfo.Name = string.Empty;
                    return jsonPropertyInfo;
                }

                private protected void VerifyMutable()
                {
                    JsonTypeInfo? parentTypeInfo = ParentTypeInfo;
                    if (parentTypeInfo != null && parentTypeInfo.IsReadOnly)
                    {
                        ThrowHelper.ThrowInvalidOperationException_PropertyInfoImmutable();
                    }
                }

                internal void EnsureConfigured()
                {
                    if (!_isConfigured)
                    {
                        Configure();
                        _isConfigured = true;
                    }
                }

                internal void Configure()
                {
                    DeclaringTypeNumberHandling = ParentTypeInfo.NumberHandling;
                    if (!IsForTypeInfo)
                    {
                        CacheNameAsUtf8BytesAndEscapedNameSection();
                    }
                    if (_jsonTypeInfo == null)
                    {
                        _jsonTypeInfo = Options.GetTypeInfoInternal(PropertyType, ensureConfigured: false);
                    }
                    DetermineEffectiveConverter(_jsonTypeInfo);
                    if (IsForTypeInfo)
                    {
                        DetermineNumberHandlingForTypeInfo();
                    }
                    else
                    {
                        DetermineNumberHandlingForProperty();
                        DetermineIgnoreCondition();
                        DetermineSerializationCapabilities();
                    }
                    if (IsRequired)
                    {
                        if (!CanDeserialize)
                        {
                            ThrowHelper.ThrowInvalidOperationException_JsonPropertyRequiredAndNotDeserializable(this);
                        }
                        if (IsExtensionData)
                        {
                            ThrowHelper.ThrowInvalidOperationException_JsonPropertyRequiredAndExtensionData(this);
                        }
                    }
                }

                private protected abstract void DetermineEffectiveConverter(JsonTypeInfo jsonTypeInfo);

                private protected abstract void DetermineMemberAccessors(MemberInfo memberInfo);

                private void DeterminePoliciesFromMember(MemberInfo memberInfo)
                {
                    Order = memberInfo.GetCustomAttribute<JsonPropertyOrderAttribute>(inherit: false)?.Order ?? 0;
                    NumberHandling = memberInfo.GetCustomAttribute<JsonNumberHandlingAttribute>(inherit: false)?.Handling;
                }

                private void DeterminePropertyNameFromMember(MemberInfo memberInfo)
                {
                    JsonPropertyNameAttribute customAttribute = memberInfo.GetCustomAttribute<JsonPropertyNameAttribute>(inherit: false);
                    string text = ((customAttribute != null) ? customAttribute.Name : ((Options.PropertyNamingPolicy == null) ? memberInfo.Name : Options.PropertyNamingPolicy.ConvertName(memberInfo.Name)));
                    if (text == null)
                    {
                        ThrowHelper.ThrowInvalidOperationException_SerializerPropertyNameNull(this);
                    }
                    Name = text;
                }

                private void CacheNameAsUtf8BytesAndEscapedNameSection()
                {
                    NameAsUtf8Bytes = Encoding.UTF8.GetBytes(Name);
                    EscapedNameSection = JsonHelpers.GetEscapedPropertyNameSection(NameAsUtf8Bytes, Options.Encoder);
                }

                private void DetermineIgnoreCondition()
                {
                    if (_ignoreCondition.HasValue)
                    {
                        return;
                    }
                    if (Options.IgnoreNullValues)
                    {
                        if (PropertyTypeCanBeNull)
                        {
                            IgnoreNullTokensOnRead = !_isUserSpecifiedSetter && !IsRequired;
                            IgnoreDefaultValuesOnWrite = ShouldSerialize == null;
                        }
                    }
                    else if (Options.DefaultIgnoreCondition == JsonIgnoreCondition.WhenWritingNull)
                    {
                        if (PropertyTypeCanBeNull)
                        {
                            IgnoreDefaultValuesOnWrite = ShouldSerialize == null;
                        }
                    }
                    else if (Options.DefaultIgnoreCondition == JsonIgnoreCondition.WhenWritingDefault)
                    {
                        IgnoreDefaultValuesOnWrite = ShouldSerialize == null;
                    }
                }

                private void DetermineSerializationCapabilities()
                {
                    CanSerialize = HasGetter;
                    CanDeserialize = HasSetter;
                    if (MemberType == (MemberTypes)0 || _ignoreCondition.HasValue)
                    {
                        return;
                    }
                    if ((ConverterStrategy & (ConverterStrategy)24) != 0)
                    {
                        if (Get == null && Set != null && !_isUserSpecifiedSetter)
                        {
                            CanDeserialize = false;
                        }
                    }
                    else if (Get != null && Set == null && IgnoreReadOnlyMember && !_isUserSpecifiedShouldSerialize)
                    {
                        CanSerialize = false;
                    }
                }

                private void DetermineNumberHandlingForTypeInfo()
                {
                    if (DeclaringTypeNumberHandling.HasValue && DeclaringTypeNumberHandling != JsonNumberHandling.Strict && !EffectiveConverter.IsInternalConverter)
                    {
                        ThrowHelper.ThrowInvalidOperationException_NumberHandlingOnPropertyInvalid(this);
                    }
                    if (NumberHandingIsApplicable())
                    {
                        EffectiveNumberHandling = DeclaringTypeNumberHandling;
                        if (!EffectiveNumberHandling.HasValue && Options.NumberHandling != 0)
                        {
                            EffectiveNumberHandling = Options.NumberHandling;
                        }
                    }
                }

                private void DetermineNumberHandlingForProperty()
                {
                    if (NumberHandingIsApplicable())
                    {
                        JsonNumberHandling? effectiveNumberHandling = NumberHandling ?? DeclaringTypeNumberHandling ?? _jsonTypeInfo.NumberHandling;
                        if (!effectiveNumberHandling.HasValue && Options.NumberHandling != 0)
                        {
                            effectiveNumberHandling = Options.NumberHandling;
                        }
                        EffectiveNumberHandling = effectiveNumberHandling;
                    }
                    else if (NumberHandling.HasValue && NumberHandling != JsonNumberHandling.Strict)
                    {
                        ThrowHelper.ThrowInvalidOperationException_NumberHandlingOnPropertyInvalid(this);
                    }
                }

                private bool NumberHandingIsApplicable()
                {
                    if (EffectiveConverter.IsInternalConverterForNumberType)
                    {
                        return true;
                    }
                    Type type = ((EffectiveConverter.IsInternalConverter && ((ConverterStrategy)24 & ConverterStrategy) != 0) ? EffectiveConverter.ElementType : PropertyType);
                    type = Nullable.GetUnderlyingType(type) ?? type;
                    if (!(type == typeof(byte)) && !(type == typeof(decimal)) && !(type == typeof(double)) && !(type == typeof(short)) && !(type == typeof(int)) && !(type == typeof(long)) && !(type == typeof(sbyte)) && !(type == typeof(float)) && !(type == typeof(ushort)) && !(type == typeof(uint)) && !(type == typeof(ulong)))
                    {
                        return type == System.Text.Json.Serialization.Metadata.JsonTypeInfo.ObjectType;
                    }
                    return true;
                }

                private void DetermineIsRequired(MemberInfo memberInfo, bool shouldCheckForRequiredKeyword)
                {
                    IsRequired = memberInfo.GetCustomAttribute<JsonRequiredAttribute>(inherit: false) != null || (shouldCheckForRequiredKeyword && memberInfo.HasRequiredMemberAttribute());
                }

                internal abstract bool GetMemberAndWriteJson(object obj, ref WriteStack state, Utf8JsonWriter writer);

                internal abstract bool GetMemberAndWriteJsonExtensionData(object obj, ref WriteStack state, Utf8JsonWriter writer);

                internal abstract object GetValueAsObject(object obj);

                internal void InitializeUsingMemberReflection(MemberInfo memberInfo, JsonConverter customConverter, JsonIgnoreCondition? ignoreCondition, bool shouldCheckForRequiredKeyword)
                {
                    ICustomAttributeProvider customAttributeProvider2 = (AttributeProvider = memberInfo);
                    ICustomAttributeProvider customAttributeProvider3 = customAttributeProvider2;
                    if (!(customAttributeProvider3 is PropertyInfo propertyInfo))
                    {
                        if (customAttributeProvider3 is FieldInfo fieldInfo)
                        {
                            MemberName = fieldInfo.Name;
                            MemberType = MemberTypes.Field;
                        }
                    }
                    else
                    {
                        MemberName = propertyInfo.Name;
                        IsVirtual = propertyInfo.IsVirtual();
                        MemberType = MemberTypes.Property;
                    }
                    CustomConverter = customConverter;
                    DeterminePoliciesFromMember(memberInfo);
                    DeterminePropertyNameFromMember(memberInfo);
                    DetermineIsRequired(memberInfo, shouldCheckForRequiredKeyword);
                    if (ignoreCondition != JsonIgnoreCondition.Always)
                    {
                        DetermineMemberAccessors(memberInfo);
                    }
                    IgnoreCondition = ignoreCondition;
                    IsExtensionData = memberInfo.GetCustomAttribute<JsonExtensionDataAttribute>(inherit: false) != null;
                }

                internal bool ReadJsonAndAddExtensionProperty(object obj, scoped ref ReadStack state, ref Utf8JsonReader reader)
                {
                    object valueAsObject = GetValueAsObject(obj);
                    if (valueAsObject is IDictionary<string, object> dictionary)
                    {
                        if (reader.TokenType == JsonTokenType.Null)
                        {
                            dictionary[state.Current.JsonPropertyNameAsString] = null;
                        }
                        else
                        {
                            JsonConverter<object> jsonConverter = GetDictionaryValueConverter<object>();
                            object value = jsonConverter.Read(ref reader, System.Text.Json.Serialization.Metadata.JsonTypeInfo.ObjectType, Options);
                            dictionary[state.Current.JsonPropertyNameAsString] = value;
                        }
                    }
                    else if (valueAsObject is IDictionary<string, JsonElement> dictionary2)
                    {
                        JsonConverter<JsonElement> jsonConverter2 = GetDictionaryValueConverter<JsonElement>();
                        JsonElement value2 = jsonConverter2.Read(ref reader, typeof(JsonElement), Options);
                        dictionary2[state.Current.JsonPropertyNameAsString] = value2;
                    }
                    else
                    {
                        EffectiveConverter.ReadElementAndSetProperty(valueAsObject, state.Current.JsonPropertyNameAsString, ref reader, Options, ref state);
                    }
                    return true;
                    JsonConverter<TValue> GetDictionaryValueConverter<TValue>()
                    {
                        JsonTypeInfo jsonTypeInfo = JsonTypeInfo.ElementTypeInfo ?? Options.GetTypeInfoInternal(typeof(TValue));
                        return ((JsonTypeInfo<TValue>)jsonTypeInfo).EffectiveConverter;
                    }
                }

                internal abstract bool ReadJsonAndSetMember(object obj, scoped ref ReadStack state, ref Utf8JsonReader reader);

                internal abstract bool ReadJsonAsObject(scoped ref ReadStack state, ref Utf8JsonReader reader, out object value);

                internal bool ReadJsonExtensionDataValue(scoped ref ReadStack state, ref Utf8JsonReader reader, out object value)
                {
                    if (JsonTypeInfo.ElementType == System.Text.Json.Serialization.Metadata.JsonTypeInfo.ObjectType && reader.TokenType == JsonTokenType.Null)
                    {
                        value = null;
                        return true;
                    }
                    JsonConverter<JsonElement> jsonConverter = (JsonConverter<JsonElement>)Options.GetConverterInternal(typeof(JsonElement));
                    if (!jsonConverter.TryRead(ref reader, typeof(JsonElement), Options, ref state, out var value2))
                    {
                        value = null;
                        return false;
                    }
                    value = value2;
                    return true;
                }

                internal void EnsureChildOf(JsonTypeInfo parent)
                {
                    if (ParentTypeInfo == null)
                    {
                        ParentTypeInfo = parent;
                    }
                    else if (ParentTypeInfo != parent)
                    {
                        ThrowHelper.ThrowInvalidOperationException_JsonPropertyInfoIsBoundToDifferentJsonTypeInfo(this);
                    }
                }
            }

            /// <summary>
            /// Represents a strongly-typed property to prevent boxing and to create a direct delegate to the getter\setter.
            /// </summary>
            /// <typeparamref name="T" /> is the <see cref="P:System.Text.Json.Serialization.JsonConverter`1.TypeToConvert" /> for either the property's converter,
            /// or a type's converter, if the current instance is a <see cref="P:System.Text.Json.Serialization.Metadata.JsonTypeInfo.PropertyInfoForTypeInfo" />.
            internal sealed class JsonPropertyInfo<T> : JsonPropertyInfo
            {
                private Func<object, T> _typedGet;

                private Action<object, T> _typedSet;

                private Func<object, T, bool> _shouldSerializeTyped;

                private JsonConverter<T> _typedEffectiveConverter;

                internal new Func<object, T> Get
                {
                    get
                    {
                        return _typedGet;
                    }
                    set
                    {
                        SetGetter(value);
                    }
                }

                internal new Action<object, T> Set
                {
                    get
                    {
                        return _typedSet;
                    }
                    set
                    {
                        SetSetter(value);
                    }
                }

                internal new Func<object, T, bool> ShouldSerialize
                {
                    get
                    {
                        return _shouldSerializeTyped;
                    }
                    set
                    {
                        SetShouldSerialize(value);
                    }
                }

                internal override object DefaultValue => default(T);

                internal override bool PropertyTypeCanBeNull => default(T) == null;

                internal new JsonConverter<T> EffectiveConverter => _typedEffectiveConverter;

                internal JsonPropertyInfo(Type declaringType, JsonTypeInfo declaringTypeInfo, JsonSerializerOptions options)
                    : base(declaringType, typeof(T), declaringTypeInfo, options)
                {
                }

                private protected override void SetGetter(Delegate getter)
                {
                    if ((object)getter == null)
                    {
                        _typedGet = null;
                        _untypedGet = null;
                        return;
                    }
                    Func<object, T> typedGetter = getter as Func<object, T>;
                    if (typedGetter != null)
                    {
                        _typedGet = typedGetter;
                        _untypedGet = ((getter is Func<object, object> func) ? func : ((Func<object, object>)((object obj) => typedGetter(obj))));
                        return;
                    }
                    Func<object, object> untypedGet = (Func<object, object>)getter;
                    _typedGet = (object obj) => (T)untypedGet(obj);
                    _untypedGet = untypedGet;
                }

                private protected override void SetSetter(Delegate setter)
                {
                    if ((object)setter == null)
                    {
                        _typedSet = null;
                        _untypedSet = null;
                        return;
                    }
                    Action<object, T> typedSetter = setter as Action<object, T>;
                    if (typedSetter != null)
                    {
                        _typedSet = typedSetter;
                        _untypedSet = ((setter is Action<object, object> action) ? action : ((Action<object, object>)delegate (object obj, object value)
                        {
                            typedSetter(obj, (T)value);
                        }));
                        return;
                    }
                    Action<object, object> untypedSet = (Action<object, object>)setter;
                    _typedSet = delegate (object obj, T value)
                    {
                        untypedSet(obj, value);
                    };
                    _untypedSet = untypedSet;
                }

                private protected override void SetShouldSerialize(Delegate predicate)
                {
                    if ((object)predicate == null)
                    {
                        _shouldSerializeTyped = null;
                        _shouldSerialize = null;
                        return;
                    }
                    Func<object, T, bool> typedPredicate = predicate as Func<object, T, bool>;
                    if (typedPredicate != null)
                    {
                        _shouldSerializeTyped = typedPredicate;
                        _shouldSerialize = ((typedPredicate is Func<object, object, bool> func) ? func : ((Func<object, object, bool>)((object obj, object value) => typedPredicate(obj, (T)value))));
                        return;
                    }
                    Func<object, object, bool> untypedPredicate = (Func<object, object, bool>)predicate;
                    _shouldSerializeTyped = (object obj, T value) => untypedPredicate(obj, value);
                    _shouldSerialize = untypedPredicate;
                }

                private protected override void DetermineMemberAccessors(MemberInfo memberInfo)
                {
                    if (!(memberInfo is PropertyInfo propertyInfo))
                    {
                        if (memberInfo is FieldInfo fieldInfo)
                        {
                            Get = base.Options.MemberAccessorStrategy.CreateFieldGetter<T>(fieldInfo);
                            if (!fieldInfo.IsInitOnly)
                            {
                                Set = base.Options.MemberAccessorStrategy.CreateFieldSetter<T>(fieldInfo);
                            }
                        }
                        return;
                    }
                    bool flag = propertyInfo.GetCustomAttribute<JsonIncludeAttribute>(inherit: false) != null;
                    MethodInfo getMethod = propertyInfo.GetMethod;
                    if (getMethod != null && (getMethod.IsPublic || flag))
                    {
                        Get = base.Options.MemberAccessorStrategy.CreatePropertyGetter<T>(propertyInfo);
                    }
                    MethodInfo setMethod = propertyInfo.SetMethod;
                    if (setMethod != null && (setMethod.IsPublic || flag))
                    {
                        Set = base.Options.MemberAccessorStrategy.CreatePropertySetter<T>(propertyInfo);
                    }
                }

                internal JsonPropertyInfo(JsonPropertyInfoValues<T> propertyInfo, JsonSerializerOptions options)
                    : this(propertyInfo.DeclaringType, (JsonTypeInfo)null, options)
                {
                    string text = ((propertyInfo.JsonPropertyName != null) ? propertyInfo.JsonPropertyName : ((options.PropertyNamingPolicy != null) ? options.PropertyNamingPolicy.ConvertName(propertyInfo.PropertyName) : propertyInfo.PropertyName));
                    if (text == null)
                    {
                        ThrowHelper.ThrowInvalidOperationException_SerializerPropertyNameNull(this);
                    }
                    base.Name = text;
                    base.MemberName = propertyInfo.PropertyName;
                    base.MemberType = (propertyInfo.IsProperty ? MemberTypes.Property : MemberTypes.Field);
                    base.SrcGen_IsPublic = propertyInfo.IsPublic;
                    base.SrcGen_HasJsonInclude = propertyInfo.HasJsonInclude;
                    base.IsExtensionData = propertyInfo.IsExtensionData;
                    base.CustomConverter = propertyInfo.Converter;
                    if (propertyInfo.IgnoreCondition != JsonIgnoreCondition.Always)
                    {
                        Get = propertyInfo.Getter;
                        Set = propertyInfo.Setter;
                    }
                    base.IgnoreCondition = propertyInfo.IgnoreCondition;
                    base.JsonTypeInfo = propertyInfo.PropertyTypeInfo;
                    base.NumberHandling = propertyInfo.NumberHandling;
                }

                private protected override void DetermineEffectiveConverter(JsonTypeInfo jsonTypeInfo)
                {
                    base.ConverterStrategy = (_typedEffectiveConverter = (JsonConverter<T>)(_effectiveConverter = base.Options.ExpandConverterFactory(base.CustomConverter, base.PropertyType)?.CreateCastingConverter<T>() ?? ((JsonTypeInfo<T>)jsonTypeInfo).EffectiveConverter)).ConverterStrategy;
                }

                internal override object GetValueAsObject(object obj)
                {
                    if (base.IsForTypeInfo)
                    {
                        return obj;
                    }
                    return Get(obj);
                }

                internal override bool GetMemberAndWriteJson(object obj, ref WriteStack state, Utf8JsonWriter writer)
                {
                    T value = Get(obj);
                    if (!EffectiveConverter.IsValueType && base.Options.ReferenceHandlingStrategy == ReferenceHandlingStrategy.IgnoreCycles && value != null && !state.IsContinuation && base.ConverterStrategy != ConverterStrategy.Value && state.ReferenceResolver.ContainsReferenceForCycleDetection(value))
                    {
                        value = default(T);
                    }
                    if (base.IgnoreDefaultValuesOnWrite)
                    {
                        if (IsDefaultValue(value))
                        {
                            return true;
                        }
                    }
                    else
                    {
                        Func<object, T, bool> shouldSerialize = ShouldSerialize;
                        if (shouldSerialize != null && !shouldSerialize(obj, value))
                        {
                            return true;
                        }
                    }
                    if (value == null)
                    {
                        if (EffectiveConverter.HandleNullOnWrite)
                        {
                            if ((int)state.Current.PropertyState < 2)
                            {
                                state.Current.PropertyState = StackFramePropertyState.Name;
                                writer.WritePropertyNameSection(base.EscapedNameSection);
                            }
                            int currentDepth = writer.CurrentDepth;
                            EffectiveConverter.Write(writer, value, base.Options);
                            if (currentDepth != writer.CurrentDepth)
                            {
                                ThrowHelper.ThrowJsonException_SerializationConverterWrite(EffectiveConverter);
                            }
                        }
                        else
                        {
                            writer.WriteNullSection(base.EscapedNameSection);
                        }
                        return true;
                    }
                    if ((int)state.Current.PropertyState < 2)
                    {
                        state.Current.PropertyState = StackFramePropertyState.Name;
                        writer.WritePropertyNameSection(base.EscapedNameSection);
                    }
                    return EffectiveConverter.TryWrite(writer, in value, base.Options, ref state);
                }

                internal override bool GetMemberAndWriteJsonExtensionData(object obj, ref WriteStack state, Utf8JsonWriter writer)
                {
                    T val = Get(obj);
                    Func<object, T, bool> shouldSerialize = ShouldSerialize;
                    if (shouldSerialize != null && !shouldSerialize(obj, val))
                    {
                        return true;
                    }
                    if (val == null)
                    {
                        return true;
                    }
                    return EffectiveConverter.TryWriteDataExtensionProperty(writer, val, base.Options, ref state);
                }

                internal override bool ReadJsonAndSetMember(object obj, scoped ref ReadStack state, ref Utf8JsonReader reader)
                {
                    bool flag = reader.TokenType == JsonTokenType.Null;
                    bool flag2;
                    if (flag && !EffectiveConverter.HandleNullOnRead && !state.IsContinuation)
                    {
                        if (default(T) != null)
                        {
                            ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(EffectiveConverter.TypeToConvert);
                        }
                        if (!base.IgnoreNullTokensOnRead)
                        {
                            Set(obj, default(T));
                        }
                        flag2 = true;
                        state.Current.MarkRequiredPropertyAsRead(this);
                    }
                    else if (EffectiveConverter.CanUseDirectReadOrWrite && !state.Current.NumberHandling.HasValue)
                    {
                        if (!flag || !base.IgnoreNullTokensOnRead || default(T) != null)
                        {
                            T arg = EffectiveConverter.Read(ref reader, base.PropertyType, base.Options);
                            Set(obj, arg);
                        }
                        flag2 = true;
                        state.Current.MarkRequiredPropertyAsRead(this);
                    }
                    else
                    {
                        flag2 = true;
                        if (!flag || !base.IgnoreNullTokensOnRead || default(T) != null || state.IsContinuation)
                        {
                            flag2 = EffectiveConverter.TryRead(ref reader, base.PropertyType, base.Options, ref state, out var value);
                            if (flag2)
                            {
                                Set(obj, value);
                                state.Current.MarkRequiredPropertyAsRead(this);
                            }
                        }
                    }
                    return flag2;
                }

                internal override bool ReadJsonAsObject(scoped ref ReadStack state, ref Utf8JsonReader reader, out object value)
                {
                    bool result;
                    if (reader.TokenType == JsonTokenType.Null && !EffectiveConverter.HandleNullOnRead && !state.IsContinuation)
                    {
                        if (default(T) != null)
                        {
                            ThrowHelper.ThrowJsonException_DeserializeUnableToConvertValue(EffectiveConverter.TypeToConvert);
                        }
                        value = default(T);
                        result = true;
                    }
                    else if (EffectiveConverter.CanUseDirectReadOrWrite && !state.Current.NumberHandling.HasValue)
                    {
                        value = EffectiveConverter.Read(ref reader, base.PropertyType, base.Options);
                        result = true;
                    }
                    else
                    {
                        result = EffectiveConverter.TryRead(ref reader, base.PropertyType, base.Options, ref state, out var value2);
                        value = value2;
                    }
                    return result;
                }

                private protected override void ConfigureIgnoreCondition(JsonIgnoreCondition? ignoreCondition)
                {
                    if (!ignoreCondition.HasValue)
                    {
                        return;
                    }
                    switch (ignoreCondition.GetValueOrDefault())
                    {
                        case JsonIgnoreCondition.Never:
                            ShouldSerialize = ShouldSerializeIgnoreConditionNever;
                            break;
                        case JsonIgnoreCondition.Always:
                            ShouldSerialize = ShouldSerializeIgnoreConditionAlways;
                            break;
                        case JsonIgnoreCondition.WhenWritingNull:
                            if (PropertyTypeCanBeNull)
                            {
                                ShouldSerialize = ShouldSerializeIgnoreWhenWritingDefault;
                                base.IgnoreDefaultValuesOnWrite = true;
                            }
                            else
                            {
                                ThrowHelper.ThrowInvalidOperationException_IgnoreConditionOnValueTypeInvalid(base.MemberName, base.DeclaringType);
                            }
                            break;
                        case JsonIgnoreCondition.WhenWritingDefault:
                            ShouldSerialize = ShouldSerializeIgnoreWhenWritingDefault;
                            base.IgnoreDefaultValuesOnWrite = true;
                            break;
                    }
                    static bool ShouldSerializeIgnoreConditionAlways(object _, T value)
                    {
                        return false;
                    }
                    static bool ShouldSerializeIgnoreConditionNever(object _, T value)
                    {
                        return true;
                    }
                    static bool ShouldSerializeIgnoreWhenWritingDefault(object _, T value)
                    {
                        if (default(T) != null)
                        {
                            return !EqualityComparer<T>.Default.Equals(default(T), value);
                        }
                        return value != null;
                    }
                }

                private static bool IsDefaultValue(T value)
                {
                    if (default(T) != null)
                    {
                        return EqualityComparer<T>.Default.Equals(default(T), value);
                    }
                    return value == null;
                }
            }

            /// <summary>
            /// Provides serialization metadata about a property or field.
            /// </summary>
            /// <typeparam name="T">The type to convert of the <see cref="T:System.Text.Json.Serialization.JsonConverter`1" /> for the property.</typeparam>
            [EditorBrowsable(EditorBrowsableState.Never)]
            public sealed class JsonPropertyInfoValues<T>
            {
                /// <summary>
                /// If <see langword="true" />, indicates that the member is a property, otherwise indicates the member is a field.
                /// </summary>
                public bool IsProperty { get; init; }

                /// <summary>
                /// Whether the property or field is public.
                /// </summary>
                public bool IsPublic { get; init; }

                /// <summary>
                /// Whether the property or field is a virtual property.
                /// </summary>
                public bool IsVirtual { get; init; }

                /// <summary>
                /// The declaring type of the property or field.
                /// </summary>
                public Type DeclaringType { get; init; }

                /// <summary>
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> info for the property or field's type.
                /// </summary>
                public JsonTypeInfo PropertyTypeInfo { get; init; }

                /// <summary>
                /// A <see cref="T:System.Text.Json.Serialization.JsonConverter" /> for the property or field, specified by <see cref="T:System.Text.Json.Serialization.JsonConverterAttribute" />.
                /// </summary>
                public JsonConverter<T>? Converter { get; init; }

                /// <summary>
                /// Provides a mechanism to get the property or field's value.
                /// </summary>
                public Func<object, T?>? Getter { get; init; }

                /// <summary>
                /// Provides a mechanism to set the property or field's value.
                /// </summary>
                public Action<object, T?>? Setter { get; init; }

                /// <summary>
                /// Specifies a condition for the member to be ignored.
                /// </summary>
                public JsonIgnoreCondition? IgnoreCondition { get; init; }

                /// <summary>
                /// Whether the property was annotated with <see cref="T:System.Text.Json.Serialization.JsonIncludeAttribute" />.
                /// </summary>
                public bool HasJsonInclude { get; init; }

                /// <summary>
                /// Whether the property was annotated with <see cref="T:System.Text.Json.Serialization.JsonExtensionDataAttribute" />.
                /// </summary>
                public bool IsExtensionData { get; init; }

                /// <summary>
                /// If the property or field is a number, specifies how it should processed when serializing and deserializing.
                /// </summary>
                public JsonNumberHandling? NumberHandling { get; init; }

                /// <summary>
                /// The name of the property or field.
                /// </summary>
                public string PropertyName { get; init; }

                /// <summary>
                /// The name to be used when processing the property or field, specified by <see cref="T:System.Text.Json.Serialization.JsonPropertyNameAttribute" />.
                /// </summary>
                public string? JsonPropertyName { get; init; }
            }

            /// <summary>
            /// Provides JSON serialization-related metadata about a type.
            /// </summary>
            /// <typeparam name="T">The generic definition of the type.</typeparam>
            public abstract class JsonTypeInfo<T> : JsonTypeInfo
            {
                private Action<Utf8JsonWriter, T> _serialize;

                private Func<T> _typedCreateObject;

                /// <summary>
                /// A Converter whose declared type always matches that of the current JsonTypeInfo.
                /// It might be the same instance as JsonTypeInfo.Converter or it could be wrapped
                /// in a CastingConverter in cases where a polymorphic converter is being used.
                /// </summary>
                internal JsonConverter<T> EffectiveConverter { get; }

                /// <summary>
                /// Gets or sets a parameterless factory to be used on deserialization.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance has been locked for further modification.
                ///
                /// -or-
                ///
                /// A parameterless factory is not supported for the current metadata <see cref="P:System.Text.Json.Serialization.Metadata.JsonTypeInfo.Kind" />.
                /// </exception>
                /// <remarks>
                /// If set to <see langword="null" />, any attempt to deserialize instances of the given type will fail at runtime.
                ///
                /// For contracts originating from <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" /> or <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" />,
                /// types with a single default constructor or default constructors annotated with <see cref="T:System.Text.Json.Serialization.JsonConstructorAttribute" />
                /// will be mapped to this delegate.
                /// </remarks>
                public new Func<T>? CreateObject
                {
                    get
                    {
                        return _typedCreateObject;
                    }
                    set
                    {
                        SetCreateObject(value);
                    }
                }

                /// <summary>
                /// Serializes an instance of <typeparamref name="T" /> using
                /// <see cref="T:System.Text.Json.Serialization.JsonSourceGenerationOptionsAttribute" /> values specified at design time.
                /// </summary>
                /// <remarks>The writer is not flushed after writing.</remarks>
                [EditorBrowsable(EditorBrowsableState.Never)]
                public Action<Utf8JsonWriter, T>? SerializeHandler
                {
                    get
                    {
                        return _serialize;
                    }
                    private protected set
                    {
                        _serialize = value;
                        base.CanUseSerializeHandler = value != null;
                    }
                }

                private protected override void SetCreateObject(Delegate createObject)
                {
                    VerifyMutable();
                    if (base.Kind == JsonTypeInfoKind.None)
                    {
                        ThrowHelper.ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(base.Kind);
                    }
                    if (!base.Converter.SupportsCreateObjectDelegate)
                    {
                        ThrowHelper.ThrowInvalidOperationException_CreateObjectConverterNotCompatible(base.Type);
                    }
                    Func<object> untypedCreateObject;
                    Func<T> typedCreateObject;
                    if ((object)createObject == null)
                    {
                        untypedCreateObject = null;
                        typedCreateObject = null;
                    }
                    else
                    {
                        Func<T> typedDelegate = createObject as Func<T>;
                        if (typedDelegate != null)
                        {
                            typedCreateObject = typedDelegate;
                            untypedCreateObject = ((createObject is Func<object> func) ? func : ((Func<object>)(() => typedDelegate())));
                        }
                        else
                        {
                            untypedCreateObject = (Func<object>)createObject;
                            typedCreateObject = () => (T)untypedCreateObject();
                        }
                    }
                    _createObject = untypedCreateObject;
                    _typedCreateObject = typedCreateObject;
                }

                private protected void SetCreateObjectIfCompatible(Delegate createObject)
                {
                    if (base.Converter.SupportsCreateObjectDelegate && !base.Converter.ConstructorIsParameterized)
                    {
                        SetCreateObject(createObject);
                    }
                }

                internal JsonTypeInfo(JsonConverter converter, JsonSerializerOptions options)
                    : base(typeof(T), converter, options)
                {
                    EffectiveConverter = converter.CreateCastingConverter<T>();
                }

                private protected override JsonPropertyInfo CreatePropertyInfoForTypeInfo()
                {
                    return new JsonPropertyInfo<T>(typeof(T), null, base.Options)
                    {
                        JsonTypeInfo = this,
                        IsForTypeInfo = true
                    };
                }

                private protected override JsonPropertyInfo CreateJsonPropertyInfo(JsonTypeInfo declaringTypeInfo, JsonSerializerOptions options)
                {
                    return new JsonPropertyInfo<T>(declaringTypeInfo.Type, declaringTypeInfo, options)
                    {
                        JsonTypeInfo = this
                    };
                }

                private protected void PopulatePolymorphismMetadata()
                {
                    JsonPolymorphismOptions jsonPolymorphismOptions = JsonPolymorphismOptions.CreateFromAttributeDeclarations(base.Type);
                    if (jsonPolymorphismOptions != null)
                    {
                        jsonPolymorphismOptions.DeclaringTypeInfo = this;
                        _polymorphismOptions = jsonPolymorphismOptions;
                    }
                }

                private protected void MapInterfaceTypesToCallbacks()
                {
                    if (base.Kind != JsonTypeInfoKind.Object)
                    {
                        return;
                    }
                    if (typeof(IJsonOnSerializing).IsAssignableFrom(typeof(T)))
                    {
                        base.OnSerializing = delegate (object obj)
                        {
                            ((IJsonOnSerializing)obj).OnSerializing();
                        };
                    }
                    if (typeof(IJsonOnSerialized).IsAssignableFrom(typeof(T)))
                    {
                        base.OnSerialized = delegate (object obj)
                        {
                            ((IJsonOnSerialized)obj).OnSerialized();
                        };
                    }
                    if (typeof(IJsonOnDeserializing).IsAssignableFrom(typeof(T)))
                    {
                        base.OnDeserializing = delegate (object obj)
                        {
                            ((IJsonOnDeserializing)obj).OnDeserializing();
                        };
                    }
                    if (typeof(IJsonOnDeserialized).IsAssignableFrom(typeof(T)))
                    {
                        base.OnDeserialized = delegate (object obj)
                        {
                            ((IJsonOnDeserialized)obj).OnDeserialized();
                        };
                    }
                }
            }

            /// <summary>
            /// Provides JSON serialization-related metadata about a type.
            /// </summary>
            [DebuggerDisplay("{DebuggerDisplay,nq}")]
            public abstract class JsonTypeInfo
            {
                internal delegate T ParameterizedConstructorDelegate<T, TArg0, TArg1, TArg2, TArg3>(TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3);

                private sealed class ParameterLookupKey
                {
                    public string Name { get; }

                    public Type Type { get; }

                    public ParameterLookupKey(string name, Type type)
                    {
                        Name = name;
                        Type = type;
                    }

                    public override int GetHashCode()
                    {
                        return StringComparer.OrdinalIgnoreCase.GetHashCode(Name);
                    }

                    public override bool Equals([System.Diagnostics.CodeAnalysis.NotNullWhen(true)] object obj)
                    {
                        ParameterLookupKey parameterLookupKey = (ParameterLookupKey)obj;
                        if (Type == parameterLookupKey.Type)
                        {
                            return string.Equals(Name, parameterLookupKey.Name, StringComparison.OrdinalIgnoreCase);
                        }
                        return false;
                    }
                }

                private sealed class ParameterLookupValue
                {
                    public string DuplicateName { get; set; }

                    public JsonPropertyInfo JsonPropertyInfo { get; }

                    public ParameterLookupValue(JsonPropertyInfo jsonPropertyInfo)
                    {
                        JsonPropertyInfo = jsonPropertyInfo;
                    }
                }

                private sealed class JsonPropertyInfoList : ConfigurationList<JsonPropertyInfo>
                {
                    private readonly JsonTypeInfo _jsonTypeInfo;

                    protected override bool IsImmutable
                    {
                        get
                        {
                            if (!_jsonTypeInfo.IsConfigured)
                            {
                                return _jsonTypeInfo.Kind != JsonTypeInfoKind.Object;
                            }
                            return true;
                        }
                    }

                    public JsonPropertyInfoList(JsonTypeInfo jsonTypeInfo)
                        : base(jsonTypeInfo.PropertyCache?.Values)
                    {
                        if (jsonTypeInfo.ExtensionDataProperty != null)
                        {
                            _list.Add(jsonTypeInfo.ExtensionDataProperty);
                        }
                        _jsonTypeInfo = jsonTypeInfo;
                    }

                    protected override void VerifyMutable()
                    {
                        _jsonTypeInfo.VerifyMutable();
                        if (_jsonTypeInfo.Kind != JsonTypeInfoKind.Object)
                        {
                            ThrowHelper.ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(_jsonTypeInfo.Kind);
                        }
                    }

                    protected override void OnAddingElement(JsonPropertyInfo item)
                    {
                        item.EnsureChildOf(_jsonTypeInfo);
                    }
                }

                /// <summary>
                /// Cached typeof(object). It is faster to cache this than to call typeof(object) multiple times.
                /// </summary>
                internal static readonly Type ObjectType = typeof(object);

                private const int PropertyNameKeyLength = 7;

                private const int ParameterNameCountCacheThreshold = 32;

                private const int PropertyNameCountCacheThreshold = 64;

                private volatile ParameterRef[] _parameterRefsSorted;

                private volatile PropertyRef[] _propertyRefsSorted;

                internal Func<JsonSerializerContext, JsonPropertyInfo[]> PropInitFunc;

                internal Func<JsonParameterInfoValues[]> CtorParamInitFunc;

                internal const string MetadataFactoryRequiresUnreferencedCode = "JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.";

                internal const string JsonObjectTypeName = "System.Text.Json.Nodes.JsonObject";

                private JsonPropertyInfoList _properties;

                private Action<object> _onSerializing;

                private Action<object> _onSerialized;

                private Action<object> _onDeserializing;

                private Action<object> _onDeserialized;

                private protected Func<object> _createObject;

                private protected JsonPolymorphismOptions _polymorphismOptions;

                private JsonTypeInfo _elementTypeInfo;

                private JsonTypeInfo _keyTypeInfo;

                private DefaultValueHolder _defaultValueHolder;

                private JsonNumberHandling? _numberHandling;

                private volatile bool _isConfigured;

                private readonly object _configureLock = new object();

                private ExceptionDispatchInfo _cachedConfigureError;

                internal int ParameterCount { get; private set; }

                internal JsonPropertyDictionary<JsonParameterInfo>? ParameterCache { get; private set; }

                internal JsonPropertyDictionary<JsonPropertyInfo>? PropertyCache { get; private protected set; }

                /// <summary>
                /// Indices of required properties.
                /// </summary>
                internal int NumberOfRequiredProperties { get; private set; }

                /// <summary>
                /// Gets or sets a parameterless factory to be used on deserialization.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance has been locked for further modification.
                ///
                /// -or-
                ///
                /// A parameterless factory is not supported for the current metadata <see cref="P:System.Text.Json.Serialization.Metadata.JsonTypeInfo.Kind" />.
                /// </exception>
                /// <remarks>
                /// If set to <see langword="null" />, any attempt to deserialize instances of the given type will result in an exception.
                ///
                /// For contracts originating from <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" /> or <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" />,
                /// types with a single default constructor or default constructors annotated with <see cref="T:System.Text.Json.Serialization.JsonConstructorAttribute" />
                /// will be mapped to this delegate.
                /// </remarks>
                public Func<object>? CreateObject
                {
                    get
                    {
                        return _createObject;
                    }
                    set
                    {
                        SetCreateObject(value);
                    }
                }

                internal Func<object>? CreateObjectForExtensionDataProperty { get; set; }

                /// <summary>
                /// Gets or sets a callback to be invoked before serialization occurs.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance has been locked for further modification.
                ///
                /// -or-
                ///
                /// Serialization callbacks are only supported for <see cref="F:System.Text.Json.Serialization.Metadata.JsonTypeInfoKind.Object" /> metadata.
                /// </exception>
                /// <remarks>
                /// For contracts originating from <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" /> or <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" />,
                /// the value of this callback will be mapped from any <see cref="T:System.Text.Json.Serialization.IJsonOnSerializing" /> implementation on the type.
                /// </remarks>
                public Action<object>? OnSerializing
                {
                    get
                    {
                        return _onSerializing;
                    }
                    set
                    {
                        VerifyMutable();
                        if (Kind != JsonTypeInfoKind.Object)
                        {
                            ThrowHelper.ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(Kind);
                        }
                        _onSerializing = value;
                    }
                }

                /// <summary>
                /// Gets or sets a callback to be invoked after serialization occurs.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance has been locked for further modification.
                ///
                /// -or-
                ///
                /// Serialization callbacks are only supported for <see cref="F:System.Text.Json.Serialization.Metadata.JsonTypeInfoKind.Object" /> metadata.
                /// </exception>
                /// <remarks>
                /// For contracts originating from <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" /> or <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" />,
                /// the value of this callback will be mapped from any <see cref="T:System.Text.Json.Serialization.IJsonOnSerialized" /> implementation on the type.
                /// </remarks>
                public Action<object>? OnSerialized
                {
                    get
                    {
                        return _onSerialized;
                    }
                    set
                    {
                        VerifyMutable();
                        if (Kind != JsonTypeInfoKind.Object)
                        {
                            ThrowHelper.ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(Kind);
                        }
                        _onSerialized = value;
                    }
                }

                /// <summary>
                /// Gets or sets a callback to be invoked before deserialization occurs.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance has been locked for further modification.
                ///
                /// -or-
                ///
                /// Serialization callbacks are only supported for <see cref="F:System.Text.Json.Serialization.Metadata.JsonTypeInfoKind.Object" /> metadata.
                /// </exception>
                /// <remarks>
                /// For contracts originating from <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" /> or <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" />,
                /// the value of this callback will be mapped from any <see cref="T:System.Text.Json.Serialization.IJsonOnDeserializing" /> implementation on the type.
                /// </remarks>
                public Action<object>? OnDeserializing
                {
                    get
                    {
                        return _onDeserializing;
                    }
                    set
                    {
                        VerifyMutable();
                        if (Kind != JsonTypeInfoKind.Object)
                        {
                            ThrowHelper.ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(Kind);
                        }
                        _onDeserializing = value;
                    }
                }

                /// <summary>
                /// Gets or sets a callback to be invoked after deserialization occurs.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance has been locked for further modification.
                ///
                /// -or-
                ///
                /// Serialization callbacks are only supported for <see cref="F:System.Text.Json.Serialization.Metadata.JsonTypeInfoKind.Object" /> metadata.
                /// </exception>
                /// <remarks>
                /// For contracts originating from <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" /> or <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" />,
                /// the value of this callback will be mapped from any <see cref="T:System.Text.Json.Serialization.IJsonOnDeserialized" /> implementation on the type.
                /// </remarks>
                public Action<object>? OnDeserialized
                {
                    get
                    {
                        return _onDeserialized;
                    }
                    set
                    {
                        VerifyMutable();
                        if (Kind != JsonTypeInfoKind.Object)
                        {
                            ThrowHelper.ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(Kind);
                        }
                        _onDeserialized = value;
                    }
                }

                /// <summary>
                /// Gets the list of <see cref="T:System.Text.Json.Serialization.Metadata.JsonPropertyInfo" /> metadata corresponding to the current type.
                /// </summary>
                /// <remarks>
                /// Property is only applicable to metadata of kind <see cref="F:System.Text.Json.Serialization.Metadata.JsonTypeInfoKind.Object" />.
                /// For other kinds an empty, read-only list will be returned.
                ///
                /// The order of <see cref="T:System.Text.Json.Serialization.Metadata.JsonPropertyInfo" /> entries in the list determines the serialization order,
                /// unless either of the entries specifies a non-zero <see cref="P:System.Text.Json.Serialization.Metadata.JsonPropertyInfo.Order" /> value,
                /// in which case the properties will be stable sorted by <see cref="P:System.Text.Json.Serialization.Metadata.JsonPropertyInfo.Order" />.
                ///
                /// It is required that added <see cref="T:System.Text.Json.Serialization.Metadata.JsonPropertyInfo" /> entries are unique up to <see cref="P:System.Text.Json.Serialization.Metadata.JsonPropertyInfo.Name" />,
                /// however this will only be validated on serialization, once the metadata instance gets locked for further modification.
                /// </remarks>
                public IList<JsonPropertyInfo> Properties
                {
                    get
                    {
                        if (_properties == null)
                        {
                            PopulatePropertyList();
                        }
                        return _properties;
                    }
                }

                /// <summary>
                /// Gets or sets a configuration object specifying polymorphism metadata.
                /// </summary>
                /// <exception cref="T:System.ArgumentException">
                /// <paramref name="value" /> has been associated with a different <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance.
                /// </exception>
                /// <exception cref="T:System.InvalidOperationException">
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance has been locked for further modification.
                ///
                /// -or-
                ///
                /// Polymorphic serialization is not supported for the current metadata <see cref="P:System.Text.Json.Serialization.Metadata.JsonTypeInfo.Kind" />.
                /// </exception>
                /// <remarks>
                /// For contracts originating from <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" /> or <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" />,
                /// the configuration of this setting will be mapped from any <see cref="T:System.Text.Json.Serialization.JsonDerivedTypeAttribute" /> or <see cref="T:System.Text.Json.Serialization.JsonPolymorphicAttribute" /> annotations.
                /// </remarks>
                public JsonPolymorphismOptions? PolymorphismOptions
                {
                    get
                    {
                        return _polymorphismOptions;
                    }
                    set
                    {
                        VerifyMutable();
                        if (value != null)
                        {
                            if (Kind == JsonTypeInfoKind.None)
                            {
                                ThrowHelper.ThrowInvalidOperationException_JsonTypeInfoOperationNotPossibleForKind(Kind);
                            }
                            if (value.DeclaringTypeInfo != null && value.DeclaringTypeInfo != this)
                            {
                                ThrowHelper.ThrowArgumentException_JsonPolymorphismOptionsAssociatedWithDifferentJsonTypeInfo("value");
                            }
                            value.DeclaringTypeInfo = this;
                        }
                        _polymorphismOptions = value;
                    }
                }

                /// <summary>
                /// Specifies whether the current instance has been locked for modification.
                /// </summary>
                /// <remarks>
                /// A <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance can be locked either if
                /// it has been passed to one of the <see cref="T:System.Text.Json.JsonSerializer" /> methods,
                /// has been associated with a <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" /> instance,
                /// or a user explicitly called the <see cref="M:System.Text.Json.Serialization.Metadata.JsonTypeInfo.MakeReadOnly" /> method on the instance.
                /// </remarks>
                public bool IsReadOnly { get; private set; }

                internal object? CreateObjectWithArgs { get; set; }

                internal object? AddMethodDelegate { get; set; }

                internal JsonPropertyInfo? ExtensionDataProperty { get; private set; }

                internal PolymorphicTypeResolver? PolymorphicTypeResolver { get; private set; }

                internal bool CanUseSerializeHandler { get; private protected set; }

                internal bool MetadataSerializationNotSupported { get; private protected set; }

                /// <summary>
                /// Return the JsonTypeInfo for the element type, or null if the type is not an enumerable or dictionary.
                /// </summary>
                /// <remarks>
                /// This should not be called during warm-up (initial creation of JsonTypeInfos) to avoid recursive behavior
                /// which could result in a StackOverflowException.
                /// </remarks>
                internal JsonTypeInfo? ElementTypeInfo
                {
                    get
                    {
                        if (_elementTypeInfo == null)
                        {
                            if (ElementType != null)
                            {
                                _elementTypeInfo = Options.GetTypeInfoInternal(ElementType);
                            }
                        }
                        else
                        {
                            _elementTypeInfo.EnsureConfigured();
                        }
                        return _elementTypeInfo;
                    }
                    set
                    {
                        _elementTypeInfo = value;
                    }
                }

                internal Type? ElementType { get; }

                /// <summary>
                /// Return the JsonTypeInfo for the key type, or null if the type is not a dictionary.
                /// </summary>
                /// <remarks>
                /// This should not be called during warm-up (initial creation of JsonTypeInfos) to avoid recursive behavior
                /// which could result in a StackOverflowException.
                /// </remarks>
                internal JsonTypeInfo? KeyTypeInfo
                {
                    get
                    {
                        if (_keyTypeInfo == null)
                        {
                            if (KeyType != null)
                            {
                                _keyTypeInfo = Options.GetTypeInfoInternal(KeyType);
                            }
                        }
                        else
                        {
                            _keyTypeInfo.EnsureConfigured();
                        }
                        return _keyTypeInfo;
                    }
                    set
                    {
                        _keyTypeInfo = value;
                    }
                }

                internal Type? KeyType { get; }

                /// <summary>
                /// Gets the <see cref="T:System.Text.Json.JsonSerializerOptions" /> value associated with the current <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance.
                /// </summary>
                public JsonSerializerOptions Options { get; }

                /// <summary>
                /// Gets the <see cref="P:System.Text.Json.Serialization.Metadata.JsonTypeInfo.Type" /> for which the JSON serialization contract is being defined.
                /// </summary>
                public Type Type { get; }

                /// <summary>
                /// Gets the <see cref="T:System.Text.Json.Serialization.JsonConverter" /> associated with the current type.
                /// </summary>
                /// <remarks>
                /// The <see cref="T:System.Text.Json.Serialization.JsonConverter" /> associated with the type determines the value of <see cref="P:System.Text.Json.Serialization.Metadata.JsonTypeInfo.Kind" />,
                /// and by extension the types of metadata that are configurable in the current JSON contract.
                /// As such, the value of the converter cannot be changed once a <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance has been created.
                /// </remarks>
                public JsonConverter Converter { get; }

                /// <summary>
                /// Determines the kind of contract metadata that the current instance is specifying.
                /// </summary>
                /// <remarks>
                /// The value of <see cref="P:System.Text.Json.Serialization.Metadata.JsonTypeInfo.Kind" /> determines what aspects of the JSON contract are configurable.
                /// For example, it is only possible to configure the <see cref="P:System.Text.Json.Serialization.Metadata.JsonTypeInfo.Properties" /> list for metadata
                /// of kind <see cref="F:System.Text.Json.Serialization.Metadata.JsonTypeInfoKind.Object" />.
                ///
                /// The value of <see cref="P:System.Text.Json.Serialization.Metadata.JsonTypeInfo.Kind" /> is determined exclusively by the <see cref="T:System.Text.Json.Serialization.JsonConverter" />
                /// resolved for the current type, and cannot be changed once resolution has happened.
                /// User-defined custom converters (specified either via <see cref="T:System.Text.Json.Serialization.JsonConverterAttribute" /> or <see cref="P:System.Text.Json.JsonSerializerOptions.Converters" />)
                /// are metadata-agnostic and thus always resolve to <see cref="F:System.Text.Json.Serialization.Metadata.JsonTypeInfoKind.None" />.
                /// </remarks>
                public JsonTypeInfoKind Kind { get; private set; }

                /// <summary>
                /// The JsonPropertyInfo for this JsonTypeInfo. It is used to obtain the converter for the TypeInfo.
                /// </summary>
                /// <remarks>
                /// The returned JsonPropertyInfo does not represent a real property; instead it represents either:
                /// a collection element type,
                /// a generic type parameter,
                /// a property type (if pushed to a new stack frame),
                /// or the root type passed into the root serialization APIs.
                /// For example, for a property returning <see cref="T:System.Collections.Generic.List`1" /> where T is a string,
                /// a JsonTypeInfo will be created with .Type=typeof(string) and .PropertyInfoForTypeInfo=JsonPropertyInfo{string}.
                /// Without this property, a "Converter" property would need to be added to JsonTypeInfo and there would be several more
                /// `if` statements to obtain the converter from either the actual JsonPropertyInfo (for a real property) or from the
                /// TypeInfo (for the cases mentioned above). In addition, methods that have a JsonPropertyInfo argument would also likely
                /// need to add an argument for JsonTypeInfo.
                /// </remarks>
                internal JsonPropertyInfo PropertyInfoForTypeInfo { get; }

                /// <summary>
                /// Returns a helper class used for computing the default value.
                /// </summary>
                internal DefaultValueHolder DefaultValueHolder => _defaultValueHolder ?? (_defaultValueHolder = System.Text.Json.Serialization.Metadata.DefaultValueHolder.CreateHolder(Type));

                /// <summary>
                /// Gets or sets the type-level <see cref="P:System.Text.Json.JsonSerializerOptions.NumberHandling" /> override.
                /// </summary>
                /// <exception cref="T:System.InvalidOperationException">
                /// The <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance has been locked for further modification.
                /// </exception>
                /// <remarks>
                /// For contracts originating from <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" /> or <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" />,
                /// the value of this callback will be mapped from any <see cref="T:System.Text.Json.Serialization.JsonNumberHandling" /> annotations.
                /// </remarks>
                public JsonNumberHandling? NumberHandling
                {
                    get
                    {
                        return _numberHandling;
                    }
                    set
                    {
                        VerifyMutable();
                        _numberHandling = value;
                    }
                }

                internal bool IsConfigured => _isConfigured;

                [DebuggerBrowsable(DebuggerBrowsableState.Never)]
                private string DebuggerDisplay => $"Type = {Type.Name}, Kind = {Kind}";

                [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
                internal JsonPropertyInfo CreatePropertyUsingReflection(Type propertyType)
                {
                    if (Options.TryGetTypeInfoCached(propertyType, out var typeInfo))
                    {
                        return typeInfo.CreateJsonPropertyInfo(this, Options);
                    }
                    Type type = typeof(JsonPropertyInfo<>).MakeGenericType(propertyType);
                    return (JsonPropertyInfo)type.CreateInstanceNoWrapExceptions(new Type[3] { typeof(Type), typeof(JsonTypeInfo), typeof(JsonSerializerOptions) }, new object[3] { Type, this, Options });
                }

                /// <summary>
                /// Creates a JsonPropertyInfo whose property type matches the type of this JsonTypeInfo instance.
                /// </summary>
                private protected abstract JsonPropertyInfo CreateJsonPropertyInfo(JsonTypeInfo declaringTypeInfo, JsonSerializerOptions options);

                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                internal JsonPropertyInfo GetProperty(ReadOnlySpan<byte> propertyName, ref ReadStackFrame frame, out byte[] utf8PropertyName)
                {
                    ValidateCanBeUsedForMetadataSerialization();
                    ulong key = GetKey(propertyName);
                    PropertyRef[] propertyRefsSorted = _propertyRefsSorted;
                    if (propertyRefsSorted != null)
                    {
                        int propertyIndex = frame.PropertyIndex;
                        int num = propertyRefsSorted.Length;
                        int num2 = Math.Min(propertyIndex, num);
                        int num3 = num2 - 1;
                        while (true)
                        {
                            if (num2 < num)
                            {
                                PropertyRef propertyRef = propertyRefsSorted[num2];
                                if (IsPropertyRefEqual(in propertyRef, propertyName, key))
                                {
                                    utf8PropertyName = propertyRef.NameFromJson;
                                    return propertyRef.Info;
                                }
                                num2++;
                                if (num3 >= 0)
                                {
                                    propertyRef = propertyRefsSorted[num3];
                                    if (IsPropertyRefEqual(in propertyRef, propertyName, key))
                                    {
                                        utf8PropertyName = propertyRef.NameFromJson;
                                        return propertyRef.Info;
                                    }
                                    num3--;
                                }
                            }
                            else
                            {
                                if (num3 < 0)
                                {
                                    break;
                                }
                                PropertyRef propertyRef = propertyRefsSorted[num3];
                                if (IsPropertyRefEqual(in propertyRef, propertyName, key))
                                {
                                    utf8PropertyName = propertyRef.NameFromJson;
                                    return propertyRef.Info;
                                }
                                num3--;
                            }
                        }
                    }
                    if (PropertyCache.TryGetValue(JsonHelpers.Utf8GetString(propertyName), out JsonPropertyInfo value))
                    {
                        if (Options.PropertyNameCaseInsensitive)
                        {
                            if (propertyName.SequenceEqual(value.NameAsUtf8Bytes))
                            {
                                utf8PropertyName = value.NameAsUtf8Bytes;
                            }
                            else
                            {
                                utf8PropertyName = propertyName.ToArray();
                            }
                        }
                        else
                        {
                            utf8PropertyName = value.NameAsUtf8Bytes;
                        }
                    }
                    else
                    {
                        value = JsonPropertyInfo.s_missingProperty;
                        utf8PropertyName = propertyName.ToArray();
                    }
                    int num4 = 0;
                    if (propertyRefsSorted != null)
                    {
                        num4 = propertyRefsSorted.Length;
                    }
                    if (num4 < 64)
                    {
                        if (frame.PropertyRefCache != null)
                        {
                            num4 += frame.PropertyRefCache.Count;
                        }
                        if (num4 < 64)
                        {
                            ref List<PropertyRef> propertyRefCache = ref frame.PropertyRefCache;
                            if (propertyRefCache == null)
                            {
                                propertyRefCache = new List<PropertyRef>();
                            }
                            PropertyRef propertyRef = new PropertyRef(key, value, utf8PropertyName);
                            frame.PropertyRefCache.Add(propertyRef);
                        }
                    }
                    return value;
                }

                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                internal JsonParameterInfo GetParameter(ReadOnlySpan<byte> propertyName, ref ReadStackFrame frame, out byte[] utf8PropertyName)
                {
                    ulong key = GetKey(propertyName);
                    ParameterRef[] parameterRefsSorted = _parameterRefsSorted;
                    if (parameterRefsSorted != null)
                    {
                        int parameterIndex = frame.CtorArgumentState.ParameterIndex;
                        int num = parameterRefsSorted.Length;
                        int num2 = Math.Min(parameterIndex, num);
                        int num3 = num2 - 1;
                        while (true)
                        {
                            if (num2 < num)
                            {
                                ParameterRef parameterRef = parameterRefsSorted[num2];
                                if (IsParameterRefEqual(in parameterRef, propertyName, key))
                                {
                                    utf8PropertyName = parameterRef.NameFromJson;
                                    return parameterRef.Info;
                                }
                                num2++;
                                if (num3 >= 0)
                                {
                                    parameterRef = parameterRefsSorted[num3];
                                    if (IsParameterRefEqual(in parameterRef, propertyName, key))
                                    {
                                        utf8PropertyName = parameterRef.NameFromJson;
                                        return parameterRef.Info;
                                    }
                                    num3--;
                                }
                            }
                            else
                            {
                                if (num3 < 0)
                                {
                                    break;
                                }
                                ParameterRef parameterRef = parameterRefsSorted[num3];
                                if (IsParameterRefEqual(in parameterRef, propertyName, key))
                                {
                                    utf8PropertyName = parameterRef.NameFromJson;
                                    return parameterRef.Info;
                                }
                                num3--;
                            }
                        }
                    }
                    if (ParameterCache.TryGetValue(JsonHelpers.Utf8GetString(propertyName), out JsonParameterInfo value))
                    {
                        if (Options.PropertyNameCaseInsensitive)
                        {
                            if (propertyName.SequenceEqual(value.NameAsUtf8Bytes))
                            {
                                utf8PropertyName = value.NameAsUtf8Bytes;
                            }
                            else
                            {
                                utf8PropertyName = propertyName.ToArray();
                            }
                        }
                        else
                        {
                            utf8PropertyName = value.NameAsUtf8Bytes;
                        }
                    }
                    else
                    {
                        utf8PropertyName = propertyName.ToArray();
                    }
                    int num4 = 0;
                    if (parameterRefsSorted != null)
                    {
                        num4 = parameterRefsSorted.Length;
                    }
                    if (num4 < 32)
                    {
                        if (frame.CtorArgumentState.ParameterRefCache != null)
                        {
                            num4 += frame.CtorArgumentState.ParameterRefCache.Count;
                        }
                        if (num4 < 32)
                        {
                            ArgumentState ctorArgumentState = frame.CtorArgumentState;
                            if (ctorArgumentState.ParameterRefCache == null)
                            {
                                ctorArgumentState.ParameterRefCache = new List<ParameterRef>();
                            }
                            ParameterRef parameterRef = new ParameterRef(key, value, utf8PropertyName);
                            frame.CtorArgumentState.ParameterRefCache.Add(parameterRef);
                        }
                    }
                    return value;
                }

                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                private static bool IsPropertyRefEqual(in PropertyRef propertyRef, ReadOnlySpan<byte> propertyName, ulong key)
                {
                    if (key == propertyRef.Key && (propertyName.Length <= 7 || propertyName.SequenceEqual(propertyRef.NameFromJson)))
                    {
                        return true;
                    }
                    return false;
                }

                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                private static bool IsParameterRefEqual(in ParameterRef parameterRef, ReadOnlySpan<byte> parameterName, ulong key)
                {
                    if (key == parameterRef.Key && (parameterName.Length <= 7 || parameterName.SequenceEqual(parameterRef.NameFromJson)))
                    {
                        return true;
                    }
                    return false;
                }

                /// <summary>
                /// Get a key from the property name.
                /// The key consists of the first 7 bytes of the property name and then the length.
                /// </summary>
                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                internal static ulong GetKey(ReadOnlySpan<byte> name)
                {
                    ref byte reference = ref MemoryMarshal.GetReference(name);
                    int length = name.Length;
                    ulong num;
                    if (length > 7)
                    {
                        num = System.Runtime.CompilerServices.Unsafe.ReadUnaligned<ulong>(ref reference) & 0xFFFFFFFFFFFFFFuL;
                        num |= (ulong)((long)Math.Min(length, 255) << 56);
                    }
                    else
                    {
                        num = ((length > 5) ? (System.Runtime.CompilerServices.Unsafe.ReadUnaligned<uint>(ref reference) | ((ulong)System.Runtime.CompilerServices.Unsafe.ReadUnaligned<ushort>(ref System.Runtime.CompilerServices.Unsafe.Add<byte>(ref reference, 4)) << 32)) : ((length > 3) ? ((ulong)System.Runtime.CompilerServices.Unsafe.ReadUnaligned<uint>(ref reference)) : ((ulong)((length > 1) ? System.Runtime.CompilerServices.Unsafe.ReadUnaligned<ushort>(ref reference) : 0))));
                        num |= (ulong)((long)length << 56);
                        if (((uint)length & (true ? 1u : 0u)) != 0)
                        {
                            int num2 = length - 1;
                            num |= (ulong)System.Runtime.CompilerServices.Unsafe.Add<byte>(ref reference, num2) << num2 * 8;
                        }
                    }
                    return num;
                }

                internal void UpdateSortedPropertyCache(ref ReadStackFrame frame)
                {
                    List<PropertyRef> propertyRefCache = frame.PropertyRefCache;
                    if (_propertyRefsSorted != null)
                    {
                        List<PropertyRef> list = new List<PropertyRef>(_propertyRefsSorted);
                        while (list.Count + propertyRefCache.Count > 64)
                        {
                            propertyRefCache.RemoveAt(propertyRefCache.Count - 1);
                        }
                        list.AddRange(propertyRefCache);
                        _propertyRefsSorted = list.ToArray();
                    }
                    else
                    {
                        _propertyRefsSorted = propertyRefCache.ToArray();
                    }
                    frame.PropertyRefCache = null;
                }

                internal void UpdateSortedParameterCache(ref ReadStackFrame frame)
                {
                    List<ParameterRef> parameterRefCache = frame.CtorArgumentState.ParameterRefCache;
                    if (_parameterRefsSorted != null)
                    {
                        List<ParameterRef> list = new List<ParameterRef>(_parameterRefsSorted);
                        while (list.Count + parameterRefCache.Count > 32)
                        {
                            parameterRefCache.RemoveAt(parameterRefCache.Count - 1);
                        }
                        list.AddRange(parameterRefCache);
                        _parameterRefsSorted = list.ToArray();
                    }
                    else
                    {
                        _parameterRefsSorted = parameterRefCache.ToArray();
                    }
                    frame.CtorArgumentState.ParameterRefCache = null;
                }

                private protected abstract void SetCreateObject(Delegate createObject);

                /// <summary>
                /// Locks the current instance for further modification.
                /// </summary>
                /// <remarks>This method is idempotent.</remarks>
                public void MakeReadOnly()
                {
                    IsReadOnly = true;
                }

                [MethodImpl(MethodImplOptions.AggressiveInlining)]
                internal void ValidateCanBeUsedForMetadataSerialization()
                {
                    if (MetadataSerializationNotSupported)
                    {
                        ThrowHelper.ThrowInvalidOperationException_NoMetadataForTypeProperties(Options.TypeInfoResolver, Type);
                    }
                }

                private protected abstract JsonPropertyInfo CreatePropertyInfoForTypeInfo();

                internal JsonTypeInfo(Type type, JsonConverter converter, JsonSerializerOptions options)
                {
                    Type = type;
                    Options = options;
                    Converter = converter;
                    PropertyInfoForTypeInfo = CreatePropertyInfoForTypeInfo();
                    ElementType = converter.ElementType;
                    ConverterStrategy converterStrategy = PropertyInfoForTypeInfo.ConverterStrategy;
                    if (converterStrategy <= ConverterStrategy.Value)
                    {
                        if (converterStrategy != 0)
                        {
                            if (converterStrategy - 1 > ConverterStrategy.Object)
                            {
                                goto IL_0078;
                            }
                        }
                        else
                        {
                            ThrowHelper.ThrowNotSupportedException_SerializationNotSupported(type);
                        }
                    }
                    else if (converterStrategy != ConverterStrategy.Enumerable)
                    {
                        if (converterStrategy != ConverterStrategy.Dictionary)
                        {
                            goto IL_0078;
                        }
                        KeyType = converter.KeyType;
                    }
                    Kind = GetTypeInfoKind(type, PropertyInfoForTypeInfo.ConverterStrategy);
                    return;
                IL_0078:
                    throw new InvalidOperationException();
                }

                internal void VerifyMutable()
                {
                    if (IsReadOnly)
                    {
                        ThrowHelper.ThrowInvalidOperationException_TypeInfoImmutable();
                    }
                }

                internal void EnsureConfigured()
                {
                    if (!_isConfigured)
                    {
                        ConfigureLocked();
                    }
                    void ConfigureLocked()
                    {
                        _cachedConfigureError?.Throw();
                        lock (_configureLock)
                        {
                            if (_isConfigured)
                            {
                                return;
                            }
                            _cachedConfigureError?.Throw();
                            try
                            {
                                Configure();
                                IsReadOnly = true;
                                _isConfigured = true;
                            }
                            catch (Exception source)
                            {
                                _cachedConfigureError = ExceptionDispatchInfo.Capture(source);
                                throw;
                            }
                        }
                    }
                }

                internal void Configure()
                {
                    if (!Options.IsImmutable)
                    {
                        Options.InitializeForMetadataGeneration();
                    }
                    PropertyInfoForTypeInfo.EnsureChildOf(this);
                    PropertyInfoForTypeInfo.EnsureConfigured();
                    CanUseSerializeHandler &= Options.SerializerContext?.CanUseSerializationLogic ?? false;
                    JsonConverter converter = Converter;
                    if (Kind == JsonTypeInfoKind.Object)
                    {
                        InitializePropertyCache();
                        if (converter.ConstructorIsParameterized)
                        {
                            InitializeConstructorParameters(GetParameterInfoValues(), Options.SerializerContext != null);
                        }
                    }
                    if (PolymorphismOptions != null)
                    {
                        PolymorphicTypeResolver = new PolymorphicTypeResolver(this);
                    }
                }

                internal virtual void LateAddProperties()
                {
                }

                /// <summary>
                /// Creates a blank <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo`1" /> instance.
                /// </summary>
                /// <typeparam name="T">The type for which contract metadata is specified.</typeparam>
                /// <param name="options">The <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance the metadata is associated with.</param>
                /// <returns>A blank <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo`1" /> instance.</returns>
                /// <exception cref="T:System.ArgumentNullException"><paramref name="options" /> is null.</exception>
                /// <remarks>
                /// The returned <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo`1" /> will be blank, with the exception of the
                /// <see cref="P:System.Text.Json.Serialization.Metadata.JsonTypeInfo.Converter" /> property which will be resolved either from
                /// <see cref="P:System.Text.Json.JsonSerializerOptions.Converters" /> or the built-in converters for the type.
                /// Any converters specified via <see cref="T:System.Text.Json.Serialization.JsonConverterAttribute" /> on the type declaration
                /// will not be resolved by this method.
                ///
                /// What converter does get resolved influences the value of <see cref="P:System.Text.Json.Serialization.Metadata.JsonTypeInfo.Kind" />,
                /// which constrains the type of metadata that can be modified in the <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance.
                /// </remarks>
                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                public static JsonTypeInfo<T> CreateJsonTypeInfo<T>(JsonSerializerOptions options)
                {
                    if (options == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("options");
                    }
                    JsonConverter converterForType = DefaultJsonTypeInfoResolver.GetConverterForType(typeof(T), options, resolveJsonConverterAttribute: false);
                    return new CustomJsonTypeInfo<T>(converterForType, options);
                }

                /// <summary>
                /// Creates a blank <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance.
                /// </summary>
                /// <param name="type">The type for which contract metadata is specified.</param>
                /// <param name="options">The <see cref="T:System.Text.Json.JsonSerializerOptions" /> instance the metadata is associated with.</param>
                /// <returns>A blank <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance.</returns>
                /// <exception cref="T:System.ArgumentNullException"><paramref name="type" /> or <paramref name="options" /> is null.</exception>
                /// <exception cref="T:System.ArgumentException"><paramref name="type" /> cannot be used for serialization.</exception>
                /// <remarks>
                /// The returned <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> will be blank, with the exception of the
                /// <see cref="P:System.Text.Json.Serialization.Metadata.JsonTypeInfo.Converter" /> property which will be resolved either from
                /// <see cref="P:System.Text.Json.JsonSerializerOptions.Converters" /> or the built-in converters for the type.
                /// Any converters specified via <see cref="T:System.Text.Json.Serialization.JsonConverterAttribute" /> on the type declaration
                /// will not be resolved by this method.
                ///
                /// What converter does get resolved influences the value of <see cref="P:System.Text.Json.Serialization.Metadata.JsonTypeInfo.Kind" />,
                /// which constrains the type of metadata that can be modified in the <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance.
                /// </remarks>
                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                public static JsonTypeInfo CreateJsonTypeInfo(Type type, JsonSerializerOptions options)
                {
                    if (type == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("type");
                    }
                    if (options == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("options");
                    }
                    if (IsInvalidForSerialization(type))
                    {
                        ThrowHelper.ThrowArgumentException_CannotSerializeInvalidType("type", type, null, null);
                    }
                    JsonConverter converterForType = DefaultJsonTypeInfoResolver.GetConverterForType(type, options, resolveJsonConverterAttribute: false);
                    if (converterForType.TypeToConvert == type)
                    {
                        return converterForType.CreateCustomJsonTypeInfo(options);
                    }
                    Type type2 = typeof(CustomJsonTypeInfo<>).MakeGenericType(type);
                    return (JsonTypeInfo)type2.CreateInstanceNoWrapExceptions(new Type[2]
                    {
                typeof(JsonConverter),
                typeof(JsonSerializerOptions)
                    }, new object[2] { converterForType, options });
                }

                /// <summary>
                /// Creates a blank <see cref="T:System.Text.Json.Serialization.Metadata.JsonPropertyInfo" /> instance for the current <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" />.
                /// </summary>
                /// <param name="propertyType">The declared type for the property.</param>
                /// <param name="name">The property name used in JSON serialization and deserialization.</param>
                /// <returns>A blank <see cref="T:System.Text.Json.Serialization.Metadata.JsonPropertyInfo" /> instance.</returns>
                /// <exception cref="T:System.ArgumentNullException"><paramref name="propertyType" /> or <paramref name="name" /> is null.</exception>
                /// <exception cref="T:System.ArgumentException"><paramref name="propertyType" /> cannot be used for serialization.</exception>
                /// <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> instance has been locked for further modification.</exception>
                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                public JsonPropertyInfo CreateJsonPropertyInfo(Type propertyType, string name)
                {
                    if (propertyType == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("propertyType");
                    }
                    if (name == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("name");
                    }
                    if (IsInvalidForSerialization(propertyType))
                    {
                        ThrowHelper.ThrowArgumentException_CannotSerializeInvalidType("propertyType", propertyType, Type, name);
                    }
                    VerifyMutable();
                    JsonPropertyInfo jsonPropertyInfo = CreatePropertyUsingReflection(propertyType);
                    jsonPropertyInfo.Name = name;
                    return jsonPropertyInfo;
                }

                [System.Diagnostics.CodeAnalysis.MemberNotNull("_properties")]
                private void PopulatePropertyList()
                {
                    if (!_isConfigured)
                    {
                        lock (_configureLock)
                        {
                            if (!_isConfigured)
                            {
                                LateAddProperties();
                                _properties = new JsonPropertyInfoList(this);
                                return;
                            }
                        }
                    }
                    _properties = new JsonPropertyInfoList(this);
                }

                internal abstract JsonParameterInfoValues[] GetParameterInfoValues();

                internal void CacheMember(JsonPropertyInfo jsonPropertyInfo, JsonPropertyDictionary<JsonPropertyInfo> propertyCache, ref Dictionary<string, JsonPropertyInfo> ignoredMembers)
                {
                    string memberName = jsonPropertyInfo.MemberName;
                    jsonPropertyInfo.EnsureChildOf(this);
                    if (jsonPropertyInfo.IsExtensionData)
                    {
                        if (ExtensionDataProperty != null)
                        {
                            ThrowHelper.ThrowInvalidOperationException_SerializationDuplicateTypeAttribute(Type, typeof(JsonExtensionDataAttribute));
                        }
                        ExtensionDataProperty = jsonPropertyInfo;
                        return;
                    }
                    if (!propertyCache.TryAdd(jsonPropertyInfo.Name, jsonPropertyInfo))
                    {
                        JsonPropertyInfo jsonPropertyInfo2 = propertyCache[jsonPropertyInfo.Name];
                        if (jsonPropertyInfo2.IsIgnored)
                        {
                            propertyCache[jsonPropertyInfo.Name] = jsonPropertyInfo;
                        }
                        else if (!jsonPropertyInfo.IsIgnored && jsonPropertyInfo2.MemberName != memberName)
                        {
                            Dictionary<string, JsonPropertyInfo> obj = ignoredMembers;
                            if (obj == null || !obj.ContainsKey(memberName))
                            {
                                ThrowHelper.ThrowInvalidOperationException_SerializerPropertyNameConflict(Type, jsonPropertyInfo.Name);
                            }
                        }
                    }
                    if (jsonPropertyInfo.IsIgnored)
                    {
                        (ignoredMembers ?? (ignoredMembers = new Dictionary<string, JsonPropertyInfo>())).Add(memberName, jsonPropertyInfo);
                    }
                }

                internal void InitializePropertyCache()
                {
                    if (_properties != null)
                    {
                        ExtensionDataProperty = null;
                        if (PropertyCache == null)
                        {
                            PropertyCache = CreatePropertyCache(_properties.Count);
                        }
                        else
                        {
                            PropertyCache.Clear();
                        }
                        bool flag = false;
                        foreach (JsonPropertyInfo property in _properties)
                        {
                            if (property.IsExtensionData)
                            {
                                if (ExtensionDataProperty != null)
                                {
                                    ThrowHelper.ThrowInvalidOperationException_SerializationDuplicateTypeAttribute(Type, typeof(JsonExtensionDataAttribute));
                                }
                                ExtensionDataProperty = property;
                            }
                            else
                            {
                                if (!PropertyCache.TryAddValue(property.Name, property))
                                {
                                    ThrowHelper.ThrowInvalidOperationException_SerializerPropertyNameConflict(Type, property.Name);
                                }
                                flag |= property.Order != 0;
                            }
                        }
                        if (flag)
                        {
                            PropertyCache.List.StableSortByKey<KeyValuePair<string, JsonPropertyInfo>, int>((KeyValuePair<string, JsonPropertyInfo> prop) => prop.Value.Order);
                        }
                    }
                    else
                    {
                        LateAddProperties();
                        if (PropertyCache == null)
                        {
                            JsonPropertyDictionary<JsonPropertyInfo> jsonPropertyDictionary2 = (PropertyCache = CreatePropertyCache(0));
                        }
                    }
                    if (ExtensionDataProperty != null)
                    {
                        ExtensionDataProperty.EnsureChildOf(this);
                        ExtensionDataProperty.EnsureConfigured();
                    }
                    int numberOfRequiredProperties = 0;
                    foreach (KeyValuePair<string, JsonPropertyInfo> item in PropertyCache.List)
                    {
                        JsonPropertyInfo value = item.Value;
                        if (value.IsRequired)
                        {
                            value.RequiredPropertyIndex = numberOfRequiredProperties++;
                        }
                        value.EnsureChildOf(this);
                        value.EnsureConfigured();
                    }
                    NumberOfRequiredProperties = numberOfRequiredProperties;
                }

                internal void InitializeConstructorParameters(JsonParameterInfoValues[] jsonParameters, bool sourceGenMode = false)
                {
                    JsonPropertyDictionary<JsonParameterInfo> jsonPropertyDictionary = new JsonPropertyDictionary<JsonParameterInfo>(Options.PropertyNameCaseInsensitive, jsonParameters.Length);
                    Dictionary<ParameterLookupKey, ParameterLookupValue> dictionary = new Dictionary<ParameterLookupKey, ParameterLookupValue>(PropertyCache.Count);
                    foreach (KeyValuePair<string, JsonPropertyInfo> item in PropertyCache.List)
                    {
                        JsonPropertyInfo value = item.Value;
                        string text = value.MemberName ?? value.Name;
                        ParameterLookupKey key = new ParameterLookupKey(text, value.PropertyType);
                        ParameterLookupValue value2 = new ParameterLookupValue(value);
                        if (!dictionary.TryAdd(in key, in value2))
                        {
                            ParameterLookupValue parameterLookupValue = dictionary[key];
                            parameterLookupValue.DuplicateName = text;
                        }
                    }
                    foreach (JsonParameterInfoValues jsonParameterInfoValues in jsonParameters)
                    {
                        ParameterLookupKey parameterLookupKey = new ParameterLookupKey(jsonParameterInfoValues.Name, jsonParameterInfoValues.ParameterType);
                        if (dictionary.TryGetValue(parameterLookupKey, out var value3))
                        {
                            if (value3.DuplicateName != null)
                            {
                                ThrowHelper.ThrowInvalidOperationException_MultiplePropertiesBindToConstructorParameters(Type, jsonParameterInfoValues.Name, value3.JsonPropertyInfo.Name, value3.DuplicateName);
                            }
                            JsonPropertyInfo jsonPropertyInfo = value3.JsonPropertyInfo;
                            JsonParameterInfo value4 = CreateConstructorParameter(jsonParameterInfoValues, jsonPropertyInfo, sourceGenMode, Options);
                            jsonPropertyDictionary.Add(jsonPropertyInfo.Name, value4);
                        }
                        else if (ExtensionDataProperty != null && StringComparer.OrdinalIgnoreCase.Equals(parameterLookupKey.Name, ExtensionDataProperty.Name))
                        {
                            ThrowHelper.ThrowInvalidOperationException_ExtensionDataCannotBindToCtorParam(ExtensionDataProperty.MemberName, ExtensionDataProperty);
                        }
                    }
                    ParameterCount = jsonParameters.Length;
                    ParameterCache = jsonPropertyDictionary;
                }

                internal static void ValidateType(Type type)
                {
                    if (IsInvalidForSerialization(type))
                    {
                        ThrowHelper.ThrowInvalidOperationException_CannotSerializeInvalidType(type, null, null);
                    }
                }

                internal static bool IsInvalidForSerialization(Type type)
                {
                    if (!(type == typeof(void)) && !type.IsPointer && !type.IsByRef && !IsByRefLike(type))
                    {
                        return type.ContainsGenericParameters;
                    }
                    return true;
                }

                private static bool IsByRefLike(Type type)
                {
                    if (!type.IsValueType)
                    {
                        return false;
                    }
                    object[] customAttributes = type.GetCustomAttributes(inherit: false);
                    for (int i = 0; i < customAttributes.Length; i++)
                    {
                        if (customAttributes[i].GetType().FullName == "System.Runtime.CompilerServices.IsByRefLikeAttribute")
                        {
                            return true;
                        }
                    }
                    return false;
                }

                internal static bool IsValidExtensionDataProperty(Type propertyType)
                {
                    if (!typeof(IDictionary<string, object>).IsAssignableFrom(propertyType) && !typeof(IDictionary<string, JsonElement>).IsAssignableFrom(propertyType))
                    {
                        if (propertyType.FullName == "System.Text.Json.Nodes.JsonObject")
                        {
                            return (object)propertyType.Assembly == typeof(JsonTypeInfo).Assembly;
                        }
                        return false;
                    }
                    return true;
                }

                internal JsonPropertyDictionary<JsonPropertyInfo> CreatePropertyCache(int capacity)
                {
                    return new JsonPropertyDictionary<JsonPropertyInfo>(Options.PropertyNameCaseInsensitive, capacity);
                }

                private static JsonParameterInfo CreateConstructorParameter(JsonParameterInfoValues parameterInfo, JsonPropertyInfo jsonPropertyInfo, bool sourceGenMode, JsonSerializerOptions options)
                {
                    if (jsonPropertyInfo.IsIgnored)
                    {
                        return JsonParameterInfo.CreateIgnoredParameterPlaceholder(parameterInfo, jsonPropertyInfo, sourceGenMode);
                    }
                    JsonConverter effectiveConverter = jsonPropertyInfo.EffectiveConverter;
                    JsonParameterInfo jsonParameterInfo = effectiveConverter.CreateJsonParameterInfo();
                    jsonParameterInfo.Initialize(parameterInfo, jsonPropertyInfo, options);
                    return jsonParameterInfo;
                }

                private static JsonTypeInfoKind GetTypeInfoKind(Type type, ConverterStrategy converterStrategy)
                {
                    if (type == typeof(object))
                    {
                        return JsonTypeInfoKind.None;
                    }
                    return converterStrategy switch
                    {
                        ConverterStrategy.Object => JsonTypeInfoKind.Object,
                        ConverterStrategy.Enumerable => JsonTypeInfoKind.Enumerable,
                        ConverterStrategy.Dictionary => JsonTypeInfoKind.Dictionary,
                        _ => JsonTypeInfoKind.None,
                    };
                }
            }

            /// <summary>
            /// Determines the kind of contract metadata a given <see cref="T:System.Text.Json.Serialization.Metadata.JsonTypeInfo" /> is specifying.
            /// </summary>
            public enum JsonTypeInfoKind
            {
                /// <summary>
                /// Type is either a simple value or uses a custom converter.
                /// </summary>
                None,
                /// <summary>
                /// Type is serialized as an object with properties.
                /// </summary>
                Object,
                /// <summary>
                /// Type is serialized as a collection with elements.
                /// </summary>
                Enumerable,
                /// <summary>
                /// Type is serialized as a dictionary with key/value pair entries.
                /// </summary>
                Dictionary
            }

            /// <summary>
            /// Contains utilities and combinators acting on <see cref="T:System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver" />.
            /// </summary>
            public static class JsonTypeInfoResolver
            {
                private sealed class CombiningJsonTypeInfoResolver : IJsonTypeInfoResolver
                {
                    private readonly IJsonTypeInfoResolver[] _resolvers;

                    public CombiningJsonTypeInfoResolver(IJsonTypeInfoResolver[] resolvers)
                    {
                        _resolvers = resolvers.AsSpan().ToArray();
                    }

                    public JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options)
                    {
                        IJsonTypeInfoResolver[] resolvers = _resolvers;
                        foreach (IJsonTypeInfoResolver jsonTypeInfoResolver in resolvers)
                        {
                            JsonTypeInfo typeInfo = jsonTypeInfoResolver.GetTypeInfo(type, options);
                            if (typeInfo != null)
                            {
                                return typeInfo;
                            }
                        }
                        return null;
                    }
                }

                /// <summary>
                /// Combines multiple <see cref="T:System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver" /> sources into one.
                /// </summary>
                /// <param name="resolvers">Sequence of contract resolvers to be queried for metadata.</param>
                /// <returns>A <see cref="T:System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver" /> combining results from <paramref name="resolvers" />.</returns>
                /// <exception cref="T:System.ArgumentException"><paramref name="resolvers" /> or any of its elements is null.</exception>
                /// <remarks>
                /// The combined resolver will query each of <paramref name="resolvers" /> in the specified order,
                /// returning the first result that is non-null. If all <paramref name="resolvers" /> return null,
                /// then the combined resolver will also return <see langword="null" />.
                ///
                /// Can be used to combine multiple <see cref="T:System.Text.Json.Serialization.JsonSerializerContext" /> sources,
                /// which typically define contract metadata for small subsets of types.
                /// It can also be used to fall back to <see cref="T:System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver" /> wherever necessary.
                /// </remarks>
                public static IJsonTypeInfoResolver Combine(params IJsonTypeInfoResolver[] resolvers)
                {
                    if (resolvers == null)
                    {
                        throw new ArgumentNullException("resolvers");
                    }
                    foreach (IJsonTypeInfoResolver jsonTypeInfoResolver in resolvers)
                    {
                        if (jsonTypeInfoResolver == null)
                        {
                            throw new ArgumentNullException("resolvers", MDCFR.Properties.Resources.CombineOneOfResolversIsNull);
                        }
                    }
                    return new CombiningJsonTypeInfoResolver(resolvers);
                }
            }

            internal abstract class MemberAccessor
            {
                public abstract Func<object> CreateConstructor([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] Type classType);

                public abstract Func<object[], T> CreateParameterizedConstructor<T>(ConstructorInfo constructor);

                public abstract JsonTypeInfo.ParameterizedConstructorDelegate<T, TArg0, TArg1, TArg2, TArg3> CreateParameterizedConstructor<T, TArg0, TArg1, TArg2, TArg3>(ConstructorInfo constructor);

                public abstract Action<TCollection, object> CreateAddMethodDelegate<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] TCollection>();

                [RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                [RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                public abstract Func<IEnumerable<TElement>, TCollection> CreateImmutableEnumerableCreateRangeDelegate<TCollection, TElement>();

                [RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                [RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                public abstract Func<IEnumerable<KeyValuePair<TKey, TValue>>, TCollection> CreateImmutableDictionaryCreateRangeDelegate<TCollection, TKey, TValue>();

                public abstract Func<object, TProperty> CreatePropertyGetter<TProperty>(PropertyInfo propertyInfo);

                public abstract Action<object, TProperty> CreatePropertySetter<TProperty>(PropertyInfo propertyInfo);

                public abstract Func<object, TProperty> CreateFieldGetter<TProperty>(FieldInfo fieldInfo);

                public abstract Action<object, TProperty> CreateFieldSetter<TProperty>(FieldInfo fieldInfo);
            }

            internal readonly struct ParameterRef
            {
                public readonly ulong Key;

                public readonly JsonParameterInfo Info;

                public readonly byte[] NameFromJson;

                public ParameterRef(ulong key, JsonParameterInfo info, byte[] nameFromJson)
                {
                    Key = key;
                    Info = info;
                    NameFromJson = nameFromJson;
                }
            }

            /// <summary>
            /// Validates and indexes polymorphic type configuration,
            /// providing derived JsonTypeInfo resolution methods
            /// in both serialization and deserialization scenaria.
            /// </summary>
            internal sealed class PolymorphicTypeResolver
            {
                /// <summary>
                /// Lazy JsonTypeInfo result holder for a derived type.
                /// </summary>
                private sealed class DerivedJsonTypeInfo
                {
                    private volatile JsonTypeInfo _jsonTypeInfo;

                    public Type DerivedType { get; }

                    public object TypeDiscriminator { get; }

                    public DerivedJsonTypeInfo(Type type, object typeDiscriminator)
                    {
                        DerivedType = type;
                        TypeDiscriminator = typeDiscriminator;
                    }

                    public JsonTypeInfo GetJsonTypeInfo(JsonSerializerOptions options)
                    {
                        return _jsonTypeInfo ?? (_jsonTypeInfo = options.GetTypeInfoInternal(DerivedType));
                    }
                }

                private readonly JsonTypeInfo _declaringTypeInfo;

                private readonly ConcurrentDictionary<Type, DerivedJsonTypeInfo> _typeToDiscriminatorId = new ConcurrentDictionary<Type, DerivedJsonTypeInfo>();

                private readonly Dictionary<object, DerivedJsonTypeInfo> _discriminatorIdtoType;

                public Type BaseType => _declaringTypeInfo.Type;

                public JsonUnknownDerivedTypeHandling UnknownDerivedTypeHandling { get; }

                public bool UsesTypeDiscriminators { get; }

                public bool IgnoreUnrecognizedTypeDiscriminators { get; }

                public string TypeDiscriminatorPropertyName { get; }

                public byte[] TypeDiscriminatorPropertyNameUtf8 { get; }

                public JsonEncodedText? CustomTypeDiscriminatorPropertyNameJsonEncoded { get; }

                public PolymorphicTypeResolver(JsonTypeInfo jsonTypeInfo)
                {
                    JsonPolymorphismOptions polymorphismOptions = jsonTypeInfo.PolymorphismOptions;
                    UnknownDerivedTypeHandling = polymorphismOptions.UnknownDerivedTypeHandling;
                    IgnoreUnrecognizedTypeDiscriminators = polymorphismOptions.IgnoreUnrecognizedTypeDiscriminators;
                    _declaringTypeInfo = jsonTypeInfo;
                    if (!IsSupportedPolymorphicBaseType(BaseType))
                    {
                        ThrowHelper.ThrowInvalidOperationException_TypeDoesNotSupportPolymorphism(BaseType);
                    }
                    bool flag = false;
                    foreach (JsonDerivedType derivedType in polymorphismOptions.DerivedTypes)
                    {
                        var (type2, key) = (JsonDerivedType)(derivedType);
                        if (!IsSupportedDerivedType(BaseType, type2) || (type2.IsAbstract && UnknownDerivedTypeHandling != JsonUnknownDerivedTypeHandling.FallBackToNearestAncestor))
                        {
                            ThrowHelper.ThrowInvalidOperationException_DerivedTypeNotSupported(BaseType, type2);
                        }
                        DerivedJsonTypeInfo value = new DerivedJsonTypeInfo(type2, key);
                        if (!_typeToDiscriminatorId.TryAdd(type2, value))
                        {
                            ThrowHelper.ThrowInvalidOperationException_DerivedTypeIsAlreadySpecified(BaseType, type2);
                        }
                        if (key != null)
                        {
                            if (!(_discriminatorIdtoType ?? (_discriminatorIdtoType = new Dictionary<object, DerivedJsonTypeInfo>())).TryAdd(in key, in value))
                            {
                                ThrowHelper.ThrowInvalidOperationException_TypeDicriminatorIdIsAlreadySpecified(BaseType, key);
                            }
                            UsesTypeDiscriminators = true;
                        }
                        flag = true;
                    }
                    if (!flag)
                    {
                        ThrowHelper.ThrowInvalidOperationException_PolymorphicTypeConfigurationDoesNotSpecifyDerivedTypes(BaseType);
                    }
                    if (UsesTypeDiscriminators)
                    {
                        if (!jsonTypeInfo.Converter.CanHaveMetadata)
                        {
                            ThrowHelper.ThrowNotSupportedException_BaseConverterDoesNotSupportMetadata(BaseType);
                        }
                        string typeDiscriminatorPropertyName = jsonTypeInfo.PolymorphismOptions.TypeDiscriminatorPropertyName;
                        JsonEncodedText value2 = ((typeDiscriminatorPropertyName == "$type") ? JsonSerializer.s_metadataType : JsonEncodedText.Encode(typeDiscriminatorPropertyName, jsonTypeInfo.Options.Encoder));
                        if ((JsonSerializer.GetMetadataPropertyName(value2.EncodedUtf8Bytes, null) & ~MetadataPropertyName.Type) != 0)
                        {
                            ThrowHelper.ThrowInvalidOperationException_InvalidCustomTypeDiscriminatorPropertyName();
                        }
                        TypeDiscriminatorPropertyName = typeDiscriminatorPropertyName;
                        TypeDiscriminatorPropertyNameUtf8 = value2.EncodedUtf8Bytes.ToArray();
                        CustomTypeDiscriminatorPropertyNameJsonEncoded = value2;
                    }
                }

                public bool TryGetDerivedJsonTypeInfo(Type runtimeType, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out JsonTypeInfo jsonTypeInfo, out object typeDiscriminator)
                {
                    if (!_typeToDiscriminatorId.TryGetValue(runtimeType, out var value))
                    {
                        switch (UnknownDerivedTypeHandling)
                        {
                            case JsonUnknownDerivedTypeHandling.FallBackToNearestAncestor:
                                value = CalculateNearestAncestor(runtimeType);
                                _typeToDiscriminatorId[runtimeType] = value;
                                break;
                            case JsonUnknownDerivedTypeHandling.FallBackToBaseType:
                                _typeToDiscriminatorId.TryGetValue(BaseType, out value);
                                _typeToDiscriminatorId[runtimeType] = value;
                                break;
                            default:
                                if (runtimeType != BaseType)
                                {
                                    ThrowHelper.ThrowNotSupportedException_RuntimeTypeNotSupported(BaseType, runtimeType);
                                }
                                break;
                        }
                    }
                    if (value == null)
                    {
                        jsonTypeInfo = null;
                        typeDiscriminator = null;
                        return false;
                    }
                    jsonTypeInfo = value.GetJsonTypeInfo(_declaringTypeInfo.Options);
                    typeDiscriminator = value.TypeDiscriminator;
                    return true;
                }

                public bool TryGetDerivedJsonTypeInfo(object typeDiscriminator, [System.Diagnostics.CodeAnalysis.NotNullWhen(true)] out JsonTypeInfo jsonTypeInfo)
                {
                    if (_discriminatorIdtoType.TryGetValue(typeDiscriminator, out var value))
                    {
                        jsonTypeInfo = value.GetJsonTypeInfo(_declaringTypeInfo.Options);
                        return true;
                    }
                    if (!IgnoreUnrecognizedTypeDiscriminators)
                    {
                        ThrowHelper.ThrowJsonException_UnrecognizedTypeDiscriminator(typeDiscriminator);
                    }
                    jsonTypeInfo = null;
                    return false;
                }

                public static bool IsSupportedPolymorphicBaseType(Type type)
                {
                    if (type != null && (type.IsClass || type.IsInterface) && !type.IsSealed && !type.IsGenericTypeDefinition && !type.IsPointer)
                    {
                        return type != JsonTypeInfo.ObjectType;
                    }
                    return false;
                }

                public static bool IsSupportedDerivedType(Type baseType, Type derivedType)
                {
                    if (baseType.IsAssignableFrom(derivedType))
                    {
                        return !derivedType.IsGenericTypeDefinition;
                    }
                    return false;
                }

                [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2070:UnrecognizedReflectionPattern", Justification = "The call to GetInterfaces will cross-reference results with interface types already declared as derived types of the polymorphic base type.")]
                private DerivedJsonTypeInfo CalculateNearestAncestor(Type type)
                {
                    if (type == BaseType)
                    {
                        return null;
                    }
                    DerivedJsonTypeInfo value = null;
                    Type baseType = type.BaseType;
                    while (BaseType.IsAssignableFrom(baseType) && !_typeToDiscriminatorId.TryGetValue(baseType, out value))
                    {
                        baseType = baseType.BaseType;
                    }
                    if (BaseType.IsInterface)
                    {
                        Type[] interfaces = type.GetInterfaces();
                        foreach (Type type2 in interfaces)
                        {
                            if (type2 != BaseType && BaseType.IsAssignableFrom(type2) && _typeToDiscriminatorId.TryGetValue(type2, out var value2) && value2 != null)
                            {
                                if (value == null)
                                {
                                    value = value2;
                                }
                                else
                                {
                                    ThrowHelper.ThrowNotSupportedException_RuntimeTypeDiamondAmbiguity(BaseType, type, value.DerivedType, value2.DerivedType);
                                }
                            }
                        }
                    }
                    return value;
                }
            }

            internal readonly struct PropertyRef
            {
                public readonly ulong Key;

                public readonly JsonPropertyInfo Info;

                public readonly byte[] NameFromJson;

                public PropertyRef(ulong key, JsonPropertyInfo info, byte[] nameFromJson)
                {
                    Key = key;
                    Info = info;
                    NameFromJson = nameFromJson;
                }
            }

            [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
            internal sealed class ReflectionEmitCachingMemberAccessor : MemberAccessor
            {
                private sealed class Cache<TKey>
                {
                    private sealed class CacheEntry
                    {
                        public readonly object Value;

                        public long LastUsedTicks;

                        public CacheEntry(object value)
                        {
                            Value = value;
                        }
                    }

                    private int _evictLock;

                    private long _lastEvictedTicks;

                    private readonly long _evictionIntervalTicks;

                    private readonly long _slidingExpirationTicks;

                    private readonly ConcurrentDictionary<TKey, CacheEntry> _cache = new ConcurrentDictionary<TKey, CacheEntry>();

                    public Cache(TimeSpan slidingExpiration, TimeSpan evictionInterval)
                    {
                        _slidingExpirationTicks = slidingExpiration.Ticks;
                        _evictionIntervalTicks = evictionInterval.Ticks;
                        _lastEvictedTicks = DateTime.UtcNow.Ticks;
                    }

                    public TValue GetOrAdd<TValue>(TKey key, Func<TKey, TValue> valueFactory) where TValue : class
                    {
                        CacheEntry orAdd = _cache.GetOrAdd(key, (TKey key) => new CacheEntry(valueFactory(key)));
                        long ticks = DateTime.UtcNow.Ticks;
                        Volatile.Write(ref orAdd.LastUsedTicks, ticks);
                        if (ticks - Volatile.Read(ref _lastEvictedTicks) >= _evictionIntervalTicks && Interlocked.CompareExchange(ref _evictLock, 1, 0) == 0)
                        {
                            if (ticks - _lastEvictedTicks >= _evictionIntervalTicks)
                            {
                                EvictStaleCacheEntries(ticks);
                                Volatile.Write(ref _lastEvictedTicks, ticks);
                            }
                            Volatile.Write(ref _evictLock, 0);
                        }
                        return (TValue)orAdd.Value;
                    }

                    public void Clear()
                    {
                        _cache.Clear();
                        _lastEvictedTicks = DateTime.UtcNow.Ticks;
                    }

                    private void EvictStaleCacheEntries(long utcNowTicks)
                    {
                        foreach (KeyValuePair<TKey, CacheEntry> item in _cache)
                        {
                            if (utcNowTicks - Volatile.Read(ref item.Value.LastUsedTicks) >= _slidingExpirationTicks)
                            {
                                _cache.TryRemove(item.Key, out var _);
                            }
                        }
                    }
                }

                private static readonly ReflectionEmitMemberAccessor s_sourceAccessor = new ReflectionEmitMemberAccessor();

                private static readonly Cache<(string id, Type declaringType, MemberInfo member)> s_cache = new Cache<(string, Type, MemberInfo)>(TimeSpan.FromMilliseconds(1000.0), TimeSpan.FromMilliseconds(200.0));

                public static void Clear()
                {
                    s_cache.Clear();
                }

                public override Action<TCollection, object> CreateAddMethodDelegate<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] TCollection>()
                {
                    return s_cache.GetOrAdd(("CreateAddMethodDelegate", typeof(TCollection), null), [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2091:UnrecognizedReflectionPattern", Justification = "Parent method annotation does not flow to lambda method, cf. https://github.com/dotnet/roslyn/issues/46646")] ((string id, Type declaringType, MemberInfo member) _) => s_sourceAccessor.CreateAddMethodDelegate<TCollection>());
                }

                public override Func<object> CreateConstructor([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] Type classType)
                {
                    return s_cache.GetOrAdd(("CreateConstructor", classType, null), [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2077:UnrecognizedReflectionPattern", Justification = "Cannot apply DynamicallyAccessedMembersAttribute to tuple properties.")] ((string id, Type declaringType, MemberInfo member) key) => s_sourceAccessor.CreateConstructor(key.declaringType));
                }

                public override Func<object, TProperty> CreateFieldGetter<TProperty>(FieldInfo fieldInfo)
                {
                    return s_cache.GetOrAdd(("CreateFieldGetter", typeof(TProperty), fieldInfo), ((string id, Type declaringType, MemberInfo member) key) => s_sourceAccessor.CreateFieldGetter<TProperty>((FieldInfo)key.member));
                }

                public override Action<object, TProperty> CreateFieldSetter<TProperty>(FieldInfo fieldInfo)
                {
                    return s_cache.GetOrAdd(("CreateFieldSetter", typeof(TProperty), fieldInfo), ((string id, Type declaringType, MemberInfo member) key) => s_sourceAccessor.CreateFieldSetter<TProperty>((FieldInfo)key.member));
                }

                [RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                public override Func<IEnumerable<KeyValuePair<TKey, TValue>>, TCollection> CreateImmutableDictionaryCreateRangeDelegate<TCollection, TKey, TValue>()
                {
                    return s_cache.GetOrAdd(("CreateImmutableDictionaryCreateRangeDelegate", typeof((TCollection, TKey, TValue)), null), [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "Parent method annotation does not flow to lambda method, cf. https://github.com/dotnet/roslyn/issues/46646")] ((string id, Type declaringType, MemberInfo member) _) => s_sourceAccessor.CreateImmutableDictionaryCreateRangeDelegate<TCollection, TKey, TValue>());
                }

                [RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                public override Func<IEnumerable<TElement>, TCollection> CreateImmutableEnumerableCreateRangeDelegate<TCollection, TElement>()
                {
                    return s_cache.GetOrAdd(("CreateImmutableEnumerableCreateRangeDelegate", typeof((TCollection, TElement)), null), [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "Parent method annotation does not flow to lambda method, cf. https://github.com/dotnet/roslyn/issues/46646")] ((string id, Type declaringType, MemberInfo member) _) => s_sourceAccessor.CreateImmutableEnumerableCreateRangeDelegate<TCollection, TElement>());
                }

                public override Func<object[], T> CreateParameterizedConstructor<T>(ConstructorInfo constructor)
                {
                    return s_cache.GetOrAdd(("CreateParameterizedConstructor", typeof(T), constructor), ((string id, Type declaringType, MemberInfo member) key) => s_sourceAccessor.CreateParameterizedConstructor<T>((ConstructorInfo)key.member));
                }

                public override JsonTypeInfo.ParameterizedConstructorDelegate<T, TArg0, TArg1, TArg2, TArg3> CreateParameterizedConstructor<T, TArg0, TArg1, TArg2, TArg3>(ConstructorInfo constructor)
                {
                    return s_cache.GetOrAdd(("CreateParameterizedConstructor", typeof(T), constructor), ((string id, Type declaringType, MemberInfo member) key) => s_sourceAccessor.CreateParameterizedConstructor<T, TArg0, TArg1, TArg2, TArg3>((ConstructorInfo)key.member));
                }

                public override Func<object, TProperty> CreatePropertyGetter<TProperty>(PropertyInfo propertyInfo)
                {
                    return s_cache.GetOrAdd(("CreatePropertyGetter", typeof(TProperty), propertyInfo), ((string id, Type declaringType, MemberInfo member) key) => s_sourceAccessor.CreatePropertyGetter<TProperty>((PropertyInfo)key.member));
                }

                public override Action<object, TProperty> CreatePropertySetter<TProperty>(PropertyInfo propertyInfo)
                {
                    return s_cache.GetOrAdd(("CreatePropertySetter", typeof(TProperty), propertyInfo), ((string id, Type declaringType, MemberInfo member) key) => s_sourceAccessor.CreatePropertySetter<TProperty>((PropertyInfo)key.member));
                }
            }

            [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
            internal sealed class ReflectionEmitMemberAccessor : MemberAccessor
            {
                public override Func<object> CreateConstructor([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] Type type)
                {
                    ConstructorInfo constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public, null, Type.EmptyTypes, null);
                    if (type.IsAbstract)
                    {
                        return null;
                    }
                    if (constructor == null && !type.IsValueType)
                    {
                        return null;
                    }
                    DynamicMethod dynamicMethod = new DynamicMethod(ConstructorInfo.ConstructorName, JsonTypeInfo.ObjectType, Type.EmptyTypes, typeof(ReflectionEmitMemberAccessor).Module, skipVisibility: true);
                    ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
                    if (constructor == null)
                    {
                        LocalBuilder local = iLGenerator.DeclareLocal(type);
                        iLGenerator.Emit(OpCodes.Ldloca_S, local);
                        iLGenerator.Emit(OpCodes.Initobj, type);
                        iLGenerator.Emit(OpCodes.Ldloc, local);
                        iLGenerator.Emit(OpCodes.Box, type);
                    }
                    else
                    {
                        iLGenerator.Emit(OpCodes.Newobj, constructor);
                        if (type.IsValueType)
                        {
                            iLGenerator.Emit(OpCodes.Box, type);
                        }
                    }
                    iLGenerator.Emit(OpCodes.Ret);
                    return (Func<object>)dynamicMethod.CreateDelegate(typeof(Func<object>));
                }

                public override Func<object[], T> CreateParameterizedConstructor<T>(ConstructorInfo constructor)
                {
                    return CreateDelegate<Func<object[], T>>(CreateParameterizedConstructor(constructor));
                }

                private static DynamicMethod CreateParameterizedConstructor(ConstructorInfo constructor)
                {
                    Type declaringType = constructor.DeclaringType;
                    ParameterInfo[] parameters = constructor.GetParameters();
                    int num = parameters.Length;
                    if (num > 64)
                    {
                        return null;
                    }
                    DynamicMethod dynamicMethod = new DynamicMethod(ConstructorInfo.ConstructorName, declaringType, new Type[1] { typeof(object[]) }, typeof(ReflectionEmitMemberAccessor).Module, skipVisibility: true);
                    ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
                    for (int i = 0; i < num; i++)
                    {
                        Type parameterType = parameters[i].ParameterType;
                        iLGenerator.Emit(OpCodes.Ldarg_0);
                        iLGenerator.Emit(OpCodes.Ldc_I4_S, i);
                        iLGenerator.Emit(OpCodes.Ldelem_Ref);
                        iLGenerator.Emit(OpCodes.Unbox_Any, parameterType);
                    }
                    iLGenerator.Emit(OpCodes.Newobj, constructor);
                    iLGenerator.Emit(OpCodes.Ret);
                    return dynamicMethod;
                }

                public override JsonTypeInfo.ParameterizedConstructorDelegate<T, TArg0, TArg1, TArg2, TArg3> CreateParameterizedConstructor<T, TArg0, TArg1, TArg2, TArg3>(ConstructorInfo constructor)
                {
                    return CreateDelegate<JsonTypeInfo.ParameterizedConstructorDelegate<T, TArg0, TArg1, TArg2, TArg3>>(CreateParameterizedConstructor(constructor, typeof(TArg0), typeof(TArg1), typeof(TArg2), typeof(TArg3)));
                }

                private static DynamicMethod CreateParameterizedConstructor(ConstructorInfo constructor, Type parameterType1, Type parameterType2, Type parameterType3, Type parameterType4)
                {
                    Type declaringType = constructor.DeclaringType;
                    ParameterInfo[] parameters = constructor.GetParameters();
                    int num = parameters.Length;
                    DynamicMethod dynamicMethod = new DynamicMethod(ConstructorInfo.ConstructorName, declaringType, new Type[4] { parameterType1, parameterType2, parameterType3, parameterType4 }, typeof(ReflectionEmitMemberAccessor).Module, skipVisibility: true);
                    ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
                    for (int i = 0; i < num; i++)
                    {
                        ILGenerator iLGenerator2 = iLGenerator;
                        iLGenerator2.Emit(i switch
                        {
                            0 => OpCodes.Ldarg_0,
                            1 => OpCodes.Ldarg_1,
                            2 => OpCodes.Ldarg_2,
                            3 => OpCodes.Ldarg_3,
                            _ => throw new InvalidOperationException(),
                        });
                    }
                    iLGenerator.Emit(OpCodes.Newobj, constructor);
                    iLGenerator.Emit(OpCodes.Ret);
                    return dynamicMethod;
                }

                public override Action<TCollection, object> CreateAddMethodDelegate<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] TCollection>()
                {
                    return CreateDelegate<Action<TCollection, object>>(CreateAddMethodDelegate(typeof(TCollection)));
                }

                private static DynamicMethod CreateAddMethodDelegate([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] Type collectionType)
                {
                    MethodInfo methodInfo = collectionType.GetMethod("Push") ?? collectionType.GetMethod("Enqueue");
                    DynamicMethod dynamicMethod = new DynamicMethod(methodInfo.Name, typeof(void), new Type[2]
                    {
                collectionType,
                JsonTypeInfo.ObjectType
                    }, typeof(ReflectionEmitMemberAccessor).Module, skipVisibility: true);
                    ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
                    iLGenerator.Emit(OpCodes.Ldarg_0);
                    iLGenerator.Emit(OpCodes.Ldarg_1);
                    iLGenerator.Emit(OpCodes.Callvirt, methodInfo);
                    iLGenerator.Emit(OpCodes.Ret);
                    return dynamicMethod;
                }

                [RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                [RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                public override Func<IEnumerable<TElement>, TCollection> CreateImmutableEnumerableCreateRangeDelegate<TCollection, TElement>()
                {
                    return CreateDelegate<Func<IEnumerable<TElement>, TCollection>>(CreateImmutableEnumerableCreateRangeDelegate(typeof(TCollection), typeof(TElement), typeof(IEnumerable<TElement>)));
                }

                [RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                private static DynamicMethod CreateImmutableEnumerableCreateRangeDelegate(Type collectionType, Type elementType, Type enumerableType)
                {
                    MethodInfo immutableEnumerableCreateRangeMethod = collectionType.GetImmutableEnumerableCreateRangeMethod(elementType);
                    DynamicMethod dynamicMethod = new DynamicMethod(immutableEnumerableCreateRangeMethod.Name, collectionType, new Type[1] { enumerableType }, typeof(ReflectionEmitMemberAccessor).Module, skipVisibility: true);
                    ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
                    iLGenerator.Emit(OpCodes.Ldarg_0);
                    iLGenerator.Emit(OpCodes.Call, immutableEnumerableCreateRangeMethod);
                    iLGenerator.Emit(OpCodes.Ret);
                    return dynamicMethod;
                }

                [RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                [RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                public override Func<IEnumerable<KeyValuePair<TKey, TValue>>, TCollection> CreateImmutableDictionaryCreateRangeDelegate<TCollection, TKey, TValue>()
                {
                    return CreateDelegate<Func<IEnumerable<KeyValuePair<TKey, TValue>>, TCollection>>(CreateImmutableDictionaryCreateRangeDelegate(typeof(TCollection), typeof(TKey), typeof(TValue), typeof(IEnumerable<KeyValuePair<TKey, TValue>>)));
                }

                [RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                private static DynamicMethod CreateImmutableDictionaryCreateRangeDelegate(Type collectionType, Type keyType, Type valueType, Type enumerableType)
                {
                    MethodInfo immutableDictionaryCreateRangeMethod = collectionType.GetImmutableDictionaryCreateRangeMethod(keyType, valueType);
                    DynamicMethod dynamicMethod = new DynamicMethod(immutableDictionaryCreateRangeMethod.Name, collectionType, new Type[1] { enumerableType }, typeof(ReflectionEmitMemberAccessor).Module, skipVisibility: true);
                    ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
                    iLGenerator.Emit(OpCodes.Ldarg_0);
                    iLGenerator.Emit(OpCodes.Call, immutableDictionaryCreateRangeMethod);
                    iLGenerator.Emit(OpCodes.Ret);
                    return dynamicMethod;
                }

                public override Func<object, TProperty> CreatePropertyGetter<TProperty>(PropertyInfo propertyInfo)
                {
                    return CreateDelegate<Func<object, TProperty>>(CreatePropertyGetter(propertyInfo, typeof(TProperty)));
                }

                private static DynamicMethod CreatePropertyGetter(PropertyInfo propertyInfo, Type runtimePropertyType)
                {
                    MethodInfo getMethod = propertyInfo.GetMethod;
                    Type declaringType = propertyInfo.DeclaringType;
                    Type propertyType = propertyInfo.PropertyType;
                    DynamicMethod dynamicMethod = CreateGetterMethod(propertyInfo.Name, runtimePropertyType);
                    ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
                    iLGenerator.Emit(OpCodes.Ldarg_0);
                    if (declaringType.IsValueType)
                    {
                        iLGenerator.Emit(OpCodes.Unbox, declaringType);
                        iLGenerator.Emit(OpCodes.Call, getMethod);
                    }
                    else
                    {
                        iLGenerator.Emit(OpCodes.Castclass, declaringType);
                        iLGenerator.Emit(OpCodes.Callvirt, getMethod);
                    }
                    if (propertyType != runtimePropertyType && propertyType.IsValueType)
                    {
                        iLGenerator.Emit(OpCodes.Box, propertyType);
                    }
                    iLGenerator.Emit(OpCodes.Ret);
                    return dynamicMethod;
                }

                public override Action<object, TProperty> CreatePropertySetter<TProperty>(PropertyInfo propertyInfo)
                {
                    return CreateDelegate<Action<object, TProperty>>(CreatePropertySetter(propertyInfo, typeof(TProperty)));
                }

                private static DynamicMethod CreatePropertySetter(PropertyInfo propertyInfo, Type runtimePropertyType)
                {
                    MethodInfo setMethod = propertyInfo.SetMethod;
                    Type declaringType = propertyInfo.DeclaringType;
                    Type propertyType = propertyInfo.PropertyType;
                    DynamicMethod dynamicMethod = CreateSetterMethod(propertyInfo.Name, runtimePropertyType);
                    ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
                    iLGenerator.Emit(OpCodes.Ldarg_0);
                    iLGenerator.Emit(declaringType.IsValueType ? OpCodes.Unbox : OpCodes.Castclass, declaringType);
                    iLGenerator.Emit(OpCodes.Ldarg_1);
                    if (propertyType != runtimePropertyType && propertyType.IsValueType)
                    {
                        iLGenerator.Emit(OpCodes.Unbox_Any, propertyType);
                    }
                    iLGenerator.Emit(declaringType.IsValueType ? OpCodes.Call : OpCodes.Callvirt, setMethod);
                    iLGenerator.Emit(OpCodes.Ret);
                    return dynamicMethod;
                }

                public override Func<object, TProperty> CreateFieldGetter<TProperty>(FieldInfo fieldInfo)
                {
                    return CreateDelegate<Func<object, TProperty>>(CreateFieldGetter(fieldInfo, typeof(TProperty)));
                }

                private static DynamicMethod CreateFieldGetter(FieldInfo fieldInfo, Type runtimeFieldType)
                {
                    Type declaringType = fieldInfo.DeclaringType;
                    Type fieldType = fieldInfo.FieldType;
                    DynamicMethod dynamicMethod = CreateGetterMethod(fieldInfo.Name, runtimeFieldType);
                    ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
                    iLGenerator.Emit(OpCodes.Ldarg_0);
                    iLGenerator.Emit(declaringType.IsValueType ? OpCodes.Unbox : OpCodes.Castclass, declaringType);
                    iLGenerator.Emit(OpCodes.Ldfld, fieldInfo);
                    if (fieldType.IsValueType && fieldType != runtimeFieldType)
                    {
                        iLGenerator.Emit(OpCodes.Box, fieldType);
                    }
                    iLGenerator.Emit(OpCodes.Ret);
                    return dynamicMethod;
                }

                public override Action<object, TProperty> CreateFieldSetter<TProperty>(FieldInfo fieldInfo)
                {
                    return CreateDelegate<Action<object, TProperty>>(CreateFieldSetter(fieldInfo, typeof(TProperty)));
                }

                private static DynamicMethod CreateFieldSetter(FieldInfo fieldInfo, Type runtimeFieldType)
                {
                    Type declaringType = fieldInfo.DeclaringType;
                    Type fieldType = fieldInfo.FieldType;
                    DynamicMethod dynamicMethod = CreateSetterMethod(fieldInfo.Name, runtimeFieldType);
                    ILGenerator iLGenerator = dynamicMethod.GetILGenerator();
                    iLGenerator.Emit(OpCodes.Ldarg_0);
                    iLGenerator.Emit(declaringType.IsValueType ? OpCodes.Unbox : OpCodes.Castclass, declaringType);
                    iLGenerator.Emit(OpCodes.Ldarg_1);
                    if (fieldType != runtimeFieldType && fieldType.IsValueType)
                    {
                        iLGenerator.Emit(OpCodes.Unbox_Any, fieldType);
                    }
                    iLGenerator.Emit(OpCodes.Stfld, fieldInfo);
                    iLGenerator.Emit(OpCodes.Ret);
                    return dynamicMethod;
                }

                private static DynamicMethod CreateGetterMethod(string memberName, Type memberType)
                {
                    return new DynamicMethod(memberName + "Getter", memberType, new Type[1] { JsonTypeInfo.ObjectType }, typeof(ReflectionEmitMemberAccessor).Module, skipVisibility: true);
                }

                private static DynamicMethod CreateSetterMethod(string memberName, Type memberType)
                {
                    return new DynamicMethod(memberName + "Setter", typeof(void), new Type[2]
                    {
                JsonTypeInfo.ObjectType,
                memberType
                    }, typeof(ReflectionEmitMemberAccessor).Module, skipVisibility: true);
                }

                [return: System.Diagnostics.CodeAnalysis.NotNullIfNotNull("method")]
                private static T CreateDelegate<T>(DynamicMethod method) where T : Delegate
                {
                    return (T)(method?.CreateDelegate(typeof(T)));
                }
            }

            /// <summary>
            /// Provides JSON serialization-related metadata about a type.
            /// </summary>
            internal sealed class ReflectionJsonTypeInfo<T> : JsonTypeInfo<T>
            {
                [RequiresUnreferencedCode("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
                [RequiresDynamicCode("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
                internal ReflectionJsonTypeInfo(JsonConverter converter, JsonSerializerOptions options)
                    : base(converter, options)
                {
                    base.NumberHandling = GetNumberHandlingForType(base.Type);
                    PopulatePolymorphismMetadata();
                    MapInterfaceTypesToCallbacks();
                    Func<object> func = base.Options.MemberAccessorStrategy.CreateConstructor(typeof(T));
                    SetCreateObjectIfCompatible(func);
                    base.CreateObjectForExtensionDataProperty = func;
                    converter.ConfigureJsonTypeInfo(this, options);
                    converter.ConfigureJsonTypeInfoUsingReflection(this, options);
                }

                [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2075:RequiresUnreferencedCode", Justification = "The ctor is marked RequiresUnreferencedCode.")]
                internal override void LateAddProperties()
                {
                    if (base.Kind != JsonTypeInfoKind.Object)
                    {
                        return;
                    }
                    Dictionary<string, JsonPropertyInfo> ignoredMembers = null;
                    bool propertyOrderSpecified = false;
                    bool shouldCheckForRequiredKeyword = typeof(T).HasRequiredMemberAttribute() && !(base.Converter.ConstructorInfo?.HasSetsRequiredMembersAttribute() ?? false);
                    Type type = base.Type;
                    while (type != null)
                    {
                        PropertyInfo[] properties = type.GetProperties(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                        if (base.PropertyCache == null)
                        {
                            JsonPropertyDictionary<JsonPropertyInfo> jsonPropertyDictionary2 = (base.PropertyCache = CreatePropertyCache(properties.Length));
                        }
                        PropertyInfo[] array = properties;
                        foreach (PropertyInfo propertyInfo in array)
                        {
                            string name = propertyInfo.Name;
                            if (propertyInfo.GetIndexParameters().Length != 0 || PropertyIsOverriddenAndIgnored(name, propertyInfo.PropertyType, propertyInfo.IsVirtual(), ignoredMembers))
                            {
                                continue;
                            }
                            MethodInfo getMethod = propertyInfo.GetMethod;
                            if ((object)getMethod == null || !getMethod.IsPublic)
                            {
                                MethodInfo setMethod = propertyInfo.SetMethod;
                                if ((object)setMethod == null || !setMethod.IsPublic)
                                {
                                    if (propertyInfo.GetCustomAttribute<JsonIncludeAttribute>(inherit: false) != null)
                                    {
                                        ThrowHelper.ThrowInvalidOperationException_JsonIncludeOnNonPublicInvalid(name, type);
                                    }
                                    continue;
                                }
                            }
                            CacheMember(propertyInfo.PropertyType, propertyInfo, ref propertyOrderSpecified, ref ignoredMembers, shouldCheckForRequiredKeyword);
                        }
                        FieldInfo[] fields = type.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
                        foreach (FieldInfo fieldInfo in fields)
                        {
                            string name2 = fieldInfo.Name;
                            if (PropertyIsOverriddenAndIgnored(name2, fieldInfo.FieldType, currentMemberIsVirtual: false, ignoredMembers))
                            {
                                continue;
                            }
                            bool flag = fieldInfo.GetCustomAttribute<JsonIncludeAttribute>(inherit: false) != null;
                            if (fieldInfo.IsPublic)
                            {
                                if (flag || base.Options.IncludeFields)
                                {
                                    CacheMember(fieldInfo.FieldType, fieldInfo, ref propertyOrderSpecified, ref ignoredMembers, shouldCheckForRequiredKeyword);
                                }
                            }
                            else if (flag)
                            {
                                ThrowHelper.ThrowInvalidOperationException_JsonIncludeOnNonPublicInvalid(name2, type);
                            }
                        }
                        type = type.BaseType;
                    }
                    if (propertyOrderSpecified)
                    {
                        base.PropertyCache.List.StableSortByKey<KeyValuePair<string, JsonPropertyInfo>, int>((KeyValuePair<string, JsonPropertyInfo> p) => p.Value.Order);
                    }
                }

                private void CacheMember(Type typeToConvert, MemberInfo memberInfo, ref bool propertyOrderSpecified, ref Dictionary<string, JsonPropertyInfo> ignoredMembers, bool shouldCheckForRequiredKeyword)
                {
                    JsonPropertyInfo jsonPropertyInfo = CreateProperty(typeToConvert, memberInfo, base.Options, shouldCheckForRequiredKeyword);
                    if (jsonPropertyInfo != null)
                    {
                        CacheMember(jsonPropertyInfo, base.PropertyCache, ref ignoredMembers);
                        propertyOrderSpecified |= jsonPropertyInfo.Order != 0;
                    }
                }

                [UnconditionalSuppressMessage("ReflectionAnalysis", "IL2026:RequiresUnreferencedCode", Justification = "The ctor is marked as RequiresUnreferencedCode")]
                [UnconditionalSuppressMessage("AotAnalysis", "IL3050:RequiresDynamicCode", Justification = "The ctor is marked RequiresDynamicCode.")]
                private JsonPropertyInfo CreateProperty(Type typeToConvert, MemberInfo memberInfo, JsonSerializerOptions options, bool shouldCheckForRequiredKeyword)
                {
                    JsonIgnoreCondition? jsonIgnoreCondition = memberInfo.GetCustomAttribute<JsonIgnoreAttribute>(inherit: false)?.Condition;
                    if (JsonTypeInfo.IsInvalidForSerialization(typeToConvert))
                    {
                        if (jsonIgnoreCondition == JsonIgnoreCondition.Always)
                        {
                            return null;
                        }
                        ThrowHelper.ThrowInvalidOperationException_CannotSerializeInvalidType(typeToConvert, memberInfo.DeclaringType, memberInfo);
                    }
                    JsonConverter customConverterForMember;
                    try
                    {
                        customConverterForMember = DefaultJsonTypeInfoResolver.GetCustomConverterForMember(typeToConvert, memberInfo, options);
                    }
                    catch (InvalidOperationException) when (jsonIgnoreCondition == JsonIgnoreCondition.Always)
                    {
                        return null;
                    }
                    JsonPropertyInfo jsonPropertyInfo = CreatePropertyUsingReflection(typeToConvert);
                    jsonPropertyInfo.InitializeUsingMemberReflection(memberInfo, customConverterForMember, jsonIgnoreCondition, shouldCheckForRequiredKeyword);
                    return jsonPropertyInfo;
                }

                private static JsonNumberHandling? GetNumberHandlingForType(Type type)
                {
                    return type.GetUniqueCustomAttribute<JsonNumberHandlingAttribute>(inherit: false)?.Handling;
                }

                private static bool PropertyIsOverriddenAndIgnored(string currentMemberName, Type currentMemberType, bool currentMemberIsVirtual, Dictionary<string, JsonPropertyInfo> ignoredMembers)
                {
                    if (ignoredMembers == null || !ignoredMembers.TryGetValue(currentMemberName, out var value))
                    {
                        return false;
                    }
                    if (currentMemberType == value.PropertyType && currentMemberIsVirtual)
                    {
                        return value.IsVirtual;
                    }
                    return false;
                }

                internal override JsonParameterInfoValues[] GetParameterInfoValues()
                {
                    ParameterInfo[] parameters = base.Converter.ConstructorInfo.GetParameters();
                    int num = parameters.Length;
                    JsonParameterInfoValues[] array = new JsonParameterInfoValues[num];
                    for (int i = 0; i < num; i++)
                    {
                        ParameterInfo parameterInfo = parameters[i];
                        if (string.IsNullOrEmpty(parameterInfo.Name))
                        {
                            ThrowHelper.ThrowNotSupportedException_ConstructorContainsNullParameterNames(base.Converter.ConstructorInfo.DeclaringType);
                        }
                        JsonParameterInfoValues jsonParameterInfoValues = new JsonParameterInfoValues
                        {
                            Name = parameterInfo.Name,
                            ParameterType = parameterInfo.ParameterType,
                            Position = parameterInfo.Position,
                            HasDefaultValue = parameterInfo.HasDefaultValue,
                            DefaultValue = parameterInfo.GetDefaultValue()
                        };
                        array[i] = jsonParameterInfoValues;
                    }
                    return array;
                }
            }

            internal sealed class ReflectionMemberAccessor : MemberAccessor
            {
                private sealed class ConstructorContext
                {
                    [DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)]
                    private readonly Type _type;

                    public ConstructorContext([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] Type type)
                    {
                        _type = type;
                    }

                    public object CreateInstance()
                    {
                        return Activator.CreateInstance(_type, nonPublic: false);
                    }
                }

                public override Func<object> CreateConstructor([DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] Type type)
                {
                    ConstructorInfo constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public, null, Type.EmptyTypes, null);
                    if (type.IsAbstract)
                    {
                        return null;
                    }
                    if (constructor == null && !type.IsValueType)
                    {
                        return null;
                    }
                    return new ConstructorContext(type).CreateInstance;
                }

                public override Func<object[], T> CreateParameterizedConstructor<T>(ConstructorInfo constructor)
                {
                    Type typeFromHandle = typeof(T);
                    int parameterCount = constructor.GetParameters().Length;
                    if (parameterCount > 64)
                    {
                        return null;
                    }
                    return delegate (object[] arguments)
                    {
                        object[] array = new object[parameterCount];
                        for (int i = 0; i < parameterCount; i++)
                        {
                            array[i] = arguments[i];
                        }
                        try
                        {
                            return (T)constructor.Invoke(array);
                        }
                        catch (TargetInvocationException ex)
                        {
                            throw ex.InnerException ?? ex;
                        }
                    };
                }

                public override JsonTypeInfo.ParameterizedConstructorDelegate<T, TArg0, TArg1, TArg2, TArg3> CreateParameterizedConstructor<T, TArg0, TArg1, TArg2, TArg3>(ConstructorInfo constructor)
                {
                    Type typeFromHandle = typeof(T);
                    int parameterCount = constructor.GetParameters().Length;
                    return delegate (TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3)
                    {
                        object[] array = new object[parameterCount];
                        for (int i = 0; i < parameterCount; i++)
                        {
                            switch (i)
                            {
                                case 0:
                                    array[0] = arg0;
                                    break;
                                case 1:
                                    array[1] = arg1;
                                    break;
                                case 2:
                                    array[2] = arg2;
                                    break;
                                case 3:
                                    array[3] = arg3;
                                    break;
                                default:
                                    throw new InvalidOperationException();
                            }
                        }
                        return (T)constructor.Invoke(array);
                    };
                }

                public override Action<TCollection, object> CreateAddMethodDelegate<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicMethods)] TCollection>()
                {
                    Type typeFromHandle = typeof(TCollection);
                    Type objectType = JsonTypeInfo.ObjectType;
                    MethodInfo addMethod = typeFromHandle.GetMethod("Push") ?? typeFromHandle.GetMethod("Enqueue");
                    return delegate (TCollection collection, object element)
                    {
                        addMethod.Invoke(collection, new object[1] { element });
                    };
                }

                [RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                [RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                public override Func<IEnumerable<TElement>, TCollection> CreateImmutableEnumerableCreateRangeDelegate<TCollection, TElement>()
                {
                    MethodInfo immutableEnumerableCreateRangeMethod = typeof(TCollection).GetImmutableEnumerableCreateRangeMethod(typeof(TElement));
                    return (Func<IEnumerable<TElement>, TCollection>)immutableEnumerableCreateRangeMethod.CreateDelegate(typeof(Func<IEnumerable<TElement>, TCollection>));
                }

                [RequiresUnreferencedCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                [RequiresDynamicCode("System.Collections.Immutable converters use Reflection to find and create Immutable Collection types, which requires unreferenced code.")]
                public override Func<IEnumerable<KeyValuePair<TKey, TValue>>, TCollection> CreateImmutableDictionaryCreateRangeDelegate<TCollection, TKey, TValue>()
                {
                    MethodInfo immutableDictionaryCreateRangeMethod = typeof(TCollection).GetImmutableDictionaryCreateRangeMethod(typeof(TKey), typeof(TValue));
                    return (Func<IEnumerable<KeyValuePair<TKey, TValue>>, TCollection>)immutableDictionaryCreateRangeMethod.CreateDelegate(typeof(Func<IEnumerable<KeyValuePair<TKey, TValue>>, TCollection>));
                }

                public override Func<object, TProperty> CreatePropertyGetter<TProperty>(PropertyInfo propertyInfo)
                {
                    MethodInfo getMethodInfo = propertyInfo.GetMethod;
                    return (object obj) => (TProperty)getMethodInfo.Invoke(obj, null);
                }

                public override Action<object, TProperty> CreatePropertySetter<TProperty>(PropertyInfo propertyInfo)
                {
                    MethodInfo setMethodInfo = propertyInfo.SetMethod;
                    return delegate (object obj, TProperty value)
                    {
                        setMethodInfo.Invoke(obj, new object[1] { value });
                    };
                }

                public override Func<object, TProperty> CreateFieldGetter<TProperty>(FieldInfo fieldInfo)
                {
                    return (object obj) => (TProperty)fieldInfo.GetValue(obj);
                }

                public override Action<object, TProperty> CreateFieldSetter<TProperty>(FieldInfo fieldInfo)
                {
                    return delegate (object obj, TProperty value)
                    {
                        fieldInfo.SetValue(obj, value);
                    };
                }
            }

            /// <summary>
            /// Creates and initializes serialization metadata for a type.
            /// </summary>
            /// <typeparam name="T"></typeparam>
            internal sealed class SourceGenJsonTypeInfo<T> : JsonTypeInfo<T>
            {
                /// <summary>
                /// Creates serialization metadata for a type using a simple converter.
                /// </summary>
                public SourceGenJsonTypeInfo(JsonConverter converter, JsonSerializerOptions options)
                    : base(converter, options)
                {
                    PopulatePolymorphismMetadata();
                    MapInterfaceTypesToCallbacks();
                    converter.ConfigureJsonTypeInfo(this, options);
                }

                /// <summary>
                /// Creates serialization metadata for an object.
                /// </summary>
                public SourceGenJsonTypeInfo(JsonSerializerOptions options, JsonObjectInfoValues<T> objectInfo)
                    : base(GetConverter(objectInfo), options)
                {
                    if (objectInfo.ObjectWithParameterizedConstructorCreator != null)
                    {
                        base.CreateObjectWithArgs = objectInfo.ObjectWithParameterizedConstructorCreator;
                        CtorParamInitFunc = objectInfo.ConstructorParameterMetadataInitializer;
                    }
                    else
                    {
                        SetCreateObjectIfCompatible(objectInfo.ObjectCreator);
                        base.CreateObjectForExtensionDataProperty = ((JsonTypeInfo)this).CreateObject;
                    }
                    PropInitFunc = objectInfo.PropertyMetadataInitializer;
                    base.SerializeHandler = objectInfo.SerializeHandler;
                    base.NumberHandling = objectInfo.NumberHandling;
                    PopulatePolymorphismMetadata();
                    MapInterfaceTypesToCallbacks();
                    base.Converter.ConfigureJsonTypeInfo(this, options);
                }

                /// <summary>
                /// Creates serialization metadata for a collection.
                /// </summary>
                public SourceGenJsonTypeInfo(JsonSerializerOptions options, JsonCollectionInfoValues<T> collectionInfo, Func<JsonConverter<T>> converterCreator, object createObjectWithArgs = null, object addFunc = null)
                    : base((JsonConverter)new JsonMetadataServicesConverter<T>(converterCreator()), options)
                {
                    if (collectionInfo == null)
                    {
                        ThrowHelper.ThrowArgumentNullException("collectionInfo");
                    }
                    base.KeyTypeInfo = collectionInfo.KeyInfo;
                    base.ElementTypeInfo = collectionInfo.ElementInfo;
                    base.NumberHandling = collectionInfo.NumberHandling;
                    base.SerializeHandler = collectionInfo.SerializeHandler;
                    base.CreateObjectWithArgs = createObjectWithArgs;
                    base.AddMethodDelegate = addFunc;
                    SetCreateObjectIfCompatible(collectionInfo.ObjectCreator);
                    PopulatePolymorphismMetadata();
                    MapInterfaceTypesToCallbacks();
                    base.Converter.ConfigureJsonTypeInfo(this, options);
                }

                private static JsonConverter GetConverter(JsonObjectInfoValues<T> objectInfo)
                {
                    if (objectInfo.ObjectWithParameterizedConstructorCreator != null)
                    {
                        return new JsonMetadataServicesConverter<T>(() => new LargeObjectWithParameterizedConstructorConverter<T>(), ConverterStrategy.Object);
                    }
                    return new JsonMetadataServicesConverter<T>(() => new ObjectDefaultConverter<T>(), ConverterStrategy.Object);
                }

                internal override JsonParameterInfoValues[] GetParameterInfoValues()
                {
                    JsonParameterInfoValues[] result;
                    if (CtorParamInitFunc == null || (result = CtorParamInitFunc()) == null)
                    {
                        if (base.SerializeHandler == null)
                        {
                            ThrowHelper.ThrowInvalidOperationException_NoMetadataForTypeCtorParams(base.Options.TypeInfoResolver, base.Type);
                        }
                        result = Array.Empty<JsonParameterInfoValues>();
                        base.MetadataSerializationNotSupported = true;
                    }
                    return result;
                }

                internal override void LateAddProperties()
                {
                    if (base.Kind != JsonTypeInfoKind.Object)
                    {
                        return;
                    }
                    JsonSerializerContext serializerContext = base.Options.SerializerContext;
                    JsonPropertyInfo[] array;
                    if (PropInitFunc == null || (array = PropInitFunc(serializerContext)) == null)
                    {
                        if (!(typeof(T) == typeof(object)) && !(base.Converter.ElementType != null))
                        {
                            if (base.SerializeHandler == null)
                            {
                                ThrowHelper.ThrowInvalidOperationException_NoMetadataForTypeProperties(base.Options.TypeInfoResolver, base.Type);
                            }
                            base.MetadataSerializationNotSupported = true;
                        }
                        return;
                    }
                    Dictionary<string, JsonPropertyInfo> ignoredMembers = null;
                    JsonPropertyDictionary<JsonPropertyInfo> propertyCache = CreatePropertyCache(array.Length);
                    foreach (JsonPropertyInfo jsonPropertyInfo in array)
                    {
                        bool srcGen_HasJsonInclude = jsonPropertyInfo.SrcGen_HasJsonInclude;
                        if (!jsonPropertyInfo.SrcGen_IsPublic)
                        {
                            if (srcGen_HasJsonInclude)
                            {
                                ThrowHelper.ThrowInvalidOperationException_JsonIncludeOnNonPublicInvalid(jsonPropertyInfo.MemberName, jsonPropertyInfo.DeclaringType);
                            }
                        }
                        else if (jsonPropertyInfo.MemberType != MemberTypes.Field || srcGen_HasJsonInclude || base.Options.IncludeFields)
                        {
                            CacheMember(jsonPropertyInfo, propertyCache, ref ignoredMembers);
                        }
                    }
                    base.PropertyCache = propertyCache;
                }
            }

        }

    }

}


