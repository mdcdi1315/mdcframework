
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.IO;
using System.Text;
using System.Threading;
using System.Collections;
using System.Diagnostics;
using System.IO.Compression;
using System.Reflection.Internal;
using System.Collections.Generic;
using System.Reflection.Metadata;
using System.Collections.Immutable;
using System.IO.MemoryMappedFiles;
using System.Runtime.InteropServices;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Reflection.Metadata.Ecma335;

#nullable enable

namespace System.Reflection
{
	[Flags]
	public enum AssemblyFlags
	{
		/// <summary>
		/// The assembly reference holds the full (unhashed) public key.
		/// Not applicable on assembly definition.
		/// </summary>
		PublicKey = 1,
		/// <summary>
		/// The implementation of the referenced assembly used at runtime is not expected to match the version seen at compile time.
		/// </summary>
		Retargetable = 0x100,
		/// <summary>
		/// The assembly contains Windows Runtime code.
		/// </summary>
		WindowsRuntime = 0x200,
		/// <summary>
		/// Content type mask. Masked bits correspond to values of <see cref="T:System.Reflection.AssemblyContentType" />.
		/// </summary>
		ContentTypeMask = 0xE00,
		/// <summary>
		/// Specifies that just-in-time (JIT) compiler optimization is disabled for the assembly.
		/// </summary>
		DisableJitCompileOptimizer = 0x4000,
		/// <summary>
		/// Specifies that just-in-time (JIT) compiler tracking is enabled for the assembly.
		/// </summary>
		EnableJitCompileTracking = 0x8000
	}

	/// <summary>
	/// Specifies all the hash algorithms used for hashing assembly files and for generating the strong name.
	/// </summary>
	public enum AssemblyHashAlgorithm
	{
		/// <summary>
		/// A mask indicating that there is no hash algorithm. If you specify None for a multi-module assembly, the common language runtime defaults to the SHA1 algorithm, since multi-module assemblies need to generate a hash.
		/// </summary>
		None = 0,
		/// <summary>
		/// Retrieves the MD5 message-digest algorithm. MD5 was developed by Rivest in 1991. It is basically MD4 with safety-belts and while it is slightly slower than MD4, it helps provide more security. The algorithm consists of four distinct rounds, which has a slightly different design from that of MD4. Message-digest size, as well as padding requirements, remain the same.
		/// </summary>
		MD5 = 32771,
		/// <summary>
		/// Retrieves a revision of the Secure Hash Algorithm that corrects an unpublished flaw in SHA.
		/// </summary>
		Sha1 = 32772,
		/// <summary>
		/// Retrieves a version of the Secure Hash Algorithm with a hash size of 256 bits.
		/// </summary>
		Sha256 = 32780,
		/// <summary>
		/// Retrieves a version of the Secure Hash Algorithm with a hash size of 384 bits.
		/// </summary>
		Sha384 = 32781,
		/// <summary>
		/// Retrieves a version of the Secure Hash Algorithm with a hash size of 512 bits.
		/// </summary>
		Sha512 = 32782
	}

	internal static class BlobUtilities
	{
		public const int SizeOfSerializedDecimal = 13;

		public const int SizeOfGuid = 16;

		public unsafe static byte[] ReadBytes(byte* buffer, int byteCount)
		{
			if (byteCount == 0)
			{
				return Array.Empty<byte>();
			}
			byte[] array = new byte[byteCount];
			Marshal.Copy((IntPtr)buffer, array, 0, byteCount);
			return array;
		}

		public unsafe static System.Collections.Immutable.ImmutableArray<byte> ReadImmutableBytes(byte* buffer, int byteCount)
		{
			byte[] array = ReadBytes(buffer, byteCount);
			return ImmutableByteArrayInterop.DangerousCreateFromUnderlyingArray(ref array);
		}

		public unsafe static void WriteBytes(this byte[] buffer, int start, byte value, int byteCount)
		{
			fixed (byte* ptr = &buffer[0])
			{
				byte* ptr2 = ptr + start;
				for (int i = 0; i < byteCount; i++)
				{
					ptr2[i] = value;
				}
			}
		}

		public unsafe static void WriteDouble(this byte[] buffer, int start, double value)
		{
			buffer.WriteUInt64(start, *(ulong*)(&value));
		}

		public unsafe static void WriteSingle(this byte[] buffer, int start, float value)
		{
			buffer.WriteUInt32(start, *(uint*)(&value));
		}

		public static void WriteByte(this byte[] buffer, int start, byte value)
		{
			buffer[start] = value;
		}

		public unsafe static void WriteUInt16(this byte[] buffer, int start, ushort value)
		{
			fixed (byte* ptr = &buffer[start])
			{
				*ptr = (byte)value;
				ptr[1] = (byte)(value >> 8);
			}
		}

		public unsafe static void WriteUInt16BE(this byte[] buffer, int start, ushort value)
		{
			fixed (byte* ptr = &buffer[start])
			{
				*ptr = (byte)(value >> 8);
				ptr[1] = (byte)value;
			}
		}

		public unsafe static void WriteUInt32BE(this byte[] buffer, int start, uint value)
		{
			fixed (byte* ptr = &buffer[start])
			{
				*ptr = (byte)(value >> 24);
				ptr[1] = (byte)(value >> 16);
				ptr[2] = (byte)(value >> 8);
				ptr[3] = (byte)value;
			}
		}

		public unsafe static void WriteUInt32(this byte[] buffer, int start, uint value)
		{
			fixed (byte* ptr = &buffer[start])
			{
				*ptr = (byte)value;
				ptr[1] = (byte)(value >> 8);
				ptr[2] = (byte)(value >> 16);
				ptr[3] = (byte)(value >> 24);
			}
		}

		public static void WriteUInt64(this byte[] buffer, int start, ulong value)
		{
			buffer.WriteUInt32(start, (uint)value);
			buffer.WriteUInt32(start + 4, (uint)(value >> 32));
		}

		public static void WriteDecimal(this byte[] buffer, int start, decimal value)
		{
			value.GetBits(out var isNegative, out var scale, out var low, out var mid, out var high);
			buffer.WriteByte(start, (byte)(scale | (isNegative ? 128u : 0u)));
			buffer.WriteUInt32(start + 1, low);
			buffer.WriteUInt32(start + 5, mid);
			buffer.WriteUInt32(start + 9, high);
		}

		public unsafe static void WriteGuid(this byte[] buffer, int start, Guid value)
		{
			fixed (byte* ptr2 = &buffer[start])
			{
				byte* ptr = (byte*)(&value);
				uint num = *(uint*)ptr;
				*ptr2 = (byte)num;
				ptr2[1] = (byte)(num >> 8);
				ptr2[2] = (byte)(num >> 16);
				ptr2[3] = (byte)(num >> 24);
				ushort num2 = *(ushort*)(ptr + 4);
				ptr2[4] = (byte)num2;
				ptr2[5] = (byte)(num2 >> 8);
				ushort num3 = *(ushort*)(ptr + 6);
				ptr2[6] = (byte)num3;
				ptr2[7] = (byte)(num3 >> 8);
				ptr2[8] = ptr[8];
				ptr2[9] = ptr[9];
				ptr2[10] = ptr[10];
				ptr2[11] = ptr[11];
				ptr2[12] = ptr[12];
				ptr2[13] = ptr[13];
				ptr2[14] = ptr[14];
				ptr2[15] = ptr[15];
			}
		}

		public unsafe static void WriteUTF8(this byte[] buffer, int start, char* charPtr, int charCount, int byteCount, bool allowUnpairedSurrogates)
		{
			char* ptr = charPtr + charCount;
			fixed (byte* ptr2 = &buffer[0])
			{
				byte* ptr3 = ptr2 + start;
				if (byteCount == charCount)
				{
					while (charPtr < ptr)
					{
						*(ptr3++) = (byte)(*(charPtr++));
					}
					return;
				}
				while (charPtr < ptr)
				{
					char c = *(charPtr++);
					if (c < '\u0080')
					{
						*(ptr3++) = (byte)c;
						continue;
					}
					if (c < 'ࠀ')
					{
						*ptr3 = (byte)(((uint)((int)c >> 6) & 0x1Fu) | 0xC0u);
						ptr3[1] = (byte)((c & 0x3Fu) | 0x80u);
						ptr3 += 2;
						continue;
					}
					if (IsSurrogateChar(c))
					{
						if (IsHighSurrogateChar(c) && charPtr < ptr && IsLowSurrogateChar(*charPtr))
						{
							int num = c;
							int num2 = *(charPtr++);
							int num3 = (num - 55296 << 10) + num2 - 56320 + 65536;
							*ptr3 = (byte)(((uint)(num3 >> 18) & 7u) | 0xF0u);
							ptr3[1] = (byte)(((uint)(num3 >> 12) & 0x3Fu) | 0x80u);
							ptr3[2] = (byte)(((uint)(num3 >> 6) & 0x3Fu) | 0x80u);
							ptr3[3] = (byte)(((uint)num3 & 0x3Fu) | 0x80u);
							ptr3 += 4;
							continue;
						}
						if (!allowUnpairedSurrogates)
						{
							c = '\ufffd';
						}
					}
					*ptr3 = (byte)(((uint)((int)c >> 12) & 0xFu) | 0xE0u);
					ptr3[1] = (byte)(((uint)((int)c >> 6) & 0x3Fu) | 0x80u);
					ptr3[2] = (byte)((c & 0x3Fu) | 0x80u);
					ptr3 += 3;
				}
			}
		}

		internal unsafe static int GetUTF8ByteCount(string str)
		{
			fixed (char* str2 = str)
			{
				return GetUTF8ByteCount(str2, str.Length);
			}
		}

		internal unsafe static int GetUTF8ByteCount(char* str, int charCount)
		{
			char* remainder;
			return GetUTF8ByteCount(str, charCount, int.MaxValue, out remainder);
		}

		internal unsafe static int GetUTF8ByteCount(char* str, int charCount, int byteLimit, out char* remainder)
		{
			char* ptr = str + charCount;
			char* ptr2 = str;
			int num = 0;
			while (ptr2 < ptr)
			{
				char c = *(ptr2++);
				int num2;
				if (c < '\u0080')
				{
					num2 = 1;
				}
				else if (c < 'ࠀ')
				{
					num2 = 2;
				}
				else if (IsHighSurrogateChar(c) && ptr2 < ptr && IsLowSurrogateChar(*ptr2))
				{
					num2 = 4;
					ptr2++;
				}
				else
				{
					num2 = 3;
				}
				if (num + num2 > byteLimit)
				{
					ptr2 -= ((num2 < 4) ? 1 : 2);
					break;
				}
				num += num2;
			}
			remainder = ptr2;
			return num;
		}

		internal static bool IsSurrogateChar(int c)
		{
			return (uint)(c - 55296) <= 2047u;
		}

		internal static bool IsHighSurrogateChar(int c)
		{
			return (uint)(c - 55296) <= 1023u;
		}

		internal static bool IsLowSurrogateChar(int c)
		{
			return (uint)(c - 56320) <= 1023u;
		}

		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ValidateRange(int bufferLength, int start, int byteCount, string byteCountParameterName)
		{
			if (start < 0 || start > bufferLength)
			{
				System.Reflection.Throw.ArgumentOutOfRange("start");
			}
			if (byteCount < 0 || byteCount > bufferLength - start)
			{
				System.Reflection.Throw.ArgumentOutOfRange(byteCountParameterName);
			}
		}

		internal static int GetUserStringByteLength(int characterCount)
		{
			return characterCount * 2 + 1;
		}

		internal static byte GetUserStringTrailingByte(string str)
		{
			foreach (char c in str)
			{
				if (c >= '\u007f')
				{
					return 1;
				}
				switch (c)
				{
				case '\u0001':
				case '\u0002':
				case '\u0003':
				case '\u0004':
				case '\u0005':
				case '\u0006':
				case '\a':
				case '\b':
				case '\u000e':
				case '\u000f':
				case '\u0010':
				case '\u0011':
				case '\u0012':
				case '\u0013':
				case '\u0014':
				case '\u0015':
				case '\u0016':
				case '\u0017':
				case '\u0018':
				case '\u0019':
				case '\u001a':
				case '\u001b':
				case '\u001c':
				case '\u001d':
				case '\u001e':
				case '\u001f':
				case '\'':
				case '-':
					return 1;
				}
			}
			return 0;
		}
	}

	/// <summary>
	/// Specifies the security actions that can be performed using declarative security.
	/// </summary>
	public enum DeclarativeSecurityAction : short
	{
		/// <summary>
		/// No declarative security action.
		/// </summary>
		None = 0,
		/// <summary>
		/// Check that all callers in the call chain have been granted specified permission,
		/// </summary>
		Demand = 2,
		/// <summary>
		/// The calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.
		/// </summary>
		Assert = 3,
		/// <summary>
		/// Without further checks refuse Demand for the specified permission.
		/// </summary>
		Deny = 4,
		/// <summary>
		/// Without further checks, refuse Demand for all permissions other than those specified.
		/// </summary>
		PermitOnly = 5,
		/// <summary>
		/// Check that the immediate caller has been granted the specified permission;
		/// </summary>
		LinkDemand = 6,
		/// <summary>
		/// The derived class inheriting the class or overriding a method is required to have been granted the specified permission.
		/// </summary>
		InheritanceDemand = 7,
		/// <summary>
		/// The request for the minimum permissions required for code to run. This action can only be used within the scope of the assembly.
		/// </summary>
		RequestMinimum = 8,
		/// <summary>
		/// The request for additional permissions that are optional (not required to run). This request implicitly refuses all other permissions not specifically requested. This action can only be used within the scope of the assembly.
		/// </summary>
		RequestOptional = 9,
		/// <summary>
		/// The request that permissions that might be misused will not be granted to the calling code. This action can only be used within the scope of the assembly.
		/// </summary>
		RequestRefuse = 10
	}

	[Flags]
	public enum ManifestResourceAttributes
	{
		/// <summary>
		/// The Resource is exported from the Assembly
		/// </summary>
		Public = 1,
		/// <summary>
		/// The Resource is not exported from the Assembly
		/// </summary>
		Private = 2,
		/// <summary>
		/// Masks just the visibility-related attributes.
		/// </summary>
		VisibilityMask = 7
	}

	[Flags]
	public enum MethodImportAttributes : short
	{
		None = 0,
		ExactSpelling = 1,
		BestFitMappingDisable = 0x20,
		BestFitMappingEnable = 0x10,
		BestFitMappingMask = 0x30,
		CharSetAnsi = 2,
		CharSetUnicode = 4,
		CharSetAuto = 6,
		CharSetMask = 6,
		ThrowOnUnmappableCharEnable = 0x1000,
		ThrowOnUnmappableCharDisable = 0x2000,
		ThrowOnUnmappableCharMask = 0x3000,
		SetLastError = 0x40,
		CallingConventionWinApi = 0x100,
		CallingConventionCDecl = 0x200,
		CallingConventionStdCall = 0x300,
		CallingConventionThisCall = 0x400,
		CallingConventionFastCall = 0x500,
		CallingConventionMask = 0x700
	}

	[Flags]
	public enum MethodSemanticsAttributes
	{
		/// <summary>
		/// Used to modify the value of the property.
		/// CLS-compliant setters are named with set_ prefix.
		/// </summary>
		Setter = 1,
		/// <summary>
		/// Used to read the value of the property.
		/// CLS-compliant getters are named with get_ prefix.
		/// </summary>
		Getter = 2,
		/// <summary>
		/// Other method for property (not getter or setter) or event (not adder, remover, or raiser).
		/// </summary>
		Other = 4,
		/// <summary>
		/// Used to add a handler for an event.
		/// Corresponds to the AddOn flag in the Ecma 335 CLI specification.
		/// CLS-compliant adders are named with add_ prefix.
		/// </summary>
		Adder = 8,
		/// <summary>
		/// Used to remove a handler for an event.
		/// Corresponds to the RemoveOn flag in the Ecma 335 CLI specification.
		/// CLS-compliant removers are named with remove_ prefix.
		/// </summary>
		Remover = 0x10,
		/// <summary>
		/// Used to indicate that an event has occurred.
		/// Corresponds to the Fire flag in the Ecma 335 CLI specification.
		/// CLS-compliant raisers are named with raise_ prefix.
		/// </summary>
		Raiser = 0x20
	}

	internal static class Throw
	{
		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void InvalidCast()
		{
			throw new InvalidCastException();
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void InvalidArgument(string message, string parameterName)
		{
			throw new ArgumentException(message, parameterName);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void InvalidArgument_OffsetForVirtualHeapHandle()
		{
			throw new ArgumentException(MDCFR.Properties.Resources.CantGetOffsetForVirtualHeapHandle, "handle");
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static Exception InvalidArgument_UnexpectedHandleKind(HandleKind kind)
		{
			throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.UnexpectedHandleKind, kind));
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static Exception InvalidArgument_Handle(string parameterName)
		{
			throw new ArgumentException(MDCFR.Properties.Resources.InvalidHandle, parameterName);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void SignatureNotVarArg()
		{
			throw new InvalidOperationException(MDCFR.Properties.Resources.SignatureNotVarArg);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void ControlFlowBuilderNotAvailable()
		{
			throw new InvalidOperationException(MDCFR.Properties.Resources.ControlFlowBuilderNotAvailable);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void InvalidOperationBuilderAlreadyLinked()
		{
			throw new InvalidOperationException(MDCFR.Properties.Resources.BuilderAlreadyLinked);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void InvalidOperation(string message)
		{
			throw new InvalidOperationException(message);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void InvalidOperation_LabelNotMarked(int id)
		{
			throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.LabelNotMarked, id));
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void LabelDoesntBelongToBuilder(string parameterName)
		{
			throw new ArgumentException(MDCFR.Properties.Resources.LabelDoesntBelongToBuilder, parameterName);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void HeapHandleRequired()
		{
			throw new ArgumentException(MDCFR.Properties.Resources.NotMetadataHeapHandle, "handle");
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void EntityOrUserStringHandleRequired()
		{
			throw new ArgumentException(MDCFR.Properties.Resources.NotMetadataTableOrUserStringHandle, "handle");
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void InvalidToken()
		{
			throw new ArgumentException(MDCFR.Properties.Resources.InvalidToken, "token");
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void ArgumentNull(string parameterName)
		{
			throw new ArgumentNullException(parameterName);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void ArgumentEmptyString(string parameterName)
		{
			throw new ArgumentException(MDCFR.Properties.Resources.ExpectedNonEmptyString, parameterName);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void ArgumentEmptyArray(string parameterName)
		{
			throw new ArgumentException(MDCFR.Properties.Resources.ExpectedNonEmptyArray, parameterName);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void ValueArgumentNull()
		{
			throw new ArgumentNullException("value");
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void BuilderArgumentNull()
		{
			throw new ArgumentNullException("builder");
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void ArgumentOutOfRange(string parameterName)
		{
			throw new ArgumentOutOfRangeException(parameterName);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void ArgumentOutOfRange(string parameterName, string message)
		{
			throw new ArgumentOutOfRangeException(parameterName, message);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void BlobTooLarge(string parameterName)
		{
			throw new ArgumentOutOfRangeException(parameterName, MDCFR.Properties.Resources.BlobTooLarge);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void IndexOutOfRange()
		{
			throw new ArgumentOutOfRangeException("index");
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void TableIndexOutOfRange()
		{
			throw new ArgumentOutOfRangeException("tableIndex");
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void ValueArgumentOutOfRange()
		{
			throw new ArgumentOutOfRangeException("value");
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void OutOfBounds()
		{
			throw new BadImageFormatException(MDCFR.Properties.Resources.OutOfBoundsRead);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void WriteOutOfBounds()
		{
			throw new InvalidOperationException(MDCFR.Properties.Resources.OutOfBoundsWrite);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void InvalidCodedIndex()
		{
			throw new BadImageFormatException(MDCFR.Properties.Resources.InvalidCodedIndex);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void InvalidHandle()
		{
			throw new BadImageFormatException(MDCFR.Properties.Resources.InvalidHandle);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void InvalidCompressedInteger()
		{
			throw new BadImageFormatException(MDCFR.Properties.Resources.InvalidCompressedInteger);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void InvalidSerializedString()
		{
			throw new BadImageFormatException(MDCFR.Properties.Resources.InvalidSerializedString);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void ImageTooSmall()
		{
			throw new BadImageFormatException(MDCFR.Properties.Resources.ImageTooSmall);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void ImageTooSmallOrContainsInvalidOffsetOrCount()
		{
			throw new BadImageFormatException(MDCFR.Properties.Resources.ImageTooSmallOrContainsInvalidOffsetOrCount);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void ReferenceOverflow()
		{
			throw new BadImageFormatException(MDCFR.Properties.Resources.RowIdOrHeapOffsetTooLarge);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void TableNotSorted(TableIndex tableIndex)
		{
			throw new BadImageFormatException(System.SR.Format(MDCFR.Properties.Resources.MetadataTableNotSorted, tableIndex));
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void InvalidOperation_TableNotSorted(TableIndex tableIndex)
		{
			throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.MetadataTableNotSorted, tableIndex));
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void InvalidOperation_PEImageNotAvailable()
		{
			throw new InvalidOperationException(MDCFR.Properties.Resources.PEImageNotAvailable);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void TooManySubnamespaces()
		{
			throw new BadImageFormatException(MDCFR.Properties.Resources.TooManySubnamespaces);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void ValueOverflow()
		{
			throw new BadImageFormatException(MDCFR.Properties.Resources.ValueTooLarge);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void SequencePointValueOutOfRange()
		{
			throw new BadImageFormatException(MDCFR.Properties.Resources.SequencePointValueOutOfRange);
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void HeapSizeLimitExceeded(HeapIndex heap)
		{
			throw new ImageFormatLimitationException(System.SR.Format(MDCFR.Properties.Resources.HeapSizeLimitExceeded, heap));
		}

		[MethodImpl(MethodImplOptions.NoInlining)]
		[DoesNotReturn]
		internal static void PEReaderDisposed()
		{
			throw new ObjectDisposedException("PEReader");
		}
	}

	internal static class TypeAttributesExtensions
	{
		private const TypeAttributes Forwarder = (TypeAttributes)2097152;

		private const TypeAttributes NestedMask = TypeAttributes.NestedFamANDAssem;

		public static bool IsForwarder(this TypeAttributes flags)
		{
			return (flags & (TypeAttributes)2097152) != 0;
		}

		public static bool IsNested(this TypeAttributes flags)
		{
			return (flags & TypeAttributes.NestedFamANDAssem) != 0;
		}
	}

	namespace Internal
	{
		/// <summary>
		/// Represents a disposable blob of memory accessed via unsafe pointer.
		/// </summary>
		internal abstract class AbstractMemoryBlock : IDisposable
		{
			/// <summary>
			/// Pointer to the underlying data (not valid after disposal).
			/// </summary>
			public unsafe abstract byte* Pointer { get; }

			/// <summary>
			/// Size of the block.
			/// </summary>
			public abstract int Size { get; }

			public unsafe BlobReader GetReader()
			{
				return new BlobReader(Pointer, Size);
			}

			/// <summary>
			/// Returns the content of the entire memory block.
			/// </summary>
			/// <remarks>
			/// Does not check bounds.
			///
			/// Only creates a copy of the data if they are not represented by a managed byte array,
			/// or if the specified range doesn't span the entire block.
			/// </remarks>
			public unsafe virtual System.Collections.Immutable.ImmutableArray<byte> GetContentUnchecked(int start, int length)
			{
				System.Collections.Immutable.ImmutableArray<byte> result = System.Reflection.BlobUtilities.ReadImmutableBytes(Pointer + start, length);
				GC.KeepAlive(this);
				return result;
			}

			/// <summary>
			/// Disposes the block.
			/// </summary>
			/// <remarks>
			/// The operation is idempotent, but must not be called concurrently with any other operations on the block.
			///
			/// Using the block after dispose is an error in our code and therefore no effort is made to throw a tidy
			/// ObjectDisposedException and null ref or AV is possible.
			/// </remarks>
			public abstract void Dispose();
		}

		internal static class BitArithmetic
		{
			internal static int CountBits(int v)
			{
				return CountBits((uint)v);
			}

			internal static int CountBits(uint v)
			{
				v -= (v >> 1) & 0x55555555;
				v = (v & 0x33333333) + ((v >> 2) & 0x33333333);
				return (int)(((v + (v >> 4)) & 0xF0F0F0F) * 16843009) >> 24;
			}

			internal static int CountBits(ulong v)
			{
				v -= (v >> 1) & 0x5555555555555555L;
				v = (v & 0x3333333333333333L) + ((v >> 2) & 0x3333333333333333L);
				return (int)(((v + (v >> 4)) & 0xF0F0F0F0F0F0F0FL) * 72340172838076673L >> 56);
			}

			internal static uint Align(uint position, uint alignment)
			{
				uint num = position & ~(alignment - 1);
				if (num == position)
				{
					return num;
				}
				return num + alignment;
			}

			internal static int Align(int position, int alignment)
			{
				int num = position & ~(alignment - 1);
				if (num == position)
				{
					return num;
				}
				return num + alignment;
			}
		}

		/// <summary>
		/// Represents a memory block backed by an array of bytes.
		/// </summary>
		internal sealed class ByteArrayMemoryBlock : System.Reflection.Internal.AbstractMemoryBlock
		{
			private System.Reflection.Internal.ByteArrayMemoryProvider _provider;

			private readonly int _start;

			private readonly int _size;

			public unsafe override byte* Pointer => _provider.Pointer + _start;

			public override int Size => _size;

			internal ByteArrayMemoryBlock(System.Reflection.Internal.ByteArrayMemoryProvider provider, int start, int size)
			{
				_provider = provider;
				_size = size;
				_start = start;
			}

			public override void Dispose()
			{
				_provider = null;
			}

			public override System.Collections.Immutable.ImmutableArray<byte> GetContentUnchecked(int start, int length)
			{
				return System.Collections.Immutable.ImmutableArray.Create<byte>(_provider.Array, _start + start, length);
			}
		}

		internal sealed class ByteArrayMemoryProvider : System.Reflection.Internal.MemoryBlockProvider
		{
			private readonly System.Collections.Immutable.ImmutableArray<byte> _array;

			private System.Reflection.Internal.PinnedObject _pinned;

			public override int Size => _array.Length;

			public System.Collections.Immutable.ImmutableArray<byte> Array => _array;

			internal unsafe byte* Pointer
			{
				get
				{
					if (_pinned == null)
					{
						System.Reflection.Internal.PinnedObject pinnedObject = new System.Reflection.Internal.PinnedObject(ImmutableByteArrayInterop.DangerousGetUnderlyingArray(_array));
						if (Interlocked.CompareExchange(ref _pinned, pinnedObject, null) != null)
						{
							pinnedObject.Dispose();
						}
					}
					return _pinned.Pointer;
				}
			}

			public ByteArrayMemoryProvider(System.Collections.Immutable.ImmutableArray<byte> array)
			{
				_array = array;
			}

			protected override void Dispose(bool disposing)
			{
				Interlocked.Exchange(ref _pinned, null)?.Dispose();
			}

			protected override System.Reflection.Internal.AbstractMemoryBlock GetMemoryBlockImpl(int start, int size)
			{
				return new System.Reflection.Internal.ByteArrayMemoryBlock(this, start, size);
			}

			public override Stream GetStream(out System.Reflection.Internal.StreamConstraints constraints)
			{
				constraints = new System.Reflection.Internal.StreamConstraints(null, 0L, Size);
				return new System.Reflection.Internal.ImmutableMemoryStream(_array);
			}
		}

		internal sealed class ByteSequenceComparer : IEqualityComparer<byte[]>, IEqualityComparer<System.Collections.Immutable.ImmutableArray<byte>>
		{
			internal static readonly ByteSequenceComparer Instance = new ByteSequenceComparer();

			private ByteSequenceComparer()
			{
			}

			internal static bool Equals(System.Collections.Immutable.ImmutableArray<byte> x, System.Collections.Immutable.ImmutableArray<byte> y)
			{
				return x.AsSpan().SequenceEqual(y.AsSpan());
			}

			internal static bool Equals(byte[] left, int leftStart, byte[] right, int rightStart, int length)
			{
				return left.AsSpan(leftStart, length).SequenceEqual(right.AsSpan(rightStart, length));
			}

			internal static bool Equals(byte[]? left, byte[]? right)
			{
				return left.AsSpan().SequenceEqual(right.AsSpan());
			}

			internal static int GetHashCode(byte[] x)
			{
				return System.Reflection.Internal.Hash.GetFNVHashCode(x);
			}

			internal static int GetHashCode(System.Collections.Immutable.ImmutableArray<byte> x)
			{
				return System.Reflection.Internal.Hash.GetFNVHashCode(x.AsSpan());
			}

			bool IEqualityComparer<byte[]>.Equals(byte[] x, byte[] y)
			{
				return Equals(x, y);
			}

			int IEqualityComparer<byte[]>.GetHashCode(byte[] x)
			{
				return GetHashCode(x);
			}

			bool IEqualityComparer<System.Collections.Immutable.ImmutableArray<byte>>.Equals(System.Collections.Immutable.ImmutableArray<byte> x, System.Collections.Immutable.ImmutableArray<byte> y)
			{
				return Equals(x, y);
			}

			int IEqualityComparer<System.Collections.Immutable.ImmutableArray<byte>>.GetHashCode(System.Collections.Immutable.ImmutableArray<byte> x)
			{
				return GetHashCode(x);
			}
		}

		internal abstract class CriticalDisposableObject : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable
		{
			protected abstract void Release();

			public void Dispose()
			{
				Release();
				GC.SuppressFinalize(this);
			}

			~CriticalDisposableObject()
			{
				Release();
			}
		}

		internal static class DecimalUtilities
		{
			public static int GetScale(this decimal value)
			{
				return (byte)(decimal.GetBits(value)[3] >> 16);
			}

			public static void GetBits(this decimal value, out bool isNegative, out byte scale, out uint low, out uint mid, out uint high)
			{
				int[] bits = decimal.GetBits(value);
				low = (uint)bits[0];
				mid = (uint)bits[1];
				high = (uint)bits[2];
				scale = (byte)(bits[3] >> 16);
				isNegative = (bits[3] & 0x80000000u) != 0;
			}
		}

		/// <summary>
		/// Provides helpers to decode strings from unmanaged memory to System.String while avoiding
		/// intermediate allocation.
		/// </summary>
		internal static class EncodingHelper
		{
			public const int PooledBufferSize = 200;

			private static readonly System.Reflection.Internal.ObjectPool<byte[]> s_pool = new System.Reflection.Internal.ObjectPool<byte[]>(() => new byte[200]);

			public unsafe static string DecodeUtf8(byte* bytes, int byteCount, byte[] prefix, MetadataStringDecoder utf8Decoder)
			{
				if (prefix != null)
				{
					return DecodeUtf8Prefixed(bytes, byteCount, prefix, utf8Decoder);
				}
				if (byteCount == 0)
				{
					return string.Empty;
				}
				return utf8Decoder.GetString(bytes, byteCount);
			}

			private unsafe static string DecodeUtf8Prefixed(byte* bytes, int byteCount, byte[] prefix, MetadataStringDecoder utf8Decoder)
			{
				int num = byteCount + prefix.Length;
				if (num == 0)
				{
					return string.Empty;
				}
				byte[] array = AcquireBuffer(num);
				prefix.CopyTo(array, 0);
				Marshal.Copy((IntPtr)bytes, array, prefix.Length, byteCount);
				string @string;
				fixed (byte* bytes2 = &array[0])
				{
					@string = utf8Decoder.GetString(bytes2, num);
				}
				ReleaseBuffer(array);
				return @string;
			}

			private static byte[] AcquireBuffer(int byteCount)
			{
				if (byteCount > 200)
				{
					return new byte[byteCount];
				}
				return s_pool.Allocate();
			}

			private static void ReleaseBuffer(byte[] buffer)
			{
				if (buffer.Length == 200)
				{
					s_pool.Free(buffer);
				}
			}
		}

		/// <summary>
		/// Replacements for System.Linq to avoid an unnecessary dependency.
		/// Parameter and return types strengthened to actual internal usage as an optimization.
		/// </summary>
		internal static class EnumerableExtensions
		{
			public static T? FirstOrDefault<T>(this System.Collections.Immutable.ImmutableArray<T> collection, Func<T, bool> predicate)
			{
				//IL_0002: Unknown result type (might be due to invalid IL or missing references)
				//IL_0007: Unknown result type (might be due to invalid IL or missing references)
				ImmutableArray<T>.Enumerator enumerator = collection.GetEnumerator();
				while (enumerator.MoveNext())
				{
					T current = enumerator.Current;
					if (predicate(current))
					{
						return current;
					}
				}
				return default(T);
			}

			public static IEnumerable<TResult> Select<TSource, TResult>(this IEnumerable<TSource> source, Func<TSource, TResult> selector)
			{
				foreach (TSource item in source)
				{
					yield return selector(item);
				}
			}

			public static T Last<T>(this System.Collections.Immutable.ImmutableArray<T>.Builder source)
			{
				return source[source.Count - 1];
			}

			public static IEnumerable<T> OrderBy<T>(this List<T> source, Comparison<T> comparison)
			{
				Comparison<T> comparison2 = comparison;
				List<T> source2 = source;
				int[] array = new int[source2.Count];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = i;
				}
				Array.Sort(array, delegate(int left, int right)
				{
					if (left == right)
					{
						return 0;
					}
					int num = comparison2(source2[left], source2[right]);
					return (num == 0) ? (left - right) : num;
				});
				int[] array2 = array;
				foreach (int index in array2)
				{
					yield return source2[index];
				}
			}
		}

		internal static class ExceptionUtilities
		{
			internal static Exception UnexpectedValue(object value)
			{
				if (value != null && value.GetType().FullName != null)
				{
					return new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.UnexpectedValue, value, value.GetType().FullName));
				}
				return new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.UnexpectedValueUnknownType, value));
			}
		}

		/// <summary>
		/// Class representing raw memory but not owning the memory.
		/// </summary>
		internal sealed class ExternalMemoryBlock : System.Reflection.Internal.AbstractMemoryBlock
		{
			private readonly object _memoryOwner;

			private unsafe byte* _buffer;

			private int _size;

			public unsafe override byte* Pointer => _buffer;

			public override int Size => _size;

			public unsafe ExternalMemoryBlock(object memoryOwner, byte* buffer, int size)
			{
				_memoryOwner = memoryOwner;
				_buffer = buffer;
				_size = size;
			}

			public unsafe override void Dispose()
			{
				_buffer = null;
				_size = 0;
			}
		}

		/// <summary>
		/// Represents raw memory owned by an external object.
		/// </summary>
		internal sealed class ExternalMemoryBlockProvider : System.Reflection.Internal.MemoryBlockProvider
		{
			private unsafe byte* _memory;

			private int _size;

			public override int Size => _size;

			public unsafe byte* Pointer => _memory;

			public unsafe ExternalMemoryBlockProvider(byte* memory, int size)
			{
				_memory = memory;
				_size = size;
			}

			protected unsafe override System.Reflection.Internal.AbstractMemoryBlock GetMemoryBlockImpl(int start, int size)
			{
				return new System.Reflection.Internal.ExternalMemoryBlock(this, _memory + start, size);
			}

			public unsafe override Stream GetStream(out System.Reflection.Internal.StreamConstraints constraints)
			{
				constraints = new System.Reflection.Internal.StreamConstraints(null, 0L, _size);
				return new System.Reflection.Internal.ReadOnlyUnmanagedMemoryStream(_memory, _size);
			}

			protected unsafe override void Dispose(bool disposing)
			{
				_memory = null;
				_size = 0;
			}
		}

		internal static class Hash
		{
			/// <summary>
			/// The offset bias value used in the FNV-1a algorithm
			/// See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
			/// </summary>
			internal const int FnvOffsetBias = -2128831035;

			/// <summary>
			/// The generative factor used in the FNV-1a algorithm
			/// See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
			/// </summary>
			internal const int FnvPrime = 16777619;

			internal static int Combine(int newKey, int currentKey)
			{
				return currentKey * -1521134295 + newKey;
			}

			internal static int Combine(uint newKey, int currentKey)
			{
				return currentKey * -1521134295 + (int)newKey;
			}

			internal static int Combine(bool newKeyPart, int currentKey)
			{
				return Combine(currentKey, newKeyPart ? 1 : 0);
			}

			/// <summary>
			/// Compute the FNV-1a hash of a sequence of bytes
			/// See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
			/// </summary>
			/// <param name="data">The sequence of bytes</param>
			/// <returns>The FNV-1a hash of <paramref name="data" /></returns>
			internal static int GetFNVHashCode(ReadOnlySpan<byte> data)
			{
				int num = -2128831035;
				for (int i = 0; i < data.Length; i++)
				{
					num = (num ^ data[i]) * 16777619;
				}
				return num;
			}
		}

			/// <summary>
			/// Provides tools for using <see cref="System.Collections.Immutable.ImmutableArray{T}" /> in interop scenarios.
			/// </summary>
			/// <remarks>
			/// *** WARNING ***
			///
			/// If you decide to copy this code elsewhere, please retain the documentation here
			/// and the Dangerous prefixes in the API names. This will help track down and audit
			/// other places where this technique (with dangerous consequences when misused) may
			/// be applied.
			///
			/// A generic version of this API was once public in a pre-release of immutable
			/// collections, but  it was deemed to be too subject to abuse when available publicly.
			///
			/// This implementation is scoped to byte arrays as that is all that the metadata reader needs.
			///
			/// Also, since we don't have access to immutable collection internals, we use a trick involving
			/// overlapping a <see cref="System.Collections.Immutable.ImmutableArray{T}" /> with an array reference. While
			/// unverifiable, it is valid. See ECMA-335, section II.10.7 Controlling instance layout:
			///
			/// "It is possible to overlap fields in this way, though offsets occupied by an object reference
			/// shall not overlap with offsets occupied by a built-in value type or a part of
			/// another object reference. While one object reference can completely overlap another, this is
			/// unverifiable."
			///
			/// Furthermore, the fact that <see cref="System.Collections.Immutable.ImmutableArray{T}" /> backed by a single byte array
			/// field is something inherent to the design of ImmutableArray in order to get its performance
			/// characteristics and therefore something we (Microsoft) are comfortable defining as a contract that
			/// can be depended upon as below.
			/// </remarks>
			internal static class ImmutableByteArrayInterop
			{
				[StructLayout(LayoutKind.Explicit)]
				private struct ByteArrayUnion
				{
					[FieldOffset(0)]
					internal byte[] UnderlyingArray;

					[FieldOffset(0)]
					internal System.Collections.Immutable.ImmutableArray<byte> ImmutableArray;
				}

				/// <summary>
				/// Creates a new instance of <see cref="T:System.Collections.Immutable.ImmutableArray`1" /> using a given mutable array as the backing
				/// field, without creating a defensive copy. It is the responsibility of the caller to ensure no other mutable
				/// references exist to the array.  Do not mutate the array after calling this method.
				/// </summary>
				/// <param name="array">The mutable array to use as the backing field. The incoming reference is set to null
				/// since it should not be retained by the caller.</param>
				/// <remarks>
				/// Users of this method should take extra care to ensure that the mutable array given as a parameter
				/// is never modified. The returned <see cref="T:System.Collections.Immutable.ImmutableArray`1" /> will use the given array as its backing
				/// field without creating a defensive copy, so changes made to the given mutable array will be observable
				/// on the returned <see cref="T:System.Collections.Immutable.ImmutableArray`1" />.  Instance and static methods of <see cref="T:System.Collections.Immutable.ImmutableArray`1" />
				/// and <see cref="T:System.Collections.Immutable.ImmutableArray" /> may malfunction if they operate on an <see cref="T:System.Collections.Immutable.ImmutableArray`1" /> instance
				/// whose underlying backing field is modified.
				/// </remarks>
				/// <returns>An immutable array.</returns>
				internal static System.Collections.Immutable.ImmutableArray<byte> DangerousCreateFromUnderlyingArray(ref byte[]? array)
				{
					byte[] underlyingArray = array;
					array = null;
					ByteArrayUnion byteArrayUnion = default(ByteArrayUnion);
					byteArrayUnion.UnderlyingArray = underlyingArray;
					return byteArrayUnion.ImmutableArray;
				}

				/// <summary>
				/// Access the backing mutable array instance for the given <see cref="T:System.Collections.Immutable.ImmutableArray`1" />, without
				/// creating a defensive copy.  It is the responsibility of the caller to ensure the array is not modified
				/// through the returned mutable reference.  Do not mutate the returned array.
				/// </summary>
				/// <param name="array">The <see cref="T:System.Collections.Immutable.ImmutableArray`1" /> from which to retrieve the backing field.</param>
				/// <remarks>
				/// Users of this method should take extra care to ensure that the returned mutable array is never modified.
				/// The returned mutable array continues to be used as the backing field of the given <see cref="T:System.Collections.Immutable.ImmutableArray`1" />
				/// without creating a defensive copy, so changes made to the returned mutable array will be observable
				/// on the given <see cref="T:System.Collections.Immutable.ImmutableArray`1" />.  Instance and static methods of <see cref="T:System.Collections.Immutable.ImmutableArray`1" />
				/// and <see cref="T:System.Collections.Immutable.ImmutableArray" /> may malfunction if they operate on an <see cref="T:System.Collections.Immutable.ImmutableArray`1" /> instance
				/// whose underlying backing field is modified.
				/// </remarks>
				/// <returns>The underlying array, or null if <see cref="P:System.Collections.Immutable.ImmutableArray`1.IsDefault" /> is true.</returns>
				internal static byte[]? DangerousGetUnderlyingArray(System.Collections.Immutable.ImmutableArray<byte> array)
				{
					ByteArrayUnion byteArrayUnion = default(ByteArrayUnion);
					byteArrayUnion.ImmutableArray = array;
					return byteArrayUnion.UnderlyingArray;
				}
			}

		internal sealed class ImmutableMemoryStream : Stream
		{
			private readonly System.Collections.Immutable.ImmutableArray<byte> _array;

			private int _position;

			public override bool CanRead => true;

			public override bool CanSeek => true;

			public override bool CanWrite => false;

			public override long Length => _array.Length;

			public override long Position
			{
				get
				{
					return _position;
				}
				set
				{
					if (value < 0 || value >= _array.Length)
					{
						throw new ArgumentOutOfRangeException("value");
					}
					_position = (int)value;
				}
			}

			internal ImmutableMemoryStream(System.Collections.Immutable.ImmutableArray<byte> array)
			{
				_array = array;
			}

			public System.Collections.Immutable.ImmutableArray<byte> GetBuffer()
			{
				return _array;
			}

			public override void Flush()
			{
			}

			public override int Read(byte[] buffer, int offset, int count)
			{
				int num = Math.Min(count, _array.Length - _position);
				_array.CopyTo(_position, buffer, offset, num);
				_position += num;
				return num;
			}

			public override long Seek(long offset, SeekOrigin origin)
			{
				long num;
				try
				{
					num = checked(origin switch
					{
						SeekOrigin.Begin => offset, 
						SeekOrigin.Current => offset + _position, 
						SeekOrigin.End => offset + _array.Length, 
						_ => throw new ArgumentOutOfRangeException("origin"), 
					});
				}
				catch (OverflowException)
				{
					throw new ArgumentOutOfRangeException("offset");
				}
				if (num < 0 || num >= _array.Length)
				{
					throw new ArgumentOutOfRangeException("offset");
				}
				_position = (int)num;
				return num;
			}

			public override void SetLength(long value)
			{
				throw new NotSupportedException();
			}

			public override void Write(byte[] buffer, int offset, int count)
			{
				throw new NotSupportedException();
			}
		}

		[DebuggerDisplay("{GetDebuggerDisplay(),nq}")]
		internal readonly struct MemoryBlock
		{
			internal enum FastComparisonResult
			{
				Equal,
				BytesStartWithText,
				TextStartsWithBytes,
				Unequal,
				Inconclusive
			}

			internal unsafe readonly byte* Pointer;

			internal readonly int Length;

			internal unsafe MemoryBlock(byte* buffer, int length)
			{
				Pointer = buffer;
				Length = length;
			}

			internal unsafe static System.Reflection.Internal.MemoryBlock CreateChecked(byte* buffer, int length)
			{
				if (length < 0)
				{
					throw new ArgumentOutOfRangeException("length");
				}
				if (buffer == null && length != 0)
				{
					System.Reflection.Throw.ArgumentNull("buffer");
				}
				return new System.Reflection.Internal.MemoryBlock(buffer, length);
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			private void CheckBounds(int offset, int byteCount)
			{
				if ((ulong)((long)(uint)offset + (long)(uint)byteCount) > (ulong)Length)
				{
					System.Reflection.Throw.OutOfBounds();
				}
			}

			internal unsafe byte[]? ToArray()
			{
				if (Pointer != null)
				{
					return PeekBytes(0, Length);
				}
				return null;
			}

			private unsafe string GetDebuggerDisplay()
			{
				if (Pointer == null)
				{
					return "<null>";
				}
				int displayedBytes;
				return GetDebuggerDisplay(out displayedBytes);
			}

			internal string GetDebuggerDisplay(out int displayedBytes)
			{
				displayedBytes = Math.Min(Length, 64);
				string text = BitConverter.ToString(PeekBytes(0, displayedBytes));
				if (displayedBytes < Length)
				{
					text += "-...";
				}
				return text;
			}

			internal unsafe string GetDebuggerDisplay(int offset)
			{
				if (Pointer == null)
				{
					return "<null>";
				}
				int displayedBytes;
				string debuggerDisplay = GetDebuggerDisplay(out displayedBytes);
				if (offset < displayedBytes)
				{
					return debuggerDisplay.Insert(offset * 3, "*");
				}
				if (displayedBytes == Length)
				{
					return debuggerDisplay + "*";
				}
				return debuggerDisplay + "*...";
			}

			internal unsafe System.Reflection.Internal.MemoryBlock GetMemoryBlockAt(int offset, int length)
			{
				CheckBounds(offset, length);
				return new System.Reflection.Internal.MemoryBlock(Pointer + offset, length);
			}

			internal unsafe byte PeekByte(int offset)
			{
				CheckBounds(offset, 1);
				return Pointer[offset];
			}

			internal int PeekInt32(int offset)
			{
				uint num = PeekUInt32(offset);
				if ((int)num != num)
				{
					System.Reflection.Throw.ValueOverflow();
				}
				return (int)num;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			internal unsafe uint PeekUInt32(int offset)
			{
				CheckBounds(offset, 4);
				byte* ptr = Pointer + offset;
				return (uint)(*ptr | (ptr[1] << 8) | (ptr[2] << 16) | (ptr[3] << 24));
			}

			/// <summary>
			/// Decodes a compressed integer value starting at offset.
			/// See Metadata Specification section II.23.2: Blobs and signatures.
			/// </summary>
			/// <param name="offset">Offset to the start of the compressed data.</param>
			/// <param name="numberOfBytesRead">Bytes actually read.</param>
			/// <returns>
			/// Value between 0 and 0x1fffffff, or <see cref="F:System.Reflection.Metadata.BlobReader.InvalidCompressedInteger" /> if the value encoding is invalid.
			/// </returns>
			internal unsafe int PeekCompressedInteger(int offset, out int numberOfBytesRead)
			{
				CheckBounds(offset, 0);
				byte* ptr = Pointer + offset;
				long num = Length - offset;
				if (num == 0L)
				{
					numberOfBytesRead = 0;
					return int.MaxValue;
				}
				byte b = *ptr;
				if ((b & 0x80) == 0)
				{
					numberOfBytesRead = 1;
					return b;
				}
				if ((b & 0x40) == 0)
				{
					if (num >= 2)
					{
						numberOfBytesRead = 2;
						return ((b & 0x3F) << 8) | ptr[1];
					}
				}
				else if ((b & 0x20) == 0 && num >= 4)
				{
					numberOfBytesRead = 4;
					return ((b & 0x1F) << 24) | (ptr[1] << 16) | (ptr[2] << 8) | ptr[3];
				}
				numberOfBytesRead = 0;
				return int.MaxValue;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			internal unsafe ushort PeekUInt16(int offset)
			{
				CheckBounds(offset, 2);
				byte* ptr = Pointer + offset;
				return (ushort)(*ptr | (ptr[1] << 8));
			}

			internal uint PeekTaggedReference(int offset, bool smallRefSize)
			{
				return PeekReferenceUnchecked(offset, smallRefSize);
			}

			internal uint PeekReferenceUnchecked(int offset, bool smallRefSize)
			{
				if (!smallRefSize)
				{
					return PeekUInt32(offset);
				}
				return PeekUInt16(offset);
			}

			internal int PeekReference(int offset, bool smallRefSize)
			{
				if (smallRefSize)
				{
					return PeekUInt16(offset);
				}
				uint num = PeekUInt32(offset);
				if (!System.Reflection.Metadata.Ecma335.TokenTypeIds.IsValidRowId(num))
				{
					System.Reflection.Throw.ReferenceOverflow();
				}
				return (int)num;
			}

			internal int PeekHeapReference(int offset, bool smallRefSize)
			{
				if (smallRefSize)
				{
					return PeekUInt16(offset);
				}
				uint num = PeekUInt32(offset);
				if (!System.Reflection.Metadata.Ecma335.HeapHandleType.IsValidHeapOffset(num))
				{
					System.Reflection.Throw.ReferenceOverflow();
				}
				return (int)num;
			}

			internal unsafe Guid PeekGuid(int offset)
			{
				CheckBounds(offset, sizeof(Guid));
				byte* ptr = Pointer + offset;
				if (BitConverter.IsLittleEndian)
				{
					return *(Guid*)ptr;
				}
				return new Guid(*ptr | (ptr[1] << 8) | (ptr[2] << 16) | (ptr[3] << 24), (short)(ptr[4] | (ptr[5] << 8)), (short)(ptr[6] | (ptr[7] << 8)), ptr[8], ptr[9], ptr[10], ptr[11], ptr[12], ptr[13], ptr[14], ptr[15]);
			}

			internal unsafe string PeekUtf16(int offset, int byteCount)
			{
				CheckBounds(offset, byteCount);
				byte* ptr = Pointer + offset;
				if (BitConverter.IsLittleEndian)
				{
					return new string((char*)ptr, 0, byteCount / 2);
				}
				return Encoding.Unicode.GetString(ptr, byteCount);
			}

			internal unsafe string PeekUtf8(int offset, int byteCount)
			{
				CheckBounds(offset, byteCount);
				return Encoding.UTF8.GetString(Pointer + offset, byteCount);
			}

			/// <summary>
			/// Read UTF8 at the given offset up to the given terminator, null terminator, or end-of-block.
			/// </summary>
			/// <param name="offset">Offset in to the block where the UTF8 bytes start.</param>
			/// <param name="prefix">UTF8 encoded prefix to prepend to the bytes at the offset before decoding.</param>
			/// <param name="utf8Decoder">The UTF8 decoder to use that allows user to adjust fallback and/or reuse existing strings without allocating a new one.</param>
			/// <param name="numberOfBytesRead">The number of bytes read, which includes the terminator if we did not hit the end of the block.</param>
			/// <param name="terminator">A character in the ASCII range that marks the end of the string.
			/// If a value other than '\0' is passed we still stop at the null terminator if encountered first.</param>
			/// <returns>The decoded string.</returns>
			internal unsafe string PeekUtf8NullTerminated(int offset, byte[]? prefix, MetadataStringDecoder utf8Decoder, out int numberOfBytesRead, char terminator = '\0')
			{
				CheckBounds(offset, 0);
				int utf8NullTerminatedLength = GetUtf8NullTerminatedLength(offset, out numberOfBytesRead, terminator);
				return EncodingHelper.DecodeUtf8(Pointer + offset, utf8NullTerminatedLength, prefix, utf8Decoder);
			}

			/// <summary>
			/// Get number of bytes from offset to given terminator, null terminator, or end-of-block (whichever comes first).
			/// Returned length does not include the terminator, but numberOfBytesRead out parameter does.
			/// </summary>
			/// <param name="offset">Offset in to the block where the UTF8 bytes start.</param>
			/// <param name="terminator">A character in the ASCII range that marks the end of the string.
			/// If a value other than '\0' is passed we still stop at the null terminator if encountered first.</param>
			/// <param name="numberOfBytesRead">The number of bytes read, which includes the terminator if we did not hit the end of the block.</param>
			/// <returns>Length (byte count) not including terminator.</returns>
			internal unsafe int GetUtf8NullTerminatedLength(int offset, out int numberOfBytesRead, char terminator = '\0')
			{
				CheckBounds(offset, 0);
				byte* ptr = Pointer + offset;
				byte* ptr2 = Pointer + Length;
				byte* ptr3;
				for (ptr3 = ptr; ptr3 < ptr2; ptr3++)
				{
					byte b = *ptr3;
					if (b == 0 || b == terminator)
					{
						break;
					}
				}
				int result = (numberOfBytesRead = (int)(ptr3 - ptr));
				if (ptr3 < ptr2)
				{
					numberOfBytesRead++;
				}
				return result;
			}

			internal unsafe int Utf8NullTerminatedOffsetOfAsciiChar(int startOffset, char asciiChar)
			{
				CheckBounds(startOffset, 0);
				for (int i = startOffset; i < Length; i++)
				{
					byte b = Pointer[i];
					if (b == 0)
					{
						break;
					}
					if (b == asciiChar)
					{
						return i;
					}
				}
				return -1;
			}

			internal bool Utf8NullTerminatedEquals(int offset, string text, MetadataStringDecoder utf8Decoder, char terminator, bool ignoreCase)
			{
				int firstDifferenceIndex;
				FastComparisonResult fastComparisonResult = Utf8NullTerminatedFastCompare(offset, text, 0, out firstDifferenceIndex, terminator, ignoreCase);
				if (fastComparisonResult == FastComparisonResult.Inconclusive)
				{
					string text2 = PeekUtf8NullTerminated(offset, null, utf8Decoder, out firstDifferenceIndex, terminator);
					return text2.Equals(text, ignoreCase ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);
				}
				return fastComparisonResult == FastComparisonResult.Equal;
			}

			internal bool Utf8NullTerminatedStartsWith(int offset, string text, MetadataStringDecoder utf8Decoder, char terminator, bool ignoreCase)
			{
				int firstDifferenceIndex;
				switch (Utf8NullTerminatedFastCompare(offset, text, 0, out firstDifferenceIndex, terminator, ignoreCase))
				{
				case FastComparisonResult.Equal:
				case FastComparisonResult.BytesStartWithText:
					return true;
				case FastComparisonResult.TextStartsWithBytes:
				case FastComparisonResult.Unequal:
					return false;
				default:
				{
					string text2 = PeekUtf8NullTerminated(offset, null, utf8Decoder, out firstDifferenceIndex, terminator);
					return text2.StartsWith(text, ignoreCase ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);
				}
				}
			}

			internal unsafe FastComparisonResult Utf8NullTerminatedFastCompare(int offset, string text, int textStart, out int firstDifferenceIndex, char terminator, bool ignoreCase)
			{
				CheckBounds(offset, 0);
				byte* ptr = Pointer + offset;
				byte* ptr2 = Pointer + Length;
				byte* ptr3 = ptr;
				int ignoreCaseMask = StringUtils.IgnoreCaseMask(ignoreCase);
				int num = textStart;
				while (num < text.Length && ptr3 != ptr2)
				{
					byte b = *ptr3;
					if (b == 0 || b == terminator)
					{
						break;
					}
					char c = text[num];
					if ((b & 0x80) == 0 && StringUtils.IsEqualAscii(c, b, ignoreCaseMask))
					{
						num++;
						ptr3++;
						continue;
					}
					firstDifferenceIndex = num;
					if (c <= '\u007f')
					{
						return FastComparisonResult.Unequal;
					}
					return FastComparisonResult.Inconclusive;
				}
				firstDifferenceIndex = num;
				bool flag = num == text.Length;
				bool flag2 = ptr3 == ptr2 || *ptr3 == 0 || *ptr3 == terminator;
				if (flag && flag2)
				{
					return FastComparisonResult.Equal;
				}
				if (!flag)
				{
					return FastComparisonResult.TextStartsWithBytes;
				}
				return FastComparisonResult.BytesStartWithText;
			}

			internal unsafe bool Utf8NullTerminatedStringStartsWithAsciiPrefix(int offset, string asciiPrefix)
			{
				CheckBounds(offset, 0);
				if (asciiPrefix.Length > Length - offset)
				{
					return false;
				}
				byte* ptr = Pointer + offset;
				for (int i = 0; i < asciiPrefix.Length; i++)
				{
					if (asciiPrefix[i] != *ptr)
					{
						return false;
					}
					ptr++;
				}
				return true;
			}

			internal unsafe int CompareUtf8NullTerminatedStringWithAsciiString(int offset, string asciiString)
			{
				CheckBounds(offset, 0);
				byte* ptr = Pointer + offset;
				int num = Length - offset;
				for (int i = 0; i < asciiString.Length; i++)
				{
					if (i > num)
					{
						return -1;
					}
					if (*ptr != asciiString[i])
					{
						return *ptr - asciiString[i];
					}
					ptr++;
				}
				if (*ptr != 0)
				{
					return 1;
				}
				return 0;
			}

			internal unsafe byte[] PeekBytes(int offset, int byteCount)
			{
				CheckBounds(offset, byteCount);
				return System.Reflection.BlobUtilities.ReadBytes(Pointer + offset, byteCount);
			}

			internal int IndexOf(byte b, int start)
			{
				CheckBounds(start, 0);
				return IndexOfUnchecked(b, start);
			}

			internal unsafe int IndexOfUnchecked(byte b, int start)
			{
				byte* ptr = Pointer + start;
				for (byte* ptr2 = Pointer + Length; ptr < ptr2; ptr++)
				{
					if (*ptr == b)
					{
						return (int)(ptr - Pointer);
					}
				}
				return -1;
			}

			internal int BinarySearch(string[] asciiKeys, int offset)
			{
				int num = 0;
				int num2 = asciiKeys.Length - 1;
				while (num <= num2)
				{
					int num3 = num + (num2 - num >> 1);
					string asciiString = asciiKeys[num3];
					int num4 = CompareUtf8NullTerminatedStringWithAsciiString(offset, asciiString);
					if (num4 == 0)
					{
						return num3;
					}
					if (num4 < 0)
					{
						num2 = num3 - 1;
					}
					else
					{
						num = num3 + 1;
					}
				}
				return ~num;
			}

			/// <summary>
			/// In a table that specifies children via a list field (e.g. TypeDef.FieldList, TypeDef.MethodList),
			/// searches for the parent given a reference to a child.
			/// </summary>
			/// <returns>Returns row number [0..RowCount).</returns>
			internal int BinarySearchForSlot(int rowCount, int rowSize, int referenceListOffset, uint referenceValue, bool isReferenceSmall)
			{
				int num = 0;
				int num2 = rowCount - 1;
				uint num3 = PeekReferenceUnchecked(num * rowSize + referenceListOffset, isReferenceSmall);
				uint num4 = PeekReferenceUnchecked(num2 * rowSize + referenceListOffset, isReferenceSmall);
				if (num2 == 1)
				{
					if (referenceValue >= num4)
					{
						return num2;
					}
					return num;
				}
				while (num2 - num > 1)
				{
					if (referenceValue <= num3)
					{
						if (referenceValue != num3)
						{
							return num - 1;
						}
						return num;
					}
					if (referenceValue >= num4)
					{
						if (referenceValue != num4)
						{
							return num2 + 1;
						}
						return num2;
					}
					int num5 = (num + num2) / 2;
					uint num6 = PeekReferenceUnchecked(num5 * rowSize + referenceListOffset, isReferenceSmall);
					if (referenceValue > num6)
					{
						num = num5;
						num3 = num6;
						continue;
					}
					if (referenceValue < num6)
					{
						num2 = num5;
						num4 = num6;
						continue;
					}
					return num5;
				}
				return num;
			}

			/// <summary>
			/// In a table ordered by a column containing entity references searches for a row with the specified reference.
			/// </summary>
			/// <returns>Returns row number [0..RowCount) or -1 if not found.</returns>
			internal int BinarySearchReference(int rowCount, int rowSize, int referenceOffset, uint referenceValue, bool isReferenceSmall)
			{
				int num = 0;
				int num2 = rowCount - 1;
				while (num <= num2)
				{
					int num3 = (num + num2) / 2;
					uint num4 = PeekReferenceUnchecked(num3 * rowSize + referenceOffset, isReferenceSmall);
					if (referenceValue > num4)
					{
						num = num3 + 1;
						continue;
					}
					if (referenceValue < num4)
					{
						num2 = num3 - 1;
						continue;
					}
					return num3;
				}
				return -1;
			}

			internal int BinarySearchReference(int[] ptrTable, int rowSize, int referenceOffset, uint referenceValue, bool isReferenceSmall)
			{
				int num = 0;
				int num2 = ptrTable.Length - 1;
				while (num <= num2)
				{
					int num3 = (num + num2) / 2;
					uint num4 = PeekReferenceUnchecked((ptrTable[num3] - 1) * rowSize + referenceOffset, isReferenceSmall);
					if (referenceValue > num4)
					{
						num = num3 + 1;
						continue;
					}
					if (referenceValue < num4)
					{
						num2 = num3 - 1;
						continue;
					}
					return num3;
				}
				return -1;
			}

			/// <summary>
			/// Calculates a range of rows that have specified value in the specified column in a table that is sorted by that column.
			/// </summary>
			internal void BinarySearchReferenceRange(int rowCount, int rowSize, int referenceOffset, uint referenceValue, bool isReferenceSmall, out int startRowNumber, out int endRowNumber)
			{
				int num = BinarySearchReference(rowCount, rowSize, referenceOffset, referenceValue, isReferenceSmall);
				if (num == -1)
				{
					startRowNumber = -1;
					endRowNumber = -1;
					return;
				}
				startRowNumber = num;
				while (startRowNumber > 0 && PeekReferenceUnchecked((startRowNumber - 1) * rowSize + referenceOffset, isReferenceSmall) == referenceValue)
				{
					startRowNumber--;
				}
				endRowNumber = num;
				while (endRowNumber + 1 < rowCount && PeekReferenceUnchecked((endRowNumber + 1) * rowSize + referenceOffset, isReferenceSmall) == referenceValue)
				{
					endRowNumber++;
				}
			}

			/// <summary>
			/// Calculates a range of rows that have specified value in the specified column in a table that is sorted by that column.
			/// </summary>
			internal void BinarySearchReferenceRange(int[] ptrTable, int rowSize, int referenceOffset, uint referenceValue, bool isReferenceSmall, out int startRowNumber, out int endRowNumber)
			{
				int num = BinarySearchReference(ptrTable, rowSize, referenceOffset, referenceValue, isReferenceSmall);
				if (num == -1)
				{
					startRowNumber = -1;
					endRowNumber = -1;
					return;
				}
				startRowNumber = num;
				while (startRowNumber > 0 && PeekReferenceUnchecked((ptrTable[startRowNumber - 1] - 1) * rowSize + referenceOffset, isReferenceSmall) == referenceValue)
				{
					startRowNumber--;
				}
				endRowNumber = num;
				while (endRowNumber + 1 < ptrTable.Length && PeekReferenceUnchecked((ptrTable[endRowNumber + 1] - 1) * rowSize + referenceOffset, isReferenceSmall) == referenceValue)
				{
					endRowNumber++;
				}
			}

			internal int LinearSearchReference(int rowSize, int referenceOffset, uint referenceValue, bool isReferenceSmall)
			{
				int i = referenceOffset;
				for (int length = Length; i < length; i += rowSize)
				{
					uint num = PeekReferenceUnchecked(i, isReferenceSmall);
					if (num == referenceValue)
					{
						return i / rowSize;
					}
				}
				return -1;
			}

			internal bool IsOrderedByReferenceAscending(int rowSize, int referenceOffset, bool isReferenceSmall)
			{
				int i = referenceOffset;
				int length = Length;
				uint num = 0u;
				for (; i < length; i += rowSize)
				{
					uint num2 = PeekReferenceUnchecked(i, isReferenceSmall);
					if (num2 < num)
					{
						return false;
					}
					num = num2;
				}
				return true;
			}

			internal int[] BuildPtrTable(int numberOfRows, int rowSize, int referenceOffset, bool isReferenceSmall)
			{
				int[] array = new int[numberOfRows];
				uint[] unsortedReferences = new uint[numberOfRows];
				for (int i = 0; i < array.Length; i++)
				{
					array[i] = i + 1;
				}
				ReadColumn(unsortedReferences, rowSize, referenceOffset, isReferenceSmall);
				Array.Sort(array, (int a, int b) => unsortedReferences[a - 1].CompareTo(unsortedReferences[b - 1]));
				return array;
			}

			private void ReadColumn(uint[] result, int rowSize, int referenceOffset, bool isReferenceSmall)
			{
				int num = referenceOffset;
				int length = Length;
				int num2 = 0;
				while (num < length)
				{
					result[num2] = PeekReferenceUnchecked(num, isReferenceSmall);
					num += rowSize;
					num2++;
				}
			}

			internal bool PeekHeapValueOffsetAndSize(int index, out int offset, out int size)
			{
				int numberOfBytesRead;
				int num = PeekCompressedInteger(index, out numberOfBytesRead);
				if (num == int.MaxValue)
				{
					offset = 0;
					size = 0;
					return false;
				}
				offset = index + numberOfBytesRead;
				size = num;
				return true;
			}
		}

		internal abstract class MemoryBlockProvider : IDisposable
		{
			/// <summary>
			/// The size of the data.
			/// </summary>
			public abstract int Size { get; }

			/// <summary>
			/// Creates and hydrates a memory block representing all data.
			/// </summary>
			/// <exception cref="T:System.IO.IOException">Error while reading from the memory source.</exception>
			public System.Reflection.Internal.AbstractMemoryBlock GetMemoryBlock()
			{
				return GetMemoryBlockImpl(0, Size);
			}

			/// <summary>
			/// Creates and hydrates a memory block representing data in the specified range.
			/// </summary>
			/// <param name="start">Starting offset relative to the beginning of the data represented by this provider.</param>
			/// <param name="size">Size of the resulting block.</param>
			/// <exception cref="T:System.IO.IOException">Error while reading from the memory source.</exception>
			public System.Reflection.Internal.AbstractMemoryBlock GetMemoryBlock(int start, int size)
			{
				if ((ulong)((long)(uint)start + (long)(uint)size) > (ulong)Size)
				{
					System.Reflection.Throw.ImageTooSmallOrContainsInvalidOffsetOrCount();
				}
				return GetMemoryBlockImpl(start, size);
			}

			/// <exception cref="T:System.IO.IOException">IO error while reading from the underlying stream.</exception>
			protected abstract System.Reflection.Internal.AbstractMemoryBlock GetMemoryBlockImpl(int start, int size);

			/// <summary>
			/// Gets a seekable and readable <see cref="T:System.IO.Stream" /> that can be used to read all data.
			/// The operations on the stream has to be done under a lock of <see cref="F:System.Reflection.Internal.StreamConstraints.GuardOpt" /> if non-null.
			/// The image starts at <see cref="F:System.Reflection.Internal.StreamConstraints.ImageStart" /> and has size <see cref="F:System.Reflection.Internal.StreamConstraints.ImageSize" />.
			/// It is the caller's responsibility not to read outside those bounds.
			/// </summary>
			public abstract Stream GetStream(out System.Reflection.Internal.StreamConstraints constraints);

			protected abstract void Dispose(bool disposing);

			public void Dispose()
			{
				Dispose(disposing: true);
				GC.SuppressFinalize(this);
			}
		}

		internal sealed class MemoryMappedFileBlock : System.Reflection.Internal.AbstractMemoryBlock
		{
			private sealed class DisposableData : System.Reflection.Internal.CriticalDisposableObject
			{
				private IDisposable _accessor;

				private SafeBuffer _safeBuffer;

				private unsafe byte* _pointer;

				public unsafe byte* Pointer => _pointer;

				public unsafe DisposableData(IDisposable accessor, SafeBuffer safeBuffer, long offset)
				{
					RuntimeHelpers.PrepareConstrainedRegions();
					try
					{
					}
					finally
					{
						byte* pointer = null;
						safeBuffer.AcquirePointer(ref pointer);
						_accessor = accessor;
						_safeBuffer = safeBuffer;
						_pointer = pointer + offset;
					}
				}

				protected unsafe override void Release()
				{
					RuntimeHelpers.PrepareConstrainedRegions();
					try
					{
					}
					finally
					{
						Interlocked.Exchange(ref _safeBuffer, null)?.ReleasePointer();
						Interlocked.Exchange(ref _accessor, null)?.Dispose();
					}
					_pointer = null;
				}
			}

			private readonly DisposableData _data;

			private readonly int _size;

			public unsafe override byte* Pointer => _data.Pointer;

			public override int Size => _size;

			internal MemoryMappedFileBlock(IDisposable accessor, SafeBuffer safeBuffer, long offset, int size)
			{
				_data = new DisposableData(accessor, safeBuffer, offset);
				_size = size;
			}

			public override void Dispose()
			{
				_data.Dispose();
			}
		}

		/// <summary>
		/// Represents memory block allocated on native heap.
		/// </summary>
		/// <remarks>
		/// Owns the native memory resource.
		/// </remarks>
		internal sealed class NativeHeapMemoryBlock : System.Reflection.Internal.AbstractMemoryBlock
		{
			private sealed class DisposableData : System.Reflection.Internal.CriticalDisposableObject
			{
				private IntPtr _pointer;

				public unsafe byte* Pointer => (byte*)(void*)_pointer;

				public DisposableData(int size)
				{
					RuntimeHelpers.PrepareConstrainedRegions();
					try
					{
					}
					finally
					{
						_pointer = Marshal.AllocHGlobal(size);
					}
				}

				protected override void Release()
				{
					RuntimeHelpers.PrepareConstrainedRegions();
					try
					{
					}
					finally
					{
						IntPtr intPtr = Interlocked.Exchange(ref _pointer, IntPtr.Zero);
						if (intPtr != IntPtr.Zero)
						{
							Marshal.FreeHGlobal(intPtr);
						}
					}
				}
			}

			private readonly DisposableData _data;

			private readonly int _size;

			public unsafe override byte* Pointer => _data.Pointer;

			public override int Size => _size;

			internal NativeHeapMemoryBlock(int size)
			{
				_data = new DisposableData(size);
				_size = size;
			}

			public override void Dispose()
			{
				_data.Dispose();
			}
		}

		/// <summary>
		/// Generic implementation of object pooling pattern with predefined pool size limit. The main
		/// purpose is that limited number of frequently used objects can be kept in the pool for
		/// further recycling.
		///
		/// Notes:
		/// 1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
		///    is no space in the pool, extra returned objects will be dropped.
		///
		/// 2) it is implied that if object was obtained from a pool, the caller will return it back in
		///    a relatively short time. Keeping checked out objects for long durations is ok, but
		///    reduces usefulness of pooling. Just new up your own.
		///
		/// Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice.
		/// Rationale:
		///    If there is no intent for reusing the object, do not use pool - just use "new".
		/// </summary>
		internal sealed class ObjectPool<T> where T : class
		{
			private struct Element
			{
				internal T Value;
			}

			private readonly Element[] _items;

			private readonly Func<T> _factory;

			internal ObjectPool(Func<T> factory)
				: this(factory, Environment.ProcessorCount * 2)
			{
			}

			internal ObjectPool(Func<T> factory, int size)
			{
				_factory = factory;
				_items = new Element[size];
			}

			private T CreateInstance()
			{
				return _factory();
			}

			/// <summary>
			/// Produces an instance.
			/// </summary>
			/// <remarks>
			/// Search strategy is a simple linear probing which is chosen for it cache-friendliness.
			/// Note that Free will try to store recycled objects close to the start thus statistically
			/// reducing how far we will typically search.
			/// </remarks>
			internal T Allocate()
			{
				Element[] items = _items;
				int num = 0;
				T val;
				while (true)
				{
					if (num < items.Length)
					{
						val = items[num].Value;
						if (val != null && val == Interlocked.CompareExchange(ref items[num].Value, null, val))
						{
							break;
						}
						num++;
						continue;
					}
					val = CreateInstance();
					break;
				}
				return val;
			}

			/// <summary>
			/// Returns objects to the pool.
			/// </summary>
			/// <remarks>
			/// Search strategy is a simple linear probing which is chosen for it cache-friendliness.
			/// Note that Free will try to store recycled objects close to the start thus statistically
			/// reducing how far we will typically search in Allocate.
			/// </remarks>
			internal void Free(T obj)
			{
				Element[] items = _items;
				for (int i = 0; i < items.Length; i++)
				{
					if (items[i].Value == null)
					{
						items[i].Value = obj;
						break;
					}
				}
			}
		}

		internal sealed class PinnedObject : System.Reflection.Internal.CriticalDisposableObject
		{
			private GCHandle _handle;

			private int _isValid;

			public unsafe byte* Pointer => (byte*)(void*)_handle.AddrOfPinnedObject();

			public PinnedObject(object obj)
			{
				RuntimeHelpers.PrepareConstrainedRegions();
				try
				{
				}
				finally
				{
					_handle = GCHandle.Alloc(obj, GCHandleType.Pinned);
					_isValid = 1;
				}
			}

			protected override void Release()
			{
				RuntimeHelpers.PrepareConstrainedRegions();
				try
				{
				}
				finally
				{
					if (Interlocked.Exchange(ref _isValid, 0) != 0)
					{
						_handle.Free();
					}
				}
			}
		}

		/// <summary>
		/// The usage is:
		///        var inst = PooledStringBuilder.GetInstance();
		///        var sb = inst.builder;
		///        ... Do Stuff...
		///        ... sb.ToString() ...
		///        inst.Free();
		/// </summary>
		internal sealed class PooledStringBuilder
		{
			public readonly StringBuilder Builder = new StringBuilder();

			private readonly System.Reflection.Internal.ObjectPool<System.Reflection.Internal.PooledStringBuilder> _pool;

			private static readonly System.Reflection.Internal.ObjectPool<System.Reflection.Internal.PooledStringBuilder> s_poolInstance = CreatePool();

			public int Length => Builder.Length;

			private PooledStringBuilder(System.Reflection.Internal.ObjectPool<System.Reflection.Internal.PooledStringBuilder> pool)
			{
				_pool = pool;
			}

			public void Free()
			{
				StringBuilder builder = Builder;
				if (builder.Capacity <= 1024)
				{
					builder.Clear();
					_pool.Free(this);
				}
			}

			public string ToStringAndFree()
			{
				string result = Builder.ToString();
				Free();
				return result;
			}

			public static System.Reflection.Internal.ObjectPool<System.Reflection.Internal.PooledStringBuilder> CreatePool()
			{
				System.Reflection.Internal.ObjectPool<System.Reflection.Internal.PooledStringBuilder> pool = null;
				pool = new System.Reflection.Internal.ObjectPool<System.Reflection.Internal.PooledStringBuilder>(() => new System.Reflection.Internal.PooledStringBuilder(pool), 32);
				return pool;
			}

			public static System.Reflection.Internal.PooledStringBuilder GetInstance()
			{
				return s_poolInstance.Allocate();
			}
		}

		internal sealed class ReadOnlyUnmanagedMemoryStream : Stream
		{
			private unsafe readonly byte* _data;

			private readonly int _length;

			private int _position;

			public override bool CanRead => true;

			public override bool CanSeek => true;

			public override bool CanWrite => false;

			public override long Length => _length;

			public override long Position
			{
				get
				{
					return _position;
				}
				set
				{
					Seek(value, SeekOrigin.Begin);
				}
			}

			public unsafe ReadOnlyUnmanagedMemoryStream(byte* data, int length)
			{
				_data = data;
				_length = length;
			}

			public unsafe override int ReadByte()
			{
				if (_position >= _length)
				{
					return -1;
				}
				return _data[_position++];
			}

			public unsafe override int Read(byte[] buffer, int offset, int count)
			{
				int num = Math.Min(count, _length - _position);
				Marshal.Copy((IntPtr)(_data + _position), buffer, offset, num);
				_position += num;
				return num;
			}

			public override void Flush()
			{
			}

			public override long Seek(long offset, SeekOrigin origin)
			{
				long num;
				try
				{
					num = checked(origin switch
					{
						SeekOrigin.Begin => offset, 
						SeekOrigin.Current => offset + _position, 
						SeekOrigin.End => offset + _length, 
						_ => throw new ArgumentOutOfRangeException("origin"), 
					});
				}
				catch (OverflowException)
				{
					throw new ArgumentOutOfRangeException("offset");
				}
				if (num < 0 || num > int.MaxValue)
				{
					throw new ArgumentOutOfRangeException("offset");
				}
				_position = (int)num;
				return num;
			}

			public override void SetLength(long value)
			{
				throw new NotSupportedException();
			}

			public override void Write(byte[] buffer, int offset, int count)
			{
				throw new NotSupportedException();
			}
		}

		internal readonly struct StreamConstraints
		{
			public readonly object? GuardOpt;

			public readonly long ImageStart;

			public readonly int ImageSize;

			public StreamConstraints(object? guardOpt, long startPosition, int imageSize)
			{
				GuardOpt = guardOpt;
				ImageStart = startPosition;
				ImageSize = imageSize;
			}
		}

		internal static class StreamExtensions
		{
			internal const int StreamCopyBufferSize = 81920;

			private static bool IsWindows => Path.DirectorySeparatorChar == '\\';

			private static SafeHandle GetSafeFileHandle(FileStream stream)
			{
				SafeHandle safeFileHandle;
				try
				{
					safeFileHandle = stream.SafeFileHandle;
				}
				catch
				{
					return null;
				}
				if (safeFileHandle != null && safeFileHandle.IsInvalid)
				{
					return null;
				}
				return safeFileHandle;
			}

			internal unsafe static int Read(this Stream stream, byte* buffer, int size)
			{
				if (!IsWindows || !(stream is FileStream stream2))
				{
					return 0;
				}
				SafeHandle safeFileHandle = GetSafeFileHandle(stream2);
				if (safeFileHandle == null)
				{
					return 0;
				}
				if (global::Interop.Kernel32.ReadFile(safeFileHandle, buffer, size, out var numBytesRead, IntPtr.Zero) != 0)
				{
					return numBytesRead;
				}
				return 0;
			}

			/// <summary>
			/// Copies specified amount of data from given stream to a target memory pointer.
			/// </summary>
			/// <exception cref="T:System.IO.IOException">unexpected stream end.</exception>
			internal unsafe static void CopyTo(this Stream source, byte* destination, int size)
			{
				byte[] array = new byte[Math.Min(81920, size)];
				while (size > 0)
				{
					int num = Math.Min(size, array.Length);
					int num2 = source.Read(array, 0, num);
					if (num2 <= 0 || num2 > num)
					{
						throw new IOException(MDCFR.Properties.Resources.UnexpectedStreamEnd);
					}
					Marshal.Copy(array, 0, (IntPtr)destination, num2);
					destination += num2;
					size -= num2;
				}
			}

			/// <summary>
			/// Attempts to read all of the requested bytes from the stream into the buffer
			/// </summary>
			/// <returns>
			/// The number of bytes read. Less than <paramref name="count" /> will
			/// only be returned if the end of stream is reached before all bytes can be read.
			/// </returns>
			/// <remarks>
			/// Unlike <see cref="M:System.IO.Stream.Read(System.Byte[],System.Int32,System.Int32)" /> it is not guaranteed that
			/// the stream position or the output buffer will be unchanged if an exception is
			/// returned.
			/// </remarks>
			internal static int TryReadAll(this Stream stream, byte[] buffer, int offset, int count)
			{
				int i;
				int num;
				for (i = 0; i < count; i += num)
				{
					num = stream.Read(buffer, offset + i, count - i);
					if (num == 0)
					{
						break;
					}
				}
				return i;
			}

			/// <summary>
			/// Resolve image size as either the given user-specified size or distance from current position to end-of-stream.
			/// Also performs the relevant argument validation and publicly visible caller has same argument names.
			/// </summary>
			/// <exception cref="T:System.ArgumentException">size is 0 and distance from current position to end-of-stream can't fit in Int32.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException">Size is negative or extends past the end-of-stream from current position.</exception>
			internal static int GetAndValidateSize(Stream stream, int size, string streamParameterName)
			{
				long num = stream.Length - stream.Position;
				if (size < 0 || size > num)
				{
					throw new ArgumentOutOfRangeException("size");
				}
				if (size != 0)
				{
					return size;
				}
				if (num > int.MaxValue)
				{
					throw new ArgumentException(MDCFR.Properties.Resources.StreamTooLarge, streamParameterName);
				}
				return (int)num;
			}
		}

		/// <summary>
		/// Represents data read from a stream.
		/// </summary>
		/// <remarks>
		/// Uses memory map to load data from streams backed by files that are bigger than <see cref="F:System.Reflection.Internal.StreamMemoryBlockProvider.MemoryMapThreshold" />.
		/// </remarks>
		internal sealed class StreamMemoryBlockProvider : System.Reflection.Internal.MemoryBlockProvider
		{
			internal const int MemoryMapThreshold = 16384;

			private Stream _stream;

			private readonly object _streamGuard;

			private readonly bool _leaveOpen;

			private bool _useMemoryMap;

			private readonly long _imageStart;

			private readonly int _imageSize;

			private MemoryMappedFile _lazyMemoryMap;

			public override int Size => _imageSize;

			public StreamMemoryBlockProvider(Stream stream, long imageStart, int imageSize, bool leaveOpen)
			{
				_stream = stream;
				_streamGuard = new object();
				_imageStart = imageStart;
				_imageSize = imageSize;
				_leaveOpen = leaveOpen;
				_useMemoryMap = stream is FileStream;
			}

			protected override void Dispose(bool disposing)
			{
				if (!_leaveOpen)
				{
					Interlocked.Exchange(ref _stream, null)?.Dispose();
				}
				Interlocked.Exchange(ref _lazyMemoryMap, null)?.Dispose();
			}

			/// <exception cref="T:System.IO.IOException">Error reading from the stream.</exception>
			internal unsafe static System.Reflection.Internal.NativeHeapMemoryBlock ReadMemoryBlockNoLock(Stream stream, long start, int size)
			{
				System.Reflection.Internal.NativeHeapMemoryBlock nativeHeapMemoryBlock = new System.Reflection.Internal.NativeHeapMemoryBlock(size);
				bool flag = true;
				try
				{
					stream.Seek(start, SeekOrigin.Begin);
					int num = 0;
					if ((num = stream.Read(nativeHeapMemoryBlock.Pointer, size)) != size)
					{
						stream.CopyTo(nativeHeapMemoryBlock.Pointer + num, size - num);
					}
					flag = false;
				}
				finally
				{
					if (flag)
					{
						nativeHeapMemoryBlock.Dispose();
					}
				}
				return nativeHeapMemoryBlock;
			}

			/// <exception cref="T:System.IO.IOException">Error while reading from the stream.</exception>
			protected override System.Reflection.Internal.AbstractMemoryBlock GetMemoryBlockImpl(int start, int size)
			{
				long start2 = _imageStart + start;
				if (_useMemoryMap && size > 16384)
				{
					if (TryCreateMemoryMappedFileBlock(start2, size, out var block))
					{
						return block;
					}
					_useMemoryMap = false;
				}
				lock (_streamGuard)
				{
					return ReadMemoryBlockNoLock(_stream, start2, size);
				}
			}

			public override Stream GetStream(out System.Reflection.Internal.StreamConstraints constraints)
			{
				constraints = new System.Reflection.Internal.StreamConstraints(_streamGuard, _imageStart, _imageSize);
				return _stream;
			}

			/// <exception cref="T:System.IO.IOException">IO error while mapping memory or not enough memory to create the mapping.</exception>
			private bool TryCreateMemoryMappedFileBlock(long start, int size, [NotNullWhen(true)] out System.Reflection.Internal.MemoryMappedFileBlock block)
			{
				if (_lazyMemoryMap == null)
				{
					MemoryMappedFile memoryMappedFile;
					lock (_streamGuard)
					{
						try
						{
							memoryMappedFile = MemoryMappedFile.CreateFromFile((FileStream)_stream, null, 0L, MemoryMappedFileAccess.Read, HandleInheritability.None, leaveOpen: true);
						}
						catch (UnauthorizedAccessException ex)
						{
							throw new IOException(ex.Message, ex);
						}
					}
					if (memoryMappedFile == null)
					{
						block = null;
						return false;
					}
					if (Interlocked.CompareExchange(ref _lazyMemoryMap, memoryMappedFile, null) != null)
					{
						memoryMappedFile.Dispose();
					}
				}
				MemoryMappedViewAccessor memoryMappedViewAccessor;
				lock (_streamGuard)
				{
					memoryMappedViewAccessor = _lazyMemoryMap.CreateViewAccessor(start, size, MemoryMappedFileAccess.Read);
				}
				if (memoryMappedViewAccessor == null)
				{
					block = null;
					return false;
				}
				block = new System.Reflection.Internal.MemoryMappedFileBlock(memoryMappedViewAccessor, memoryMappedViewAccessor.SafeMemoryMappedViewHandle, memoryMappedViewAccessor.PointerOffset, size);
				return true;
			}
		}
	}

	namespace Metadata
	{
		using System.ComponentModel;
		using System.Reflection.Internal;
		using System.Runtime.Serialization;
		using Microsoft.Win32.SafeHandles;
		using System.Configuration.Assemblies;
		using System.Reflection.PortableExecutable;

		/// <summary>
		/// Represents the shape of an array type.
		/// </summary>
		public readonly struct ArrayShape
		{
			/// <summary>
			/// Gets the number of dimensions in the array.
			/// </summary>
			public int Rank { get; }

			/// <summary>
			/// Gets the sizes of each dimension. Length may be smaller than rank, in which case the trailing dimensions have unspecified sizes.
			/// </summary>
			public System.Collections.Immutable.ImmutableArray<int> Sizes { get; }

			/// <summary>
			/// Gets the lower-bounds of each dimension. Length may be smaller than rank, in which case the trailing dimensions have unspecified lower bounds.
			/// </summary>
			public System.Collections.Immutable.ImmutableArray<int> LowerBounds { get; }

			public ArrayShape(int rank, System.Collections.Immutable.ImmutableArray<int> sizes, System.Collections.Immutable.ImmutableArray<int> lowerBounds)
			{
				Rank = rank;
				Sizes = sizes;
				LowerBounds = lowerBounds;
			}
		}

		public readonly struct AssemblyDefinition
		{
			private readonly MetadataReader _reader;

			public AssemblyHashAlgorithm HashAlgorithm => _reader.AssemblyTable.GetHashAlgorithm();

			public Version Version => _reader.AssemblyTable.GetVersion();

			public AssemblyFlags Flags => _reader.AssemblyTable.GetFlags();

			public StringHandle Name => _reader.AssemblyTable.GetName();

			public StringHandle Culture => _reader.AssemblyTable.GetCulture();

			public BlobHandle PublicKey => _reader.AssemblyTable.GetPublicKey();

			public AssemblyName GetAssemblyName()
			{
				AssemblyFlags assemblyFlags = Flags;
				if (!PublicKey.IsNil)
				{
					assemblyFlags |= AssemblyFlags.PublicKey;
				}
				return _reader.GetAssemblyName(Name, Version, Culture, PublicKey, HashAlgorithm, assemblyFlags);
			}

			internal AssemblyDefinition(MetadataReader reader)
			{
				_reader = reader;
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, EntityHandle.AssemblyDefinition);
			}

			public DeclarativeSecurityAttributeHandleCollection GetDeclarativeSecurityAttributes()
			{
				return new DeclarativeSecurityAttributeHandleCollection(_reader, EntityHandle.AssemblyDefinition);
			}
		}

		public readonly struct AssemblyDefinitionHandle : IEquatable<AssemblyDefinitionHandle>
		{
			private const uint tokenType = 536870912u;

			private const byte tokenTypeSmall = 32;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			internal AssemblyDefinitionHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static AssemblyDefinitionHandle FromRowId(int rowId)
			{
				return new AssemblyDefinitionHandle(rowId);
			}

			public static implicit operator Handle(AssemblyDefinitionHandle handle)
			{
				return new Handle(32, handle._rowId);
			}

			public static implicit operator EntityHandle(AssemblyDefinitionHandle handle)
			{
				return new EntityHandle((uint)(0x20000000uL | (ulong)handle._rowId));
			}

			public static explicit operator AssemblyDefinitionHandle(Handle handle)
			{
				if (handle.VType != 32)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new AssemblyDefinitionHandle(handle.RowId);
			}

			public static explicit operator AssemblyDefinitionHandle(EntityHandle handle)
			{
				if (handle.VType != 536870912)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new AssemblyDefinitionHandle(handle.RowId);
			}

			public static bool operator ==(AssemblyDefinitionHandle left, AssemblyDefinitionHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is AssemblyDefinitionHandle)
				{
					return ((AssemblyDefinitionHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(AssemblyDefinitionHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(AssemblyDefinitionHandle left, AssemblyDefinitionHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		public readonly struct AssemblyFile
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private AssemblyFileHandle Handle => AssemblyFileHandle.FromRowId(_rowId);

			/// <summary>
			/// True if the file contains metadata.
			/// </summary>
			/// <remarks>
			/// Corresponds to Flags field of File table in ECMA-335 Standard.
			/// </remarks>
			public bool ContainsMetadata => _reader.FileTable.GetFlags(Handle) == 0;

			/// <summary>
			/// File name with extension.
			/// </summary>
			/// <remarks>
			/// Corresponds to Name field of File table in ECMA-335 Standard.
			/// </remarks>
			public StringHandle Name => _reader.FileTable.GetName(Handle);

			/// <summary>
			/// Hash value of the file content calculated using <see cref="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm" />.
			/// </summary>
			/// <remarks>
			/// Corresponds to HashValue field of File table in ECMA-335 Standard.
			/// </remarks>
			public BlobHandle HashValue => _reader.FileTable.GetHashValue(Handle);

			internal AssemblyFile(MetadataReader reader, AssemblyFileHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, Handle);
			}
		}

		public readonly struct AssemblyFileHandle : IEquatable<AssemblyFileHandle>
		{
			private const uint tokenType = 637534208u;

			private const byte tokenTypeSmall = 38;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private AssemblyFileHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static AssemblyFileHandle FromRowId(int rowId)
			{
				return new AssemblyFileHandle(rowId);
			}

			public static implicit operator Handle(AssemblyFileHandle handle)
			{
				return new Handle(38, handle._rowId);
			}

			public static implicit operator EntityHandle(AssemblyFileHandle handle)
			{
				return new EntityHandle((uint)(0x26000000uL | (ulong)handle._rowId));
			}

			public static explicit operator AssemblyFileHandle(Handle handle)
			{
				if (handle.VType != 38)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new AssemblyFileHandle(handle.RowId);
			}

			public static explicit operator AssemblyFileHandle(EntityHandle handle)
			{
				if (handle.VType != 637534208)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new AssemblyFileHandle(handle.RowId);
			}

			public static bool operator ==(AssemblyFileHandle left, AssemblyFileHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is AssemblyFileHandle)
				{
					return ((AssemblyFileHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(AssemblyFileHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(AssemblyFileHandle left, AssemblyFileHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		/// <summary>
		/// Represents a collection of <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />.
		/// </summary>
		public readonly struct AssemblyFileHandleCollection : IReadOnlyCollection<AssemblyFileHandle>, IEnumerable<AssemblyFileHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<AssemblyFileHandle>, IDisposable, IEnumerator
			{
				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public AssemblyFileHandle Current => AssemblyFileHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal Enumerator(int lastRowId)
				{
					_lastRowId = lastRowId;
					_currentRowId = 0;
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly int _lastRowId;

			public int Count => _lastRowId;

			internal AssemblyFileHandleCollection(int lastRowId)
			{
				_lastRowId = lastRowId;
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_lastRowId);
			}

			IEnumerator<AssemblyFileHandle> IEnumerable<AssemblyFileHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public readonly struct AssemblyReference
		{
			private readonly MetadataReader _reader;

			private readonly uint _treatmentAndRowId;

			private static readonly Version s_version_4_0_0_0 = new Version(4, 0, 0, 0);

			private int RowId => (int)(_treatmentAndRowId & 0xFFFFFF);

			private bool IsVirtual => (_treatmentAndRowId & 0x80000000u) != 0;

			public Version Version
			{
				get
				{
					if (IsVirtual)
					{
						return GetVirtualVersion();
					}
					if (RowId == _reader.WinMDMscorlibRef)
					{
						return s_version_4_0_0_0;
					}
					return _reader.AssemblyRefTable.GetVersion(RowId);
				}
			}

			public AssemblyFlags Flags
			{
				get
				{
					if (IsVirtual)
					{
						return GetVirtualFlags();
					}
					return _reader.AssemblyRefTable.GetFlags(RowId);
				}
			}

			public StringHandle Name
			{
				get
				{
					if (IsVirtual)
					{
						return GetVirtualName();
					}
					return _reader.AssemblyRefTable.GetName(RowId);
				}
			}

			public StringHandle Culture
			{
				get
				{
					if (IsVirtual)
					{
						return GetVirtualCulture();
					}
					return _reader.AssemblyRefTable.GetCulture(RowId);
				}
			}

			public BlobHandle PublicKeyOrToken
			{
				get
				{
					if (IsVirtual)
					{
						return GetVirtualPublicKeyOrToken();
					}
					return _reader.AssemblyRefTable.GetPublicKeyOrToken(RowId);
				}
			}

			public BlobHandle HashValue
			{
				get
				{
					if (IsVirtual)
					{
						return GetVirtualHashValue();
					}
					return _reader.AssemblyRefTable.GetHashValue(RowId);
				}
			}

			public AssemblyName GetAssemblyName()
			{
				return _reader.GetAssemblyName(Name, Version, Culture, PublicKeyOrToken, AssemblyHashAlgorithm.None, Flags);
			}

			internal AssemblyReference(MetadataReader reader, uint treatmentAndRowId)
			{
				_reader = reader;
				_treatmentAndRowId = treatmentAndRowId;
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				if (IsVirtual)
				{
					return GetVirtualCustomAttributes();
				}
				return new CustomAttributeHandleCollection(_reader, AssemblyReferenceHandle.FromRowId(RowId));
			}

			private static Version GetVirtualVersion()
			{
				return s_version_4_0_0_0;
			}

			private AssemblyFlags GetVirtualFlags()
			{
				return _reader.AssemblyRefTable.GetFlags(_reader.WinMDMscorlibRef);
			}

			private StringHandle GetVirtualName()
			{
				return StringHandle.FromVirtualIndex(GetVirtualNameIndex((AssemblyReferenceHandle.VirtualIndex)RowId));
			}

			private static StringHandle.VirtualIndex GetVirtualNameIndex(AssemblyReferenceHandle.VirtualIndex index)
			{
				return index switch
				{
					AssemblyReferenceHandle.VirtualIndex.System_ObjectModel => StringHandle.VirtualIndex.System_ObjectModel,
					AssemblyReferenceHandle.VirtualIndex.System_Runtime => StringHandle.VirtualIndex.System_Runtime,
					AssemblyReferenceHandle.VirtualIndex.System_Runtime_InteropServices_WindowsRuntime => StringHandle.VirtualIndex.System_Runtime_InteropServices_WindowsRuntime,
					AssemblyReferenceHandle.VirtualIndex.System_Runtime_WindowsRuntime => StringHandle.VirtualIndex.System_Runtime_WindowsRuntime,
					AssemblyReferenceHandle.VirtualIndex.System_Runtime_WindowsRuntime_UI_Xaml => StringHandle.VirtualIndex.System_Runtime_WindowsRuntime_UI_Xaml,
					AssemblyReferenceHandle.VirtualIndex.System_Numerics_Vectors => StringHandle.VirtualIndex.System_Numerics_Vectors,
					_ => StringHandle.VirtualIndex.System_Runtime_WindowsRuntime,
				};
			}

			private static StringHandle GetVirtualCulture()
			{
				return default(StringHandle);
			}

			private BlobHandle GetVirtualPublicKeyOrToken()
			{
				AssemblyReferenceHandle.VirtualIndex rowId = (AssemblyReferenceHandle.VirtualIndex)RowId;
				if ((uint)(rowId - 3) <= 1u)
				{
					return _reader.AssemblyRefTable.GetPublicKeyOrToken(_reader.WinMDMscorlibRef);
				}
				return BlobHandle.FromVirtualIndex(((_reader.AssemblyRefTable.GetFlags(_reader.WinMDMscorlibRef) & AssemblyFlags.PublicKey) == 0) ? BlobHandle.VirtualIndex.ContractPublicKeyToken : BlobHandle.VirtualIndex.ContractPublicKey, 0);
			}

			private static BlobHandle GetVirtualHashValue()
			{
				return default(BlobHandle);
			}

			private CustomAttributeHandleCollection GetVirtualCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, AssemblyReferenceHandle.FromRowId(_reader.WinMDMscorlibRef));
			}
		}

		public readonly struct AssemblyReferenceHandle : IEquatable<AssemblyReferenceHandle>
		{
			internal enum VirtualIndex
			{
				System_Runtime,
				System_Runtime_InteropServices_WindowsRuntime,
				System_ObjectModel,
				System_Runtime_WindowsRuntime,
				System_Runtime_WindowsRuntime_UI_Xaml,
				System_Numerics_Vectors,
				Count
			}

			private const uint tokenType = 587202560u;

			private const byte tokenTypeSmall = 35;

			private readonly uint _value;

			internal uint Value => _value;

			private uint VToken => _value | 0x23000000u;

			public bool IsNil => _value == 0;

			internal bool IsVirtual => (_value & 0x80000000u) != 0;

			internal int RowId => (int)(_value & 0xFFFFFF);

			private AssemblyReferenceHandle(uint value)
			{
				_value = value;
			}

			internal static AssemblyReferenceHandle FromRowId(int rowId)
			{
				return new AssemblyReferenceHandle((uint)rowId);
			}

			internal static AssemblyReferenceHandle FromVirtualIndex(VirtualIndex virtualIndex)
			{
				return new AssemblyReferenceHandle(0x80000000u | (uint)virtualIndex);
			}

			public static implicit operator Handle(AssemblyReferenceHandle handle)
			{
				return Handle.FromVToken(handle.VToken);
			}

			public static implicit operator EntityHandle(AssemblyReferenceHandle handle)
			{
				return new EntityHandle(handle.VToken);
			}

			public static explicit operator AssemblyReferenceHandle(Handle handle)
			{
				if (handle.Type != 35)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new AssemblyReferenceHandle(handle.SpecificEntityHandleValue);
			}

			public static explicit operator AssemblyReferenceHandle(EntityHandle handle)
			{
				if (handle.Type != 587202560)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new AssemblyReferenceHandle(handle.SpecificHandleValue);
			}

			public static bool operator ==(AssemblyReferenceHandle left, AssemblyReferenceHandle right)
			{
				return left._value == right._value;
			}

			public override bool Equals(object? obj)
			{
				if (obj is AssemblyReferenceHandle)
				{
					return ((AssemblyReferenceHandle)obj)._value == _value;
				}
				return false;
			}

			public bool Equals(AssemblyReferenceHandle other)
			{
				return _value == other._value;
			}

			public override int GetHashCode()
			{
				return _value.GetHashCode();
			}

			public static bool operator !=(AssemblyReferenceHandle left, AssemblyReferenceHandle right)
			{
				return left._value != right._value;
			}
		}

		/// <summary>
		/// Collection of assembly references.
		/// </summary>
		public readonly struct AssemblyReferenceHandleCollection : IReadOnlyCollection<AssemblyReferenceHandle>, IEnumerable<AssemblyReferenceHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<AssemblyReferenceHandle>, IDisposable, IEnumerator
			{
				private readonly MetadataReader _reader;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				private int _virtualRowId;

				public AssemblyReferenceHandle Current
				{
					get
					{
						if (_virtualRowId >= 0)
						{
							if (_virtualRowId == 16777216)
							{
								return default(AssemblyReferenceHandle);
							}
							return AssemblyReferenceHandle.FromVirtualIndex((AssemblyReferenceHandle.VirtualIndex)_virtualRowId);
						}
						return AssemblyReferenceHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));
					}
				}

				object IEnumerator.Current => Current;

				internal Enumerator(MetadataReader reader)
				{
					_reader = reader;
					_currentRowId = 0;
					_virtualRowId = -1;
				}

				public bool MoveNext()
				{
					if (_currentRowId < _reader.AssemblyRefTable.NumberOfNonVirtualRows)
					{
						_currentRowId++;
						return true;
					}
					if (_virtualRowId < _reader.AssemblyRefTable.NumberOfVirtualRows - 1)
					{
						_virtualRowId++;
						return true;
					}
					_currentRowId = 16777216;
					_virtualRowId = 16777216;
					return false;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly MetadataReader _reader;

			public int Count => _reader.AssemblyRefTable.NumberOfNonVirtualRows + _reader.AssemblyRefTable.NumberOfVirtualRows;

			internal AssemblyReferenceHandleCollection(MetadataReader reader)
			{
				_reader = reader;
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_reader);
			}

			IEnumerator<AssemblyReferenceHandle> IEnumerable<AssemblyReferenceHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public readonly struct Blob
		{
			internal readonly byte[] Buffer;

			internal readonly int Start;

			public int Length { get; }

			public bool IsDefault => Buffer == null;

			internal Blob(byte[] buffer, int start, int length)
			{
				Buffer = buffer;
				Start = start;
				Length = length;
			}

			public ArraySegment<byte> GetBytes()
			{
				return new ArraySegment<byte>(Buffer, Start, Length);
			}
		}

		[DebuggerDisplay("{GetDebuggerDisplay(),nq}")]
		public class BlobBuilder
		{
			internal struct Chunks : IEnumerable<BlobBuilder>, IEnumerable, IEnumerator<BlobBuilder>, IDisposable, IEnumerator
			{
				private readonly BlobBuilder _head;

				private BlobBuilder _next;

				private BlobBuilder _currentOpt;

				object IEnumerator.Current => Current;

				public BlobBuilder Current => _currentOpt;

				internal Chunks(BlobBuilder builder)
				{
					_head = builder;
					_next = builder.FirstChunk;
					_currentOpt = null;
				}

				public bool MoveNext()
				{
					if (_currentOpt == _head)
					{
						return false;
					}
					if (_currentOpt == _head._nextOrPrevious)
					{
						_currentOpt = _head;
						return true;
					}
					_currentOpt = _next;
					_next = _next._nextOrPrevious;
					return true;
				}

				public void Reset()
				{
					_currentOpt = null;
					_next = _head.FirstChunk;
				}

				void IDisposable.Dispose()
				{
				}

				public Chunks GetEnumerator()
				{
					return this;
				}

				IEnumerator<BlobBuilder> IEnumerable<BlobBuilder>.GetEnumerator()
				{
					return GetEnumerator();
				}

				IEnumerator IEnumerable.GetEnumerator()
				{
					return GetEnumerator();
				}
			}

			public struct Blobs : IEnumerable<Blob>, IEnumerable, IEnumerator<Blob>, IDisposable, IEnumerator
			{
				private Chunks _chunks;

				object IEnumerator.Current => Current;

				public Blob Current
				{
					get
					{
						BlobBuilder current = _chunks.Current;
						if (current != null)
						{
							return new Blob(current._buffer, 0, current.Length);
						}
						return default(Blob);
					}
				}

				internal Blobs(BlobBuilder builder)
				{
					_chunks = new Chunks(builder);
				}

				public bool MoveNext()
				{
					return _chunks.MoveNext();
				}

				public void Reset()
				{
					_chunks.Reset();
				}

				void IDisposable.Dispose()
				{
				}

				public Blobs GetEnumerator()
				{
					return this;
				}

				IEnumerator<Blob> IEnumerable<Blob>.GetEnumerator()
				{
					return GetEnumerator();
				}

				IEnumerator IEnumerable.GetEnumerator()
				{
					return GetEnumerator();
				}
			}

			internal const int DefaultChunkSize = 256;

			internal const int MinChunkSize = 16;

			private BlobBuilder _nextOrPrevious;

			private int _previousLengthOrFrozenSuffixLengthDelta;

			private byte[] _buffer;

			private uint _length;

			private const uint IsFrozenMask = 2147483648u;

			private BlobBuilder FirstChunk => _nextOrPrevious._nextOrPrevious;

			private bool IsHead => (_length & 0x80000000u) == 0;

			private int Length => (int)(_length & 0x7FFFFFFF);

			private uint FrozenLength => _length | 0x80000000u;

			public int Count => _previousLengthOrFrozenSuffixLengthDelta + Length;

			private int PreviousLength
			{
				get
				{
					return _previousLengthOrFrozenSuffixLengthDelta;
				}
				set
				{
					_previousLengthOrFrozenSuffixLengthDelta = value;
				}
			}

			protected int FreeBytes => _buffer.Length - Length;

			protected internal int ChunkCapacity => _buffer.Length;

			public BlobBuilder(int capacity = 256)
			{
				if (capacity < 0)
				{
					System.Reflection.Throw.ArgumentOutOfRange("capacity");
				}
				_nextOrPrevious = this;
				_buffer = new byte[Math.Max(16, capacity)];
			}

			protected virtual BlobBuilder AllocateChunk(int minimalSize)
			{
				return new BlobBuilder(Math.Max(_buffer.Length, minimalSize));
			}

			protected virtual void FreeChunk()
			{
			}

			public void Clear()
			{
				if (!IsHead)
				{
					System.Reflection.Throw.InvalidOperationBuilderAlreadyLinked();
				}
				BlobBuilder firstChunk = FirstChunk;
				if (firstChunk != this)
				{
					byte[] buffer = firstChunk._buffer;
					firstChunk._length = FrozenLength;
					firstChunk._buffer = _buffer;
					_buffer = buffer;
				}
				foreach (BlobBuilder chunk in GetChunks())
				{
					if (chunk != this)
					{
						chunk.ClearChunk();
						chunk.FreeChunk();
					}
				}
				ClearChunk();
			}

			protected void Free()
			{
				Clear();
				FreeChunk();
			}

			internal void ClearChunk()
			{
				_length = 0u;
				_previousLengthOrFrozenSuffixLengthDelta = 0;
				_nextOrPrevious = this;
			}

			[Conditional("DEBUG")]
			private void CheckInvariants()
			{
				if (!IsHead)
				{
					return;
				}
				int num = 0;
				foreach (BlobBuilder chunk in GetChunks())
				{
					num += chunk.Length;
				}
			}

			internal Chunks GetChunks()
			{
				if (!IsHead)
				{
					System.Reflection.Throw.InvalidOperationBuilderAlreadyLinked();
				}
				return new Chunks(this);
			}

			/// <summary>
			/// Returns a sequence of all blobs that represent the content of the builder.
			/// </summary>
			/// <exception cref="T:System.InvalidOperationException">Content is not available, the builder has been linked with another one.</exception>
			public Blobs GetBlobs()
			{
				if (!IsHead)
				{
					System.Reflection.Throw.InvalidOperationBuilderAlreadyLinked();
				}
				return new Blobs(this);
			}

			/// <summary>
			/// Compares the current content of this writer with another one.
			/// </summary>
			/// <exception cref="T:System.InvalidOperationException">Content is not available, the builder has been linked with another one.</exception>
			public bool ContentEquals(BlobBuilder other)
			{
				if (!IsHead)
				{
					System.Reflection.Throw.InvalidOperationBuilderAlreadyLinked();
				}
				if (this == other)
				{
					return true;
				}
				if (other == null)
				{
					return false;
				}
				if (!other.IsHead)
				{
					System.Reflection.Throw.InvalidOperationBuilderAlreadyLinked();
				}
				if (Count != other.Count)
				{
					return false;
				}
				Chunks chunks = GetChunks();
				Chunks chunks2 = other.GetChunks();
				int num = 0;
				int num2 = 0;
				bool flag = chunks.MoveNext();
				bool flag2 = chunks2.MoveNext();
				while (flag && flag2)
				{
					BlobBuilder current = chunks.Current;
					BlobBuilder current2 = chunks2.Current;
					int num3 = Math.Min(current.Length - num, current2.Length - num2);
					if (!ByteSequenceComparer.Equals(current._buffer, num, current2._buffer, num2, num3))
					{
						return false;
					}
					num += num3;
					num2 += num3;
					if (num == current.Length)
					{
						flag = chunks.MoveNext();
						num = 0;
					}
					if (num2 == current2.Length)
					{
						flag2 = chunks2.MoveNext();
						num2 = 0;
					}
				}
				return flag == flag2;
			}

			/// <exception cref="T:System.InvalidOperationException">Content is not available, the builder has been linked with another one.</exception>
			public byte[] ToArray()
			{
				return ToArray(0, Count);
			}

			/// <exception cref="T:System.ArgumentOutOfRangeException">Range specified by <paramref name="start" /> and <paramref name="byteCount" /> falls outside of the bounds of the buffer content.</exception>
			/// <exception cref="T:System.InvalidOperationException">Content is not available, the builder has been linked with another one.</exception>
			public byte[] ToArray(int start, int byteCount)
			{
				System.Reflection.BlobUtilities.ValidateRange(Count, start, byteCount, "byteCount");
				byte[] array = new byte[byteCount];
				int num = 0;
				int num2 = start;
				int num3 = start + byteCount;
				foreach (BlobBuilder chunk in GetChunks())
				{
					int num4 = num + chunk.Length;
					if (num4 > num2)
					{
						int num5 = Math.Min(num3, num4) - num2;
						Array.Copy(chunk._buffer, num2 - num, array, num2 - start, num5);
						num2 += num5;
						if (num2 == num3)
						{
							break;
						}
					}
					num = num4;
				}
				return array;
			}

			/// <exception cref="T:System.InvalidOperationException">Content is not available, the builder has been linked with another one.</exception>
			public System.Collections.Immutable.ImmutableArray<byte> ToImmutableArray()
			{
				return ToImmutableArray(0, Count);
			}

			/// <exception cref="T:System.ArgumentOutOfRangeException">Range specified by <paramref name="start" /> and <paramref name="byteCount" /> falls outside of the bounds of the buffer content.</exception>
			/// <exception cref="T:System.InvalidOperationException">Content is not available, the builder has been linked with another one.</exception>
			public System.Collections.Immutable.ImmutableArray<byte> ToImmutableArray(int start, int byteCount)
			{
				byte[] array = ToArray(start, byteCount);
				return ImmutableByteArrayInterop.DangerousCreateFromUnderlyingArray(ref array);
			}

			/// <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> is null.</exception>
			/// <exception cref="T:System.InvalidOperationException">Content is not available, the builder has been linked with another one.</exception>
			public void WriteContentTo(Stream destination)
			{
				if (destination == null)
				{
					System.Reflection.Throw.ArgumentNull("destination");
				}
				foreach (BlobBuilder chunk in GetChunks())
				{
					destination.Write(chunk._buffer, 0, chunk.Length);
				}
			}

			/// <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> is default(<see cref="T:System.Reflection.Metadata.BlobWriter" />).</exception>
			/// <exception cref="T:System.InvalidOperationException">Content is not available, the builder has been linked with another one.</exception>
			public void WriteContentTo(ref BlobWriter destination)
			{
				if (destination.IsDefault)
				{
					System.Reflection.Throw.ArgumentNull("destination");
				}
				foreach (BlobBuilder chunk in GetChunks())
				{
					destination.WriteBytes(chunk._buffer, 0, chunk.Length);
				}
			}

			/// <exception cref="T:System.ArgumentNullException"><paramref name="destination" /> is null.</exception>
			/// <exception cref="T:System.InvalidOperationException">Content is not available, the builder has been linked with another one.</exception>
			public void WriteContentTo(BlobBuilder destination)
			{
				if (destination == null)
				{
					System.Reflection.Throw.ArgumentNull("destination");
				}
				foreach (BlobBuilder chunk in GetChunks())
				{
					destination.WriteBytes(chunk._buffer, 0, chunk.Length);
				}
			}

			/// <exception cref="T:System.ArgumentNullException"><paramref name="prefix" /> is null.</exception>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void LinkPrefix(BlobBuilder prefix)
			{
				if (prefix == null)
				{
					System.Reflection.Throw.ArgumentNull("prefix");
				}
				if (!prefix.IsHead || !IsHead)
				{
					System.Reflection.Throw.InvalidOperationBuilderAlreadyLinked();
				}
				if (prefix.Count != 0)
				{
					PreviousLength += prefix.Count;
					prefix._length = prefix.FrozenLength;
					BlobBuilder firstChunk = FirstChunk;
					BlobBuilder firstChunk2 = prefix.FirstChunk;
					BlobBuilder nextOrPrevious = _nextOrPrevious;
					BlobBuilder nextOrPrevious2 = prefix._nextOrPrevious;
					_nextOrPrevious = ((nextOrPrevious != this) ? nextOrPrevious : prefix);
					prefix._nextOrPrevious = ((firstChunk != this) ? firstChunk : ((firstChunk2 != prefix) ? firstChunk2 : prefix));
					if (nextOrPrevious != this)
					{
						nextOrPrevious._nextOrPrevious = ((firstChunk2 != prefix) ? firstChunk2 : prefix);
					}
					if (nextOrPrevious2 != prefix)
					{
						nextOrPrevious2._nextOrPrevious = prefix;
					}
				}
			}

			/// <exception cref="T:System.ArgumentNullException"><paramref name="suffix" /> is null.</exception>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void LinkSuffix(BlobBuilder suffix)
			{
				if (suffix == null)
				{
					System.Reflection.Throw.ArgumentNull("suffix");
				}
				if (!IsHead || !suffix.IsHead)
				{
					System.Reflection.Throw.InvalidOperationBuilderAlreadyLinked();
				}
				if (suffix.Count == 0)
				{
					return;
				}
				bool flag = Count == 0;
				byte[] buffer = suffix._buffer;
				uint length = suffix._length;
				int previousLength = suffix.PreviousLength;
				int length2 = suffix.Length;
				suffix._buffer = _buffer;
				suffix._length = FrozenLength;
				_buffer = buffer;
				_length = length;
				PreviousLength += suffix.Length + previousLength;
				suffix._previousLengthOrFrozenSuffixLengthDelta = previousLength + length2 - suffix.Length;
				if (!flag)
				{
					BlobBuilder firstChunk = FirstChunk;
					BlobBuilder firstChunk2 = suffix.FirstChunk;
					BlobBuilder nextOrPrevious = _nextOrPrevious;
					BlobBuilder blobBuilder = (_nextOrPrevious = suffix._nextOrPrevious);
					suffix._nextOrPrevious = ((firstChunk2 != suffix) ? firstChunk2 : ((firstChunk != this) ? firstChunk : suffix));
					if (nextOrPrevious != this)
					{
						nextOrPrevious._nextOrPrevious = suffix;
					}
					if (blobBuilder != suffix)
					{
						blobBuilder._nextOrPrevious = ((firstChunk != this) ? firstChunk : suffix);
					}
				}
			}

			private void AddLength(int value)
			{
				_length += (uint)value;
			}

			[MethodImpl(MethodImplOptions.NoInlining)]
			private void Expand(int newLength)
			{
				if (!IsHead)
				{
					System.Reflection.Throw.InvalidOperationBuilderAlreadyLinked();
				}
				BlobBuilder blobBuilder = AllocateChunk(Math.Max(newLength, 16));
				if (blobBuilder.ChunkCapacity < newLength)
				{
					throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.ReturnedBuilderSizeTooSmall, GetType(), "AllocateChunk"));
				}
				byte[] buffer = blobBuilder._buffer;
				if (_length == 0)
				{
					blobBuilder._buffer = _buffer;
					_buffer = buffer;
					return;
				}
				BlobBuilder nextOrPrevious = _nextOrPrevious;
				BlobBuilder firstChunk = FirstChunk;
				if (nextOrPrevious == this)
				{
					_nextOrPrevious = blobBuilder;
				}
				else
				{
					blobBuilder._nextOrPrevious = firstChunk;
					nextOrPrevious._nextOrPrevious = blobBuilder;
					_nextOrPrevious = blobBuilder;
				}
				blobBuilder._buffer = _buffer;
				blobBuilder._length = FrozenLength;
				blobBuilder._previousLengthOrFrozenSuffixLengthDelta = PreviousLength;
				_buffer = buffer;
				PreviousLength += Length;
				_length = 0u;
			}

			/// <summary>
			/// Reserves a contiguous block of bytes.
			/// </summary>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> is negative.</exception>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public Blob ReserveBytes(int byteCount)
			{
				if (byteCount < 0)
				{
					System.Reflection.Throw.ArgumentOutOfRange("byteCount");
				}
				int start = ReserveBytesImpl(byteCount);
				return new Blob(_buffer, start, byteCount);
			}

			private int ReserveBytesImpl(int byteCount)
			{
				uint num = _length;
				if (num > _buffer.Length - byteCount)
				{
					Expand(byteCount);
					num = 0u;
				}
				_length = num + (uint)byteCount;
				return (int)num;
			}

			private int ReserveBytesPrimitive(int byteCount)
			{
				return ReserveBytesImpl(byteCount);
			}

			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> is negative.</exception>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteBytes(byte value, int byteCount)
			{
				if (byteCount < 0)
				{
					System.Reflection.Throw.ArgumentOutOfRange("byteCount");
				}
				if (!IsHead)
				{
					System.Reflection.Throw.InvalidOperationBuilderAlreadyLinked();
				}
				int num = Math.Min(FreeBytes, byteCount);
				_buffer.WriteBytes(Length, value, num);
				AddLength(num);
				int num2 = byteCount - num;
				if (num2 > 0)
				{
					Expand(num2);
					_buffer.WriteBytes(0, value, num2);
					AddLength(num2);
				}
			}

			/// <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is null.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> is negative.</exception>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public unsafe void WriteBytes(byte* buffer, int byteCount)
			{
				if (buffer == null)
				{
					System.Reflection.Throw.ArgumentNull("buffer");
				}
				if (byteCount < 0)
				{
					System.Reflection.Throw.ArgumentOutOfRange("byteCount");
				}
				if (!IsHead)
				{
					System.Reflection.Throw.InvalidOperationBuilderAlreadyLinked();
				}
				WriteBytesUnchecked(buffer, byteCount);
			}

			private unsafe void WriteBytesUnchecked(byte* buffer, int byteCount)
			{
				int num = Math.Min(FreeBytes, byteCount);
				Marshal.Copy((IntPtr)buffer, _buffer, Length, num);
				AddLength(num);
				int num2 = byteCount - num;
				if (num2 > 0)
				{
					Expand(num2);
					Marshal.Copy((IntPtr)(buffer + num), _buffer, 0, num2);
					AddLength(num2);
				}
			}

			/// <exception cref="T:System.ArgumentNullException"><paramref name="source" /> is null.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> is negative.</exception>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			/// <returns>Bytes successfully written from the <paramref name="source" />.</returns>
			public int TryWriteBytes(Stream source, int byteCount)
			{
				if (source == null)
				{
					System.Reflection.Throw.ArgumentNull("source");
				}
				if (byteCount < 0)
				{
					throw new ArgumentOutOfRangeException("byteCount");
				}
				if (byteCount == 0)
				{
					return 0;
				}
				int num = 0;
				int num2 = Math.Min(FreeBytes, byteCount);
				if (num2 > 0)
				{
					num = source.TryReadAll(_buffer, Length, num2);
					AddLength(num);
					if (num != num2)
					{
						return num;
					}
				}
				int num3 = byteCount - num2;
				if (num3 > 0)
				{
					Expand(num3);
					num = source.TryReadAll(_buffer, 0, num3);
					AddLength(num);
					num += num2;
				}
				return num;
			}

			/// <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is null.</exception>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteBytes(System.Collections.Immutable.ImmutableArray<byte> buffer)
			{
				WriteBytes(buffer, 0, (!buffer.IsDefault) ? buffer.Length : 0);
			}

			/// <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is null.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException">Range specified by <paramref name="start" /> and <paramref name="byteCount" /> falls outside of the bounds of the <paramref name="buffer" />.</exception>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteBytes(System.Collections.Immutable.ImmutableArray<byte> buffer, int start, int byteCount)
			{
				WriteBytes(ImmutableByteArrayInterop.DangerousGetUnderlyingArray(buffer), start, byteCount);
			}

			/// <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is null.</exception>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteBytes(byte[] buffer)
			{
				WriteBytes(buffer, 0, (buffer != null) ? buffer.Length : 0);
			}

			/// <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is null.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException">Range specified by <paramref name="start" /> and <paramref name="byteCount" /> falls outside of the bounds of the <paramref name="buffer" />.</exception>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public unsafe void WriteBytes(byte[] buffer, int start, int byteCount)
			{
				if (buffer == null)
				{
					System.Reflection.Throw.ArgumentNull("buffer");
				}
				System.Reflection.BlobUtilities.ValidateRange(buffer.Length, start, byteCount, "byteCount");
				if (!IsHead)
				{
					System.Reflection.Throw.InvalidOperationBuilderAlreadyLinked();
				}
				if (buffer.Length != 0)
				{
					fixed (byte* ptr = &buffer[0])
					{
						WriteBytesUnchecked(ptr + start, byteCount);
					}
				}
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void PadTo(int position)
			{
				WriteBytes(0, position - Count);
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void Align(int alignment)
			{
				int count = Count;
				WriteBytes(0, BitArithmetic.Align(count, alignment) - count);
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteBoolean(bool value)
			{
				WriteByte((byte)(value ? 1u : 0u));
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteByte(byte value)
			{
				int start = ReserveBytesPrimitive(1);
				_buffer.WriteByte(start, value);
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteSByte(sbyte value)
			{
				WriteByte((byte)value);
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteDouble(double value)
			{
				int start = ReserveBytesPrimitive(8);
				_buffer.WriteDouble(start, value);
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteSingle(float value)
			{
				int start = ReserveBytesPrimitive(4);
				_buffer.WriteSingle(start, value);
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteInt16(short value)
			{
				WriteUInt16((ushort)value);
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteUInt16(ushort value)
			{
				int start = ReserveBytesPrimitive(2);
				_buffer.WriteUInt16(start, value);
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteInt16BE(short value)
			{
				WriteUInt16BE((ushort)value);
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteUInt16BE(ushort value)
			{
				int start = ReserveBytesPrimitive(2);
				_buffer.WriteUInt16BE(start, value);
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteInt32BE(int value)
			{
				WriteUInt32BE((uint)value);
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteUInt32BE(uint value)
			{
				int start = ReserveBytesPrimitive(4);
				_buffer.WriteUInt32BE(start, value);
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteInt32(int value)
			{
				WriteUInt32((uint)value);
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteUInt32(uint value)
			{
				int start = ReserveBytesPrimitive(4);
				_buffer.WriteUInt32(start, value);
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteInt64(long value)
			{
				WriteUInt64((ulong)value);
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteUInt64(ulong value)
			{
				int start = ReserveBytesPrimitive(8);
				_buffer.WriteUInt64(start, value);
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteDecimal(decimal value)
			{
				int start = ReserveBytesPrimitive(13);
				_buffer.WriteDecimal(start, value);
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteGuid(Guid value)
			{
				int start = ReserveBytesPrimitive(16);
				_buffer.WriteGuid(start, value);
			}

			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteDateTime(DateTime value)
			{
				WriteInt64(value.Ticks);
			}

			/// <summary>
			/// Writes a reference to a heap (heap offset) or a table (row number).
			/// </summary>
			/// <param name="reference">Heap offset or table row number.</param>
			/// <param name="isSmall">True to encode the reference as 16-bit integer, false to encode as 32-bit integer.</param>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteReference(int reference, bool isSmall)
			{
				if (isSmall)
				{
					WriteUInt16((ushort)reference);
				}
				else
				{
					WriteInt32(reference);
				}
			}

			/// <summary>
			/// Writes UTF16 (little-endian) encoded string at the current position.
			/// </summary>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is null.</exception>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public unsafe void WriteUTF16(char[] value)
			{
				if (value == null)
				{
					System.Reflection.Throw.ArgumentNull("value");
				}
				if (!IsHead)
				{
					System.Reflection.Throw.InvalidOperationBuilderAlreadyLinked();
				}
				if (value.Length == 0)
				{
					return;
				}
				if (BitConverter.IsLittleEndian)
				{
					fixed (char* buffer = &value[0])
					{
						WriteBytesUnchecked((byte*)buffer, value.Length * 2);
					}
					return;
				}
				for (int i = 0; i < value.Length; i++)
				{
					WriteUInt16(value[i]);
				}
			}

			/// <summary>
			/// Writes UTF16 (little-endian) encoded string at the current position.
			/// </summary>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is null.</exception>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public unsafe void WriteUTF16(string value)
			{
				if (value == null)
				{
					System.Reflection.Throw.ArgumentNull("value");
				}
				if (!IsHead)
				{
					System.Reflection.Throw.InvalidOperationBuilderAlreadyLinked();
				}
				if (BitConverter.IsLittleEndian)
				{
					fixed (char* buffer = value)
					{
						WriteBytesUnchecked((byte*)buffer, value.Length * 2);
					}
					return;
				}
				for (int i = 0; i < value.Length; i++)
				{
					WriteUInt16(value[i]);
				}
			}

			/// <summary>
			/// Writes string in SerString format (see ECMA-335-II 23.3 Custom attributes).
			/// </summary>
			/// <remarks>
			/// The string is UTF8 encoded and prefixed by the its size in bytes.
			/// Null string is represented as a single byte 0xFF.
			/// </remarks>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteSerializedString(string? value)
			{
				if (value == null)
				{
					WriteByte(byte.MaxValue);
				}
				else
				{
					WriteUTF8(value, 0, value.Length, allowUnpairedSurrogates: true, prependSize: true);
				}
			}

			/// <summary>
			/// Writes string in User String (#US) heap format (see ECMA-335-II 24.2.4 #US and #Blob heaps):
			/// </summary>
			/// <remarks>
			/// The string is UTF16 encoded and prefixed by the its size in bytes.
			///
			/// This final byte holds the value 1 if and only if any UTF16 character within the string has any bit set in its top byte,
			/// or its low byte is any of the following: 0x01-0x08, 0x0E-0x1F, 0x27, 0x2D, 0x7F. Otherwise, it holds 0.
			/// The 1 signifies Unicode characters that require handling beyond that normally provided for 8-bit encoding sets.
			/// </remarks>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteUserString(string value)
			{
				if (value == null)
				{
					System.Reflection.Throw.ArgumentNull("value");
				}
				WriteCompressedInteger(System.Reflection.BlobUtilities.GetUserStringByteLength(value.Length));
				WriteUTF16(value);
				WriteByte(System.Reflection.BlobUtilities.GetUserStringTrailingByte(value));
			}

			/// <summary>
			/// Writes UTF8 encoded string at the current position.
			/// </summary>
			/// <param name="value">Constant value.</param>
			/// <param name="allowUnpairedSurrogates">
			/// True to encode unpaired surrogates as specified, otherwise replace them with U+FFFD character.
			/// </param>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is null.</exception>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteUTF8(string value, bool allowUnpairedSurrogates = true)
			{
				if (value == null)
				{
					System.Reflection.Throw.ArgumentNull("value");
				}
				WriteUTF8(value, 0, value.Length, allowUnpairedSurrogates, prependSize: false);
			}

			internal unsafe void WriteUTF8(string str, int start, int length, bool allowUnpairedSurrogates, bool prependSize)
			{
				if (!IsHead)
				{
					System.Reflection.Throw.InvalidOperationBuilderAlreadyLinked();
				}
				fixed (char* ptr = str)
				{
					char* ptr2 = ptr + start;
					int byteLimit = FreeBytes - (prependSize ? 4 : 0);
					char* remainder;
					int uTF8ByteCount = System.Reflection.BlobUtilities.GetUTF8ByteCount(ptr2, length, byteLimit, out remainder);
					int num = (int)(remainder - ptr2);
					int charCount = length - num;
					int uTF8ByteCount2 = System.Reflection.BlobUtilities.GetUTF8ByteCount(remainder, charCount);
					if (prependSize)
					{
						WriteCompressedInteger(uTF8ByteCount + uTF8ByteCount2);
					}
					_buffer.WriteUTF8(Length, ptr2, num, uTF8ByteCount, allowUnpairedSurrogates);
					AddLength(uTF8ByteCount);
					if (uTF8ByteCount2 > 0)
					{
						Expand(uTF8ByteCount2);
						_buffer.WriteUTF8(0, remainder, charCount, uTF8ByteCount2, allowUnpairedSurrogates);
						AddLength(uTF8ByteCount2);
					}
				}
			}

			/// <summary>
			/// Implements compressed signed integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.
			/// </summary>
			/// <remarks>
			/// If the value lies between -64 (0xFFFFFFC0) and 63 (0x3F), inclusive, encode as a one-byte integer:
			/// bit 7 clear, value bits 5 through 0 held in bits 6 through 1, sign bit (value bit 31) in bit 0.
			///
			/// If the value lies between -8192 (0xFFFFE000) and 8191 (0x1FFF), inclusive, encode as a two-byte integer:
			/// 15 set, bit 14 clear, value bits 12 through 0 held in bits 13 through 1, sign bit(value bit 31) in bit 0.
			///
			/// If the value lies between -268435456 (0xF000000) and 268435455 (0x0FFFFFFF), inclusive, encode as a four-byte integer:
			/// 31 set, 30 set, bit 29 clear, value bits 27 through 0 held in bits 28 through 1, sign bit(value bit 31) in bit 0.
			/// </remarks>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" /> can't be represented as a compressed signed integer.</exception>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteCompressedSignedInteger(int value)
			{
				BlobWriterImpl.WriteCompressedSignedInteger(this, value);
			}

			/// <summary>
			/// Implements compressed unsigned integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.
			/// </summary>
			/// <remarks>
			/// If the value lies between 0 (0x00) and 127 (0x7F), inclusive,
			/// encode as a one-byte integer (bit 7 is clear, value held in bits 6 through 0).
			///
			/// If the value lies between 28 (0x80) and 214 - 1 (0x3FFF), inclusive,
			/// encode as a 2-byte integer with bit 15 set, bit 14 clear (value held in bits 13 through 0).
			///
			/// Otherwise, encode as a 4-byte integer, with bit 31 set, bit 30 set, bit 29 clear (value held in bits 28 through 0).
			/// </remarks>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" /> can't be represented as a compressed unsigned integer.</exception>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteCompressedInteger(int value)
			{
				BlobWriterImpl.WriteCompressedInteger(this, (uint)value);
			}

			/// <summary>
			/// Writes a constant value (see ECMA-335 Partition II section 22.9) at the current position.
			/// </summary>
			/// <exception cref="T:System.ArgumentException"><paramref name="value" /> is not of a constant type.</exception>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteConstant(object? value)
			{
				BlobWriterImpl.WriteConstant(this, value);
			}

			internal string GetDebuggerDisplay()
			{
				if (!IsHead)
				{
					return "<" + Display(_buffer, Length) + ">";
				}
				return string.Join("->", from chunk in GetChunks()
										 select "[" + Display(chunk._buffer, chunk.Length) + "]");
			}

			private static string Display(byte[] bytes, int length)
			{
				if (length > 64)
				{
					return BitConverter.ToString(bytes, 0, 32) + "-...-" + BitConverter.ToString(bytes, length - 32, 32);
				}
				return BitConverter.ToString(bytes, 0, length);
			}
		}

		public readonly struct BlobContentId : IEquatable<BlobContentId>
		{
			private const int Size = 20;

			public Guid Guid { get; }

			public uint Stamp { get; }

			public bool IsDefault
			{
				get
				{
					if (Guid == default(Guid))
					{
						return Stamp == 0;
					}
					return false;
				}
			}

			public BlobContentId(Guid guid, uint stamp)
			{
				Guid = guid;
				Stamp = stamp;
			}

			public BlobContentId(System.Collections.Immutable.ImmutableArray<byte> id)
				: this(ImmutableByteArrayInterop.DangerousGetUnderlyingArray(id))
			{
			}

			public unsafe BlobContentId(byte[] id)
			{
				if (id == null)
				{
					System.Reflection.Throw.ArgumentNull("id");
				}
				if (id.Length != 20)
				{
					throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.UnexpectedArrayLength, 20), "id");
				}
				fixed (byte* buffer = &id[0])
				{
					BlobReader blobReader = new BlobReader(buffer, id.Length);
					Guid = blobReader.ReadGuid();
					Stamp = blobReader.ReadUInt32();
				}
			}

			public static BlobContentId FromHash(System.Collections.Immutable.ImmutableArray<byte> hashCode)
			{
				return FromHash(ImmutableByteArrayInterop.DangerousGetUnderlyingArray(hashCode));
			}

			public static BlobContentId FromHash(byte[] hashCode)
			{
				if (hashCode == null)
				{
					System.Reflection.Throw.ArgumentNull("hashCode");
				}
				if (hashCode.Length < 20)
				{
					throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.HashTooShort, 20), "hashCode");
				}
				uint a = (uint)((hashCode[3] << 24) | (hashCode[2] << 16) | (hashCode[1] << 8) | hashCode[0]);
				ushort num = (ushort)((hashCode[5] << 8) | hashCode[4]);
				ushort num2 = (ushort)((hashCode[7] << 8) | hashCode[6]);
				byte b = hashCode[8];
				byte e = hashCode[9];
				byte f = hashCode[10];
				byte g = hashCode[11];
				byte h = hashCode[12];
				byte i = hashCode[13];
				byte j = hashCode[14];
				byte k = hashCode[15];
				num2 = (ushort)((num2 & 0xFFFu) | 0x4000u);
				b = (byte)((b & 0x3Fu) | 0x80u);
				Guid guid = new Guid((int)a, (short)num, (short)num2, b, e, f, g, h, i, j, k);
				uint stamp = 0x80000000u | (uint)((hashCode[19] << 24) | (hashCode[18] << 16) | (hashCode[17] << 8) | hashCode[16]);
				return new BlobContentId(guid, stamp);
			}

			public static Func<IEnumerable<Blob>, BlobContentId> GetTimeBasedProvider()
			{
				uint timestamp = (uint)(DateTime.UtcNow - new DateTime(1970, 1, 1)).TotalSeconds;
				return (IEnumerable<Blob> content) => new BlobContentId(Guid.NewGuid(), timestamp);
			}

			public bool Equals(BlobContentId other)
			{
				if (Guid == other.Guid)
				{
					return Stamp == other.Stamp;
				}
				return false;
			}

			public override bool Equals([NotNullWhen(true)] object? obj)
			{
				if (obj is BlobContentId other)
				{
					return Equals(other);
				}
				return false;
			}

			public override int GetHashCode()
			{
				return System.Reflection.Internal.Hash.Combine(Stamp, Guid.GetHashCode());
			}

			public static bool operator ==(BlobContentId left, BlobContentId right)
			{
				return left.Equals(right);
			}

			public static bool operator !=(BlobContentId left, BlobContentId right)
			{
				return !left.Equals(right);
			}
		}

		public readonly struct BlobHandle : IEquatable<BlobHandle>
		{
			internal enum VirtualIndex : byte
			{
				Nil,
				ContractPublicKeyToken,
				ContractPublicKey,
				AttributeUsage_AllowSingle,
				AttributeUsage_AllowMultiple,
				Count
			}

			private readonly uint _value;

			internal const int TemplateParameterOffset_AttributeUsageTarget = 2;

			internal uint RawValue => _value;

			public bool IsNil => _value == 0;

			internal bool IsVirtual => (_value & 0x80000000u) != 0;

			private ushort VirtualValue => (ushort)(_value >> 8);

			private BlobHandle(uint value)
			{
				_value = value;
			}

			internal static BlobHandle FromOffset(int heapOffset)
			{
				return new BlobHandle((uint)heapOffset);
			}

			internal static BlobHandle FromVirtualIndex(VirtualIndex virtualIndex, ushort virtualValue)
			{
				return new BlobHandle(0x80000000u | (uint)(virtualValue << 8) | (uint)virtualIndex);
			}

			internal unsafe void SubstituteTemplateParameters(byte[] blob)
			{
				fixed (byte* ptr = &blob[2])
				{
					*(int*)ptr = VirtualValue;
				}
			}

			public static implicit operator Handle(BlobHandle handle)
			{
				return new Handle((byte)(((handle._value & 0x80000000u) >> 24) | 0x71u), (int)(handle._value & 0x1FFFFFFF));
			}

			public static explicit operator BlobHandle(Handle handle)
			{
				if ((handle.VType & 0x7F) != 113)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new BlobHandle((uint)(((handle.VType & 0x80) << 24) | handle.Offset));
			}

			internal int GetHeapOffset()
			{
				return (int)_value;
			}

			internal VirtualIndex GetVirtualIndex()
			{
				return (VirtualIndex)(_value & 0xFFu);
			}

			public override bool Equals([NotNullWhen(true)] object? obj)
			{
				if (obj is BlobHandle other)
				{
					return Equals(other);
				}
				return false;
			}

			public bool Equals(BlobHandle other)
			{
				return _value == other._value;
			}

			public override int GetHashCode()
			{
				return (int)_value;
			}

			public static bool operator ==(BlobHandle left, BlobHandle right)
			{
				return left.Equals(right);
			}

			public static bool operator !=(BlobHandle left, BlobHandle right)
			{
				return !left.Equals(right);
			}
		}

		[DebuggerDisplay("{GetDebuggerDisplay(),nq}")]
		public struct BlobReader
		{
			internal const int InvalidCompressedInteger = int.MaxValue;

			private readonly System.Reflection.Internal.MemoryBlock _block;

			private unsafe readonly byte* _endPointer;

			private unsafe byte* _currentPointer;

			private static readonly uint[] s_corEncodeTokenArray = new uint[4] { 33554432u, 16777216u, 452984832u, 0u };

			/// <summary>
			/// Pointer to the byte at the start of the underlying memory block.
			/// </summary>
			public unsafe byte* StartPointer => _block.Pointer;

			/// <summary>
			/// Pointer to the byte at the current position of the reader.
			/// </summary>
			public unsafe byte* CurrentPointer => _currentPointer;

			/// <summary>
			/// The total length of the underlying memory block.
			/// </summary>
			public int Length => _block.Length;

			/// <summary>
			/// Gets or sets the offset from start of the blob to the current position.
			/// </summary>
			/// <exception cref="T:System.BadImageFormatException">Offset is set outside the bounds of underlying reader.</exception>
			public unsafe int Offset
			{
				get
				{
					return (int)(_currentPointer - _block.Pointer);
				}
				set
				{
					if ((uint)value > (uint)_block.Length)
					{
						System.Reflection.Throw.OutOfBounds();
					}
					_currentPointer = _block.Pointer + value;
				}
			}

			/// <summary>
			/// Bytes remaining from current position to end of underlying memory block.
			/// </summary>
			public unsafe int RemainingBytes => (int)(_endPointer - _currentPointer);

			/// <summary>
			/// Creates a reader of the specified memory block.
			/// </summary>
			/// <param name="buffer">Pointer to the start of the memory block.</param>
			/// <param name="length">Length in bytes of the memory block.</param>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is null and <paramref name="length" /> is greater than zero.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> is negative.</exception>
			/// <exception cref="T:System.PlatformNotSupportedException">The current platform is not little-endian.</exception>
			public unsafe BlobReader(byte* buffer, int length)
				: this(System.Reflection.Internal.MemoryBlock.CreateChecked(buffer, length))
			{
			}

			internal unsafe BlobReader(System.Reflection.Internal.MemoryBlock block)
			{
				_block = block;
				_currentPointer = block.Pointer;
				_endPointer = block.Pointer + block.Length;
			}

			internal unsafe string GetDebuggerDisplay()
			{
				if (_block.Pointer == null)
				{
					return "<null>";
				}
				int displayedBytes;
				string debuggerDisplay = _block.GetDebuggerDisplay(out displayedBytes);
				if (Offset < displayedBytes)
				{
					return debuggerDisplay.Insert(Offset * 3, "*");
				}
				if (displayedBytes == _block.Length)
				{
					return debuggerDisplay + "*";
				}
				return debuggerDisplay + "*...";
			}

			/// <summary>
			/// Repositions the reader to the start of the underlying memory block.
			/// </summary>
			public unsafe void Reset()
			{
				_currentPointer = _block.Pointer;
			}

			/// <summary>
			/// Repositions the reader forward by the number of bytes required to satisfy the given alignment.
			/// </summary>
			public void Align(byte alignment)
			{
				if (!TryAlign(alignment))
				{
					System.Reflection.Throw.OutOfBounds();
				}
			}

			internal unsafe bool TryAlign(byte alignment)
			{
				int num = Offset & (alignment - 1);
				if (num != 0)
				{
					int num2 = alignment - num;
					if (num2 > RemainingBytes)
					{
						return false;
					}
					_currentPointer += num2;
				}
				return true;
			}

			internal unsafe System.Reflection.Internal.MemoryBlock GetMemoryBlockAt(int offset, int length)
			{
				CheckBounds(offset, length);
				return new System.Reflection.Internal.MemoryBlock(_currentPointer + offset, length);
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			private unsafe void CheckBounds(int offset, int byteCount)
			{
				if ((ulong)((long)(uint)offset + (long)(uint)byteCount) > (ulong)(_endPointer - _currentPointer))
				{
					System.Reflection.Throw.OutOfBounds();
				}
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			private unsafe void CheckBounds(int byteCount)
			{
				if ((uint)byteCount > _endPointer - _currentPointer)
				{
					System.Reflection.Throw.OutOfBounds();
				}
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			private unsafe byte* GetCurrentPointerAndAdvance(int length)
			{
				byte* currentPointer = _currentPointer;
				if ((uint)length > (uint)(_endPointer - currentPointer))
				{
					System.Reflection.Throw.OutOfBounds();
				}
				_currentPointer = currentPointer + length;
				return currentPointer;
			}

			[MethodImpl(MethodImplOptions.AggressiveInlining)]
			private unsafe byte* GetCurrentPointerAndAdvance1()
			{
				byte* currentPointer = _currentPointer;
				if (currentPointer == _endPointer)
				{
					System.Reflection.Throw.OutOfBounds();
				}
				_currentPointer = currentPointer + 1;
				return currentPointer;
			}

			public bool ReadBoolean()
			{
				return ReadByte() != 0;
			}

			public unsafe sbyte ReadSByte()
			{
				return (sbyte)(*GetCurrentPointerAndAdvance1());
			}

			public unsafe byte ReadByte()
			{
				return *GetCurrentPointerAndAdvance1();
			}

			public unsafe char ReadChar()
			{
				byte* currentPointerAndAdvance = GetCurrentPointerAndAdvance(2);
				return (char)(*currentPointerAndAdvance + (currentPointerAndAdvance[1] << 8));
			}

			public unsafe short ReadInt16()
			{
				byte* currentPointerAndAdvance = GetCurrentPointerAndAdvance(2);
				return (short)(*currentPointerAndAdvance + (currentPointerAndAdvance[1] << 8));
			}

			public unsafe ushort ReadUInt16()
			{
				byte* currentPointerAndAdvance = GetCurrentPointerAndAdvance(2);
				return (ushort)(*currentPointerAndAdvance + (currentPointerAndAdvance[1] << 8));
			}

			public unsafe int ReadInt32()
			{
				byte* currentPointerAndAdvance = GetCurrentPointerAndAdvance(4);
				return *currentPointerAndAdvance + (currentPointerAndAdvance[1] << 8) + (currentPointerAndAdvance[2] << 16) + (currentPointerAndAdvance[3] << 24);
			}

			public unsafe uint ReadUInt32()
			{
				byte* currentPointerAndAdvance = GetCurrentPointerAndAdvance(4);
				return (uint)(*currentPointerAndAdvance + (currentPointerAndAdvance[1] << 8) + (currentPointerAndAdvance[2] << 16) + (currentPointerAndAdvance[3] << 24));
			}

			public unsafe long ReadInt64()
			{
				byte* currentPointerAndAdvance = GetCurrentPointerAndAdvance(8);
				uint num = (uint)(*currentPointerAndAdvance + (currentPointerAndAdvance[1] << 8) + (currentPointerAndAdvance[2] << 16) + (currentPointerAndAdvance[3] << 24));
				uint num2 = (uint)(currentPointerAndAdvance[4] + (currentPointerAndAdvance[5] << 8) + (currentPointerAndAdvance[6] << 16) + (currentPointerAndAdvance[7] << 24));
				return (long)(num + ((ulong)num2 << 32));
			}

			public ulong ReadUInt64()
			{
				return (ulong)ReadInt64();
			}

			public unsafe float ReadSingle()
			{
				int num = ReadInt32();
				return *(float*)(&num);
			}

			public unsafe double ReadDouble()
			{
				long num = ReadInt64();
				return *(double*)(&num);
			}

			public unsafe Guid ReadGuid()
			{
				byte* currentPointerAndAdvance = GetCurrentPointerAndAdvance(16);
				if (BitConverter.IsLittleEndian)
				{
					return *(Guid*)currentPointerAndAdvance;
				}
				return new Guid(*currentPointerAndAdvance | (currentPointerAndAdvance[1] << 8) | (currentPointerAndAdvance[2] << 16) | (currentPointerAndAdvance[3] << 24), (short)(currentPointerAndAdvance[4] | (currentPointerAndAdvance[5] << 8)), (short)(currentPointerAndAdvance[6] | (currentPointerAndAdvance[7] << 8)), currentPointerAndAdvance[8], currentPointerAndAdvance[9], currentPointerAndAdvance[10], currentPointerAndAdvance[11], currentPointerAndAdvance[12], currentPointerAndAdvance[13], currentPointerAndAdvance[14], currentPointerAndAdvance[15]);
			}

			/// <summary>
			/// Reads <see cref="T:System.Decimal" /> number.
			/// </summary>
			/// <remarks>
			/// Decimal number is encoded in 13 bytes as follows:
			/// - byte 0: highest bit indicates sign (1 for negative, 0 for non-negative); the remaining 7 bits encode scale
			/// - bytes 1..12: 96-bit unsigned integer in little endian encoding.
			/// </remarks>
			/// <exception cref="T:System.BadImageFormatException">The data at the current position was not a valid <see cref="T:System.Decimal" /> number.</exception>
			public unsafe decimal ReadDecimal()
			{
				byte* currentPointerAndAdvance = GetCurrentPointerAndAdvance(13);
				byte b = (byte)(*currentPointerAndAdvance & 0x7Fu);
				if (b > 28)
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.ValueTooLarge);
				}
				return new decimal(currentPointerAndAdvance[1] | (currentPointerAndAdvance[2] << 8) | (currentPointerAndAdvance[3] << 16) | (currentPointerAndAdvance[4] << 24), currentPointerAndAdvance[5] | (currentPointerAndAdvance[6] << 8) | (currentPointerAndAdvance[7] << 16) | (currentPointerAndAdvance[8] << 24), currentPointerAndAdvance[9] | (currentPointerAndAdvance[10] << 8) | (currentPointerAndAdvance[11] << 16) | (currentPointerAndAdvance[12] << 24), (*currentPointerAndAdvance & 0x80) != 0, b);
			}

			public DateTime ReadDateTime()
			{
				return new DateTime(ReadInt64());
			}

			public SignatureHeader ReadSignatureHeader()
			{
				return new SignatureHeader(ReadByte());
			}

			/// <summary>
			/// Finds specified byte in the blob following the current position.
			/// </summary>
			/// <returns>
			/// Index relative to the current position, or -1 if the byte is not found in the blob following the current position.
			/// </returns>
			/// <remarks>
			/// Doesn't change the current position.
			/// </remarks>
			public int IndexOf(byte value)
			{
				int offset = Offset;
				int num = _block.IndexOfUnchecked(value, offset);
				if (num < 0)
				{
					return -1;
				}
				return num - offset;
			}

			/// <summary>
			/// Reads UTF8 encoded string starting at the current position.
			/// </summary>
			/// <param name="byteCount">The number of bytes to read.</param>
			/// <returns>The string.</returns>
			/// <exception cref="T:System.BadImageFormatException"><paramref name="byteCount" /> bytes not available.</exception>
			public unsafe string ReadUTF8(int byteCount)
			{
				string result = _block.PeekUtf8(Offset, byteCount);
				_currentPointer += byteCount;
				return result;
			}

			/// <summary>
			/// Reads UTF16 (little-endian) encoded string starting at the current position.
			/// </summary>
			/// <param name="byteCount">The number of bytes to read.</param>
			/// <returns>The string.</returns>
			/// <exception cref="T:System.BadImageFormatException"><paramref name="byteCount" /> bytes not available.</exception>
			public unsafe string ReadUTF16(int byteCount)
			{
				string result = _block.PeekUtf16(Offset, byteCount);
				_currentPointer += byteCount;
				return result;
			}

			/// <summary>
			/// Reads bytes starting at the current position.
			/// </summary>
			/// <param name="byteCount">The number of bytes to read.</param>
			/// <returns>The byte array.</returns>
			/// <exception cref="T:System.BadImageFormatException"><paramref name="byteCount" /> bytes not available.</exception>
			public unsafe byte[] ReadBytes(int byteCount)
			{
				byte[] result = _block.PeekBytes(Offset, byteCount);
				_currentPointer += byteCount;
				return result;
			}

			/// <summary>
			/// Reads bytes starting at the current position in to the given buffer at the given offset;
			/// </summary>
			/// <param name="byteCount">The number of bytes to read.</param>
			/// <param name="buffer">The destination buffer the bytes read will be written.</param>
			/// <param name="bufferOffset">The offset in the destination buffer where the bytes read will be written.</param>
			/// <exception cref="T:System.BadImageFormatException"><paramref name="byteCount" /> bytes not available.</exception>
			public unsafe void ReadBytes(int byteCount, byte[] buffer, int bufferOffset)
			{
				Marshal.Copy((IntPtr)GetCurrentPointerAndAdvance(byteCount), buffer, bufferOffset, byteCount);
			}

			internal unsafe string ReadUtf8NullTerminated()
			{
				int numberOfBytesRead;
				string result = _block.PeekUtf8NullTerminated(Offset, null, MetadataStringDecoder.DefaultUTF8, out numberOfBytesRead);
				_currentPointer += numberOfBytesRead;
				return result;
			}

			private unsafe int ReadCompressedIntegerOrInvalid()
			{
				int numberOfBytesRead;
				int result = _block.PeekCompressedInteger(Offset, out numberOfBytesRead);
				_currentPointer += numberOfBytesRead;
				return result;
			}

			/// <summary>
			/// Reads an unsigned compressed integer value.
			/// See Metadata Specification section II.23.2: Blobs and signatures.
			/// </summary>
			/// <param name="value">The value of the compressed integer that was read.</param>
			/// <returns>true if the value was read successfully. false if the data at the current position was not a valid compressed integer.</returns>
			public bool TryReadCompressedInteger(out int value)
			{
				value = ReadCompressedIntegerOrInvalid();
				return value != int.MaxValue;
			}

			/// <summary>
			/// Reads an unsigned compressed integer value.
			/// See Metadata Specification section II.23.2: Blobs and signatures.
			/// </summary>
			/// <returns>The value of the compressed integer that was read.</returns>
			/// <exception cref="T:System.BadImageFormatException">The data at the current position was not a valid compressed integer.</exception>
			public int ReadCompressedInteger()
			{
				if (!TryReadCompressedInteger(out var value))
				{
					System.Reflection.Throw.InvalidCompressedInteger();
				}
				return value;
			}

			/// <summary>
			/// Reads a signed compressed integer value.
			/// See Metadata Specification section II.23.2: Blobs and signatures.
			/// </summary>
			/// <param name="value">The value of the compressed integer that was read.</param>
			/// <returns>true if the value was read successfully. false if the data at the current position was not a valid compressed integer.</returns>
			public unsafe bool TryReadCompressedSignedInteger(out int value)
			{
				value = _block.PeekCompressedInteger(Offset, out var numberOfBytesRead);
				if (value == int.MaxValue)
				{
					return false;
				}
				bool flag = (value & 1) != 0;
				value >>= 1;
				if (flag)
				{
					switch (numberOfBytesRead)
					{
						case 1:
							value |= -64;
							break;
						case 2:
							value |= -8192;
							break;
						default:
							value |= -268435456;
							break;
					}
				}
				_currentPointer += numberOfBytesRead;
				return true;
			}

			/// <summary>
			/// Reads a signed compressed integer value.
			/// See Metadata Specification section II.23.2: Blobs and signatures.
			/// </summary>
			/// <returns>The value of the compressed integer that was read.</returns>
			/// <exception cref="T:System.BadImageFormatException">The data at the current position was not a valid compressed integer.</exception>
			public int ReadCompressedSignedInteger()
			{
				if (!TryReadCompressedSignedInteger(out var value))
				{
					System.Reflection.Throw.InvalidCompressedInteger();
				}
				return value;
			}

			/// <summary>
			/// Reads type code encoded in a serialized custom attribute value.
			/// </summary>
			/// <returns><see cref="F:System.Reflection.Metadata.SerializationTypeCode.Invalid" /> if the encoding is invalid.</returns>
			public SerializationTypeCode ReadSerializationTypeCode()
			{
				int num = ReadCompressedIntegerOrInvalid();
				if (num > 255)
				{
					return SerializationTypeCode.Invalid;
				}
				return (SerializationTypeCode)num;
			}

			/// <summary>
			/// Reads type code encoded in a signature.
			/// </summary>
			/// <returns><see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid" /> if the encoding is invalid.</returns>
			public SignatureTypeCode ReadSignatureTypeCode()
			{
				int num = ReadCompressedIntegerOrInvalid();
				if ((uint)(num - 17) <= 1u)
				{
					return SignatureTypeCode.TypeHandle;
				}
				if (num > 255)
				{
					return SignatureTypeCode.Invalid;
				}
				return (SignatureTypeCode)num;
			}

			/// <summary>
			/// Reads a string encoded as a compressed integer containing its length followed by
			/// its contents in UTF8. Null strings are encoded as a single 0xFF byte.
			/// </summary>
			/// <remarks>Defined as a 'SerString' in the ECMA CLI specification.</remarks>
			/// <returns>String value or null.</returns>
			/// <exception cref="T:System.BadImageFormatException">If the encoding is invalid.</exception>
			public string? ReadSerializedString()
			{
				if (TryReadCompressedInteger(out var value))
				{
					return ReadUTF8(value);
				}
				if (ReadByte() != byte.MaxValue)
				{
					System.Reflection.Throw.InvalidSerializedString();
				}
				return null;
			}

			/// <summary>
			/// Reads a type handle encoded in a signature as TypeDefOrRefOrSpecEncoded (see ECMA-335 II.23.2.8).
			/// </summary>
			/// <returns>The handle or nil if the encoding is invalid.</returns>
			public EntityHandle ReadTypeHandle()
			{
				uint num = (uint)ReadCompressedIntegerOrInvalid();
				uint num2 = s_corEncodeTokenArray[num & 3];
				if (num == int.MaxValue || num2 == 0)
				{
					return default(EntityHandle);
				}
				return new EntityHandle(num2 | (num >> 2));
			}

			/// <summary>
			/// Reads a #Blob heap handle encoded as a compressed integer.
			/// </summary>
			/// <remarks>
			/// Blobs that contain references to other blobs are used in Portable PDB format, for example <see cref="P:System.Reflection.Metadata.Document.Name" />.
			/// </remarks>
			public BlobHandle ReadBlobHandle()
			{
				return BlobHandle.FromOffset(ReadCompressedInteger());
			}

			/// <summary>
			/// Reads a constant value (see ECMA-335 Partition II section 22.9) from the current position.
			/// </summary>
			/// <exception cref="T:System.BadImageFormatException">Error while reading from the blob.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="typeCode" /> is not a valid <see cref="T:System.Reflection.Metadata.ConstantTypeCode" />.</exception>
			/// <returns>
			/// Boxed constant value. To avoid allocating the object use Read* methods directly.
			/// Constants of type <see cref="F:System.Reflection.Metadata.ConstantTypeCode.String" /> are encoded as UTF16 strings, use <see cref="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)" /> to read them.
			/// </returns>
			public object? ReadConstant(ConstantTypeCode typeCode)
			{
				switch (typeCode)
				{
					case ConstantTypeCode.Boolean:
						return ReadBoolean();
					case ConstantTypeCode.Char:
						return ReadChar();
					case ConstantTypeCode.SByte:
						return ReadSByte();
					case ConstantTypeCode.Int16:
						return ReadInt16();
					case ConstantTypeCode.Int32:
						return ReadInt32();
					case ConstantTypeCode.Int64:
						return ReadInt64();
					case ConstantTypeCode.Byte:
						return ReadByte();
					case ConstantTypeCode.UInt16:
						return ReadUInt16();
					case ConstantTypeCode.UInt32:
						return ReadUInt32();
					case ConstantTypeCode.UInt64:
						return ReadUInt64();
					case ConstantTypeCode.Single:
						return ReadSingle();
					case ConstantTypeCode.Double:
						return ReadDouble();
					case ConstantTypeCode.String:
						return ReadUTF16(RemainingBytes);
					case ConstantTypeCode.NullReference:
						if (ReadUInt32() != 0)
						{
							throw new BadImageFormatException(MDCFR.Properties.Resources.InvalidConstantValue);
						}
						return null;
					default:
						throw new ArgumentOutOfRangeException("typeCode");
				}
			}
		}

		public struct BlobWriter
		{
			private readonly byte[] _buffer;

			private readonly int _start;

			private readonly int _end;

			private int _position;

			internal bool IsDefault => _buffer == null;

			public int Offset
			{
				get
				{
					return _position - _start;
				}
				set
				{
					if (value < 0 || _start > _end - value)
					{
						System.Reflection.Throw.ValueArgumentOutOfRange();
					}
					_position = _start + value;
				}
			}

			public int Length => _end - _start;

			public int RemainingBytes => _end - _position;

			public Blob Blob => new Blob(_buffer, _start, Length);

			public BlobWriter(int size)
				: this(new byte[size])
			{
			}

			public BlobWriter(byte[] buffer)
				: this(buffer, 0, buffer.Length)
			{
			}

			public BlobWriter(Blob blob)
				: this(blob.Buffer, blob.Start, blob.Length)
			{
			}

			public BlobWriter(byte[] buffer, int start, int count)
			{
				_buffer = buffer;
				_start = start;
				_position = start;
				_end = start + count;
			}

			/// <summary>
			/// Compares the current content of this writer with another one.
			/// </summary>
			public bool ContentEquals(BlobWriter other)
			{
				if (Length == other.Length)
				{
					return ByteSequenceComparer.Equals(_buffer, _start, other._buffer, other._start, Length);
				}
				return false;
			}

			public byte[] ToArray()
			{
				return ToArray(0, Offset);
			}

			/// <exception cref="T:System.ArgumentOutOfRangeException">Range specified by <paramref name="start" /> and <paramref name="byteCount" /> falls outside of the bounds of the buffer content.</exception>
			public byte[] ToArray(int start, int byteCount)
			{
				System.Reflection.BlobUtilities.ValidateRange(Length, start, byteCount, "byteCount");
				byte[] array = new byte[byteCount];
				Array.Copy(_buffer, _start + start, array, 0, byteCount);
				return array;
			}

			public System.Collections.Immutable.ImmutableArray<byte> ToImmutableArray()
			{
				return ToImmutableArray(0, Offset);
			}

			/// <exception cref="T:System.ArgumentOutOfRangeException">Range specified by <paramref name="start" /> and <paramref name="byteCount" /> falls outside of the bounds of the buffer content.</exception>
			public System.Collections.Immutable.ImmutableArray<byte> ToImmutableArray(int start, int byteCount)
			{
				byte[] array = ToArray(start, byteCount);
				return ImmutableByteArrayInterop.DangerousCreateFromUnderlyingArray(ref array);
			}

			private int Advance(int value)
			{
				int position = _position;
				if (position > _end - value)
				{
					System.Reflection.Throw.OutOfBounds();
				}
				_position = position + value;
				return position;
			}

			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> is negative.</exception>
			public unsafe void WriteBytes(byte value, int byteCount)
			{
				if (byteCount < 0)
				{
					System.Reflection.Throw.ArgumentOutOfRange("byteCount");
				}
				int num = Advance(byteCount);
				fixed (byte* ptr = _buffer)
				{
					byte* ptr2 = ptr + num;
					for (int i = 0; i < byteCount; i++)
					{
						ptr2[i] = value;
					}
				}
			}

			/// <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is null.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> is negative.</exception>
			public unsafe void WriteBytes(byte* buffer, int byteCount)
			{
				if (buffer == null)
				{
					System.Reflection.Throw.ArgumentNull("buffer");
				}
				if (byteCount < 0)
				{
					System.Reflection.Throw.ArgumentOutOfRange("byteCount");
				}
				WriteBytesUnchecked(buffer, byteCount);
			}

			private unsafe void WriteBytesUnchecked(byte* buffer, int byteCount)
			{
				int startIndex = Advance(byteCount);
				Marshal.Copy((IntPtr)buffer, _buffer, startIndex, byteCount);
			}

			/// <exception cref="T:System.ArgumentNullException"><paramref name="source" /> is null.</exception>
			public void WriteBytes(BlobBuilder source)
			{
				if (source == null)
				{
					System.Reflection.Throw.ArgumentNull("source");
				}
				source.WriteContentTo(ref this);
			}

			/// <exception cref="T:System.ArgumentNullException"><paramref name="source" /> is null.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> is negative.</exception>
			public int WriteBytes(Stream source, int byteCount)
			{
				if (source == null)
				{
					System.Reflection.Throw.ArgumentNull("source");
				}
				if (byteCount < 0)
				{
					System.Reflection.Throw.ArgumentOutOfRange("byteCount");
				}
				int num = Advance(byteCount);
				int num2 = source.TryReadAll(_buffer, num, byteCount);
				_position = num + num2;
				return num2;
			}

			/// <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is null.</exception>
			public void WriteBytes(System.Collections.Immutable.ImmutableArray<byte> buffer)
			{
				WriteBytes(buffer, 0, (!buffer.IsDefault) ? buffer.Length : 0);
			}

			/// <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is null.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException">Range specified by <paramref name="start" /> and <paramref name="byteCount" /> falls outside of the bounds of the <paramref name="buffer" />.</exception>
			public void WriteBytes(System.Collections.Immutable.ImmutableArray<byte> buffer, int start, int byteCount)
			{
				WriteBytes(ImmutableByteArrayInterop.DangerousGetUnderlyingArray(buffer), start, byteCount);
			}

			/// <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is null.</exception>
			public void WriteBytes(byte[] buffer)
			{
				WriteBytes(buffer, 0, (buffer != null) ? buffer.Length : 0);
			}

			/// <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> is null.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException">Range specified by <paramref name="start" /> and <paramref name="byteCount" /> falls outside of the bounds of the <paramref name="buffer" />.</exception>
			public unsafe void WriteBytes(byte[] buffer, int start, int byteCount)
			{
				if (buffer == null)
				{
					System.Reflection.Throw.ArgumentNull("buffer");
				}
				System.Reflection.BlobUtilities.ValidateRange(buffer.Length, start, byteCount, "byteCount");
				if (buffer.Length != 0)
				{
					fixed (byte* ptr = &buffer[0])
					{
						WriteBytes(ptr + start, byteCount);
					}
				}
			}

			public void PadTo(int offset)
			{
				WriteBytes(0, offset - Offset);
			}

			public void Align(int alignment)
			{
				int offset = Offset;
				WriteBytes(0, BitArithmetic.Align(offset, alignment) - offset);
			}

			public void WriteBoolean(bool value)
			{
				WriteByte((byte)(value ? 1u : 0u));
			}

			public void WriteByte(byte value)
			{
				int num = Advance(1);
				_buffer[num] = value;
			}

			public void WriteSByte(sbyte value)
			{
				WriteByte((byte)value);
			}

			public void WriteDouble(double value)
			{
				int start = Advance(8);
				_buffer.WriteDouble(start, value);
			}

			public void WriteSingle(float value)
			{
				int start = Advance(4);
				_buffer.WriteSingle(start, value);
			}

			public void WriteInt16(short value)
			{
				WriteUInt16((ushort)value);
			}

			public void WriteUInt16(ushort value)
			{
				int start = Advance(2);
				_buffer.WriteUInt16(start, value);
			}

			public void WriteInt16BE(short value)
			{
				WriteUInt16BE((ushort)value);
			}

			public void WriteUInt16BE(ushort value)
			{
				int start = Advance(2);
				_buffer.WriteUInt16BE(start, value);
			}

			public void WriteInt32BE(int value)
			{
				WriteUInt32BE((uint)value);
			}

			public void WriteUInt32BE(uint value)
			{
				int start = Advance(4);
				_buffer.WriteUInt32BE(start, value);
			}

			public void WriteInt32(int value)
			{
				WriteUInt32((uint)value);
			}

			public void WriteUInt32(uint value)
			{
				int start = Advance(4);
				_buffer.WriteUInt32(start, value);
			}

			public void WriteInt64(long value)
			{
				WriteUInt64((ulong)value);
			}

			public void WriteUInt64(ulong value)
			{
				int start = Advance(8);
				_buffer.WriteUInt64(start, value);
			}

			public void WriteDecimal(decimal value)
			{
				int start = Advance(13);
				_buffer.WriteDecimal(start, value);
			}

			public void WriteGuid(Guid value)
			{
				int start = Advance(16);
				_buffer.WriteGuid(start, value);
			}

			public void WriteDateTime(DateTime value)
			{
				WriteInt64(value.Ticks);
			}

			/// <summary>
			/// Writes a reference to a heap (heap offset) or a table (row number).
			/// </summary>
			/// <param name="reference">Heap offset or table row number.</param>
			/// <param name="isSmall">True to encode the reference as 16-bit integer, false to encode as 32-bit integer.</param>
			public void WriteReference(int reference, bool isSmall)
			{
				if (isSmall)
				{
					WriteUInt16((ushort)reference);
				}
				else
				{
					WriteInt32(reference);
				}
			}

			/// <summary>
			/// Writes UTF16 (little-endian) encoded string at the current position.
			/// </summary>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is null.</exception>
			public unsafe void WriteUTF16(char[] value)
			{
				if (value == null)
				{
					System.Reflection.Throw.ArgumentNull("value");
				}
				if (value.Length == 0)
				{
					return;
				}
				if (BitConverter.IsLittleEndian)
				{
					fixed (char* buffer = &value[0])
					{
						WriteBytesUnchecked((byte*)buffer, value.Length * 2);
					}
					return;
				}
				for (int i = 0; i < value.Length; i++)
				{
					WriteUInt16(value[i]);
				}
			}

			/// <summary>
			/// Writes UTF16 (little-endian) encoded string at the current position.
			/// </summary>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is null.</exception>
			public unsafe void WriteUTF16(string value)
			{
				if (value == null)
				{
					System.Reflection.Throw.ArgumentNull("value");
				}
				if (BitConverter.IsLittleEndian)
				{
					fixed (char* buffer = value)
					{
						WriteBytesUnchecked((byte*)buffer, value.Length * 2);
					}
					return;
				}
				for (int i = 0; i < value.Length; i++)
				{
					WriteUInt16(value[i]);
				}
			}

			/// <summary>
			/// Writes string in SerString format (see ECMA-335-II 23.3 Custom attributes).
			/// </summary>
			/// <remarks>
			/// The string is UTF8 encoded and prefixed by the its size in bytes.
			/// Null string is represented as a single byte 0xFF.
			/// </remarks>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteSerializedString(string? str)
			{
				if (str == null)
				{
					WriteByte(byte.MaxValue);
				}
				else
				{
					WriteUTF8(str, 0, str.Length, allowUnpairedSurrogates: true, prependSize: true);
				}
			}

			/// <summary>
			/// Writes string in User String (#US) heap format (see ECMA-335-II 24.2.4 #US and #Blob heaps):
			/// </summary>
			/// <remarks>
			/// The string is UTF16 encoded and prefixed by the its size in bytes.
			///
			/// This final byte holds the value 1 if and only if any UTF16 character within the string has any bit set in its top byte,
			/// or its low byte is any of the following: 0x01-0x08, 0x0E-0x1F, 0x27, 0x2D, 0x7F. Otherwise, it holds 0.
			/// The 1 signifies Unicode characters that require handling beyond that normally provided for 8-bit encoding sets.
			/// </remarks>
			/// <exception cref="T:System.InvalidOperationException">Builder is not writable, it has been linked with another one.</exception>
			public void WriteUserString(string value)
			{
				if (value == null)
				{
					System.Reflection.Throw.ArgumentNull("value");
				}
				WriteCompressedInteger(System.Reflection.BlobUtilities.GetUserStringByteLength(value.Length));
				WriteUTF16(value);
				WriteByte(System.Reflection.BlobUtilities.GetUserStringTrailingByte(value));
			}

			/// <summary>
			/// Writes UTF8 encoded string at the current position.
			/// </summary>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is null.</exception>
			public void WriteUTF8(string value, bool allowUnpairedSurrogates)
			{
				if (value == null)
				{
					System.Reflection.Throw.ArgumentNull("value");
				}
				WriteUTF8(value, 0, value.Length, allowUnpairedSurrogates, prependSize: false);
			}

			private unsafe void WriteUTF8(string str, int start, int length, bool allowUnpairedSurrogates, bool prependSize)
			{
				fixed (char* ptr = str)
				{
					char* ptr2 = ptr + start;
					int uTF8ByteCount = System.Reflection.BlobUtilities.GetUTF8ByteCount(ptr2, length);
					if (prependSize)
					{
						WriteCompressedInteger(uTF8ByteCount);
					}
					int start2 = Advance(uTF8ByteCount);
					_buffer.WriteUTF8(start2, ptr2, length, uTF8ByteCount, allowUnpairedSurrogates);
				}
			}

			/// <summary>
			/// Implements compressed signed integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.
			/// </summary>
			/// <remarks>
			/// If the value lies between -64 (0xFFFFFFC0) and 63 (0x3F), inclusive, encode as a one-byte integer:
			/// bit 7 clear, value bits 5 through 0 held in bits 6 through 1, sign bit (value bit 31) in bit 0.
			///
			/// If the value lies between -8192 (0xFFFFE000) and 8191 (0x1FFF), inclusive, encode as a two-byte integer:
			/// 15 set, bit 14 clear, value bits 12 through 0 held in bits 13 through 1, sign bit(value bit 31) in bit 0.
			///
			/// If the value lies between -268435456 (0xF000000) and 268435455 (0x0FFFFFFF), inclusive, encode as a four-byte integer:
			/// 31 set, 30 set, bit 29 clear, value bits 27 through 0 held in bits 28 through 1, sign bit(value bit 31) in bit 0.
			/// </remarks>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" /> can't be represented as a compressed signed integer.</exception>
			public void WriteCompressedSignedInteger(int value)
			{
				BlobWriterImpl.WriteCompressedSignedInteger(ref this, value);
			}

			/// <summary>
			/// Implements compressed unsigned integer encoding as defined by ECMA-335-II chapter 23.2: Blobs and signatures.
			/// </summary>
			/// <remarks>
			/// If the value lies between 0 (0x00) and 127 (0x7F), inclusive,
			/// encode as a one-byte integer (bit 7 is clear, value held in bits 6 through 0).
			///
			/// If the value lies between 28 (0x80) and 214 - 1 (0x3FFF), inclusive,
			/// encode as a 2-byte integer with bit 15 set, bit 14 clear(value held in bits 13 through 0).
			///
			/// Otherwise, encode as a 4-byte integer, with bit 31 set, bit 30 set, bit 29 clear (value held in bits 28 through 0).
			/// </remarks>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="value" /> can't be represented as a compressed unsigned integer.</exception>
			public void WriteCompressedInteger(int value)
			{
				BlobWriterImpl.WriteCompressedInteger(ref this, (uint)value);
			}

			/// <summary>
			/// Writes a constant value (see ECMA-335 Partition II section 22.9) at the current position.
			/// </summary>
			/// <exception cref="T:System.ArgumentException"><paramref name="value" /> is not of a constant type.</exception>
			public void WriteConstant(object? value)
			{
				BlobWriterImpl.WriteConstant(ref this, value);
			}

			public void Clear()
			{
				_position = _start;
			}
		}

		internal static class BlobWriterImpl
		{
			internal const int SingleByteCompressedIntegerMaxValue = 127;

			internal const int TwoByteCompressedIntegerMaxValue = 16383;

			internal const int MaxCompressedIntegerValue = 536870911;

			internal const int MinSignedCompressedIntegerValue = -268435456;

			internal const int MaxSignedCompressedIntegerValue = 268435455;

			internal static int GetCompressedIntegerSize(int value)
			{
				if (value <= 127)
				{
					return 1;
				}
				if (value <= 16383)
				{
					return 2;
				}
				return 4;
			}

			internal static void WriteCompressedInteger(ref BlobWriter writer, uint value)
			{
				if (value <= 127)
				{
					writer.WriteByte((byte)value);
				}
				else if (value <= 16383)
				{
					writer.WriteUInt16BE((ushort)(0x8000u | value));
				}
				else if (value <= 536870911)
				{
					writer.WriteUInt32BE(0xC0000000u | value);
				}
				else
				{
					System.Reflection.Throw.ValueArgumentOutOfRange();
				}
			}

			internal static void WriteCompressedInteger(BlobBuilder writer, uint value)
			{
				if (value <= 127)
				{
					writer.WriteByte((byte)value);
				}
				else if (value <= 16383)
				{
					writer.WriteUInt16BE((ushort)(0x8000u | value));
				}
				else if (value <= 536870911)
				{
					writer.WriteUInt32BE(0xC0000000u | value);
				}
				else
				{
					System.Reflection.Throw.ValueArgumentOutOfRange();
				}
			}

			internal static void WriteCompressedSignedInteger(ref BlobWriter writer, int value)
			{
				int num = value >> 31;
				if ((value & -64) == (num & -64))
				{
					int num2 = ((value & 0x3F) << 1) | (num & 1);
					writer.WriteByte((byte)num2);
				}
				else if ((value & -8192) == (num & -8192))
				{
					int num3 = ((value & 0x1FFF) << 1) | (num & 1);
					writer.WriteUInt16BE((ushort)(0x8000u | (uint)num3));
				}
				else if ((value & -268435456) == (num & -268435456))
				{
					int num4 = ((value & 0xFFFFFFF) << 1) | (num & 1);
					writer.WriteUInt32BE(0xC0000000u | (uint)num4);
				}
				else
				{
					System.Reflection.Throw.ValueArgumentOutOfRange();
				}
			}

			internal static void WriteCompressedSignedInteger(BlobBuilder writer, int value)
			{
				int num = value >> 31;
				if ((value & -64) == (num & -64))
				{
					int num2 = ((value & 0x3F) << 1) | (num & 1);
					writer.WriteByte((byte)num2);
				}
				else if ((value & -8192) == (num & -8192))
				{
					int num3 = ((value & 0x1FFF) << 1) | (num & 1);
					writer.WriteUInt16BE((ushort)(0x8000u | (uint)num3));
				}
				else if ((value & -268435456) == (num & -268435456))
				{
					int num4 = ((value & 0xFFFFFFF) << 1) | (num & 1);
					writer.WriteUInt32BE(0xC0000000u | (uint)num4);
				}
				else
				{
					System.Reflection.Throw.ValueArgumentOutOfRange();
				}
			}

			internal static void WriteConstant(ref BlobWriter writer, object? value)
			{
				if (value == null)
				{
					writer.WriteUInt32(0u);
					return;
				}
				Type type = value.GetType();
				if (type.GetTypeInfo().IsEnum)
				{
					type = Enum.GetUnderlyingType(type);
				}
				if (type == typeof(bool))
				{
					writer.WriteBoolean((bool)value);
					return;
				}
				if (type == typeof(int))
				{
					writer.WriteInt32((int)value);
					return;
				}
				if (type == typeof(string))
				{
					writer.WriteUTF16((string)value);
					return;
				}
				if (type == typeof(byte))
				{
					writer.WriteByte((byte)value);
					return;
				}
				if (type == typeof(char))
				{
					writer.WriteUInt16((char)value);
					return;
				}
				if (type == typeof(double))
				{
					writer.WriteDouble((double)value);
					return;
				}
				if (type == typeof(short))
				{
					writer.WriteInt16((short)value);
					return;
				}
				if (type == typeof(long))
				{
					writer.WriteInt64((long)value);
					return;
				}
				if (type == typeof(sbyte))
				{
					writer.WriteSByte((sbyte)value);
					return;
				}
				if (type == typeof(float))
				{
					writer.WriteSingle((float)value);
					return;
				}
				if (type == typeof(ushort))
				{
					writer.WriteUInt16((ushort)value);
					return;
				}
				if (type == typeof(uint))
				{
					writer.WriteUInt32((uint)value);
					return;
				}
				if (type == typeof(ulong))
				{
					writer.WriteUInt64((ulong)value);
					return;
				}
				throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.InvalidConstantValueOfType, type));
			}

			internal static void WriteConstant(BlobBuilder writer, object? value)
			{
				if (value == null)
				{
					writer.WriteUInt32(0u);
					return;
				}
				Type type = value.GetType();
				if (type.GetTypeInfo().IsEnum)
				{
					type = Enum.GetUnderlyingType(type);
				}
				if (type == typeof(bool))
				{
					writer.WriteBoolean((bool)value);
					return;
				}
				if (type == typeof(int))
				{
					writer.WriteInt32((int)value);
					return;
				}
				if (type == typeof(string))
				{
					writer.WriteUTF16((string)value);
					return;
				}
				if (type == typeof(byte))
				{
					writer.WriteByte((byte)value);
					return;
				}
				if (type == typeof(char))
				{
					writer.WriteUInt16((char)value);
					return;
				}
				if (type == typeof(double))
				{
					writer.WriteDouble((double)value);
					return;
				}
				if (type == typeof(short))
				{
					writer.WriteInt16((short)value);
					return;
				}
				if (type == typeof(long))
				{
					writer.WriteInt64((long)value);
					return;
				}
				if (type == typeof(sbyte))
				{
					writer.WriteSByte((sbyte)value);
					return;
				}
				if (type == typeof(float))
				{
					writer.WriteSingle((float)value);
					return;
				}
				if (type == typeof(ushort))
				{
					writer.WriteUInt16((ushort)value);
					return;
				}
				if (type == typeof(uint))
				{
					writer.WriteUInt32((uint)value);
					return;
				}
				if (type == typeof(ulong))
				{
					writer.WriteUInt64((ulong)value);
					return;
				}
				throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.InvalidConstantValueOfType, type));
			}
		}

		public readonly struct Constant
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private ConstantHandle Handle => ConstantHandle.FromRowId(_rowId);

			/// <summary>
			/// The type of the constant value.
			/// </summary>
			/// <remarks>
			/// Corresponds to Type field of Constant table in ECMA-335 Standard.
			/// </remarks>
			public ConstantTypeCode TypeCode => _reader.ConstantTable.GetType(Handle);

			/// <summary>
			/// The constant value.
			/// </summary>
			/// <remarks>
			/// Corresponds to Value field of Constant table in ECMA-335 Standard.
			/// </remarks>
			public BlobHandle Value => _reader.ConstantTable.GetValue(Handle);

			/// <summary>
			/// The parent handle (<see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, or <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />).
			/// </summary>
			/// <remarks>
			/// Corresponds to Parent field of Constant table in ECMA-335 Standard.
			/// </remarks>
			public EntityHandle Parent => _reader.ConstantTable.GetParent(Handle);

			internal Constant(MetadataReader reader, int rowId)
			{
				_reader = reader;
				_rowId = rowId;
			}
		}

		public readonly struct ConstantHandle : IEquatable<ConstantHandle>
		{
			private const uint tokenType = 184549376u;

			private const byte tokenTypeSmall = 11;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private ConstantHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static ConstantHandle FromRowId(int rowId)
			{
				return new ConstantHandle(rowId);
			}

			public static implicit operator Handle(ConstantHandle handle)
			{
				return new Handle(11, handle._rowId);
			}

			public static implicit operator EntityHandle(ConstantHandle handle)
			{
				return new EntityHandle((uint)(0xB000000uL | (ulong)handle._rowId));
			}

			public static explicit operator ConstantHandle(Handle handle)
			{
				if (handle.VType != 11)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new ConstantHandle(handle.RowId);
			}

			public static explicit operator ConstantHandle(EntityHandle handle)
			{
				if (handle.VType != 184549376)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new ConstantHandle(handle.RowId);
			}

			public static bool operator ==(ConstantHandle left, ConstantHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is ConstantHandle)
				{
					return ((ConstantHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(ConstantHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(ConstantHandle left, ConstantHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		public enum ConstantTypeCode : byte
		{
			Invalid = 0,
			Boolean = 2,
			Char = 3,
			SByte = 4,
			Byte = 5,
			Int16 = 6,
			UInt16 = 7,
			Int32 = 8,
			UInt32 = 9,
			Int64 = 10,
			UInt64 = 11,
			Single = 12,
			Double = 13,
			String = 14,
			NullReference = 18
		}

		public readonly struct CustomAttribute
		{
			private readonly MetadataReader _reader;

			private readonly uint _treatmentAndRowId;

			private int RowId => (int)(_treatmentAndRowId & 0xFFFFFF);

			private CustomAttributeHandle Handle => CustomAttributeHandle.FromRowId(RowId);

			private MethodDefTreatment Treatment => (MethodDefTreatment)(_treatmentAndRowId >> 24);

			/// <summary>
			/// The constructor (<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />) of the custom attribute type.
			/// </summary>
			/// <remarks>
			/// Corresponds to Type field of CustomAttribute table in ECMA-335 Standard.
			/// </remarks>
			public EntityHandle Constructor => _reader.CustomAttributeTable.GetConstructor(Handle);

			/// <summary>
			/// The handle of the metadata entity the attribute is applied to.
			/// </summary>
			/// <remarks>
			/// Corresponds to Parent field of CustomAttribute table in ECMA-335 Standard.
			/// </remarks>
			public EntityHandle Parent => _reader.CustomAttributeTable.GetParent(Handle);

			/// <summary>
			/// The value of the attribute.
			/// </summary>
			/// <remarks>
			/// Corresponds to Value field of CustomAttribute table in ECMA-335 Standard.
			/// </remarks>
			public BlobHandle Value
			{
				get
				{
					if (Treatment == MethodDefTreatment.None)
					{
						return _reader.CustomAttributeTable.GetValue(Handle);
					}
					return GetProjectedValue();
				}
			}

			internal CustomAttribute(MetadataReader reader, uint treatmentAndRowId)
			{
				_reader = reader;
				_treatmentAndRowId = treatmentAndRowId;
			}

			/// <summary>
			/// Decodes the arguments encoded in the value blob.
			/// </summary>
			public CustomAttributeValue<TType> DecodeValue<TType>(ICustomAttributeTypeProvider<TType> provider)
			{
				return new CustomAttributeDecoder<TType>(provider, _reader).DecodeValue(Constructor, Value);
			}

			private BlobHandle GetProjectedValue()
			{
				CustomAttributeValueTreatment customAttributeValueTreatment = _reader.CalculateCustomAttributeValueTreatment(Handle);
				if (customAttributeValueTreatment == CustomAttributeValueTreatment.None)
				{
					return _reader.CustomAttributeTable.GetValue(Handle);
				}
				return GetProjectedValue(customAttributeValueTreatment);
			}

			private BlobHandle GetProjectedValue(CustomAttributeValueTreatment treatment)
			{
				BlobHandle.VirtualIndex virtualIndex;
				bool flag;
				switch (treatment)
				{
					case CustomAttributeValueTreatment.AttributeUsageVersionAttribute:
					case CustomAttributeValueTreatment.AttributeUsageDeprecatedAttribute:
						virtualIndex = BlobHandle.VirtualIndex.AttributeUsage_AllowMultiple;
						flag = true;
						break;
					case CustomAttributeValueTreatment.AttributeUsageAllowMultiple:
						virtualIndex = BlobHandle.VirtualIndex.AttributeUsage_AllowMultiple;
						flag = false;
						break;
					case CustomAttributeValueTreatment.AttributeUsageAllowSingle:
						virtualIndex = BlobHandle.VirtualIndex.AttributeUsage_AllowSingle;
						flag = false;
						break;
					default:
						return default(BlobHandle);
				}
				BlobHandle value = _reader.CustomAttributeTable.GetValue(Handle);
				BlobReader blobReader = _reader.GetBlobReader(value);
				if (blobReader.Length != 8)
				{
					return value;
				}
				if (blobReader.ReadInt16() != 1)
				{
					return value;
				}
				AttributeTargets attributeTargets = ProjectAttributeTargetValue(blobReader.ReadUInt32());
				if (flag)
				{
					attributeTargets |= AttributeTargets.Constructor | AttributeTargets.Property;
				}
				return BlobHandle.FromVirtualIndex(virtualIndex, (ushort)attributeTargets);
			}

			private static AttributeTargets ProjectAttributeTargetValue(uint rawValue)
			{
				if (rawValue == uint.MaxValue)
				{
					return AttributeTargets.All;
				}
				AttributeTargets attributeTargets = (AttributeTargets)0;
				if ((rawValue & (true ? 1u : 0u)) != 0)
				{
					attributeTargets |= AttributeTargets.Delegate;
				}
				if ((rawValue & 2u) != 0)
				{
					attributeTargets |= AttributeTargets.Enum;
				}
				if ((rawValue & 4u) != 0)
				{
					attributeTargets |= AttributeTargets.Event;
				}
				if ((rawValue & 8u) != 0)
				{
					attributeTargets |= AttributeTargets.Field;
				}
				if ((rawValue & 0x10u) != 0)
				{
					attributeTargets |= AttributeTargets.Interface;
				}
				if ((rawValue & 0x40u) != 0)
				{
					attributeTargets |= AttributeTargets.Method;
				}
				if ((rawValue & 0x80u) != 0)
				{
					attributeTargets |= AttributeTargets.Parameter;
				}
				if ((rawValue & 0x100u) != 0)
				{
					attributeTargets |= AttributeTargets.Property;
				}
				if ((rawValue & 0x200u) != 0)
				{
					attributeTargets |= AttributeTargets.Class;
				}
				if ((rawValue & 0x400u) != 0)
				{
					attributeTargets |= AttributeTargets.Struct;
				}
				return attributeTargets;
			}
		}

		public readonly struct CustomAttributeHandle : IEquatable<CustomAttributeHandle>
		{
			private const uint tokenType = 201326592u;

			private const byte tokenTypeSmall = 12;

			private readonly int _rowId;

			public bool IsNil => _rowId == 0;

			internal int RowId => _rowId;

			private CustomAttributeHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static CustomAttributeHandle FromRowId(int rowId)
			{
				return new CustomAttributeHandle(rowId);
			}

			public static implicit operator Handle(CustomAttributeHandle handle)
			{
				return new Handle(12, handle._rowId);
			}

			public static implicit operator EntityHandle(CustomAttributeHandle handle)
			{
				return new EntityHandle((uint)(0xC000000uL | (ulong)handle._rowId));
			}

			public static explicit operator CustomAttributeHandle(Handle handle)
			{
				if (handle.VType != 12)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new CustomAttributeHandle(handle.RowId);
			}

			public static explicit operator CustomAttributeHandle(EntityHandle handle)
			{
				if (handle.VType != 201326592)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new CustomAttributeHandle(handle.RowId);
			}

			public static bool operator ==(CustomAttributeHandle left, CustomAttributeHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is CustomAttributeHandle)
				{
					return ((CustomAttributeHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(CustomAttributeHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(CustomAttributeHandle left, CustomAttributeHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		public readonly struct CustomAttributeHandleCollection : IReadOnlyCollection<CustomAttributeHandle>, IEnumerable<CustomAttributeHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<CustomAttributeHandle>, IDisposable, IEnumerator
			{
				private readonly MetadataReader _reader;

				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public CustomAttributeHandle Current
				{
					get
					{
						if (_reader.CustomAttributeTable.PtrTable != null)
						{
							return GetCurrentCustomAttributeIndirect();
						}
						return CustomAttributeHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));
					}
				}

				object IEnumerator.Current => Current;

				internal Enumerator(MetadataReader reader, int firstRowId, int lastRowId)
				{
					_reader = reader;
					_currentRowId = firstRowId - 1;
					_lastRowId = lastRowId;
				}

				private CustomAttributeHandle GetCurrentCustomAttributeIndirect()
				{
					return CustomAttributeHandle.FromRowId(_reader.CustomAttributeTable.PtrTable[(_currentRowId & 0xFFFFFF) - 1]);
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly MetadataReader _reader;

			private readonly int _firstRowId;

			private readonly int _lastRowId;

			public int Count => _lastRowId - _firstRowId + 1;

			internal CustomAttributeHandleCollection(MetadataReader reader)
			{
				_reader = reader;
				_firstRowId = 1;
				_lastRowId = reader.CustomAttributeTable.NumberOfRows;
			}

			internal CustomAttributeHandleCollection(MetadataReader reader, EntityHandle handle)
			{
				_reader = reader;
				reader.CustomAttributeTable.GetAttributeRange(handle, out _firstRowId, out _lastRowId);
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_reader, _firstRowId, _lastRowId);
			}

			IEnumerator<CustomAttributeHandle> IEnumerable<CustomAttributeHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public readonly struct CustomAttributeNamedArgument<TType>
		{
			public string? Name { get; }

			public CustomAttributeNamedArgumentKind Kind { get; }

			public TType Type { get; }

			public object? Value { get; }

			public CustomAttributeNamedArgument(string? name, CustomAttributeNamedArgumentKind kind, TType type, object? value)
			{
				Name = name;
				Kind = kind;
				Type = type;
				Value = value;
			}
		}

		public enum CustomAttributeNamedArgumentKind : byte { Field = 83, Property }

		public readonly struct CustomAttributeTypedArgument<TType>
		{
			public TType Type { get; }

			public object? Value { get; }

			public CustomAttributeTypedArgument(TType type, object? value)
			{
				Type = type;
				Value = value;
			}
		}

		public readonly struct CustomAttributeValue<TType>
		{
			public System.Collections.Immutable.ImmutableArray<CustomAttributeTypedArgument<TType>> FixedArguments { get; }

			public System.Collections.Immutable.ImmutableArray<CustomAttributeNamedArgument<TType>> NamedArguments { get; }

			public CustomAttributeValue(System.Collections.Immutable.ImmutableArray<CustomAttributeTypedArgument<TType>> fixedArguments, System.Collections.Immutable.ImmutableArray<CustomAttributeNamedArgument<TType>> namedArguments)
			{
				FixedArguments = fixedArguments;
				NamedArguments = namedArguments;
			}
		}

		public readonly struct CustomDebugInformation
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private CustomDebugInformationHandle Handle => CustomDebugInformationHandle.FromRowId(_rowId);

			public EntityHandle Parent => _reader.CustomDebugInformationTable.GetParent(Handle);

			public GuidHandle Kind => _reader.CustomDebugInformationTable.GetKind(Handle);

			public BlobHandle Value => _reader.CustomDebugInformationTable.GetValue(Handle);

			internal CustomDebugInformation(MetadataReader reader, CustomDebugInformationHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}
		}

		public readonly struct CustomDebugInformationHandle : IEquatable<CustomDebugInformationHandle>
		{
			private const uint tokenType = 922746880u;

			private const byte tokenTypeSmall = 55;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private CustomDebugInformationHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static CustomDebugInformationHandle FromRowId(int rowId)
			{
				return new CustomDebugInformationHandle(rowId);
			}

			public static implicit operator Handle(CustomDebugInformationHandle handle)
			{
				return new Handle(55, handle._rowId);
			}

			public static implicit operator EntityHandle(CustomDebugInformationHandle handle)
			{
				return new EntityHandle((uint)(0x37000000uL | (ulong)handle._rowId));
			}

			public static explicit operator CustomDebugInformationHandle(Handle handle)
			{
				if (handle.VType != 55)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new CustomDebugInformationHandle(handle.RowId);
			}

			public static explicit operator CustomDebugInformationHandle(EntityHandle handle)
			{
				if (handle.VType != 922746880)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new CustomDebugInformationHandle(handle.RowId);
			}

			public static bool operator ==(CustomDebugInformationHandle left, CustomDebugInformationHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals([NotNullWhen(true)] object? obj)
			{
				if (obj is CustomDebugInformationHandle customDebugInformationHandle)
				{
					return customDebugInformationHandle._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(CustomDebugInformationHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(CustomDebugInformationHandle left, CustomDebugInformationHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		public readonly struct CustomDebugInformationHandleCollection : IReadOnlyCollection<CustomDebugInformationHandle>, IEnumerable<CustomDebugInformationHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<CustomDebugInformationHandle>, IDisposable, IEnumerator
			{
				private readonly MetadataReader _reader;

				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public CustomDebugInformationHandle Current => CustomDebugInformationHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal Enumerator(MetadataReader reader, int firstRowId, int lastRowId)
				{
					_reader = reader;
					_lastRowId = lastRowId;
					_currentRowId = firstRowId - 1;
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly MetadataReader _reader;

			private readonly int _firstRowId;

			private readonly int _lastRowId;

			public int Count => _lastRowId - _firstRowId + 1;

			internal CustomDebugInformationHandleCollection(MetadataReader reader)
			{
				_reader = reader;
				_firstRowId = 1;
				_lastRowId = reader.CustomDebugInformationTable.NumberOfRows;
			}

			internal CustomDebugInformationHandleCollection(MetadataReader reader, EntityHandle handle)
			{
				_reader = reader;
				reader.CustomDebugInformationTable.GetRange(handle, out _firstRowId, out _lastRowId);
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_reader, _firstRowId, _lastRowId);
			}

			IEnumerator<CustomDebugInformationHandle> IEnumerable<CustomDebugInformationHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public sealed class DebugMetadataHeader
		{
			public System.Collections.Immutable.ImmutableArray<byte> Id { get; }

			public MethodDefinitionHandle EntryPoint { get; }

			/// <summary>
			/// Gets the offset (in bytes) from the start of the metadata blob to the start of the <see cref="P:System.Reflection.Metadata.DebugMetadataHeader.Id" /> blob.
			/// </summary>
			public int IdStartOffset { get; }

			internal DebugMetadataHeader(System.Collections.Immutable.ImmutableArray<byte> id, MethodDefinitionHandle entryPoint, int idStartOffset)
			{
				Id = id;
				EntryPoint = entryPoint;
				IdStartOffset = idStartOffset;
			}
		}

		public readonly struct DeclarativeSecurityAttribute
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			public DeclarativeSecurityAction Action => _reader.DeclSecurityTable.GetAction(_rowId);

			public EntityHandle Parent => _reader.DeclSecurityTable.GetParent(_rowId);

			public BlobHandle PermissionSet => _reader.DeclSecurityTable.GetPermissionSet(_rowId);

			internal DeclarativeSecurityAttribute(MetadataReader reader, int rowId)
			{
				_reader = reader;
				_rowId = rowId;
			}
		}

		public readonly struct DeclarativeSecurityAttributeHandle : IEquatable<DeclarativeSecurityAttributeHandle>
		{
			private const uint tokenType = 234881024u;

			private const byte tokenTypeSmall = 14;

			private readonly int _rowId;

			public bool IsNil => _rowId == 0;

			internal int RowId => _rowId;

			private DeclarativeSecurityAttributeHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static DeclarativeSecurityAttributeHandle FromRowId(int rowId)
			{
				return new DeclarativeSecurityAttributeHandle(rowId);
			}

			public static implicit operator Handle(DeclarativeSecurityAttributeHandle handle)
			{
				return new Handle(14, handle._rowId);
			}

			public static implicit operator EntityHandle(DeclarativeSecurityAttributeHandle handle)
			{
				return new EntityHandle((uint)(0xE000000uL | (ulong)handle._rowId));
			}

			public static explicit operator DeclarativeSecurityAttributeHandle(Handle handle)
			{
				if (handle.VType != 14)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new DeclarativeSecurityAttributeHandle(handle.RowId);
			}

			public static explicit operator DeclarativeSecurityAttributeHandle(EntityHandle handle)
			{
				if (handle.VType != 234881024)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new DeclarativeSecurityAttributeHandle(handle.RowId);
			}

			public static bool operator ==(DeclarativeSecurityAttributeHandle left, DeclarativeSecurityAttributeHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is DeclarativeSecurityAttributeHandle)
				{
					return ((DeclarativeSecurityAttributeHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(DeclarativeSecurityAttributeHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(DeclarativeSecurityAttributeHandle left, DeclarativeSecurityAttributeHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		public readonly struct DeclarativeSecurityAttributeHandleCollection : IReadOnlyCollection<DeclarativeSecurityAttributeHandle>, IEnumerable<DeclarativeSecurityAttributeHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<DeclarativeSecurityAttributeHandle>, IDisposable, IEnumerator
			{
				private readonly MetadataReader _reader;

				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public DeclarativeSecurityAttributeHandle Current => DeclarativeSecurityAttributeHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal Enumerator(MetadataReader reader, int firstRowId, int lastRowId)
				{
					_reader = reader;
					_currentRowId = firstRowId - 1;
					_lastRowId = lastRowId;
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly MetadataReader _reader;

			private readonly int _firstRowId;

			private readonly int _lastRowId;

			public int Count => _lastRowId - _firstRowId + 1;

			internal DeclarativeSecurityAttributeHandleCollection(MetadataReader reader)
			{
				_reader = reader;
				_firstRowId = 1;
				_lastRowId = reader.DeclSecurityTable.NumberOfRows;
			}

			internal DeclarativeSecurityAttributeHandleCollection(MetadataReader reader, EntityHandle handle)
			{
				_reader = reader;
				reader.DeclSecurityTable.GetAttributeRange(handle, out _firstRowId, out _lastRowId);
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_reader, _firstRowId, _lastRowId);
			}

			IEnumerator<DeclarativeSecurityAttributeHandle> IEnumerable<DeclarativeSecurityAttributeHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		/// <summary>
		/// Source document in debug metadata.
		/// </summary>
		/// <remarks>
		/// See also https://github.com/dotnet/runtime/blob/main/src/libraries/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#document-table-0x30.
		/// </remarks>
		public readonly struct Document
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private DocumentHandle Handle => DocumentHandle.FromRowId(_rowId);

			/// <summary>
			/// Returns Document Name Blob.
			/// </summary>
			public DocumentNameBlobHandle Name => _reader.DocumentTable.GetName(Handle);

			/// <summary>
			/// Source code language (C#, VB, F#, etc.)
			/// </summary>
			public GuidHandle Language => _reader.DocumentTable.GetLanguage(Handle);

			/// <summary>
			/// Hash algorithm used to calculate <see cref="P:System.Reflection.Metadata.Document.Hash" /> (SHA1, SHA256, etc.)
			/// </summary>
			public GuidHandle HashAlgorithm => _reader.DocumentTable.GetHashAlgorithm(Handle);

			/// <summary>
			/// Document content hash.
			/// </summary>
			/// <remarks>
			/// <see cref="P:System.Reflection.Metadata.Document.HashAlgorithm" /> determines the algorithm used to produce this hash.
			/// The source document is hashed in its binary form as stored in the file.
			/// </remarks>
			public BlobHandle Hash => _reader.DocumentTable.GetHash(Handle);

			internal Document(MetadataReader reader, DocumentHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}
		}

		public readonly struct DocumentHandle : IEquatable<DocumentHandle>
		{
			private const uint tokenType = 805306368u;

			private const byte tokenTypeSmall = 48;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private DocumentHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static DocumentHandle FromRowId(int rowId)
			{
				return new DocumentHandle(rowId);
			}

			public static implicit operator Handle(DocumentHandle handle)
			{
				return new Handle(48, handle._rowId);
			}

			public static implicit operator EntityHandle(DocumentHandle handle)
			{
				return new EntityHandle((uint)(0x30000000uL | (ulong)handle._rowId));
			}

			public static explicit operator DocumentHandle(Handle handle)
			{
				if (handle.VType != 48)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new DocumentHandle(handle.RowId);
			}

			public static explicit operator DocumentHandle(EntityHandle handle)
			{
				if (handle.VType != 805306368)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new DocumentHandle(handle.RowId);
			}

			public static bool operator ==(DocumentHandle left, DocumentHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is DocumentHandle documentHandle)
				{
					return documentHandle._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(DocumentHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(DocumentHandle left, DocumentHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		public readonly struct DocumentHandleCollection : IReadOnlyCollection<DocumentHandle>, IEnumerable<DocumentHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<DocumentHandle>, IDisposable, IEnumerator
			{
				private readonly MetadataReader _reader;

				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public DocumentHandle Current => DocumentHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal Enumerator(MetadataReader reader, int firstRowId, int lastRowId)
				{
					_reader = reader;
					_lastRowId = lastRowId;
					_currentRowId = firstRowId - 1;
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly MetadataReader _reader;

			private readonly int _firstRowId;

			private readonly int _lastRowId;

			public int Count => _lastRowId - _firstRowId + 1;

			internal DocumentHandleCollection(MetadataReader reader)
			{
				_reader = reader;
				_firstRowId = 1;
				_lastRowId = reader.DocumentTable.NumberOfRows;
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_reader, _firstRowId, _lastRowId);
			}

			IEnumerator<DocumentHandle> IEnumerable<DocumentHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		/// <summary>
		/// <see cref="System.Reflection.Metadata.BlobHandle" /> representing a blob on #Blob heap in Portable PDB
		/// structured as Document Name.
		/// </summary>
		/// <remarks>
		/// The kind of the handle is <see cref="System.Reflection.Metadata.HandleKind.Blob" />.
		/// The handle is a specialization of <see cref="System.Reflection.Metadata.BlobHandle" /> and doesn't have a distinct kind.
		/// </remarks>
		public readonly struct DocumentNameBlobHandle : IEquatable<DocumentNameBlobHandle>
		{
			private readonly int _heapOffset;

			public bool IsNil => _heapOffset == 0;

			private DocumentNameBlobHandle(int heapOffset)
			{
				_heapOffset = heapOffset;
			}

			internal static DocumentNameBlobHandle FromOffset(int heapOffset)
			{
				return new DocumentNameBlobHandle(heapOffset);
			}

			public static implicit operator BlobHandle(DocumentNameBlobHandle handle)
			{
				return BlobHandle.FromOffset(handle._heapOffset);
			}

			public static explicit operator DocumentNameBlobHandle(BlobHandle handle)
			{
				if (handle.IsVirtual)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return FromOffset(handle.GetHeapOffset());
			}

			public override bool Equals([NotNullWhen(true)] object? obj)
			{
				if (obj is DocumentNameBlobHandle other)
				{
					return Equals(other);
				}
				return false;
			}

			public bool Equals(DocumentNameBlobHandle other)
			{
				return _heapOffset == other._heapOffset;
			}

			public override int GetHashCode()
			{
				return _heapOffset;
			}

			public static bool operator ==(DocumentNameBlobHandle left, DocumentNameBlobHandle right)
			{
				return left.Equals(right);
			}

			public static bool operator !=(DocumentNameBlobHandle left, DocumentNameBlobHandle right)
			{
				return !left.Equals(right);
			}
		}

		/// <summary>
		/// Represents a metadata entity (type reference/definition/specification, method definition, custom attribute, etc.).
		/// </summary>
		/// <remarks>
		/// Use <see cref="System.Reflection.Metadata.EntityHandle" /> to store multiple kinds of entity handles.
		/// It has smaller memory footprint than <see cref="System.Reflection.Metadata.Handle" />.
		/// </remarks>
		public readonly struct EntityHandle : IEquatable<EntityHandle>
		{
			private readonly uint _vToken;

			public static readonly ModuleDefinitionHandle ModuleDefinition = new ModuleDefinitionHandle(1);

			public static readonly AssemblyDefinitionHandle AssemblyDefinition = new AssemblyDefinitionHandle(1);

			internal uint Type => _vToken & 0x7F000000u;

			internal uint VType => _vToken & 0xFF000000u;

			internal bool IsVirtual => (_vToken & 0x80000000u) != 0;

			public bool IsNil => (_vToken & 0x80FFFFFFu) == 0;

			internal int RowId => (int)(_vToken & 0xFFFFFF);

			/// <summary>
			/// Value stored in a specific entity handle (see <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, etc.).
			/// </summary>
			internal uint SpecificHandleValue => _vToken & 0x80FFFFFFu;

			public HandleKind Kind => (HandleKind)(Type >> 24);

			internal int Token => (int)_vToken;

			internal EntityHandle(uint vToken)
			{
				_vToken = vToken;
			}

			public static implicit operator Handle(EntityHandle handle)
			{
				return Handle.FromVToken(handle._vToken);
			}

			public static explicit operator EntityHandle(Handle handle)
			{
				if (handle.IsHeapHandle)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new EntityHandle(handle.EntityHandleValue);
			}

			public override bool Equals([NotNullWhen(true)] object? obj)
			{
				if (obj is EntityHandle other)
				{
					return Equals(other);
				}
				return false;
			}

			public bool Equals(EntityHandle other)
			{
				return _vToken == other._vToken;
			}

			public override int GetHashCode()
			{
				return (int)_vToken;
			}

			public static bool operator ==(EntityHandle left, EntityHandle right)
			{
				return left.Equals(right);
			}

			public static bool operator !=(EntityHandle left, EntityHandle right)
			{
				return !left.Equals(right);
			}

			internal static int Compare(EntityHandle left, EntityHandle right)
			{
				return left._vToken.CompareTo(right._vToken);
			}
		}

		public readonly struct EventAccessors
		{
			private readonly int _adderRowId;

			private readonly int _removerRowId;

			private readonly int _raiserRowId;

			private readonly System.Collections.Immutable.ImmutableArray<MethodDefinitionHandle> _others;

			public MethodDefinitionHandle Adder => MethodDefinitionHandle.FromRowId(_adderRowId);

			public MethodDefinitionHandle Remover => MethodDefinitionHandle.FromRowId(_removerRowId);

			public MethodDefinitionHandle Raiser => MethodDefinitionHandle.FromRowId(_raiserRowId);

			public System.Collections.Immutable.ImmutableArray<MethodDefinitionHandle> Others => _others;

			internal EventAccessors(int adderRowId, int removerRowId, int raiserRowId, System.Collections.Immutable.ImmutableArray<MethodDefinitionHandle> others)
			{
				_adderRowId = adderRowId;
				_removerRowId = removerRowId;
				_raiserRowId = raiserRowId;
				_others = others;
			}
		}

		public readonly struct EventDefinition
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private EventDefinitionHandle Handle => EventDefinitionHandle.FromRowId(_rowId);

			public StringHandle Name => _reader.EventTable.GetName(Handle);

			public EventAttributes Attributes => _reader.EventTable.GetFlags(Handle);

			public EntityHandle Type => _reader.EventTable.GetEventType(Handle);

			internal EventDefinition(MetadataReader reader, EventDefinitionHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, Handle);
			}

			public EventAccessors GetAccessors()
			{
				int adderRowId = 0;
				int removerRowId = 0;
				int raiserRowId = 0;
				System.Collections.Immutable.ImmutableArray<MethodDefinitionHandle>.Builder builder = null;
				ushort methodCount;
				int num = _reader.MethodSemanticsTable.FindSemanticMethodsForEvent(Handle, out methodCount);
				for (ushort num2 = 0; num2 < methodCount; num2 = (ushort)(num2 + 1))
				{
					int rowId = num + num2;
					switch (_reader.MethodSemanticsTable.GetSemantics(rowId))
					{
						case MethodSemanticsAttributes.Adder:
							adderRowId = _reader.MethodSemanticsTable.GetMethod(rowId).RowId;
							break;
						case MethodSemanticsAttributes.Remover:
							removerRowId = _reader.MethodSemanticsTable.GetMethod(rowId).RowId;
							break;
						case MethodSemanticsAttributes.Raiser:
							raiserRowId = _reader.MethodSemanticsTable.GetMethod(rowId).RowId;
							break;
						case MethodSemanticsAttributes.Other:
							if (builder == null)
							{
								builder = System.Collections.Immutable.ImmutableArray.CreateBuilder<MethodDefinitionHandle>();
							}
							builder.Add(_reader.MethodSemanticsTable.GetMethod(rowId));
							break;
					}
				}
				System.Collections.Immutable.ImmutableArray<MethodDefinitionHandle> others = builder?.ToImmutable() ?? System.Collections.Immutable.ImmutableArray<MethodDefinitionHandle>.Empty;
				return new EventAccessors(adderRowId, removerRowId, raiserRowId, others);
			}
		}

		public readonly struct EventDefinitionHandle : IEquatable<EventDefinitionHandle>
		{
			private const uint tokenType = 335544320u;

			private const byte tokenTypeSmall = 20;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private EventDefinitionHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static EventDefinitionHandle FromRowId(int rowId)
			{
				return new EventDefinitionHandle(rowId);
			}

			public static implicit operator Handle(EventDefinitionHandle handle)
			{
				return new Handle(20, handle._rowId);
			}

			public static implicit operator EntityHandle(EventDefinitionHandle handle)
			{
				return new EntityHandle((uint)(0x14000000uL | (ulong)handle._rowId));
			}

			public static explicit operator EventDefinitionHandle(Handle handle)
			{
				if (handle.VType != 20)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new EventDefinitionHandle(handle.RowId);
			}

			public static explicit operator EventDefinitionHandle(EntityHandle handle)
			{
				if (handle.VType != 335544320)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new EventDefinitionHandle(handle.RowId);
			}

			public static bool operator ==(EventDefinitionHandle left, EventDefinitionHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is EventDefinitionHandle)
				{
					return ((EventDefinitionHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(EventDefinitionHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(EventDefinitionHandle left, EventDefinitionHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		public readonly struct EventDefinitionHandleCollection : IReadOnlyCollection<EventDefinitionHandle>, IEnumerable<EventDefinitionHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<EventDefinitionHandle>, IDisposable, IEnumerator
			{
				private readonly MetadataReader _reader;

				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public EventDefinitionHandle Current
				{
					get
					{
						if (_reader.UseEventPtrTable)
						{
							return GetCurrentEventIndirect();
						}
						return EventDefinitionHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));
					}
				}

				object IEnumerator.Current => Current;

				internal Enumerator(MetadataReader reader, int firstRowId, int lastRowId)
				{
					_reader = reader;
					_currentRowId = firstRowId - 1;
					_lastRowId = lastRowId;
				}

				private EventDefinitionHandle GetCurrentEventIndirect()
				{
					return _reader.EventPtrTable.GetEventFor(_currentRowId & 0xFFFFFF);
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly MetadataReader _reader;

			private readonly int _firstRowId;

			private readonly int _lastRowId;

			public int Count => _lastRowId - _firstRowId + 1;

			internal EventDefinitionHandleCollection(MetadataReader reader)
			{
				_reader = reader;
				_firstRowId = 1;
				_lastRowId = reader.EventTable.NumberOfRows;
			}

			internal EventDefinitionHandleCollection(MetadataReader reader, TypeDefinitionHandle containingType)
			{
				_reader = reader;
				reader.GetEventRange(containingType, out _firstRowId, out _lastRowId);
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_reader, _firstRowId, _lastRowId);
			}

			IEnumerator<EventDefinitionHandle> IEnumerable<EventDefinitionHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public readonly struct ExceptionRegion
		{
			private readonly ExceptionRegionKind _kind;

			private readonly int _tryOffset;

			private readonly int _tryLength;

			private readonly int _handlerOffset;

			private readonly int _handlerLength;

			private readonly int _classTokenOrFilterOffset;

			public ExceptionRegionKind Kind => _kind;

			/// <summary>
			/// Start IL offset of the try block.
			/// </summary>
			public int TryOffset => _tryOffset;

			/// <summary>
			/// Length in bytes of try block.
			/// </summary>
			public int TryLength => _tryLength;

			/// <summary>
			/// Start IL offset of the exception handler.
			/// </summary>
			public int HandlerOffset => _handlerOffset;

			/// <summary>
			/// Length in bytes of the exception handler.
			/// </summary>
			public int HandlerLength => _handlerLength;

			/// <summary>
			/// IL offset of the start of the filter block, or -1 if the region is not a filter.
			/// </summary>
			public int FilterOffset
			{
				get
				{
					if (Kind != ExceptionRegionKind.Filter)
					{
						return -1;
					}
					return _classTokenOrFilterOffset;
				}
			}

			/// <summary>
			/// Returns a TypeRef, TypeDef, or TypeSpec handle if the region represents a catch, nil token otherwise.
			/// </summary>
			public EntityHandle CatchType
			{
				get
				{
					if (Kind != 0)
					{
						return default(EntityHandle);
					}
					return new EntityHandle((uint)_classTokenOrFilterOffset);
				}
			}

			internal ExceptionRegion(ExceptionRegionKind kind, int tryOffset, int tryLength, int handlerOffset, int handlerLength, int classTokenOrFilterOffset)
			{
				_kind = kind;
				_tryOffset = tryOffset;
				_tryLength = tryLength;
				_handlerOffset = handlerOffset;
				_handlerLength = handlerLength;
				_classTokenOrFilterOffset = classTokenOrFilterOffset;
			}
		}

		public enum ExceptionRegionKind : ushort { Catch = 0, Filter = 1, Finally = 2, Fault = 4 }

		public readonly struct ExportedType
		{
			internal readonly MetadataReader reader;

			internal readonly int rowId;

			private ExportedTypeHandle Handle => ExportedTypeHandle.FromRowId(rowId);

			public TypeAttributes Attributes => reader.ExportedTypeTable.GetFlags(rowId);

			public bool IsForwarder
			{
				get
				{
					if (Attributes.IsForwarder())
					{
						return Implementation.Kind == HandleKind.AssemblyReference;
					}
					return false;
				}
			}

			/// <summary>
			/// Name of the target type, or nil if the type is nested or defined in a root namespace.
			/// </summary>
			public StringHandle Name => reader.ExportedTypeTable.GetTypeName(rowId);

			/// <summary>
			/// Full name of the namespace where the target type, or nil if the type is nested or defined in a root namespace.
			/// </summary>
			public StringHandle Namespace => reader.ExportedTypeTable.GetTypeNamespaceString(rowId);

			/// <summary>
			/// The definition handle of the namespace where the target type is defined, or nil if the type is nested or defined in a root namespace.
			/// </summary>
			public NamespaceDefinitionHandle NamespaceDefinition => reader.ExportedTypeTable.GetTypeNamespace(rowId);

			/// <summary>
			/// Handle to resolve the implementation of the target type.
			/// </summary>
			/// <returns>
			/// <list type="bullet">
			/// <item><description><see cref="T:System.Reflection.Metadata.AssemblyFileHandle" /> representing another module in the assembly.</description></item>
			/// <item><description><see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> representing another assembly if <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> is true.</description></item>
			/// <item><description><see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> representing the declaring exported type in which this was is nested.</description></item>
			/// </list>
			/// </returns>
			public EntityHandle Implementation => reader.ExportedTypeTable.GetImplementation(rowId);

			internal ExportedType(MetadataReader reader, int rowId)
			{
				this.reader = reader;
				this.rowId = rowId;
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(reader, Handle);
			}
		}

		public readonly struct ExportedTypeHandle : IEquatable<ExportedTypeHandle>
		{
			private const uint tokenType = 654311424u;

			private const byte tokenTypeSmall = 39;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private ExportedTypeHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static ExportedTypeHandle FromRowId(int rowId)
			{
				return new ExportedTypeHandle(rowId);
			}

			public static implicit operator Handle(ExportedTypeHandle handle)
			{
				return new Handle(39, handle._rowId);
			}

			public static implicit operator EntityHandle(ExportedTypeHandle handle)
			{
				return new EntityHandle((uint)(0x27000000uL | (ulong)handle._rowId));
			}

			public static explicit operator ExportedTypeHandle(Handle handle)
			{
				if (handle.VType != 39)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new ExportedTypeHandle(handle.RowId);
			}

			public static explicit operator ExportedTypeHandle(EntityHandle handle)
			{
				if (handle.VType != 654311424)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new ExportedTypeHandle(handle.RowId);
			}

			public static bool operator ==(ExportedTypeHandle left, ExportedTypeHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is ExportedTypeHandle)
				{
					return ((ExportedTypeHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(ExportedTypeHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(ExportedTypeHandle left, ExportedTypeHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		/// <summary>
		/// Represents a collection of <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.
		/// </summary>
		public readonly struct ExportedTypeHandleCollection : IReadOnlyCollection<ExportedTypeHandle>, IEnumerable<ExportedTypeHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<ExportedTypeHandle>, IDisposable, IEnumerator
			{
				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public ExportedTypeHandle Current => ExportedTypeHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal Enumerator(int lastRowId)
				{
					_lastRowId = lastRowId;
					_currentRowId = 0;
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly int _lastRowId;

			public int Count => _lastRowId;

			internal ExportedTypeHandleCollection(int lastRowId)
			{
				_lastRowId = lastRowId;
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_lastRowId);
			}

			IEnumerator<ExportedTypeHandle> IEnumerable<ExportedTypeHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public readonly struct FieldDefinition
		{
			private readonly MetadataReader _reader;

			private readonly uint _treatmentAndRowId;

			private int RowId => (int)(_treatmentAndRowId & 0xFFFFFF);

			private FieldDefTreatment Treatment => (FieldDefTreatment)(_treatmentAndRowId >> 24);

			private FieldDefinitionHandle Handle => FieldDefinitionHandle.FromRowId(RowId);

			public StringHandle Name
			{
				get
				{
					if (Treatment == FieldDefTreatment.None)
					{
						return _reader.FieldTable.GetName(Handle);
					}
					return GetProjectedName();
				}
			}

			public FieldAttributes Attributes
			{
				get
				{
					if (Treatment == FieldDefTreatment.None)
					{
						return _reader.FieldTable.GetFlags(Handle);
					}
					return GetProjectedFlags();
				}
			}

			public BlobHandle Signature
			{
				get
				{
					if (Treatment == FieldDefTreatment.None)
					{
						return _reader.FieldTable.GetSignature(Handle);
					}
					return GetProjectedSignature();
				}
			}

			internal FieldDefinition(MetadataReader reader, uint treatmentAndRowId)
			{
				_reader = reader;
				_treatmentAndRowId = treatmentAndRowId;
			}

			public TType DecodeSignature<TType, TGenericContext>(ISignatureTypeProvider<TType, TGenericContext> provider, TGenericContext genericContext)
			{
				SignatureDecoder<TType, TGenericContext> signatureDecoder = new SignatureDecoder<TType, TGenericContext>(provider, _reader, genericContext);
				BlobReader blobReader = _reader.GetBlobReader(Signature);
				return signatureDecoder.DecodeFieldSignature(ref blobReader);
			}

			public TypeDefinitionHandle GetDeclaringType()
			{
				return _reader.GetDeclaringType(Handle);
			}

			public ConstantHandle GetDefaultValue()
			{
				return _reader.ConstantTable.FindConstant(Handle);
			}

			public int GetRelativeVirtualAddress()
			{
				int num = _reader.FieldRvaTable.FindFieldRvaRowId(Handle.RowId);
				if (num == 0)
				{
					return 0;
				}
				return _reader.FieldRvaTable.GetRva(num);
			}

			/// <summary>
			/// Returns field layout offset, or -1 if not available.
			/// </summary>
			public int GetOffset()
			{
				int num = _reader.FieldLayoutTable.FindFieldLayoutRowId(Handle);
				if (num == 0)
				{
					return -1;
				}
				uint offset = _reader.FieldLayoutTable.GetOffset(num);
				if (offset > int.MaxValue)
				{
					return -1;
				}
				return (int)offset;
			}

			public BlobHandle GetMarshallingDescriptor()
			{
				int num = _reader.FieldMarshalTable.FindFieldMarshalRowId(Handle);
				if (num == 0)
				{
					return default(BlobHandle);
				}
				return _reader.FieldMarshalTable.GetNativeType(num);
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, Handle);
			}

			private StringHandle GetProjectedName()
			{
				return _reader.FieldTable.GetName(Handle);
			}

			private FieldAttributes GetProjectedFlags()
			{
				FieldAttributes flags = _reader.FieldTable.GetFlags(Handle);
				if (Treatment == FieldDefTreatment.EnumValue)
				{
					return (flags & ~FieldAttributes.FieldAccessMask) | FieldAttributes.Public;
				}
				return flags;
			}

			private BlobHandle GetProjectedSignature()
			{
				return _reader.FieldTable.GetSignature(Handle);
			}
		}

		public readonly struct FieldDefinitionHandle : IEquatable<FieldDefinitionHandle>
		{
			private const uint tokenType = 67108864u;

			private const byte tokenTypeSmall = 4;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private FieldDefinitionHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static FieldDefinitionHandle FromRowId(int rowId)
			{
				return new FieldDefinitionHandle(rowId);
			}

			public static implicit operator Handle(FieldDefinitionHandle handle)
			{
				return new Handle(4, handle._rowId);
			}

			public static implicit operator EntityHandle(FieldDefinitionHandle handle)
			{
				return new EntityHandle((uint)(0x4000000uL | (ulong)handle._rowId));
			}

			public static explicit operator FieldDefinitionHandle(Handle handle)
			{
				if (handle.VType != 4)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new FieldDefinitionHandle(handle.RowId);
			}

			public static explicit operator FieldDefinitionHandle(EntityHandle handle)
			{
				if (handle.VType != 67108864)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new FieldDefinitionHandle(handle.RowId);
			}

			public static bool operator ==(FieldDefinitionHandle left, FieldDefinitionHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is FieldDefinitionHandle)
				{
					return ((FieldDefinitionHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(FieldDefinitionHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(FieldDefinitionHandle left, FieldDefinitionHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		public readonly struct FieldDefinitionHandleCollection : IReadOnlyCollection<FieldDefinitionHandle>, IEnumerable<FieldDefinitionHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<FieldDefinitionHandle>, IDisposable, IEnumerator
			{
				private readonly MetadataReader _reader;

				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public FieldDefinitionHandle Current
				{
					get
					{
						if (_reader.UseFieldPtrTable)
						{
							return GetCurrentFieldIndirect();
						}
						return FieldDefinitionHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));
					}
				}

				object IEnumerator.Current => Current;

				internal Enumerator(MetadataReader reader, int firstRowId, int lastRowId)
				{
					_reader = reader;
					_currentRowId = firstRowId - 1;
					_lastRowId = lastRowId;
				}

				private FieldDefinitionHandle GetCurrentFieldIndirect()
				{
					return _reader.FieldPtrTable.GetFieldFor(_currentRowId & 0xFFFFFF);
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly MetadataReader _reader;

			private readonly int _firstRowId;

			private readonly int _lastRowId;

			public int Count => _lastRowId - _firstRowId + 1;

			internal FieldDefinitionHandleCollection(MetadataReader reader)
			{
				_reader = reader;
				_firstRowId = 1;
				_lastRowId = reader.FieldTable.NumberOfRows;
			}

			internal FieldDefinitionHandleCollection(MetadataReader reader, TypeDefinitionHandle containingType)
			{
				_reader = reader;
				reader.GetFieldRange(containingType, out _firstRowId, out _lastRowId);
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_reader, _firstRowId, _lastRowId);
			}

			IEnumerator<FieldDefinitionHandle> IEnumerable<FieldDefinitionHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public readonly struct GenericParameter
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private GenericParameterHandle Handle => GenericParameterHandle.FromRowId(_rowId);

			/// <summary>
			/// <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />.
			/// </summary>
			/// <remarks>
			/// Corresponds to Owner field of GenericParam table in ECMA-335 Standard.
			/// </remarks>
			public EntityHandle Parent => _reader.GenericParamTable.GetOwner(Handle);

			/// <summary>
			/// Attributes specifying variance and constraints.
			/// </summary>
			/// <remarks>
			/// Corresponds to Flags field of GenericParam table in ECMA-335 Standard.
			/// </remarks>
			public GenericParameterAttributes Attributes => _reader.GenericParamTable.GetFlags(Handle);

			/// <summary>
			/// Zero-based index of the parameter within the declaring generic type or method declaration.
			/// </summary>
			/// <remarks>
			/// Corresponds to Number field of GenericParam table in ECMA-335 Standard.
			/// </remarks>
			public int Index => _reader.GenericParamTable.GetNumber(Handle);

			/// <summary>
			/// The name of the generic parameter.
			/// </summary>
			/// <remarks>
			/// Corresponds to Name field of GenericParam table in ECMA-335 Standard.
			/// </remarks>
			public StringHandle Name => _reader.GenericParamTable.GetName(Handle);

			internal GenericParameter(MetadataReader reader, GenericParameterHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}

			public GenericParameterConstraintHandleCollection GetConstraints()
			{
				return _reader.GenericParamConstraintTable.FindConstraintsForGenericParam(Handle);
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, Handle);
			}
		}

		public readonly struct GenericParameterConstraint
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private GenericParameterConstraintHandle Handle => GenericParameterConstraintHandle.FromRowId(_rowId);

			/// <summary>
			/// The constrained <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />.
			/// </summary>
			/// <remarks>
			/// Corresponds to Owner field of GenericParamConstraint table in ECMA-335 Standard.
			/// </remarks>
			public GenericParameterHandle Parameter => _reader.GenericParamConstraintTable.GetOwner(Handle);

			/// <summary>
			/// Handle (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, or <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />)
			/// specifying from which type this generic parameter is constrained to derive,
			/// or which interface this generic parameter is constrained to implement.
			/// </summary>
			/// <remarks>
			/// Corresponds to Constraint field of GenericParamConstraint table in ECMA-335 Standard.
			/// </remarks>
			public EntityHandle Type => _reader.GenericParamConstraintTable.GetConstraint(Handle);

			internal GenericParameterConstraint(MetadataReader reader, GenericParameterConstraintHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, Handle);
			}
		}

		public readonly struct GenericParameterConstraintHandle : IEquatable<GenericParameterConstraintHandle>
		{
			private const uint tokenType = 738197504u;

			private const byte tokenTypeSmall = 44;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private GenericParameterConstraintHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static GenericParameterConstraintHandle FromRowId(int rowId)
			{
				return new GenericParameterConstraintHandle(rowId);
			}

			public static implicit operator Handle(GenericParameterConstraintHandle handle)
			{
				return new Handle(44, handle._rowId);
			}

			public static implicit operator EntityHandle(GenericParameterConstraintHandle handle)
			{
				return new EntityHandle((uint)(0x2C000000uL | (ulong)handle._rowId));
			}

			public static explicit operator GenericParameterConstraintHandle(Handle handle)
			{
				if (handle.VType != 44)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new GenericParameterConstraintHandle(handle.RowId);
			}

			public static explicit operator GenericParameterConstraintHandle(EntityHandle handle)
			{
				if (handle.VType != 738197504)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new GenericParameterConstraintHandle(handle.RowId);
			}

			public static bool operator ==(GenericParameterConstraintHandle left, GenericParameterConstraintHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is GenericParameterConstraintHandle)
				{
					return ((GenericParameterConstraintHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(GenericParameterConstraintHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(GenericParameterConstraintHandle left, GenericParameterConstraintHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		/// <summary>
		/// Represents constraints of a generic type parameter.
		/// </summary>
		public readonly struct GenericParameterConstraintHandleCollection : IReadOnlyList<GenericParameterConstraintHandle>, IReadOnlyCollection<GenericParameterConstraintHandle>, IEnumerable<GenericParameterConstraintHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<GenericParameterConstraintHandle>, IDisposable, IEnumerator
			{
				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public GenericParameterConstraintHandle Current => GenericParameterConstraintHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal Enumerator(int firstRowId, int lastRowId)
				{
					_currentRowId = firstRowId - 1;
					_lastRowId = lastRowId;
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly int _firstRowId;

			private readonly ushort _count;

			public int Count => _count;

			public GenericParameterConstraintHandle this[int index]
			{
				get
				{
					if (index < 0 || index >= _count)
					{
						System.Reflection.Throw.IndexOutOfRange();
					}
					return GenericParameterConstraintHandle.FromRowId(_firstRowId + index);
				}
			}

			internal GenericParameterConstraintHandleCollection(int firstRowId, ushort count)
			{
				_firstRowId = firstRowId;
				_count = count;
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_firstRowId, _firstRowId + _count - 1);
			}

			IEnumerator<GenericParameterConstraintHandle> IEnumerable<GenericParameterConstraintHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public readonly struct GenericParameterHandle : IEquatable<GenericParameterHandle>
		{
			private const uint tokenType = 704643072u;

			private const byte tokenTypeSmall = 42;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private GenericParameterHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static GenericParameterHandle FromRowId(int rowId)
			{
				return new GenericParameterHandle(rowId);
			}

			public static implicit operator Handle(GenericParameterHandle handle)
			{
				return new Handle(42, handle._rowId);
			}

			public static implicit operator EntityHandle(GenericParameterHandle handle)
			{
				return new EntityHandle((uint)(0x2A000000uL | (ulong)handle._rowId));
			}

			public static explicit operator GenericParameterHandle(Handle handle)
			{
				if (handle.VType != 42)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new GenericParameterHandle(handle.RowId);
			}

			public static explicit operator GenericParameterHandle(EntityHandle handle)
			{
				if (handle.VType != 704643072)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new GenericParameterHandle(handle.RowId);
			}

			public static bool operator ==(GenericParameterHandle left, GenericParameterHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is GenericParameterHandle)
				{
					return ((GenericParameterHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(GenericParameterHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(GenericParameterHandle left, GenericParameterHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		/// <summary>
		/// Represents generic type parameters of a method or type.
		/// </summary>
		public readonly struct GenericParameterHandleCollection : IReadOnlyList<GenericParameterHandle>, IReadOnlyCollection<GenericParameterHandle>, IEnumerable<GenericParameterHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<GenericParameterHandle>, IDisposable, IEnumerator
			{
				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public GenericParameterHandle Current => GenericParameterHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal Enumerator(int firstRowId, int lastRowId)
				{
					_currentRowId = firstRowId - 1;
					_lastRowId = lastRowId;
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly int _firstRowId;

			private readonly ushort _count;

			public int Count => _count;

			public GenericParameterHandle this[int index]
			{
				get
				{
					if (index < 0 || index >= _count)
					{
						System.Reflection.Throw.IndexOutOfRange();
					}
					return GenericParameterHandle.FromRowId(_firstRowId + index);
				}
			}

			internal GenericParameterHandleCollection(int firstRowId, ushort count)
			{
				_firstRowId = firstRowId;
				_count = count;
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_firstRowId, _firstRowId + _count - 1);
			}

			IEnumerator<GenericParameterHandle> IEnumerable<GenericParameterHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public readonly struct GuidHandle : IEquatable<GuidHandle>
		{
			private readonly int _index;

			public bool IsNil => _index == 0;

			internal int Index => _index;

			private GuidHandle(int index)
			{
				_index = index;
			}

			internal static GuidHandle FromIndex(int heapIndex)
			{
				return new GuidHandle(heapIndex);
			}

			public static implicit operator Handle(GuidHandle handle)
			{
				return new Handle(114, handle._index);
			}

			public static explicit operator GuidHandle(Handle handle)
			{
				if (handle.VType != 114)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new GuidHandle(handle.Offset);
			}

			public override bool Equals([NotNullWhen(true)] object? obj)
			{
				if (obj is GuidHandle other)
				{
					return Equals(other);
				}
				return false;
			}

			public bool Equals(GuidHandle other)
			{
				return _index == other._index;
			}

			public override int GetHashCode()
			{
				return _index;
			}

			public static bool operator ==(GuidHandle left, GuidHandle right)
			{
				return left.Equals(right);
			}

			public static bool operator !=(GuidHandle left, GuidHandle right)
			{
				return !left.Equals(right);
			}
		}

		/// <summary>
		/// Represents any metadata entity (type reference/definition/specification, method definition, custom attribute, etc.) or value (string, blob, guid, user string).
		/// </summary>
		/// <remarks>
		/// Use <see cref="System.Reflection.Metadata.Handle" /> to store multiple kinds of handles.
		/// </remarks>
		public readonly struct Handle : IEquatable<Handle>
		{
			private readonly int _value;

			private readonly byte _vType;

			public static readonly ModuleDefinitionHandle ModuleDefinition = new ModuleDefinitionHandle(1);

			public static readonly AssemblyDefinitionHandle AssemblyDefinition = new AssemblyDefinitionHandle(1);

			internal int RowId => _value;

			internal int Offset => _value;

			/// <summary>
			/// Token type (0x##000000), does not include virtual flag.
			/// </summary>
			internal uint EntityHandleType => Type << 24;

			/// <summary>
			/// Small token type (0x##), does not include virtual flag.
			/// </summary>
			internal uint Type => _vType & 0x7Fu;

			/// <summary>
			/// Value stored in an <see cref="T:System.Reflection.Metadata.EntityHandle" />.
			/// </summary>
			internal uint EntityHandleValue => (uint)((_vType << 24) | _value);

			/// <summary>
			/// Value stored in a concrete entity handle (see <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, etc.).
			/// </summary>
			internal uint SpecificEntityHandleValue => (uint)(((_vType & 0x80) << 24) | _value);

			internal byte VType => _vType;

			internal bool IsVirtual => (_vType & 0x80) != 0;

			internal bool IsHeapHandle => (_vType & 0x70) == 112;

			public HandleKind Kind
			{
				get
				{
					uint type = Type;
					if ((type & 0xFFFFFFFCu) == 120)
					{
						return HandleKind.String;
					}
					return (HandleKind)type;
				}
			}

			public bool IsNil => (_value | (_vType & 0x80)) == 0;

			internal bool IsEntityOrUserStringHandle => Type <= 112;

			internal int Token => (_vType << 24) | _value;

			/// <summary>
			/// Creates <see cref="T:System.Reflection.Metadata.Handle" /> from a token or a token combined with a virtual flag.
			/// </summary>
			internal static Handle FromVToken(uint vToken)
			{
				return new Handle((byte)(vToken >> 24), (int)(vToken & 0xFFFFFF));
			}

			internal Handle(byte vType, int value)
			{
				_vType = vType;
				_value = value;
			}

			public override bool Equals([NotNullWhen(true)] object? obj)
			{
				if (obj is Handle other)
				{
					return Equals(other);
				}
				return false;
			}

			public bool Equals(Handle other)
			{
				if (_value == other._value)
				{
					return _vType == other._vType;
				}
				return false;
			}

			public override int GetHashCode()
			{
				return _value ^ (_vType << 24);
			}

			public static bool operator ==(Handle left, Handle right)
			{
				return left.Equals(right);
			}

			public static bool operator !=(Handle left, Handle right)
			{
				return !left.Equals(right);
			}

			internal static int Compare(Handle left, Handle right)
			{
				return ((long)((uint)left._value | ((ulong)left._vType << 32))).CompareTo((long)((uint)right._value | ((ulong)right._vType << 32)));
			}
		}

		public sealed class HandleComparer : IEqualityComparer<Handle>, IComparer<Handle>, IEqualityComparer<EntityHandle>, IComparer<EntityHandle>
		{
			private static readonly HandleComparer s_default = new HandleComparer();

			public static HandleComparer Default => s_default;

			private HandleComparer()
			{
			}

			public bool Equals(Handle x, Handle y)
			{
				return x.Equals(y);
			}

			public bool Equals(EntityHandle x, EntityHandle y)
			{
				return x.Equals(y);
			}

			public int GetHashCode(Handle obj)
			{
				return obj.GetHashCode();
			}

			public int GetHashCode(EntityHandle obj)
			{
				return obj.GetHashCode();
			}

			/// <summary>
			/// Compares two handles.
			/// </summary>
			/// <remarks>
			/// The order of handles that differ in kind and are not <see cref="T:System.Reflection.Metadata.EntityHandle" /> is undefined.
			/// Returns 0 if and only if <see cref="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)" /> returns true.
			/// </remarks>
			public int Compare(Handle x, Handle y)
			{
				return Handle.Compare(x, y);
			}

			/// <summary>
			/// Compares two entity handles.
			/// </summary>
			/// <remarks>
			/// Returns 0 if and only if <see cref="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)" /> returns true.
			/// </remarks>
			public int Compare(EntityHandle x, EntityHandle y)
			{
				return EntityHandle.Compare(x, y);
			}
		}

		public enum HandleKind : byte
		{
			ModuleDefinition = 0,
			TypeReference = 1,
			TypeDefinition = 2,
			FieldDefinition = 4,
			MethodDefinition = 6,
			Parameter = 8,
			InterfaceImplementation = 9,
			MemberReference = 10,
			Constant = 11,
			CustomAttribute = 12,
			DeclarativeSecurityAttribute = 14,
			StandaloneSignature = 17,
			EventDefinition = 20,
			PropertyDefinition = 23,
			MethodImplementation = 25,
			ModuleReference = 26,
			TypeSpecification = 27,
			AssemblyDefinition = 32,
			AssemblyFile = 38,
			AssemblyReference = 35,
			ExportedType = 39,
			GenericParameter = 42,
			MethodSpecification = 43,
			GenericParameterConstraint = 44,
			ManifestResource = 40,
			Document = 48,
			MethodDebugInformation = 49,
			LocalScope = 50,
			LocalVariable = 51,
			LocalConstant = 52,
			ImportScope = 53,
			CustomDebugInformation = 55,
			NamespaceDefinition = 124,
			UserString = 112,
			String = 120,
			Blob = 113,
			Guid = 114
		}

		internal static class HandleKindExtensions
		{
			internal static bool IsHeapHandle(this HandleKind kind) { return (int)kind >= 124; }
		}

		public interface IConstructedTypeProvider<TType> : ISZArrayTypeProvider<TType>
		{
			/// <summary>
			/// Gets the type symbol for a generic instantiation of the given generic type with the given type arguments.
			/// </summary>
			TType GetGenericInstantiation(TType genericType, System.Collections.Immutable.ImmutableArray<TType> typeArguments);

			/// <summary>
			/// Gets the type symbol for a generalized array of the given element type and shape.
			/// </summary>
			TType GetArrayType(TType elementType, ArrayShape shape);

			/// <summary>
			/// Gets the type symbol for a managed pointer to the given element type.
			/// </summary>
			TType GetByReferenceType(TType elementType);

			/// <summary>
			/// Gets the type symbol for an unmanaged pointer to the given element ty
			/// </summary>
			TType GetPointerType(TType elementType);
		}

		public interface ICustomAttributeTypeProvider<TType> : ISimpleTypeProvider<TType>, ISZArrayTypeProvider<TType>
		{
			/// <summary>
			/// Gets the TType representation for <see cref="T:System.Type" />.
			/// </summary>
			TType GetSystemType();

			/// <summary>
			/// Returns true if the given type represents <see cref="T:System.Type" />.
			/// </summary>
			bool IsSystemType(TType type);

			/// <summary>
			/// Get the type symbol for the given serialized type name.
			/// The serialized type name is in so-called "reflection notation" (i.e. as understood by <see cref="M:System.Type.GetType(System.String)" />.)
			/// </summary>
			/// <exception cref="T:System.BadImageFormatException">The name is malformed.</exception>
			TType GetTypeFromSerializedName(string name);

			/// <summary>
			/// Gets the underlying type of the given enum type symbol.
			/// </summary>
			/// <exception cref="T:System.BadImageFormatException">The given type symbol does not represent an enum.</exception>
			PrimitiveTypeCode GetUnderlyingEnumType(TType type);
		}

		public enum ILOpCode : ushort
		{
			Nop = 0,
			Break = 1,
			Ldarg_0 = 2,
			Ldarg_1 = 3,
			Ldarg_2 = 4,
			Ldarg_3 = 5,
			Ldloc_0 = 6,
			Ldloc_1 = 7,
			Ldloc_2 = 8,
			Ldloc_3 = 9,
			Stloc_0 = 10,
			Stloc_1 = 11,
			Stloc_2 = 12,
			Stloc_3 = 13,
			Ldarg_s = 14,
			Ldarga_s = 15,
			Starg_s = 16,
			Ldloc_s = 17,
			Ldloca_s = 18,
			Stloc_s = 19,
			Ldnull = 20,
			Ldc_i4_m1 = 21,
			Ldc_i4_0 = 22,
			Ldc_i4_1 = 23,
			Ldc_i4_2 = 24,
			Ldc_i4_3 = 25,
			Ldc_i4_4 = 26,
			Ldc_i4_5 = 27,
			Ldc_i4_6 = 28,
			Ldc_i4_7 = 29,
			Ldc_i4_8 = 30,
			Ldc_i4_s = 31,
			Ldc_i4 = 32,
			Ldc_i8 = 33,
			Ldc_r4 = 34,
			Ldc_r8 = 35,
			Dup = 37,
			Pop = 38,
			Jmp = 39,
			Call = 40,
			Calli = 41,
			Ret = 42,
			Br_s = 43,
			Brfalse_s = 44,
			Brtrue_s = 45,
			Beq_s = 46,
			Bge_s = 47,
			Bgt_s = 48,
			Ble_s = 49,
			Blt_s = 50,
			Bne_un_s = 51,
			Bge_un_s = 52,
			Bgt_un_s = 53,
			Ble_un_s = 54,
			Blt_un_s = 55,
			Br = 56,
			Brfalse = 57,
			Brtrue = 58,
			Beq = 59,
			Bge = 60,
			Bgt = 61,
			Ble = 62,
			Blt = 63,
			Bne_un = 64,
			Bge_un = 65,
			Bgt_un = 66,
			Ble_un = 67,
			Blt_un = 68,
			Switch = 69,
			Ldind_i1 = 70,
			Ldind_u1 = 71,
			Ldind_i2 = 72,
			Ldind_u2 = 73,
			Ldind_i4 = 74,
			Ldind_u4 = 75,
			Ldind_i8 = 76,
			Ldind_i = 77,
			Ldind_r4 = 78,
			Ldind_r8 = 79,
			Ldind_ref = 80,
			Stind_ref = 81,
			Stind_i1 = 82,
			Stind_i2 = 83,
			Stind_i4 = 84,
			Stind_i8 = 85,
			Stind_r4 = 86,
			Stind_r8 = 87,
			Add = 88,
			Sub = 89,
			Mul = 90,
			Div = 91,
			Div_un = 92,
			Rem = 93,
			Rem_un = 94,
			And = 95,
			Or = 96,
			Xor = 97,
			Shl = 98,
			Shr = 99,
			Shr_un = 100,
			Neg = 101,
			Not = 102,
			Conv_i1 = 103,
			Conv_i2 = 104,
			Conv_i4 = 105,
			Conv_i8 = 106,
			Conv_r4 = 107,
			Conv_r8 = 108,
			Conv_u4 = 109,
			Conv_u8 = 110,
			Callvirt = 111,
			Cpobj = 112,
			Ldobj = 113,
			Ldstr = 114,
			Newobj = 115,
			Castclass = 116,
			Isinst = 117,
			Conv_r_un = 118,
			Unbox = 121,
			Throw = 122,
			Ldfld = 123,
			Ldflda = 124,
			Stfld = 125,
			Ldsfld = 126,
			Ldsflda = 127,
			Stsfld = 128,
			Stobj = 129,
			Conv_ovf_i1_un = 130,
			Conv_ovf_i2_un = 131,
			Conv_ovf_i4_un = 132,
			Conv_ovf_i8_un = 133,
			Conv_ovf_u1_un = 134,
			Conv_ovf_u2_un = 135,
			Conv_ovf_u4_un = 136,
			Conv_ovf_u8_un = 137,
			Conv_ovf_i_un = 138,
			Conv_ovf_u_un = 139,
			Box = 140,
			Newarr = 141,
			Ldlen = 142,
			Ldelema = 143,
			Ldelem_i1 = 144,
			Ldelem_u1 = 145,
			Ldelem_i2 = 146,
			Ldelem_u2 = 147,
			Ldelem_i4 = 148,
			Ldelem_u4 = 149,
			Ldelem_i8 = 150,
			Ldelem_i = 151,
			Ldelem_r4 = 152,
			Ldelem_r8 = 153,
			Ldelem_ref = 154,
			Stelem_i = 155,
			Stelem_i1 = 156,
			Stelem_i2 = 157,
			Stelem_i4 = 158,
			Stelem_i8 = 159,
			Stelem_r4 = 160,
			Stelem_r8 = 161,
			Stelem_ref = 162,
			Ldelem = 163,
			Stelem = 164,
			Unbox_any = 165,
			Conv_ovf_i1 = 179,
			Conv_ovf_u1 = 180,
			Conv_ovf_i2 = 181,
			Conv_ovf_u2 = 182,
			Conv_ovf_i4 = 183,
			Conv_ovf_u4 = 184,
			Conv_ovf_i8 = 185,
			Conv_ovf_u8 = 186,
			Refanyval = 194,
			Ckfinite = 195,
			Mkrefany = 198,
			Ldtoken = 208,
			Conv_u2 = 209,
			Conv_u1 = 210,
			Conv_i = 211,
			Conv_ovf_i = 212,
			Conv_ovf_u = 213,
			Add_ovf = 214,
			Add_ovf_un = 215,
			Mul_ovf = 216,
			Mul_ovf_un = 217,
			Sub_ovf = 218,
			Sub_ovf_un = 219,
			Endfinally = 220,
			Leave = 221,
			Leave_s = 222,
			Stind_i = 223,
			Conv_u = 224,
			Arglist = 65024,
			Ceq = 65025,
			Cgt = 65026,
			Cgt_un = 65027,
			Clt = 65028,
			Clt_un = 65029,
			Ldftn = 65030,
			Ldvirtftn = 65031,
			Ldarg = 65033,
			Ldarga = 65034,
			Starg = 65035,
			Ldloc = 65036,
			Ldloca = 65037,
			Stloc = 65038,
			Localloc = 65039,
			Endfilter = 65041,
			Unaligned = 65042,
			Volatile = 65043,
			Tail = 65044,
			Initobj = 65045,
			Constrained = 65046,
			Cpblk = 65047,
			Initblk = 65048,
			Rethrow = 65050,
			Sizeof = 65052,
			Refanytype = 65053,
			Readonly = 65054
		}

		public static class ILOpCodeExtensions
		{
			/// <summary>
			/// Returns true of the specified op-code is a branch to a label.
			/// </summary>
			public static bool IsBranch(this ILOpCode opCode)
			{
				if (opCode - 43 <= ILOpCode.Ldc_i4_3 || opCode - 221 <= ILOpCode.Break)
				{
					return true;
				}
				return false;
			}

			/// <summary>
			/// Calculate the size of the specified branch instruction operand.
			/// </summary>
			/// <param name="opCode">Branch op-code.</param>
			/// <returns>1 if <paramref name="opCode" /> is a short branch or 4 if it is a long branch.</returns>
			/// <exception cref="T:System.ArgumentException">Specified <paramref name="opCode" /> is not a branch op-code.</exception>
			public static int GetBranchOperandSize(this ILOpCode opCode)
			{
				switch (opCode)
				{
					case ILOpCode.Br_s:
					case ILOpCode.Brfalse_s:
					case ILOpCode.Brtrue_s:
					case ILOpCode.Beq_s:
					case ILOpCode.Bge_s:
					case ILOpCode.Bgt_s:
					case ILOpCode.Ble_s:
					case ILOpCode.Blt_s:
					case ILOpCode.Bne_un_s:
					case ILOpCode.Bge_un_s:
					case ILOpCode.Bgt_un_s:
					case ILOpCode.Ble_un_s:
					case ILOpCode.Blt_un_s:
					case ILOpCode.Leave_s:
						return 1;
					case ILOpCode.Br:
					case ILOpCode.Brfalse:
					case ILOpCode.Brtrue:
					case ILOpCode.Beq:
					case ILOpCode.Bge:
					case ILOpCode.Bgt:
					case ILOpCode.Ble:
					case ILOpCode.Blt:
					case ILOpCode.Bne_un:
					case ILOpCode.Bge_un:
					case ILOpCode.Bgt_un:
					case ILOpCode.Ble_un:
					case ILOpCode.Blt_un:
					case ILOpCode.Leave:
						return 4;
					default:
						throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.UnexpectedOpCode, opCode), "opCode");
				}
			}

			/// <summary>
			/// Get a short form of the specified branch op-code.
			/// </summary>
			/// <param name="opCode">Branch op-code.</param>
			/// <returns>Short form of the branch op-code.</returns>
			/// <exception cref="T:System.ArgumentException">Specified <paramref name="opCode" /> is not a branch op-code.</exception>
			public static ILOpCode GetShortBranch(this ILOpCode opCode)
			{
				switch (opCode)
				{
					case ILOpCode.Br_s:
					case ILOpCode.Brfalse_s:
					case ILOpCode.Brtrue_s:
					case ILOpCode.Beq_s:
					case ILOpCode.Bge_s:
					case ILOpCode.Bgt_s:
					case ILOpCode.Ble_s:
					case ILOpCode.Blt_s:
					case ILOpCode.Bne_un_s:
					case ILOpCode.Bge_un_s:
					case ILOpCode.Bgt_un_s:
					case ILOpCode.Ble_un_s:
					case ILOpCode.Blt_un_s:
					case ILOpCode.Leave_s:
						return opCode;
					case ILOpCode.Br:
						return ILOpCode.Br_s;
					case ILOpCode.Brfalse:
						return ILOpCode.Brfalse_s;
					case ILOpCode.Brtrue:
						return ILOpCode.Brtrue_s;
					case ILOpCode.Beq:
						return ILOpCode.Beq_s;
					case ILOpCode.Bge:
						return ILOpCode.Bge_s;
					case ILOpCode.Bgt:
						return ILOpCode.Bgt_s;
					case ILOpCode.Ble:
						return ILOpCode.Ble_s;
					case ILOpCode.Blt:
						return ILOpCode.Blt_s;
					case ILOpCode.Bne_un:
						return ILOpCode.Bne_un_s;
					case ILOpCode.Bge_un:
						return ILOpCode.Bge_un_s;
					case ILOpCode.Bgt_un:
						return ILOpCode.Bgt_un_s;
					case ILOpCode.Ble_un:
						return ILOpCode.Ble_un_s;
					case ILOpCode.Blt_un:
						return ILOpCode.Blt_un_s;
					case ILOpCode.Leave:
						return ILOpCode.Leave_s;
					default:
						throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.UnexpectedOpCode, opCode), "opCode");
				}
			}

			/// <summary>
			/// Get a long form of the specified branch op-code.
			/// </summary>
			/// <param name="opCode">Branch op-code.</param>
			/// <returns>Long form of the branch op-code.</returns>
			/// <exception cref="T:System.ArgumentException">Specified <paramref name="opCode" /> is not a branch op-code.</exception>
			public static ILOpCode GetLongBranch(this ILOpCode opCode)
			{
				switch (opCode)
				{
					case ILOpCode.Br:
					case ILOpCode.Brfalse:
					case ILOpCode.Brtrue:
					case ILOpCode.Beq:
					case ILOpCode.Bge:
					case ILOpCode.Bgt:
					case ILOpCode.Ble:
					case ILOpCode.Blt:
					case ILOpCode.Bne_un:
					case ILOpCode.Bge_un:
					case ILOpCode.Bgt_un:
					case ILOpCode.Ble_un:
					case ILOpCode.Blt_un:
					case ILOpCode.Leave:
						return opCode;
					case ILOpCode.Br_s:
						return ILOpCode.Br;
					case ILOpCode.Brfalse_s:
						return ILOpCode.Brfalse;
					case ILOpCode.Brtrue_s:
						return ILOpCode.Brtrue;
					case ILOpCode.Beq_s:
						return ILOpCode.Beq;
					case ILOpCode.Bge_s:
						return ILOpCode.Bge;
					case ILOpCode.Bgt_s:
						return ILOpCode.Bgt;
					case ILOpCode.Ble_s:
						return ILOpCode.Ble;
					case ILOpCode.Blt_s:
						return ILOpCode.Blt;
					case ILOpCode.Bne_un_s:
						return ILOpCode.Bne_un;
					case ILOpCode.Bge_un_s:
						return ILOpCode.Bge_un;
					case ILOpCode.Bgt_un_s:
						return ILOpCode.Bgt_un;
					case ILOpCode.Ble_un_s:
						return ILOpCode.Ble_un;
					case ILOpCode.Blt_un_s:
						return ILOpCode.Blt_un;
					case ILOpCode.Leave_s:
						return ILOpCode.Leave;
					default:
						throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.UnexpectedOpCode, opCode), "opCode");
				}
			}
		}

		[Serializable]
		public class ImageFormatLimitationException : Exception
		{
			public ImageFormatLimitationException()
			{
			}

			public ImageFormatLimitationException(string? message)
				: base(message)
			{
			}

			public ImageFormatLimitationException(string? message, Exception? innerException)
				: base(message, innerException)
			{
			}

			protected ImageFormatLimitationException(SerializationInfo info, StreamingContext context)
				: base(info, context)
			{
			}
		}

		public readonly struct ImportDefinition
		{
			private readonly Handle _typeOrNamespace;

			public ImportDefinitionKind Kind { get; }

			public BlobHandle Alias { get; }

			public AssemblyReferenceHandle TargetAssembly { get; }

			public BlobHandle TargetNamespace => (BlobHandle)_typeOrNamespace;

			public EntityHandle TargetType => (EntityHandle)_typeOrNamespace;

			internal ImportDefinition(ImportDefinitionKind kind, BlobHandle alias = default(BlobHandle), AssemblyReferenceHandle assembly = default(AssemblyReferenceHandle), Handle typeOrNamespace = default(Handle))
			{
				Kind = kind;
				Alias = alias;
				TargetAssembly = assembly;
				_typeOrNamespace = typeOrNamespace;
			}
		}

		public readonly struct ImportDefinitionCollection : IEnumerable<ImportDefinition>, IEnumerable
		{
			public struct Enumerator : IEnumerator<ImportDefinition>, IDisposable, IEnumerator
			{
				private BlobReader _reader;

				private ImportDefinition _current;

				public ImportDefinition Current => _current;

				object IEnumerator.Current => _current;

				internal Enumerator(System.Reflection.Internal.MemoryBlock block)
				{
					_reader = new BlobReader(block);
					_current = default(ImportDefinition);
				}

				/// <exception cref="T:System.BadImageFormatException">Invalid blob format.</exception>
				public bool MoveNext()
				{
					if (_reader.RemainingBytes == 0)
					{
						return false;
					}
					ImportDefinitionKind importDefinitionKind = (ImportDefinitionKind)_reader.ReadByte();
					switch (importDefinitionKind)
					{
						case ImportDefinitionKind.ImportType:
							{
								Handle typeOrNamespace = _reader.ReadTypeHandle();
								_current = new ImportDefinition(importDefinitionKind, default(BlobHandle), default(AssemblyReferenceHandle), typeOrNamespace);
								break;
							}
						case ImportDefinitionKind.ImportNamespace:
							{
								Handle typeOrNamespace = MetadataTokens.BlobHandle(_reader.ReadCompressedInteger());
								_current = new ImportDefinition(importDefinitionKind, default(BlobHandle), default(AssemblyReferenceHandle), typeOrNamespace);
								break;
							}
						case ImportDefinitionKind.ImportAssemblyNamespace:
							{
								AssemblyReferenceHandle assembly = MetadataTokens.AssemblyReferenceHandle(_reader.ReadCompressedInteger());
								Handle typeOrNamespace = MetadataTokens.BlobHandle(_reader.ReadCompressedInteger());
								_current = new ImportDefinition(importDefinitionKind, default(BlobHandle), assembly, typeOrNamespace);
								break;
							}
						case ImportDefinitionKind.ImportAssemblyReferenceAlias:
							_current = new ImportDefinition(importDefinitionKind, MetadataTokens.BlobHandle(_reader.ReadCompressedInteger()));
							break;
						case ImportDefinitionKind.AliasAssemblyReference:
							_current = new ImportDefinition(importDefinitionKind, MetadataTokens.BlobHandle(_reader.ReadCompressedInteger()), MetadataTokens.AssemblyReferenceHandle(_reader.ReadCompressedInteger()));
							break;
						case ImportDefinitionKind.AliasType:
							{
								BlobHandle alias2 = MetadataTokens.BlobHandle(_reader.ReadCompressedInteger());
								Handle typeOrNamespace = _reader.ReadTypeHandle();
								_current = new ImportDefinition(importDefinitionKind, alias2, default(AssemblyReferenceHandle), typeOrNamespace);
								break;
							}
						case ImportDefinitionKind.ImportXmlNamespace:
						case ImportDefinitionKind.AliasNamespace:
							{
								BlobHandle alias = MetadataTokens.BlobHandle(_reader.ReadCompressedInteger());
								Handle typeOrNamespace = MetadataTokens.BlobHandle(_reader.ReadCompressedInteger());
								_current = new ImportDefinition(importDefinitionKind, alias, default(AssemblyReferenceHandle), typeOrNamespace);
								break;
							}
						case ImportDefinitionKind.AliasAssemblyNamespace:
							_current = new ImportDefinition(importDefinitionKind, MetadataTokens.BlobHandle(_reader.ReadCompressedInteger()), MetadataTokens.AssemblyReferenceHandle(_reader.ReadCompressedInteger()), MetadataTokens.BlobHandle(_reader.ReadCompressedInteger()));
							break;
						default:
							throw new BadImageFormatException(System.SR.Format(MDCFR.Properties.Resources.InvalidImportDefinitionKind, importDefinitionKind));
					}
					return true;
				}

				public void Reset()
				{
					_reader.Reset();
					_current = default(ImportDefinition);
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly System.Reflection.Internal.MemoryBlock _block;

			internal ImportDefinitionCollection(System.Reflection.Internal.MemoryBlock block)
			{
				_block = block;
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_block);
			}

			IEnumerator<ImportDefinition> IEnumerable<ImportDefinition>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public enum ImportDefinitionKind
		{
			ImportNamespace = 1,
			ImportAssemblyNamespace,
			ImportType,
			ImportXmlNamespace,
			ImportAssemblyReferenceAlias,
			AliasAssemblyReference,
			AliasNamespace,
			AliasAssemblyNamespace,
			AliasType
		}

		/// <summary>
		/// Lexical scope within which a group of imports are available. Stored in debug metadata.
		/// </summary>
		/// <remarks>
		/// See https://github.com/dotnet/runtime/blob/main/src/libraries/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#importscope-table-0x35
		/// </remarks>
		public readonly struct ImportScope
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private ImportScopeHandle Handle => ImportScopeHandle.FromRowId(_rowId);

			public ImportScopeHandle Parent => _reader.ImportScopeTable.GetParent(Handle);

			public BlobHandle ImportsBlob => _reader.ImportScopeTable.GetImports(Handle);

			internal ImportScope(MetadataReader reader, ImportScopeHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}

			public ImportDefinitionCollection GetImports()
			{
				return new ImportDefinitionCollection(_reader.BlobHeap.GetMemoryBlock(ImportsBlob));
			}
		}

		public readonly struct ImportScopeCollection : IReadOnlyCollection<ImportScopeHandle>, IEnumerable<ImportScopeHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<ImportScopeHandle>, IDisposable, IEnumerator
			{
				private readonly MetadataReader _reader;

				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public ImportScopeHandle Current => ImportScopeHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal Enumerator(MetadataReader reader, int firstRowId, int lastRowId)
				{
					_reader = reader;
					_lastRowId = lastRowId;
					_currentRowId = firstRowId - 1;
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly MetadataReader _reader;

			private readonly int _firstRowId;

			private readonly int _lastRowId;

			public int Count => _lastRowId - _firstRowId + 1;

			internal ImportScopeCollection(MetadataReader reader)
			{
				_reader = reader;
				_firstRowId = 1;
				_lastRowId = reader.ImportScopeTable.NumberOfRows;
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_reader, _firstRowId, _lastRowId);
			}

			IEnumerator<ImportScopeHandle> IEnumerable<ImportScopeHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public readonly struct ImportScopeHandle : IEquatable<ImportScopeHandle>
		{
			private const uint tokenType = 889192448u;

			private const byte tokenTypeSmall = 53;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private ImportScopeHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static ImportScopeHandle FromRowId(int rowId)
			{
				return new ImportScopeHandle(rowId);
			}

			public static implicit operator Handle(ImportScopeHandle handle)
			{
				return new Handle(53, handle._rowId);
			}

			public static implicit operator EntityHandle(ImportScopeHandle handle)
			{
				return new EntityHandle((uint)(0x35000000uL | (ulong)handle._rowId));
			}

			public static explicit operator ImportScopeHandle(Handle handle)
			{
				if (handle.VType != 53)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new ImportScopeHandle(handle.RowId);
			}

			public static explicit operator ImportScopeHandle(EntityHandle handle)
			{
				if (handle.VType != 889192448)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new ImportScopeHandle(handle.RowId);
			}

			public static bool operator ==(ImportScopeHandle left, ImportScopeHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals([NotNullWhen(true)] object? obj)
			{
				if (obj is ImportScopeHandle importScopeHandle)
				{
					return importScopeHandle._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(ImportScopeHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(ImportScopeHandle left, ImportScopeHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		public readonly struct InterfaceImplementation
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private InterfaceImplementationHandle Handle => InterfaceImplementationHandle.FromRowId(_rowId);

			/// <summary>
			/// The interface that is implemented
			/// <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, or <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />
			/// </summary>
			public EntityHandle Interface => _reader.InterfaceImplTable.GetInterface(_rowId);

			internal InterfaceImplementation(MetadataReader reader, InterfaceImplementationHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, Handle);
			}
		}

		public readonly struct InterfaceImplementationHandle : IEquatable<InterfaceImplementationHandle>
		{
			private const uint tokenType = 150994944u;

			private const byte tokenTypeSmall = 9;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			internal InterfaceImplementationHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static InterfaceImplementationHandle FromRowId(int rowId)
			{
				return new InterfaceImplementationHandle(rowId);
			}

			public static implicit operator Handle(InterfaceImplementationHandle handle)
			{
				return new Handle(9, handle._rowId);
			}

			public static implicit operator EntityHandle(InterfaceImplementationHandle handle)
			{
				return new EntityHandle((uint)(0x9000000uL | (ulong)handle._rowId));
			}

			public static explicit operator InterfaceImplementationHandle(Handle handle)
			{
				if (handle.VType != 9)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new InterfaceImplementationHandle(handle.RowId);
			}

			public static explicit operator InterfaceImplementationHandle(EntityHandle handle)
			{
				if (handle.VType != 150994944)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new InterfaceImplementationHandle(handle.RowId);
			}

			public static bool operator ==(InterfaceImplementationHandle left, InterfaceImplementationHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is InterfaceImplementationHandle)
				{
					return ((InterfaceImplementationHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(InterfaceImplementationHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(InterfaceImplementationHandle left, InterfaceImplementationHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		public readonly struct InterfaceImplementationHandleCollection : IReadOnlyCollection<InterfaceImplementationHandle>, IEnumerable<InterfaceImplementationHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<InterfaceImplementationHandle>, IDisposable, IEnumerator
			{
				private readonly MetadataReader _reader;

				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public InterfaceImplementationHandle Current => InterfaceImplementationHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal Enumerator(MetadataReader reader, int firstRowId, int lastRowId)
				{
					_reader = reader;
					_currentRowId = firstRowId - 1;
					_lastRowId = lastRowId;
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly MetadataReader _reader;

			private readonly int _firstRowId;

			private readonly int _lastRowId;

			public int Count => _lastRowId - _firstRowId + 1;

			internal InterfaceImplementationHandleCollection(MetadataReader reader, TypeDefinitionHandle implementingType)
			{
				_reader = reader;
				reader.InterfaceImplTable.GetInterfaceImplRange(implementingType, out _firstRowId, out _lastRowId);
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_reader, _firstRowId, _lastRowId);
			}

			IEnumerator<InterfaceImplementationHandle> IEnumerable<InterfaceImplementationHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public interface ISignatureTypeProvider<TType, TGenericContext> : ISimpleTypeProvider<TType>, IConstructedTypeProvider<TType>, ISZArrayTypeProvider<TType>
		{
			/// <summary>
			/// Gets the a type symbol for the function pointer type of the given method signature.
			/// </summary>
			TType GetFunctionPointerType(MethodSignature<TType> signature);

			/// <summary>
			/// Gets the type symbol for the generic method parameter at the given zero-based index.
			/// </summary>
			TType GetGenericMethodParameter(TGenericContext genericContext, int index);

			/// <summary>
			/// Gets the type symbol for the generic type parameter at the given zero-based index.
			/// </summary>
			TType GetGenericTypeParameter(TGenericContext genericContext, int index);

			/// <summary>
			/// Gets the type symbol for a type with a custom modifier applied.
			/// </summary>
			/// <param name="modifier">The modifier type applied. </param>
			/// <param name="unmodifiedType">The type symbol of the underlying type without modifiers applied.</param>
			/// <param name="isRequired">True if the modifier is required, false if it's optional.</param>
			TType GetModifiedType(TType modifier, TType unmodifiedType, bool isRequired);

			/// <summary>
			/// Gets the type symbol for a local variable type that is marked as pinned.
			/// </summary>
			TType GetPinnedType(TType elementType);

			/// <summary>
			/// Gets the type symbol for a type specification.
			/// </summary>
			/// <param name="reader">
			/// The metadata reader that was passed to the signature decoder. It may be null.
			/// </param>
			/// <param name="genericContext">
			/// The context that was passed to the signature decoder.
			/// </param>
			/// <param name="handle">
			/// The type specification handle.
			/// </param>
			/// <param name="rawTypeKind">
			/// The kind of the type as specified in the signature. To interpret this value use <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />
			/// Note that when the signature comes from a WinMD file additional processing is needed to determine whether the target type is a value type or a reference type.
			/// </param>
			TType GetTypeFromSpecification(MetadataReader reader, TGenericContext genericContext, TypeSpecificationHandle handle, byte rawTypeKind);
		}

		public interface ISimpleTypeProvider<TType>
		{
			/// <summary>
			/// Gets the type symbol for a primitive type.
			/// </summary>
			TType GetPrimitiveType(PrimitiveTypeCode typeCode);

			/// <summary>
			/// Gets the type symbol for a type definition.
			/// </summary>
			/// <param name="reader">
			/// The metadata reader that was passed to the signature decoder. It may be null.
			/// </param>
			/// <param name="handle">
			/// The type definition handle.
			/// </param>
			/// <param name="rawTypeKind">
			/// The kind of the type as specified in the signature. To interpret this value use <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />
			/// Note that when the signature comes from a WinMD file additional processing is needed to determine whether the target type is a value type or a reference type.
			/// </param>
			TType GetTypeFromDefinition(MetadataReader reader, TypeDefinitionHandle handle, byte rawTypeKind);

			/// <summary>
			/// Gets the type symbol for a type reference.
			/// </summary>
			/// <param name="reader">
			/// The metadata reader that was passed to the signature decoder. It may be null.
			/// </param>
			/// <param name="handle">
			/// The type definition handle.
			/// </param>
			/// <param name="rawTypeKind">
			/// The kind of the type as specified in the signature. To interpret this value use <see cref="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.ResolveSignatureTypeKind(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle,System.Byte)" />
			/// Note that when the signature comes from a WinMD file additional processing is needed to determine whether the target type is a value type or a reference type.
			/// </param>
			TType GetTypeFromReference(MetadataReader reader, TypeReferenceHandle handle, byte rawTypeKind);
		}

		public interface ISZArrayTypeProvider<TType>
		{
			/// <summary>
			/// Gets the type symbol for a single-dimensional array with zero lower bounds of the given element type.
			/// </summary>
			TType GetSZArrayType(TType elementType);
		}

		/// <summary>
		/// Local constant. Stored in debug metadata.
		/// </summary>
		/// <remarks>
		/// See https://github.com/dotnet/runtime/blob/main/src/libraries/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#localconstant-table-0x34.
		/// </remarks>
		public readonly struct LocalConstant
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private LocalConstantHandle Handle => LocalConstantHandle.FromRowId(_rowId);

			public StringHandle Name => _reader.LocalConstantTable.GetName(Handle);

			/// <summary>
			/// The constant signature.
			/// </summary>
			public BlobHandle Signature => _reader.LocalConstantTable.GetSignature(Handle);

			internal LocalConstant(MetadataReader reader, LocalConstantHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}
		}

		public readonly struct LocalConstantHandle : IEquatable<LocalConstantHandle>
		{
			private const uint tokenType = 872415232u;

			private const byte tokenTypeSmall = 52;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private LocalConstantHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static LocalConstantHandle FromRowId(int rowId)
			{
				return new LocalConstantHandle(rowId);
			}

			public static implicit operator Handle(LocalConstantHandle handle)
			{
				return new Handle(52, handle._rowId);
			}

			public static implicit operator EntityHandle(LocalConstantHandle handle)
			{
				return new EntityHandle((uint)(0x34000000uL | (ulong)handle._rowId));
			}

			public static explicit operator LocalConstantHandle(Handle handle)
			{
				if (handle.VType != 52)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new LocalConstantHandle(handle.RowId);
			}

			public static explicit operator LocalConstantHandle(EntityHandle handle)
			{
				if (handle.VType != 872415232)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new LocalConstantHandle(handle.RowId);
			}

			public static bool operator ==(LocalConstantHandle left, LocalConstantHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals([NotNullWhen(true)] object? obj)
			{
				if (obj is LocalConstantHandle localConstantHandle)
				{
					return localConstantHandle._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(LocalConstantHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(LocalConstantHandle left, LocalConstantHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		public readonly struct LocalConstantHandleCollection : IReadOnlyCollection<LocalConstantHandle>, IEnumerable<LocalConstantHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<LocalConstantHandle>, IDisposable, IEnumerator
			{
				private readonly MetadataReader _reader;

				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public LocalConstantHandle Current => LocalConstantHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal Enumerator(MetadataReader reader, int firstRowId, int lastRowId)
				{
					_reader = reader;
					_lastRowId = lastRowId;
					_currentRowId = firstRowId - 1;
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly MetadataReader _reader;

			private readonly int _firstRowId;

			private readonly int _lastRowId;

			public int Count => _lastRowId - _firstRowId + 1;

			internal LocalConstantHandleCollection(MetadataReader reader, LocalScopeHandle scope)
			{
				_reader = reader;
				if (scope.IsNil)
				{
					_firstRowId = 1;
					_lastRowId = reader.LocalConstantTable.NumberOfRows;
				}
				else
				{
					reader.GetLocalConstantRange(scope, out _firstRowId, out _lastRowId);
				}
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_reader, _firstRowId, _lastRowId);
			}

			IEnumerator<LocalConstantHandle> IEnumerable<LocalConstantHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		/// <summary>
		/// Scope of local variables and constants. Stored in debug metadata.
		/// </summary>
		/// <remarks>
		/// See https://github.com/dotnet/runtime/blob/main/src/libraries/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#localscope-table-0x32.
		/// </remarks>
		public readonly struct LocalScope
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private LocalScopeHandle Handle => LocalScopeHandle.FromRowId(_rowId);

			public MethodDefinitionHandle Method => _reader.LocalScopeTable.GetMethod(_rowId);

			public ImportScopeHandle ImportScope => _reader.LocalScopeTable.GetImportScope(Handle);

			public int StartOffset => _reader.LocalScopeTable.GetStartOffset(_rowId);

			public int Length => _reader.LocalScopeTable.GetLength(_rowId);

			public int EndOffset => _reader.LocalScopeTable.GetEndOffset(_rowId);

			internal LocalScope(MetadataReader reader, LocalScopeHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}

			public LocalVariableHandleCollection GetLocalVariables()
			{
				return new LocalVariableHandleCollection(_reader, Handle);
			}

			public LocalConstantHandleCollection GetLocalConstants()
			{
				return new LocalConstantHandleCollection(_reader, Handle);
			}

			public LocalScopeHandleCollection.ChildrenEnumerator GetChildren()
			{
				return new LocalScopeHandleCollection.ChildrenEnumerator(_reader, _rowId);
			}
		}

		public readonly struct LocalScopeHandle : IEquatable<LocalScopeHandle>
		{
			private const uint tokenType = 838860800u;

			private const byte tokenTypeSmall = 50;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private LocalScopeHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static LocalScopeHandle FromRowId(int rowId)
			{
				return new LocalScopeHandle(rowId);
			}

			public static implicit operator Handle(LocalScopeHandle handle)
			{
				return new Handle(50, handle._rowId);
			}

			public static implicit operator EntityHandle(LocalScopeHandle handle)
			{
				return new EntityHandle((uint)(0x32000000uL | (ulong)handle._rowId));
			}

			public static explicit operator LocalScopeHandle(Handle handle)
			{
				if (handle.VType != 50)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new LocalScopeHandle(handle.RowId);
			}

			public static explicit operator LocalScopeHandle(EntityHandle handle)
			{
				if (handle.VType != 838860800)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new LocalScopeHandle(handle.RowId);
			}

			public static bool operator ==(LocalScopeHandle left, LocalScopeHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is LocalScopeHandle localScopeHandle)
				{
					return localScopeHandle._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(LocalScopeHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(LocalScopeHandle left, LocalScopeHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		public readonly struct LocalScopeHandleCollection : IReadOnlyCollection<LocalScopeHandle>, IEnumerable<LocalScopeHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<LocalScopeHandle>, IDisposable, IEnumerator
			{
				private readonly MetadataReader _reader;

				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public LocalScopeHandle Current => LocalScopeHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal Enumerator(MetadataReader reader, int firstRowId, int lastRowId)
				{
					_reader = reader;
					_lastRowId = lastRowId;
					_currentRowId = firstRowId - 1;
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			public struct ChildrenEnumerator : IEnumerator<LocalScopeHandle>, IDisposable, IEnumerator
			{
				private readonly MetadataReader _reader;

				private readonly int _parentEndOffset;

				private readonly int _parentRowId;

				private readonly MethodDefinitionHandle _parentMethodRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public LocalScopeHandle Current => LocalScopeHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal ChildrenEnumerator(MetadataReader reader, int parentRowId)
				{
					_reader = reader;
					_parentEndOffset = reader.LocalScopeTable.GetEndOffset(parentRowId);
					_parentMethodRowId = reader.LocalScopeTable.GetMethod(parentRowId);
					_currentRowId = 0;
					_parentRowId = parentRowId;
				}

				public bool MoveNext()
				{
					int currentRowId = _currentRowId;
					int num;
					int num2;
					switch (currentRowId)
					{
						case 16777216:
							return false;
						case 0:
							num = -1;
							num2 = _parentRowId + 1;
							break;
						default:
							num = _reader.LocalScopeTable.GetEndOffset(currentRowId);
							num2 = currentRowId + 1;
							break;
					}
					int numberOfRows = _reader.LocalScopeTable.NumberOfRows;
					int endOffset;
					while (true)
					{
						if (num2 > numberOfRows || _parentMethodRowId != _reader.LocalScopeTable.GetMethod(num2))
						{
							_currentRowId = 16777216;
							return false;
						}
						endOffset = _reader.LocalScopeTable.GetEndOffset(num2);
						if (endOffset > num)
						{
							break;
						}
						num2++;
					}
					if (endOffset > _parentEndOffset)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId = num2;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly MetadataReader _reader;

			private readonly int _firstRowId;

			private readonly int _lastRowId;

			public int Count => _lastRowId - _firstRowId + 1;

			internal LocalScopeHandleCollection(MetadataReader reader, int methodDefinitionRowId)
			{
				_reader = reader;
				if (methodDefinitionRowId == 0)
				{
					_firstRowId = 1;
					_lastRowId = reader.LocalScopeTable.NumberOfRows;
				}
				else
				{
					reader.LocalScopeTable.GetLocalScopeRange(methodDefinitionRowId, out _firstRowId, out _lastRowId);
				}
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_reader, _firstRowId, _lastRowId);
			}

			IEnumerator<LocalScopeHandle> IEnumerable<LocalScopeHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		/// <summary>
		/// Local variable. Stored in debug metadata.
		/// </summary>
		/// <remarks>
		/// See https://github.com/dotnet/runtime/blob/main/src/libraries/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#localvariable-table-0x33.
		/// </remarks>
		public readonly struct LocalVariable
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private LocalVariableHandle Handle => LocalVariableHandle.FromRowId(_rowId);

			public LocalVariableAttributes Attributes => _reader.LocalVariableTable.GetAttributes(Handle);

			public int Index => _reader.LocalVariableTable.GetIndex(Handle);

			public StringHandle Name => _reader.LocalVariableTable.GetName(Handle);

			internal LocalVariable(MetadataReader reader, LocalVariableHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}
		}

		[Flags]
		public enum LocalVariableAttributes { None = 0, DebuggerHidden = 1 }

		public readonly struct LocalVariableHandle : IEquatable<LocalVariableHandle>
		{
			private const uint tokenType = 855638016u;

			private const byte tokenTypeSmall = 51;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private LocalVariableHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static LocalVariableHandle FromRowId(int rowId)
			{
				return new LocalVariableHandle(rowId);
			}

			public static implicit operator Handle(LocalVariableHandle handle)
			{
				return new Handle(51, handle._rowId);
			}

			public static implicit operator EntityHandle(LocalVariableHandle handle)
			{
				return new EntityHandle((uint)(0x33000000uL | (ulong)handle._rowId));
			}

			public static explicit operator LocalVariableHandle(Handle handle)
			{
				if (handle.VType != 51)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new LocalVariableHandle(handle.RowId);
			}

			public static explicit operator LocalVariableHandle(EntityHandle handle)
			{
				if (handle.VType != 855638016)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new LocalVariableHandle(handle.RowId);
			}

			public static bool operator ==(LocalVariableHandle left, LocalVariableHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is LocalVariableHandle localVariableHandle)
				{
					return localVariableHandle._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(LocalVariableHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(LocalVariableHandle left, LocalVariableHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		public readonly struct LocalVariableHandleCollection : IReadOnlyCollection<LocalVariableHandle>, IEnumerable<LocalVariableHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<LocalVariableHandle>, IDisposable, IEnumerator
			{
				private readonly MetadataReader _reader;

				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public LocalVariableHandle Current => LocalVariableHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal Enumerator(MetadataReader reader, int firstRowId, int lastRowId)
				{
					_reader = reader;
					_lastRowId = lastRowId;
					_currentRowId = firstRowId - 1;
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly MetadataReader _reader;

			private readonly int _firstRowId;

			private readonly int _lastRowId;

			public int Count => _lastRowId - _firstRowId + 1;

			internal LocalVariableHandleCollection(MetadataReader reader, LocalScopeHandle scope)
			{
				_reader = reader;
				if (scope.IsNil)
				{
					_firstRowId = 1;
					_lastRowId = reader.LocalVariableTable.NumberOfRows;
				}
				else
				{
					reader.GetLocalVariableRange(scope, out _firstRowId, out _lastRowId);
				}
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_reader, _firstRowId, _lastRowId);
			}

			IEnumerator<LocalVariableHandle> IEnumerable<LocalVariableHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public readonly struct ManifestResource
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private ManifestResourceHandle Handle => ManifestResourceHandle.FromRowId(_rowId);

			/// <summary>
			/// Specifies the byte offset within the referenced file at which this resource record begins.
			/// </summary>
			/// <remarks>
			/// Corresponds to Offset field of ManifestResource table in ECMA-335 Standard.
			/// </remarks>
			public long Offset => _reader.ManifestResourceTable.GetOffset(Handle);

			/// <summary>
			/// Resource attributes.
			/// </summary>
			/// <remarks>
			/// Corresponds to Flags field of ManifestResource table in ECMA-335 Standard.
			/// </remarks>
			public ManifestResourceAttributes Attributes => _reader.ManifestResourceTable.GetFlags(Handle);

			/// <summary>
			/// Name of the resource.
			/// </summary>
			/// <remarks>
			/// Corresponds to Name field of ManifestResource table in ECMA-335 Standard.
			/// </remarks>
			public StringHandle Name => _reader.ManifestResourceTable.GetName(Handle);

			/// <summary>
			/// <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, or nil handle.
			/// </summary>
			/// <remarks>
			/// Corresponds to Implementation field of ManifestResource table in ECMA-335 Standard.
			///
			/// If nil then <see cref="P:System.Reflection.Metadata.ManifestResource.Offset" /> is an offset in the PE image that contains the metadata,
			/// starting from the Resource entry in the CLI header.
			/// </remarks>
			public EntityHandle Implementation => _reader.ManifestResourceTable.GetImplementation(Handle);

			internal ManifestResource(MetadataReader reader, ManifestResourceHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, Handle);
			}
		}

		public readonly struct ManifestResourceHandle : IEquatable<ManifestResourceHandle>
		{
			private const uint tokenType = 671088640u;

			private const byte tokenTypeSmall = 40;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private ManifestResourceHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static ManifestResourceHandle FromRowId(int rowId)
			{
				return new ManifestResourceHandle(rowId);
			}

			public static implicit operator Handle(ManifestResourceHandle handle)
			{
				return new Handle(40, handle._rowId);
			}

			public static implicit operator EntityHandle(ManifestResourceHandle handle)
			{
				return new EntityHandle((uint)(0x28000000uL | (ulong)handle._rowId));
			}

			public static explicit operator ManifestResourceHandle(Handle handle)
			{
				if (handle.VType != 40)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new ManifestResourceHandle(handle.RowId);
			}

			public static explicit operator ManifestResourceHandle(EntityHandle handle)
			{
				if (handle.VType != 671088640)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new ManifestResourceHandle(handle.RowId);
			}

			public static bool operator ==(ManifestResourceHandle left, ManifestResourceHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is ManifestResourceHandle)
				{
					return ((ManifestResourceHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(ManifestResourceHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(ManifestResourceHandle left, ManifestResourceHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		/// <summary>
		/// Represents a collection of <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />.
		/// </summary>
		public readonly struct ManifestResourceHandleCollection : IReadOnlyCollection<ManifestResourceHandle>, IEnumerable<ManifestResourceHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<ManifestResourceHandle>, IDisposable, IEnumerator
			{
				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public ManifestResourceHandle Current => ManifestResourceHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal Enumerator(int lastRowId)
				{
					_lastRowId = lastRowId;
					_currentRowId = 0;
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly int _lastRowId;

			public int Count => _lastRowId;

			internal ManifestResourceHandleCollection(int lastRowId)
			{
				_lastRowId = lastRowId;
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_lastRowId);
			}

			IEnumerator<ManifestResourceHandle> IEnumerable<ManifestResourceHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public readonly struct MemberReference
		{
			private readonly MetadataReader _reader;

			private readonly uint _treatmentAndRowId;

			private int RowId => (int)(_treatmentAndRowId & 0xFFFFFF);

			private MemberRefTreatment Treatment => (MemberRefTreatment)(_treatmentAndRowId >> 24);

			private MemberReferenceHandle Handle => MemberReferenceHandle.FromRowId(RowId);

			/// <summary>
			/// MethodDef, ModuleRef,TypeDef, TypeRef, or TypeSpec handle.
			/// </summary>
			public EntityHandle Parent
			{
				get
				{
					if (Treatment == MemberRefTreatment.None)
					{
						return _reader.MemberRefTable.GetClass(Handle);
					}
					return GetProjectedParent();
				}
			}

			public StringHandle Name
			{
				get
				{
					if (Treatment == MemberRefTreatment.None)
					{
						return _reader.MemberRefTable.GetName(Handle);
					}
					return GetProjectedName();
				}
			}

			/// <summary>
			/// Gets a handle to the signature blob.
			/// </summary>
			public BlobHandle Signature
			{
				get
				{
					if (Treatment == MemberRefTreatment.None)
					{
						return _reader.MemberRefTable.GetSignature(Handle);
					}
					return GetProjectedSignature();
				}
			}

			internal MemberReference(MetadataReader reader, uint treatmentAndRowId)
			{
				_reader = reader;
				_treatmentAndRowId = treatmentAndRowId;
			}

			public TType DecodeFieldSignature<TType, TGenericContext>(ISignatureTypeProvider<TType, TGenericContext> provider, TGenericContext genericContext)
			{
				SignatureDecoder<TType, TGenericContext> signatureDecoder = new SignatureDecoder<TType, TGenericContext>(provider, _reader, genericContext);
				BlobReader blobReader = _reader.GetBlobReader(Signature);
				return signatureDecoder.DecodeFieldSignature(ref blobReader);
			}

			public MethodSignature<TType> DecodeMethodSignature<TType, TGenericContext>(ISignatureTypeProvider<TType, TGenericContext> provider, TGenericContext genericContext)
			{
				SignatureDecoder<TType, TGenericContext> signatureDecoder = new SignatureDecoder<TType, TGenericContext>(provider, _reader, genericContext);
				BlobReader blobReader = _reader.GetBlobReader(Signature);
				return signatureDecoder.DecodeMethodSignature(ref blobReader);
			}

			/// <summary>
			/// Determines if the member reference is to a method or field.
			/// </summary>
			/// <exception cref="T:System.BadImageFormatException">The member reference signature is invalid.</exception>
			public MemberReferenceKind GetKind()
			{
				return _reader.GetBlobReader(Signature).ReadSignatureHeader().Kind switch
				{
					SignatureKind.Method => MemberReferenceKind.Method,
					SignatureKind.Field => MemberReferenceKind.Field,
					_ => throw new BadImageFormatException(),
				};
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, Handle);
			}

			private EntityHandle GetProjectedParent()
			{
				return _reader.MemberRefTable.GetClass(Handle);
			}

			private StringHandle GetProjectedName()
			{
				if (Treatment == MemberRefTreatment.Dispose)
				{
					return StringHandle.FromVirtualIndex(StringHandle.VirtualIndex.Dispose);
				}
				return _reader.MemberRefTable.GetName(Handle);
			}

			private BlobHandle GetProjectedSignature()
			{
				return _reader.MemberRefTable.GetSignature(Handle);
			}
		}

		public readonly struct MemberReferenceHandle : IEquatable<MemberReferenceHandle>
		{
			private const uint tokenType = 167772160u;

			private const byte tokenTypeSmall = 10;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private MemberReferenceHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static MemberReferenceHandle FromRowId(int rowId)
			{
				return new MemberReferenceHandle(rowId);
			}

			public static implicit operator Handle(MemberReferenceHandle handle)
			{
				return new Handle(10, handle._rowId);
			}

			public static implicit operator EntityHandle(MemberReferenceHandle handle)
			{
				return new EntityHandle((uint)(0xA000000uL | (ulong)handle._rowId));
			}

			public static explicit operator MemberReferenceHandle(Handle handle)
			{
				if (handle.VType != 10)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new MemberReferenceHandle(handle.RowId);
			}

			public static explicit operator MemberReferenceHandle(EntityHandle handle)
			{
				if (handle.VType != 167772160)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new MemberReferenceHandle(handle.RowId);
			}

			public static bool operator ==(MemberReferenceHandle left, MemberReferenceHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is MemberReferenceHandle)
				{
					return ((MemberReferenceHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(MemberReferenceHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(MemberReferenceHandle left, MemberReferenceHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		/// <summary>
		/// Represents a collection of <see cref="System.Reflection.Metadata.MemberReferenceHandle" />.
		/// </summary>
		public readonly struct MemberReferenceHandleCollection : IReadOnlyCollection<MemberReferenceHandle>, IEnumerable<MemberReferenceHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<MemberReferenceHandle>, IDisposable, IEnumerator
			{
				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public MemberReferenceHandle Current => MemberReferenceHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal Enumerator(int lastRowId)
				{
					_lastRowId = lastRowId;
					_currentRowId = 0;
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly int _lastRowId;

			public int Count => _lastRowId;

			internal MemberReferenceHandleCollection(int lastRowId)
			{
				_lastRowId = lastRowId;
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_lastRowId);
			}

			IEnumerator<MemberReferenceHandle> IEnumerable<MemberReferenceHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		/// <summary>
		/// Indicates whether a <see cref="System.Reflection.Metadata.MemberReference" /> references a method or field.
		/// </summary>
		public enum MemberReferenceKind
		{
			/// <summary>
			/// The <see cref="System.Reflection.Metadata.MemberReference" /> references a method.
			/// </summary>
			Method,
			/// <summary>
			/// The <see cref="System.Reflection.Metadata.MemberReference" /> references a field.
			/// </summary>
			Field
		}

		public enum MetadataKind
		{
			/// <summary>
			/// CLI metadata.
			/// </summary>
			Ecma335,
			/// <summary>
			/// Windows Metadata.
			/// </summary>
			WindowsMetadata,
			/// <summary>
			/// Windows Metadata generated by managed compilers.
			/// </summary>
			ManagedWindowsMetadata
		}

		/// <summary>
		/// Reads metadata as defined byte the ECMA 335 CLI specification.
		/// </summary>
		public sealed class MetadataReader
		{
			private readonly struct ProjectionInfo
			{
				public readonly string WinRTNamespace;

				public readonly StringHandle.VirtualIndex ClrNamespace;

				public readonly StringHandle.VirtualIndex ClrName;

				public readonly AssemblyReferenceHandle.VirtualIndex AssemblyRef;

				public readonly TypeDefTreatment Treatment;

				public readonly TypeRefSignatureTreatment SignatureTreatment;

				public readonly bool IsIDisposable;

				public ProjectionInfo(string winRtNamespace, StringHandle.VirtualIndex clrNamespace, StringHandle.VirtualIndex clrName, AssemblyReferenceHandle.VirtualIndex clrAssembly, TypeDefTreatment treatment = TypeDefTreatment.RedirectedToClrType, TypeRefSignatureTreatment signatureTreatment = TypeRefSignatureTreatment.None, bool isIDisposable = false)
				{
					WinRTNamespace = winRtNamespace;
					ClrNamespace = clrNamespace;
					ClrName = clrName;
					AssemblyRef = clrAssembly;
					Treatment = treatment;
					SignatureTreatment = signatureTreatment;
					IsIDisposable = isIDisposable;
				}
			}

			internal readonly NamespaceCache NamespaceCache;

			internal readonly System.Reflection.Internal.MemoryBlock Block;

			internal readonly int WinMDMscorlibRef;

			private readonly object _memoryOwnerObj;

			private readonly MetadataReaderOptions _options;

			private Dictionary<TypeDefinitionHandle, System.Collections.Immutable.ImmutableArray<TypeDefinitionHandle>> _lazyNestedTypesMap;

			private readonly string _versionString;

			private readonly MetadataKind _metadataKind;

			private readonly System.Reflection.Metadata.Ecma335.MetadataStreamKind _metadataStreamKind;

			private readonly DebugMetadataHeader _debugMetadataHeader;

			internal StringHeap StringHeap;

			internal System.Reflection.Metadata.Ecma335.BlobHeap BlobHeap;

			internal GuidHeap GuidHeap;

			internal UserStringHeap UserStringHeap;

			/// <summary>
			/// True if the metadata stream has minimal delta format. Used for EnC.
			/// </summary>
			/// <remarks>
			/// The metadata stream has minimal delta format if "#JTD" stream is present.
			/// Minimal delta format uses large size (4B) when encoding table/heap references.
			/// The heaps in minimal delta only contain data of the delta,
			/// there is no padding at the beginning of the heaps that would align them
			/// with the original full metadata heaps.
			/// </remarks>
			internal bool IsMinimalDelta;

			private readonly System.Reflection.Metadata.Ecma335.TableMask _sortedTables;

			/// <summary>
			/// A row count for each possible table. May be indexed by <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />.
			/// </summary>
			internal int[] TableRowCounts;

			internal ModuleTableReader ModuleTable;

			internal TypeRefTableReader TypeRefTable;

			internal TypeDefTableReader TypeDefTable;

			internal FieldPtrTableReader FieldPtrTable;

			internal FieldTableReader FieldTable;

			internal MethodPtrTableReader MethodPtrTable;

			internal MethodTableReader MethodDefTable;

			internal ParamPtrTableReader ParamPtrTable;

			internal ParamTableReader ParamTable;

			internal InterfaceImplTableReader InterfaceImplTable;

			internal MemberRefTableReader MemberRefTable;

			internal ConstantTableReader ConstantTable;

			internal CustomAttributeTableReader CustomAttributeTable;

			internal FieldMarshalTableReader FieldMarshalTable;

			internal DeclSecurityTableReader DeclSecurityTable;

			internal ClassLayoutTableReader ClassLayoutTable;

			internal FieldLayoutTableReader FieldLayoutTable;

			internal StandAloneSigTableReader StandAloneSigTable;

			internal EventMapTableReader EventMapTable;

			internal EventPtrTableReader EventPtrTable;

			internal EventTableReader EventTable;

			internal PropertyMapTableReader PropertyMapTable;

			internal PropertyPtrTableReader PropertyPtrTable;

			internal PropertyTableReader PropertyTable;

			internal MethodSemanticsTableReader MethodSemanticsTable;

			internal MethodImplTableReader MethodImplTable;

			internal ModuleRefTableReader ModuleRefTable;

			internal TypeSpecTableReader TypeSpecTable;

			internal ImplMapTableReader ImplMapTable;

			internal FieldRVATableReader FieldRvaTable;

			internal EnCLogTableReader EncLogTable;

			internal EnCMapTableReader EncMapTable;

			internal AssemblyTableReader AssemblyTable;

			internal AssemblyProcessorTableReader AssemblyProcessorTable;

			internal AssemblyOSTableReader AssemblyOSTable;

			internal AssemblyRefTableReader AssemblyRefTable;

			internal AssemblyRefProcessorTableReader AssemblyRefProcessorTable;

			internal AssemblyRefOSTableReader AssemblyRefOSTable;

			internal FileTableReader FileTable;

			internal ExportedTypeTableReader ExportedTypeTable;

			internal ManifestResourceTableReader ManifestResourceTable;

			internal NestedClassTableReader NestedClassTable;

			internal GenericParamTableReader GenericParamTable;

			internal MethodSpecTableReader MethodSpecTable;

			internal GenericParamConstraintTableReader GenericParamConstraintTable;

			internal System.Reflection.Metadata.Ecma335.DocumentTableReader DocumentTable;

			internal System.Reflection.Metadata.Ecma335.MethodDebugInformationTableReader MethodDebugInformationTable;

			internal LocalScopeTableReader LocalScopeTable;

			internal LocalVariableTableReader LocalVariableTable;

			internal LocalConstantTableReader LocalConstantTable;

			internal ImportScopeTableReader ImportScopeTable;

			internal StateMachineMethodTableReader StateMachineMethodTable;

			internal CustomDebugInformationTableReader CustomDebugInformationTable;

			private const int SmallIndexSize = 2;

			private const int LargeIndexSize = 4;

			internal const string ClrPrefix = "<CLR>";

			internal static readonly byte[] WinRTPrefix = ((ReadOnlySpan<byte>)new byte[7] { 60, 87, 105, 110, 82, 84, 62 }).ToArray();

			private static string[] s_projectedTypeNames;

			private static ProjectionInfo[] s_projectionInfos;

			internal bool UseFieldPtrTable => FieldPtrTable.NumberOfRows > 0;

			internal bool UseMethodPtrTable => MethodPtrTable.NumberOfRows > 0;

			internal bool UseParamPtrTable => ParamPtrTable.NumberOfRows > 0;

			internal bool UseEventPtrTable => EventPtrTable.NumberOfRows > 0;

			internal bool UsePropertyPtrTable => PropertyPtrTable.NumberOfRows > 0;

			/// <summary>
			/// Pointer to the underlying data.
			/// </summary>
			public unsafe byte* MetadataPointer => Block.Pointer;

			/// <summary>
			/// Length of the underlying data.
			/// </summary>
			public int MetadataLength => Block.Length;

			/// <summary>
			/// Options passed to the constructor.
			/// </summary>
			public MetadataReaderOptions Options => _options;

			/// <summary>
			/// Version string read from metadata header.
			/// </summary>
			public string MetadataVersion => _versionString;

			/// <summary>
			/// Information decoded from #Pdb stream, or null if the stream is not present.
			/// </summary>
			public DebugMetadataHeader? DebugMetadataHeader => _debugMetadataHeader;

			/// <summary>
			/// The kind of the metadata (plain ECMA335, WinMD, etc.).
			/// </summary>
			public MetadataKind MetadataKind => _metadataKind;

			/// <summary>
			/// Comparer used to compare strings stored in metadata.
			/// </summary>
			public MetadataStringComparer StringComparer => new MetadataStringComparer(this);

			/// <summary>
			/// The decoder used by the reader to produce <see cref="T:System.String" /> instances from UTF8 encoded byte sequences.
			/// </summary>
			public MetadataStringDecoder UTF8Decoder { get; }

			/// <summary>
			/// Returns true if the metadata represent an assembly.
			/// </summary>
			public bool IsAssembly => AssemblyTable.NumberOfRows == 1;

			public AssemblyReferenceHandleCollection AssemblyReferences => new AssemblyReferenceHandleCollection(this);

			public TypeDefinitionHandleCollection TypeDefinitions => new TypeDefinitionHandleCollection(TypeDefTable.NumberOfRows);

			public TypeReferenceHandleCollection TypeReferences => new TypeReferenceHandleCollection(TypeRefTable.NumberOfRows);

			public CustomAttributeHandleCollection CustomAttributes => new CustomAttributeHandleCollection(this);

			public DeclarativeSecurityAttributeHandleCollection DeclarativeSecurityAttributes => new DeclarativeSecurityAttributeHandleCollection(this);

			public MemberReferenceHandleCollection MemberReferences => new MemberReferenceHandleCollection(MemberRefTable.NumberOfRows);

			public ManifestResourceHandleCollection ManifestResources => new ManifestResourceHandleCollection(ManifestResourceTable.NumberOfRows);

			public AssemblyFileHandleCollection AssemblyFiles => new AssemblyFileHandleCollection(FileTable.NumberOfRows);

			public ExportedTypeHandleCollection ExportedTypes => new ExportedTypeHandleCollection(ExportedTypeTable.NumberOfRows);

			public MethodDefinitionHandleCollection MethodDefinitions => new MethodDefinitionHandleCollection(this);

			public FieldDefinitionHandleCollection FieldDefinitions => new FieldDefinitionHandleCollection(this);

			public EventDefinitionHandleCollection EventDefinitions => new EventDefinitionHandleCollection(this);

			public PropertyDefinitionHandleCollection PropertyDefinitions => new PropertyDefinitionHandleCollection(this);

			public DocumentHandleCollection Documents => new DocumentHandleCollection(this);

			public MethodDebugInformationHandleCollection MethodDebugInformation => new MethodDebugInformationHandleCollection(this);

			public LocalScopeHandleCollection LocalScopes => new LocalScopeHandleCollection(this, 0);

			public LocalVariableHandleCollection LocalVariables => new LocalVariableHandleCollection(this, default(LocalScopeHandle));

			public LocalConstantHandleCollection LocalConstants => new LocalConstantHandleCollection(this, default(LocalScopeHandle));

			public ImportScopeCollection ImportScopes => new ImportScopeCollection(this);

			public CustomDebugInformationHandleCollection CustomDebugInformation => new CustomDebugInformationHandleCollection(this);

			internal AssemblyName GetAssemblyName(StringHandle nameHandle, Version version, StringHandle cultureHandle, BlobHandle publicKeyOrTokenHandle, AssemblyHashAlgorithm assemblyHashAlgorithm, AssemblyFlags flags)
			{
				string @string = GetString(nameHandle);
				string cultureName = ((!cultureHandle.IsNil) ? GetString(cultureHandle) : "");
				byte[] array = ((!publicKeyOrTokenHandle.IsNil) ? GetBlobBytes(publicKeyOrTokenHandle) : Array.Empty<byte>());
				AssemblyName assemblyName = new AssemblyName
				{
					Name = @string,
					Version = version,
					CultureName = cultureName,
					HashAlgorithm = (System.Configuration.Assemblies.AssemblyHashAlgorithm)assemblyHashAlgorithm,
					Flags = GetAssemblyNameFlags(flags),
					ContentType = GetContentTypeFromAssemblyFlags(flags)
				};
				if ((flags & AssemblyFlags.PublicKey) != 0)
				{
					assemblyName.SetPublicKey(array);
				}
				else
				{
					assemblyName.SetPublicKeyToken(array);
				}
				return assemblyName;
			}

			/// <summary>
			/// Gets the <see cref="T:System.Reflection.AssemblyName" /> for a given file.
			/// </summary>
			/// <param name="assemblyFile">The path for the assembly which <see cref="T:System.Reflection.AssemblyName" /> is to be returned.</param>
			/// <returns>An <see cref="T:System.Reflection.AssemblyName" /> that represents the given <paramref name="assemblyFile" />.</returns>
			/// <exception cref="T:System.ArgumentNullException">If <paramref name="assemblyFile" /> is null.</exception>
			/// <exception cref="T:System.ArgumentException">If <paramref name="assemblyFile" /> is invalid.</exception>
			/// <exception cref="T:System.IO.FileNotFoundException">If <paramref name="assemblyFile" /> is not found.</exception>
			/// <exception cref="T:System.BadImageFormatException">If <paramref name="assemblyFile" /> is not a valid assembly.</exception>
			public unsafe static AssemblyName GetAssemblyName(string assemblyFile)
			{
				if (assemblyFile == null)
				{
					System.Reflection.Throw.ArgumentNull("assemblyFile");
				}
				FileStream fileStream = null;
				MemoryMappedFile memoryMappedFile = null;
				MemoryMappedViewAccessor memoryMappedViewAccessor = null;
				PEReader pEReader = null;
				try
				{
					try
					{
						fileStream = new FileStream(assemblyFile, FileMode.Open, FileAccess.Read, FileShare.Read, 1, useAsync: false);
						if (fileStream.Length == 0L)
						{
							throw new BadImageFormatException(MDCFR.Properties.Resources.PEImageDoesNotHaveMetadata, assemblyFile);
						}
						memoryMappedFile = MemoryMappedFile.CreateFromFile(fileStream, null, fileStream.Length, MemoryMappedFileAccess.Read, HandleInheritability.None, leaveOpen: true);
						memoryMappedViewAccessor = memoryMappedFile.CreateViewAccessor(0L, 0L, MemoryMappedFileAccess.Read);
						SafeMemoryMappedViewHandle safeMemoryMappedViewHandle = memoryMappedViewAccessor.SafeMemoryMappedViewHandle;
						pEReader = new PEReader((byte*)(void*)safeMemoryMappedViewHandle.DangerousGetHandle(), (int)safeMemoryMappedViewHandle.ByteLength);
						MetadataReader metadataReader = pEReader.GetMetadataReader(MetadataReaderOptions.None);
						return metadataReader.GetAssemblyDefinition().GetAssemblyName();
					}
					finally
					{
						pEReader?.Dispose();
						memoryMappedViewAccessor?.Dispose();
						memoryMappedFile?.Dispose();
						fileStream?.Dispose();
					}
				}
				catch (InvalidOperationException ex)
				{
					throw new BadImageFormatException(ex.Message);
				}
			}

			private static AssemblyNameFlags GetAssemblyNameFlags(AssemblyFlags flags)
			{
				AssemblyNameFlags assemblyNameFlags = AssemblyNameFlags.None;
				if ((flags & AssemblyFlags.PublicKey) != 0)
				{
					assemblyNameFlags |= AssemblyNameFlags.PublicKey;
				}
				if ((flags & AssemblyFlags.Retargetable) != 0)
				{
					assemblyNameFlags |= AssemblyNameFlags.Retargetable;
				}
				if ((flags & AssemblyFlags.EnableJitCompileTracking) != 0)
				{
					assemblyNameFlags |= AssemblyNameFlags.EnableJITcompileTracking;
				}
				if ((flags & AssemblyFlags.DisableJitCompileOptimizer) != 0)
				{
					assemblyNameFlags |= AssemblyNameFlags.EnableJITcompileOptimizer;
				}
				return assemblyNameFlags;
			}

			private static AssemblyContentType GetContentTypeFromAssemblyFlags(AssemblyFlags flags)
			{
				return (AssemblyContentType)((int)(flags & AssemblyFlags.ContentTypeMask) >> 9);
			}

			/// <summary>
			/// Creates a metadata reader from the metadata stored at the given memory location.
			/// </summary>
			/// <remarks>
			/// The memory is owned by the caller and it must be kept memory alive and unmodified throughout the lifetime of the <see cref="T:System.Reflection.Metadata.MetadataReader" />.
			/// </remarks>
			public unsafe MetadataReader(byte* metadata, int length)
				: this(metadata, length, MetadataReaderOptions.Default, null, null)
			{
			}

			/// <summary>
			/// Creates a metadata reader from the metadata stored at the given memory location.
			/// </summary>
			/// <remarks>
			/// The memory is owned by the caller and it must be kept memory alive and unmodified throughout the lifetime of the <see cref="T:System.Reflection.Metadata.MetadataReader" />.
			/// Use <see cref="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)" /> to obtain
			/// metadata from a PE image.
			/// </remarks>
			public unsafe MetadataReader(byte* metadata, int length, MetadataReaderOptions options)
				: this(metadata, length, options, null, null)
			{
			}

			/// <summary>
			/// Creates a metadata reader from the metadata stored at the given memory location.
			/// </summary>
			/// <remarks>
			/// The memory is owned by the caller and it must be kept memory alive and unmodified throughout the lifetime of the <see cref="T:System.Reflection.Metadata.MetadataReader" />.
			/// Use <see cref="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)" /> to obtain
			/// metadata from a PE image.
			/// </remarks>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> is not positive.</exception>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="metadata" /> is null.</exception>
			/// <exception cref="T:System.ArgumentException">The encoding of <paramref name="utf8Decoder" /> is not <see cref="T:System.Text.UTF8Encoding" />.</exception>
			/// <exception cref="T:System.PlatformNotSupportedException">The current platform is big-endian.</exception>
			/// <exception cref="T:System.BadImageFormatException">Bad metadata header.</exception>
			public unsafe MetadataReader(byte* metadata, int length, MetadataReaderOptions options, MetadataStringDecoder? utf8Decoder)
				: this(metadata, length, options, utf8Decoder, null)
			{
			}

			internal unsafe MetadataReader(byte* metadata, int length, MetadataReaderOptions options, MetadataStringDecoder? utf8Decoder, object? memoryOwner)
			{
				if (length < 0)
				{
					System.Reflection.Throw.ArgumentOutOfRange("length");
				}
				if (metadata == null)
				{
					System.Reflection.Throw.ArgumentNull("metadata");
				}
				if (utf8Decoder == null)
				{
					utf8Decoder = MetadataStringDecoder.DefaultUTF8;
				}
				if (!(utf8Decoder.Encoding is UTF8Encoding))
				{
					System.Reflection.Throw.InvalidArgument(MDCFR.Properties.Resources.MetadataStringDecoderEncodingMustBeUtf8, "utf8Decoder");
				}
				Block = new System.Reflection.Internal.MemoryBlock(metadata, length);
				_memoryOwnerObj = memoryOwner;
				_options = options;
				UTF8Decoder = utf8Decoder;
				BlobReader memReader = new BlobReader(Block);
				ReadMetadataHeader(ref memReader, out _versionString);
				_metadataKind = GetMetadataKind(_versionString);
				System.Reflection.Metadata.Ecma335.StreamHeader[] streamHeaders = ReadStreamHeaders(ref memReader);
				InitializeStreamReaders(in Block, streamHeaders, out _metadataStreamKind, out var metadataTableStream, out var standalonePdbStream);
				int[] externalTableRowCounts;
				if (standalonePdbStream.Length > 0)
				{
					int pdbStreamOffset = (int)(standalonePdbStream.Pointer - metadata);
					ReadStandalonePortablePdbStream(standalonePdbStream, pdbStreamOffset, out _debugMetadataHeader, out externalTableRowCounts);
				}
				else
				{
					externalTableRowCounts = null;
				}
				BlobReader reader = new BlobReader(metadataTableStream);
				ReadMetadataTableHeader(ref reader, out var heapSizes, out var metadataTableRowCounts, out _sortedTables);
				InitializeTableReaders(reader.GetMemoryBlockAt(0, reader.RemainingBytes), heapSizes, metadataTableRowCounts, externalTableRowCounts);
				if (standalonePdbStream.Length == 0 && ModuleTable.NumberOfRows < 1)
				{
					throw new BadImageFormatException(System.SR.Format(MDCFR.Properties.Resources.ModuleTableInvalidNumberOfRows, ModuleTable.NumberOfRows));
				}
				NamespaceCache = new NamespaceCache(this);
				if (_metadataKind != 0)
				{
					WinMDMscorlibRef = FindMscorlibAssemblyRefNoProjection();
				}
			}

			/// <summary>
			/// Looks like this function reads beginning of the header described in
			/// ECMA-335 24.2.1 Metadata root
			/// </summary>
			private void ReadMetadataHeader(ref BlobReader memReader, out string versionString)
			{
				if (memReader.RemainingBytes < 16)
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.MetadataHeaderTooSmall);
				}
				uint num = memReader.ReadUInt32();
				if (num != 1112167234)
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.MetadataSignature);
				}
				memReader.ReadUInt16();
				memReader.ReadUInt16();
				memReader.ReadUInt32();
				int num2 = memReader.ReadInt32();
				if (memReader.RemainingBytes < num2)
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.NotEnoughSpaceForVersionString);
				}
				versionString = memReader.GetMemoryBlockAt(0, num2).PeekUtf8NullTerminated(0, null, UTF8Decoder, out var _);
				memReader.Offset += num2;
			}

			private MetadataKind GetMetadataKind(string versionString)
			{
				if ((_options & MetadataReaderOptions.Default) == 0)
				{
					return MetadataKind.Ecma335;
				}
				if (!versionString.Contains("WindowsRuntime"))
				{
					return MetadataKind.Ecma335;
				}
				if (versionString.Contains("CLR"))
				{
					return MetadataKind.ManagedWindowsMetadata;
				}
				return MetadataKind.WindowsMetadata;
			}

			/// <summary>
			/// Reads stream headers described in ECMA-335 24.2.2 Stream header
			/// </summary>
			private static System.Reflection.Metadata.Ecma335.StreamHeader[] ReadStreamHeaders(ref BlobReader memReader)
			{
				memReader.ReadUInt16();
				int num = memReader.ReadInt16();
				System.Reflection.Metadata.Ecma335.StreamHeader[] array = new System.Reflection.Metadata.Ecma335.StreamHeader[num];
				for (int i = 0; i < array.Length; i++)
				{
					if (memReader.RemainingBytes < 8)
					{
						throw new BadImageFormatException(MDCFR.Properties.Resources.StreamHeaderTooSmall);
					}
					array[i].Offset = memReader.ReadUInt32();
					array[i].Size = memReader.ReadInt32();
					array[i].Name = memReader.ReadUtf8NullTerminated();
					if (!memReader.TryAlign(4) || memReader.RemainingBytes == 0)
					{
						throw new BadImageFormatException(MDCFR.Properties.Resources.NotEnoughSpaceForStreamHeaderName);
					}
				}
				return array;
			}

			private void InitializeStreamReaders(in System.Reflection.Internal.MemoryBlock metadataRoot, System.Reflection.Metadata.Ecma335.StreamHeader[] streamHeaders, out System.Reflection.Metadata.Ecma335.MetadataStreamKind metadataStreamKind, out System.Reflection.Internal.MemoryBlock metadataTableStream, out System.Reflection.Internal.MemoryBlock standalonePdbStream)
			{
				metadataTableStream = default(System.Reflection.Internal.MemoryBlock);
				standalonePdbStream = default(System.Reflection.Internal.MemoryBlock);
				metadataStreamKind = System.Reflection.Metadata.Ecma335.MetadataStreamKind.Illegal;
				for (int i = 0; i < streamHeaders.Length; i++)
				{
					System.Reflection.Metadata.Ecma335.StreamHeader streamHeader = streamHeaders[i];
					switch (streamHeader.Name)
					{
						case "#Strings":
							if (metadataRoot.Length < streamHeader.Offset + streamHeader.Size)
							{
								throw new BadImageFormatException(MDCFR.Properties.Resources.NotEnoughSpaceForStringStream);
							}
							StringHeap = new StringHeap(metadataRoot.GetMemoryBlockAt((int)streamHeader.Offset, streamHeader.Size), _metadataKind);
							break;
						case "#Blob":
							if (metadataRoot.Length < streamHeader.Offset + streamHeader.Size)
							{
								throw new BadImageFormatException(MDCFR.Properties.Resources.NotEnoughSpaceForBlobStream);
							}
							BlobHeap = new System.Reflection.Metadata.Ecma335.BlobHeap(metadataRoot.GetMemoryBlockAt((int)streamHeader.Offset, streamHeader.Size), _metadataKind);
							break;
						case "#GUID":
							if (metadataRoot.Length < streamHeader.Offset + streamHeader.Size)
							{
								throw new BadImageFormatException(MDCFR.Properties.Resources.NotEnoughSpaceForGUIDStream);
							}
							GuidHeap = new GuidHeap(metadataRoot.GetMemoryBlockAt((int)streamHeader.Offset, streamHeader.Size));
							break;
						case "#US":
							if (metadataRoot.Length < streamHeader.Offset + streamHeader.Size)
							{
								throw new BadImageFormatException(MDCFR.Properties.Resources.NotEnoughSpaceForBlobStream);
							}
							UserStringHeap = new UserStringHeap(metadataRoot.GetMemoryBlockAt((int)streamHeader.Offset, streamHeader.Size));
							break;
						case "#~":
							if (metadataRoot.Length < streamHeader.Offset + streamHeader.Size)
							{
								throw new BadImageFormatException(MDCFR.Properties.Resources.NotEnoughSpaceForMetadataStream);
							}
							metadataStreamKind = System.Reflection.Metadata.Ecma335.MetadataStreamKind.Compressed;
							metadataTableStream = metadataRoot.GetMemoryBlockAt((int)streamHeader.Offset, streamHeader.Size);
							break;
						case "#-":
							if (metadataRoot.Length < streamHeader.Offset + streamHeader.Size)
							{
								throw new BadImageFormatException(MDCFR.Properties.Resources.NotEnoughSpaceForMetadataStream);
							}
							metadataStreamKind = System.Reflection.Metadata.Ecma335.MetadataStreamKind.Uncompressed;
							metadataTableStream = metadataRoot.GetMemoryBlockAt((int)streamHeader.Offset, streamHeader.Size);
							break;
						case "#JTD":
							if (metadataRoot.Length < streamHeader.Offset + streamHeader.Size)
							{
								throw new BadImageFormatException(MDCFR.Properties.Resources.NotEnoughSpaceForMetadataStream);
							}
							IsMinimalDelta = true;
							break;
						case "#Pdb":
							if (metadataRoot.Length < streamHeader.Offset + streamHeader.Size)
							{
								throw new BadImageFormatException(MDCFR.Properties.Resources.NotEnoughSpaceForMetadataStream);
							}
							standalonePdbStream = metadataRoot.GetMemoryBlockAt((int)streamHeader.Offset, streamHeader.Size);
							break;
					}
				}
				if (IsMinimalDelta && metadataStreamKind != System.Reflection.Metadata.Ecma335.MetadataStreamKind.Uncompressed)
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.InvalidMetadataStreamFormat);
				}
			}

			private void ReadMetadataTableHeader(ref BlobReader reader, out System.Reflection.Metadata.Ecma335.HeapSizes heapSizes, out int[] metadataTableRowCounts, out System.Reflection.Metadata.Ecma335.TableMask sortedTables)
			{
				if (reader.RemainingBytes < 24)
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.MetadataTableHeaderTooSmall);
				}
				reader.ReadUInt32();
				reader.ReadByte();
				reader.ReadByte();
				heapSizes = (System.Reflection.Metadata.Ecma335.HeapSizes)reader.ReadByte();
				reader.ReadByte();
				ulong num = reader.ReadUInt64();
				sortedTables = (System.Reflection.Metadata.Ecma335.TableMask)reader.ReadUInt64();
				ulong num2 = 71811071505072127uL;
				if ((num & ~num2) != 0L)
				{
					throw new BadImageFormatException(System.SR.Format(MDCFR.Properties.Resources.UnknownTables, num));
				}
				if (_metadataStreamKind == System.Reflection.Metadata.Ecma335.MetadataStreamKind.Compressed && (num & 0x804800A8u) != 0L)
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.IllegalTablesInCompressedMetadataStream);
				}
				metadataTableRowCounts = ReadMetadataTableRowCounts(ref reader, num);
				if ((heapSizes & System.Reflection.Metadata.Ecma335.HeapSizes.ExtraData) == System.Reflection.Metadata.Ecma335.HeapSizes.ExtraData)
				{
					reader.ReadUInt32();
				}
			}

			private static int[] ReadMetadataTableRowCounts(ref BlobReader memReader, ulong presentTableMask)
			{
				ulong num = 1uL;
				int[] array = new int[MetadataTokens.TableCount];
				for (int i = 0; i < array.Length; i++)
				{
					if ((presentTableMask & num) != 0L)
					{
						if (memReader.RemainingBytes < 4)
						{
							throw new BadImageFormatException(MDCFR.Properties.Resources.TableRowCountSpaceTooSmall);
						}
						uint num2 = memReader.ReadUInt32();
						if (num2 > 16777215)
						{
							throw new BadImageFormatException(System.SR.Format(MDCFR.Properties.Resources.InvalidRowCount, num2));
						}
						array[i] = (int)num2;
					}
					num <<= 1;
				}
				return array;
			}

			internal static void ReadStandalonePortablePdbStream(System.Reflection.Internal.MemoryBlock pdbStreamBlock, int pdbStreamOffset, out DebugMetadataHeader debugMetadataHeader, out int[] externalTableRowCounts)
			{
				BlobReader memReader = new BlobReader(pdbStreamBlock);
				byte[] array = memReader.ReadBytes(20);
				uint num = memReader.ReadUInt32();
				int num2 = (int)(num & 0xFFFFFF);
				if (num != 0 && ((num & 0x7F000000) != 100663296 || num2 == 0))
				{
					throw new BadImageFormatException(System.SR.Format(MDCFR.Properties.Resources.InvalidEntryPointToken, num));
				}
				ulong num3 = memReader.ReadUInt64();
				if ((num3 & 0xFFFFE036C04800A8uL) != 0L)
				{
					throw new BadImageFormatException(System.SR.Format(MDCFR.Properties.Resources.UnknownTables, num3));
				}
				externalTableRowCounts = ReadMetadataTableRowCounts(ref memReader, num3);
				debugMetadataHeader = new DebugMetadataHeader(ImmutableByteArrayInterop.DangerousCreateFromUnderlyingArray(ref array), MethodDefinitionHandle.FromRowId(num2), pdbStreamOffset);
			}

			private int GetReferenceSize(int[] rowCounts, TableIndex index)
			{
				if ((long)rowCounts[(uint)index] >= 65536L || IsMinimalDelta)
				{
					return 4;
				}
				return 2;
			}

			private void InitializeTableReaders(System.Reflection.Internal.MemoryBlock metadataTablesMemoryBlock, System.Reflection.Metadata.Ecma335.HeapSizes heapSizes, int[] rowCounts, int[] externalRowCountsOpt)
			{
				TableRowCounts = rowCounts;
				int fieldRefSize = ((GetReferenceSize(rowCounts, TableIndex.FieldPtr) > 2) ? 4 : GetReferenceSize(rowCounts, TableIndex.Field));
				int methodRefSize = ((GetReferenceSize(rowCounts, TableIndex.MethodPtr) > 2) ? 4 : GetReferenceSize(rowCounts, TableIndex.MethodDef));
				int paramRefSize = ((GetReferenceSize(rowCounts, TableIndex.ParamPtr) > 2) ? 4 : GetReferenceSize(rowCounts, TableIndex.Param));
				int eventRefSize = ((GetReferenceSize(rowCounts, TableIndex.EventPtr) > 2) ? 4 : GetReferenceSize(rowCounts, TableIndex.Event));
				int propertyRefSize = ((GetReferenceSize(rowCounts, TableIndex.PropertyPtr) > 2) ? 4 : GetReferenceSize(rowCounts, TableIndex.Property));
				int typeDefOrRefRefSize = ComputeCodedTokenSize(16384, rowCounts, System.Reflection.Metadata.Ecma335.TableMask.TypeRef | System.Reflection.Metadata.Ecma335.TableMask.TypeDef | System.Reflection.Metadata.Ecma335.TableMask.TypeSpec);
				int hasConstantRefSize = ComputeCodedTokenSize(16384, rowCounts, System.Reflection.Metadata.Ecma335.TableMask.Field | System.Reflection.Metadata.Ecma335.TableMask.Param | System.Reflection.Metadata.Ecma335.TableMask.Property);
				int hasCustomAttributeRefSize = ComputeCodedTokenSize(2048, rowCounts, System.Reflection.Metadata.Ecma335.TableMask.Module | System.Reflection.Metadata.Ecma335.TableMask.TypeRef | System.Reflection.Metadata.Ecma335.TableMask.TypeDef | System.Reflection.Metadata.Ecma335.TableMask.Field | System.Reflection.Metadata.Ecma335.TableMask.MethodDef | System.Reflection.Metadata.Ecma335.TableMask.Param | System.Reflection.Metadata.Ecma335.TableMask.InterfaceImpl | System.Reflection.Metadata.Ecma335.TableMask.MemberRef | System.Reflection.Metadata.Ecma335.TableMask.DeclSecurity | System.Reflection.Metadata.Ecma335.TableMask.StandAloneSig | System.Reflection.Metadata.Ecma335.TableMask.Event | System.Reflection.Metadata.Ecma335.TableMask.Property | System.Reflection.Metadata.Ecma335.TableMask.ModuleRef | System.Reflection.Metadata.Ecma335.TableMask.TypeSpec | System.Reflection.Metadata.Ecma335.TableMask.Assembly | System.Reflection.Metadata.Ecma335.TableMask.AssemblyRef | System.Reflection.Metadata.Ecma335.TableMask.File | System.Reflection.Metadata.Ecma335.TableMask.ExportedType | System.Reflection.Metadata.Ecma335.TableMask.ManifestResource | System.Reflection.Metadata.Ecma335.TableMask.GenericParam | System.Reflection.Metadata.Ecma335.TableMask.MethodSpec | System.Reflection.Metadata.Ecma335.TableMask.GenericParamConstraint);
				int hasFieldMarshalRefSize = ComputeCodedTokenSize(32768, rowCounts, System.Reflection.Metadata.Ecma335.TableMask.Field | System.Reflection.Metadata.Ecma335.TableMask.Param);
				int hasDeclSecurityRefSize = ComputeCodedTokenSize(16384, rowCounts, System.Reflection.Metadata.Ecma335.TableMask.TypeDef | System.Reflection.Metadata.Ecma335.TableMask.MethodDef | System.Reflection.Metadata.Ecma335.TableMask.Assembly);
				int memberRefParentRefSize = ComputeCodedTokenSize(8192, rowCounts, System.Reflection.Metadata.Ecma335.TableMask.TypeRef | System.Reflection.Metadata.Ecma335.TableMask.TypeDef | System.Reflection.Metadata.Ecma335.TableMask.MethodDef | System.Reflection.Metadata.Ecma335.TableMask.ModuleRef | System.Reflection.Metadata.Ecma335.TableMask.TypeSpec);
				int hasSemanticRefSize = ComputeCodedTokenSize(32768, rowCounts, System.Reflection.Metadata.Ecma335.TableMask.Event | System.Reflection.Metadata.Ecma335.TableMask.Property);
				int methodDefOrRefRefSize = ComputeCodedTokenSize(32768, rowCounts, System.Reflection.Metadata.Ecma335.TableMask.MethodDef | System.Reflection.Metadata.Ecma335.TableMask.MemberRef);
				int memberForwardedRefSize = ComputeCodedTokenSize(32768, rowCounts, System.Reflection.Metadata.Ecma335.TableMask.Field | System.Reflection.Metadata.Ecma335.TableMask.MethodDef);
				int implementationRefSize = ComputeCodedTokenSize(16384, rowCounts, System.Reflection.Metadata.Ecma335.TableMask.AssemblyRef | System.Reflection.Metadata.Ecma335.TableMask.File | System.Reflection.Metadata.Ecma335.TableMask.ExportedType);
				int customAttributeTypeRefSize = ComputeCodedTokenSize(8192, rowCounts, System.Reflection.Metadata.Ecma335.TableMask.MethodDef | System.Reflection.Metadata.Ecma335.TableMask.MemberRef);
				int resolutionScopeRefSize = ComputeCodedTokenSize(16384, rowCounts, System.Reflection.Metadata.Ecma335.TableMask.Module | System.Reflection.Metadata.Ecma335.TableMask.TypeRef | System.Reflection.Metadata.Ecma335.TableMask.ModuleRef | System.Reflection.Metadata.Ecma335.TableMask.AssemblyRef);
				int typeOrMethodDefRefSize = ComputeCodedTokenSize(32768, rowCounts, System.Reflection.Metadata.Ecma335.TableMask.TypeDef | System.Reflection.Metadata.Ecma335.TableMask.MethodDef);
				int stringHeapRefSize = (((heapSizes & System.Reflection.Metadata.Ecma335.HeapSizes.StringHeapLarge) == System.Reflection.Metadata.Ecma335.HeapSizes.StringHeapLarge) ? 4 : 2);
				int guidHeapRefSize = (((heapSizes & System.Reflection.Metadata.Ecma335.HeapSizes.GuidHeapLarge) == System.Reflection.Metadata.Ecma335.HeapSizes.GuidHeapLarge) ? 4 : 2);
				int blobHeapRefSize = (((heapSizes & System.Reflection.Metadata.Ecma335.HeapSizes.BlobHeapLarge) == System.Reflection.Metadata.Ecma335.HeapSizes.BlobHeapLarge) ? 4 : 2);
				int num = 0;
				ModuleTable = new ModuleTableReader(rowCounts[0], stringHeapRefSize, guidHeapRefSize, metadataTablesMemoryBlock, num);
				num += ModuleTable.Block.Length;
				TypeRefTable = new TypeRefTableReader(rowCounts[1], resolutionScopeRefSize, stringHeapRefSize, metadataTablesMemoryBlock, num);
				num += TypeRefTable.Block.Length;
				TypeDefTable = new TypeDefTableReader(rowCounts[2], fieldRefSize, methodRefSize, typeDefOrRefRefSize, stringHeapRefSize, metadataTablesMemoryBlock, num);
				num += TypeDefTable.Block.Length;
				FieldPtrTable = new FieldPtrTableReader(rowCounts[3], GetReferenceSize(rowCounts, TableIndex.Field), metadataTablesMemoryBlock, num);
				num += FieldPtrTable.Block.Length;
				FieldTable = new FieldTableReader(rowCounts[4], stringHeapRefSize, blobHeapRefSize, metadataTablesMemoryBlock, num);
				num += FieldTable.Block.Length;
				MethodPtrTable = new MethodPtrTableReader(rowCounts[5], GetReferenceSize(rowCounts, TableIndex.MethodDef), metadataTablesMemoryBlock, num);
				num += MethodPtrTable.Block.Length;
				MethodDefTable = new MethodTableReader(rowCounts[6], paramRefSize, stringHeapRefSize, blobHeapRefSize, metadataTablesMemoryBlock, num);
				num += MethodDefTable.Block.Length;
				ParamPtrTable = new ParamPtrTableReader(rowCounts[7], GetReferenceSize(rowCounts, TableIndex.Param), metadataTablesMemoryBlock, num);
				num += ParamPtrTable.Block.Length;
				ParamTable = new ParamTableReader(rowCounts[8], stringHeapRefSize, metadataTablesMemoryBlock, num);
				num += ParamTable.Block.Length;
				InterfaceImplTable = new InterfaceImplTableReader(rowCounts[9], IsDeclaredSorted(System.Reflection.Metadata.Ecma335.TableMask.InterfaceImpl), GetReferenceSize(rowCounts, TableIndex.TypeDef), typeDefOrRefRefSize, metadataTablesMemoryBlock, num);
				num += InterfaceImplTable.Block.Length;
				MemberRefTable = new MemberRefTableReader(rowCounts[10], memberRefParentRefSize, stringHeapRefSize, blobHeapRefSize, metadataTablesMemoryBlock, num);
				num += MemberRefTable.Block.Length;
				ConstantTable = new ConstantTableReader(rowCounts[11], IsDeclaredSorted(System.Reflection.Metadata.Ecma335.TableMask.Constant), hasConstantRefSize, blobHeapRefSize, metadataTablesMemoryBlock, num);
				num += ConstantTable.Block.Length;
				CustomAttributeTable = new CustomAttributeTableReader(rowCounts[12], IsDeclaredSorted(System.Reflection.Metadata.Ecma335.TableMask.CustomAttribute), hasCustomAttributeRefSize, customAttributeTypeRefSize, blobHeapRefSize, metadataTablesMemoryBlock, num);
				num += CustomAttributeTable.Block.Length;
				FieldMarshalTable = new FieldMarshalTableReader(rowCounts[13], IsDeclaredSorted(System.Reflection.Metadata.Ecma335.TableMask.FieldMarshal), hasFieldMarshalRefSize, blobHeapRefSize, metadataTablesMemoryBlock, num);
				num += FieldMarshalTable.Block.Length;
				DeclSecurityTable = new DeclSecurityTableReader(rowCounts[14], IsDeclaredSorted(System.Reflection.Metadata.Ecma335.TableMask.DeclSecurity), hasDeclSecurityRefSize, blobHeapRefSize, metadataTablesMemoryBlock, num);
				num += DeclSecurityTable.Block.Length;
				ClassLayoutTable = new ClassLayoutTableReader(rowCounts[15], IsDeclaredSorted(System.Reflection.Metadata.Ecma335.TableMask.ClassLayout), GetReferenceSize(rowCounts, TableIndex.TypeDef), metadataTablesMemoryBlock, num);
				num += ClassLayoutTable.Block.Length;
				FieldLayoutTable = new FieldLayoutTableReader(rowCounts[16], IsDeclaredSorted(System.Reflection.Metadata.Ecma335.TableMask.FieldLayout), GetReferenceSize(rowCounts, TableIndex.Field), metadataTablesMemoryBlock, num);
				num += FieldLayoutTable.Block.Length;
				StandAloneSigTable = new StandAloneSigTableReader(rowCounts[17], blobHeapRefSize, metadataTablesMemoryBlock, num);
				num += StandAloneSigTable.Block.Length;
				EventMapTable = new EventMapTableReader(rowCounts[18], GetReferenceSize(rowCounts, TableIndex.TypeDef), eventRefSize, metadataTablesMemoryBlock, num);
				num += EventMapTable.Block.Length;
				EventPtrTable = new EventPtrTableReader(rowCounts[19], GetReferenceSize(rowCounts, TableIndex.Event), metadataTablesMemoryBlock, num);
				num += EventPtrTable.Block.Length;
				EventTable = new EventTableReader(rowCounts[20], typeDefOrRefRefSize, stringHeapRefSize, metadataTablesMemoryBlock, num);
				num += EventTable.Block.Length;
				PropertyMapTable = new PropertyMapTableReader(rowCounts[21], GetReferenceSize(rowCounts, TableIndex.TypeDef), propertyRefSize, metadataTablesMemoryBlock, num);
				num += PropertyMapTable.Block.Length;
				PropertyPtrTable = new PropertyPtrTableReader(rowCounts[22], GetReferenceSize(rowCounts, TableIndex.Property), metadataTablesMemoryBlock, num);
				num += PropertyPtrTable.Block.Length;
				PropertyTable = new PropertyTableReader(rowCounts[23], stringHeapRefSize, blobHeapRefSize, metadataTablesMemoryBlock, num);
				num += PropertyTable.Block.Length;
				MethodSemanticsTable = new MethodSemanticsTableReader(rowCounts[24], IsDeclaredSorted(System.Reflection.Metadata.Ecma335.TableMask.MethodSemantics), GetReferenceSize(rowCounts, TableIndex.MethodDef), hasSemanticRefSize, metadataTablesMemoryBlock, num);
				num += MethodSemanticsTable.Block.Length;
				MethodImplTable = new MethodImplTableReader(rowCounts[25], IsDeclaredSorted(System.Reflection.Metadata.Ecma335.TableMask.MethodImpl), GetReferenceSize(rowCounts, TableIndex.TypeDef), methodDefOrRefRefSize, metadataTablesMemoryBlock, num);
				num += MethodImplTable.Block.Length;
				ModuleRefTable = new ModuleRefTableReader(rowCounts[26], stringHeapRefSize, metadataTablesMemoryBlock, num);
				num += ModuleRefTable.Block.Length;
				TypeSpecTable = new TypeSpecTableReader(rowCounts[27], blobHeapRefSize, metadataTablesMemoryBlock, num);
				num += TypeSpecTable.Block.Length;
				ImplMapTable = new ImplMapTableReader(rowCounts[28], IsDeclaredSorted(System.Reflection.Metadata.Ecma335.TableMask.ImplMap), GetReferenceSize(rowCounts, TableIndex.ModuleRef), memberForwardedRefSize, stringHeapRefSize, metadataTablesMemoryBlock, num);
				num += ImplMapTable.Block.Length;
				FieldRvaTable = new FieldRVATableReader(rowCounts[29], IsDeclaredSorted(System.Reflection.Metadata.Ecma335.TableMask.FieldRva), GetReferenceSize(rowCounts, TableIndex.Field), metadataTablesMemoryBlock, num);
				num += FieldRvaTable.Block.Length;
				EncLogTable = new EnCLogTableReader(rowCounts[30], metadataTablesMemoryBlock, num, _metadataStreamKind);
				num += EncLogTable.Block.Length;
				EncMapTable = new EnCMapTableReader(rowCounts[31], metadataTablesMemoryBlock, num);
				num += EncMapTable.Block.Length;
				AssemblyTable = new AssemblyTableReader(rowCounts[32], stringHeapRefSize, blobHeapRefSize, metadataTablesMemoryBlock, num);
				num += AssemblyTable.Block.Length;
				AssemblyProcessorTable = new AssemblyProcessorTableReader(rowCounts[33], metadataTablesMemoryBlock, num);
				num += AssemblyProcessorTable.Block.Length;
				AssemblyOSTable = new AssemblyOSTableReader(rowCounts[34], metadataTablesMemoryBlock, num);
				num += AssemblyOSTable.Block.Length;
				AssemblyRefTable = new AssemblyRefTableReader(rowCounts[35], stringHeapRefSize, blobHeapRefSize, metadataTablesMemoryBlock, num, _metadataKind);
				num += AssemblyRefTable.Block.Length;
				AssemblyRefProcessorTable = new AssemblyRefProcessorTableReader(rowCounts[36], GetReferenceSize(rowCounts, TableIndex.AssemblyRef), metadataTablesMemoryBlock, num);
				num += AssemblyRefProcessorTable.Block.Length;
				AssemblyRefOSTable = new AssemblyRefOSTableReader(rowCounts[37], GetReferenceSize(rowCounts, TableIndex.AssemblyRef), metadataTablesMemoryBlock, num);
				num += AssemblyRefOSTable.Block.Length;
				FileTable = new FileTableReader(rowCounts[38], stringHeapRefSize, blobHeapRefSize, metadataTablesMemoryBlock, num);
				num += FileTable.Block.Length;
				ExportedTypeTable = new ExportedTypeTableReader(rowCounts[39], implementationRefSize, stringHeapRefSize, metadataTablesMemoryBlock, num);
				num += ExportedTypeTable.Block.Length;
				ManifestResourceTable = new ManifestResourceTableReader(rowCounts[40], implementationRefSize, stringHeapRefSize, metadataTablesMemoryBlock, num);
				num += ManifestResourceTable.Block.Length;
				NestedClassTable = new NestedClassTableReader(rowCounts[41], IsDeclaredSorted(System.Reflection.Metadata.Ecma335.TableMask.NestedClass), GetReferenceSize(rowCounts, TableIndex.TypeDef), metadataTablesMemoryBlock, num);
				num += NestedClassTable.Block.Length;
				GenericParamTable = new GenericParamTableReader(rowCounts[42], IsDeclaredSorted(System.Reflection.Metadata.Ecma335.TableMask.GenericParam), typeOrMethodDefRefSize, stringHeapRefSize, metadataTablesMemoryBlock, num);
				num += GenericParamTable.Block.Length;
				MethodSpecTable = new MethodSpecTableReader(rowCounts[43], methodDefOrRefRefSize, blobHeapRefSize, metadataTablesMemoryBlock, num);
				num += MethodSpecTable.Block.Length;
				GenericParamConstraintTable = new GenericParamConstraintTableReader(rowCounts[44], IsDeclaredSorted(System.Reflection.Metadata.Ecma335.TableMask.GenericParamConstraint), GetReferenceSize(rowCounts, TableIndex.GenericParam), typeDefOrRefRefSize, metadataTablesMemoryBlock, num);
				num += GenericParamConstraintTable.Block.Length;
				int[] rowCounts2 = ((externalRowCountsOpt != null) ? CombineRowCounts(rowCounts, externalRowCountsOpt, TableIndex.Document) : rowCounts);
				int referenceSize = GetReferenceSize(rowCounts2, TableIndex.MethodDef);
				int hasCustomDebugInformationRefSize = ComputeCodedTokenSize(2048, rowCounts2, System.Reflection.Metadata.Ecma335.TableMask.Module | System.Reflection.Metadata.Ecma335.TableMask.TypeRef | System.Reflection.Metadata.Ecma335.TableMask.TypeDef | System.Reflection.Metadata.Ecma335.TableMask.Field | System.Reflection.Metadata.Ecma335.TableMask.MethodDef | System.Reflection.Metadata.Ecma335.TableMask.Param | System.Reflection.Metadata.Ecma335.TableMask.InterfaceImpl | System.Reflection.Metadata.Ecma335.TableMask.MemberRef | System.Reflection.Metadata.Ecma335.TableMask.DeclSecurity | System.Reflection.Metadata.Ecma335.TableMask.StandAloneSig | System.Reflection.Metadata.Ecma335.TableMask.Event | System.Reflection.Metadata.Ecma335.TableMask.Property | System.Reflection.Metadata.Ecma335.TableMask.ModuleRef | System.Reflection.Metadata.Ecma335.TableMask.TypeSpec | System.Reflection.Metadata.Ecma335.TableMask.Assembly | System.Reflection.Metadata.Ecma335.TableMask.AssemblyRef | System.Reflection.Metadata.Ecma335.TableMask.File | System.Reflection.Metadata.Ecma335.TableMask.ExportedType | System.Reflection.Metadata.Ecma335.TableMask.ManifestResource | System.Reflection.Metadata.Ecma335.TableMask.GenericParam | System.Reflection.Metadata.Ecma335.TableMask.MethodSpec | System.Reflection.Metadata.Ecma335.TableMask.GenericParamConstraint | System.Reflection.Metadata.Ecma335.TableMask.Document | System.Reflection.Metadata.Ecma335.TableMask.LocalScope | System.Reflection.Metadata.Ecma335.TableMask.LocalVariable | System.Reflection.Metadata.Ecma335.TableMask.LocalConstant | System.Reflection.Metadata.Ecma335.TableMask.ImportScope);
				DocumentTable = new System.Reflection.Metadata.Ecma335.DocumentTableReader(rowCounts[48], guidHeapRefSize, blobHeapRefSize, metadataTablesMemoryBlock, num);
				num += DocumentTable.Block.Length;
				MethodDebugInformationTable = new System.Reflection.Metadata.Ecma335.MethodDebugInformationTableReader(rowCounts[49], GetReferenceSize(rowCounts, TableIndex.Document), blobHeapRefSize, metadataTablesMemoryBlock, num);
				num += MethodDebugInformationTable.Block.Length;
				LocalScopeTable = new LocalScopeTableReader(rowCounts[50], IsDeclaredSorted(System.Reflection.Metadata.Ecma335.TableMask.LocalScope), referenceSize, GetReferenceSize(rowCounts, TableIndex.ImportScope), GetReferenceSize(rowCounts, TableIndex.LocalVariable), GetReferenceSize(rowCounts, TableIndex.LocalConstant), metadataTablesMemoryBlock, num);
				num += LocalScopeTable.Block.Length;
				LocalVariableTable = new LocalVariableTableReader(rowCounts[51], stringHeapRefSize, metadataTablesMemoryBlock, num);
				num += LocalVariableTable.Block.Length;
				LocalConstantTable = new LocalConstantTableReader(rowCounts[52], stringHeapRefSize, blobHeapRefSize, metadataTablesMemoryBlock, num);
				num += LocalConstantTable.Block.Length;
				ImportScopeTable = new ImportScopeTableReader(rowCounts[53], GetReferenceSize(rowCounts, TableIndex.ImportScope), blobHeapRefSize, metadataTablesMemoryBlock, num);
				num += ImportScopeTable.Block.Length;
				StateMachineMethodTable = new StateMachineMethodTableReader(rowCounts[54], IsDeclaredSorted(System.Reflection.Metadata.Ecma335.TableMask.StateMachineMethod), referenceSize, metadataTablesMemoryBlock, num);
				num += StateMachineMethodTable.Block.Length;
				CustomDebugInformationTable = new CustomDebugInformationTableReader(rowCounts[55], IsDeclaredSorted(System.Reflection.Metadata.Ecma335.TableMask.CustomDebugInformation), hasCustomDebugInformationRefSize, guidHeapRefSize, blobHeapRefSize, metadataTablesMemoryBlock, num);
				num += CustomDebugInformationTable.Block.Length;
				if (num > metadataTablesMemoryBlock.Length)
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.MetadataTablesTooSmall);
				}
			}

			private static int[] CombineRowCounts(int[] local, int[] external, TableIndex firstLocalTableIndex)
			{
				int[] array = new int[local.Length];
				for (int i = 0; i < (int)firstLocalTableIndex; i++)
				{
					array[i] = external[i];
				}
				for (int j = (int)firstLocalTableIndex; j < array.Length; j++)
				{
					array[j] = local[j];
				}
				return array;
			}

			private int ComputeCodedTokenSize(int largeRowSize, int[] rowCounts, System.Reflection.Metadata.Ecma335.TableMask tablesReferenced)
			{
				if (IsMinimalDelta)
				{
					return 4;
				}
				bool flag = true;
				ulong num = (ulong)tablesReferenced;
				for (int i = 0; i < MetadataTokens.TableCount; i++)
				{
					if ((num & 1) != 0L)
					{
						flag = flag && rowCounts[i] < largeRowSize;
					}
					num >>= 1;
				}
				if (!flag)
				{
					return 4;
				}
				return 2;
			}

			private bool IsDeclaredSorted(System.Reflection.Metadata.Ecma335.TableMask index)
			{
				return (_sortedTables & index) != 0;
			}

			internal void GetFieldRange(TypeDefinitionHandle typeDef, out int firstFieldRowId, out int lastFieldRowId)
			{
				int rowId = typeDef.RowId;
				firstFieldRowId = TypeDefTable.GetFieldStart(rowId);
				if (firstFieldRowId == 0)
				{
					firstFieldRowId = 1;
					lastFieldRowId = 0;
				}
				else if (rowId == TypeDefTable.NumberOfRows)
				{
					lastFieldRowId = (UseFieldPtrTable ? FieldPtrTable.NumberOfRows : FieldTable.NumberOfRows);
				}
				else
				{
					lastFieldRowId = TypeDefTable.GetFieldStart(rowId + 1) - 1;
				}
			}

			internal void GetMethodRange(TypeDefinitionHandle typeDef, out int firstMethodRowId, out int lastMethodRowId)
			{
				int rowId = typeDef.RowId;
				firstMethodRowId = TypeDefTable.GetMethodStart(rowId);
				if (firstMethodRowId == 0)
				{
					firstMethodRowId = 1;
					lastMethodRowId = 0;
				}
				else if (rowId == TypeDefTable.NumberOfRows)
				{
					lastMethodRowId = (UseMethodPtrTable ? MethodPtrTable.NumberOfRows : MethodDefTable.NumberOfRows);
				}
				else
				{
					lastMethodRowId = TypeDefTable.GetMethodStart(rowId + 1) - 1;
				}
			}

			internal void GetEventRange(TypeDefinitionHandle typeDef, out int firstEventRowId, out int lastEventRowId)
			{
				int num = EventMapTable.FindEventMapRowIdFor(typeDef);
				if (num == 0)
				{
					firstEventRowId = 1;
					lastEventRowId = 0;
					return;
				}
				firstEventRowId = EventMapTable.GetEventListStartFor(num);
				if (num == EventMapTable.NumberOfRows)
				{
					lastEventRowId = (UseEventPtrTable ? EventPtrTable.NumberOfRows : EventTable.NumberOfRows);
				}
				else
				{
					lastEventRowId = EventMapTable.GetEventListStartFor(num + 1) - 1;
				}
			}

			internal void GetPropertyRange(TypeDefinitionHandle typeDef, out int firstPropertyRowId, out int lastPropertyRowId)
			{
				int num = PropertyMapTable.FindPropertyMapRowIdFor(typeDef);
				if (num == 0)
				{
					firstPropertyRowId = 1;
					lastPropertyRowId = 0;
					return;
				}
				firstPropertyRowId = PropertyMapTable.GetPropertyListStartFor(num);
				if (num == PropertyMapTable.NumberOfRows)
				{
					lastPropertyRowId = (UsePropertyPtrTable ? PropertyPtrTable.NumberOfRows : PropertyTable.NumberOfRows);
				}
				else
				{
					lastPropertyRowId = PropertyMapTable.GetPropertyListStartFor(num + 1) - 1;
				}
			}

			internal void GetParameterRange(MethodDefinitionHandle methodDef, out int firstParamRowId, out int lastParamRowId)
			{
				int rowId = methodDef.RowId;
				firstParamRowId = MethodDefTable.GetParamStart(rowId);
				if (firstParamRowId == 0)
				{
					firstParamRowId = 1;
					lastParamRowId = 0;
				}
				else if (rowId == MethodDefTable.NumberOfRows)
				{
					lastParamRowId = (UseParamPtrTable ? ParamPtrTable.NumberOfRows : ParamTable.NumberOfRows);
				}
				else
				{
					lastParamRowId = MethodDefTable.GetParamStart(rowId + 1) - 1;
				}
			}

			internal void GetLocalVariableRange(LocalScopeHandle scope, out int firstVariableRowId, out int lastVariableRowId)
			{
				int rowId = scope.RowId;
				firstVariableRowId = LocalScopeTable.GetVariableStart(rowId);
				if (firstVariableRowId == 0)
				{
					firstVariableRowId = 1;
					lastVariableRowId = 0;
				}
				else if (rowId == LocalScopeTable.NumberOfRows)
				{
					lastVariableRowId = LocalVariableTable.NumberOfRows;
				}
				else
				{
					lastVariableRowId = LocalScopeTable.GetVariableStart(rowId + 1) - 1;
				}
			}

			internal void GetLocalConstantRange(LocalScopeHandle scope, out int firstConstantRowId, out int lastConstantRowId)
			{
				int rowId = scope.RowId;
				firstConstantRowId = LocalScopeTable.GetConstantStart(rowId);
				if (firstConstantRowId == 0)
				{
					firstConstantRowId = 1;
					lastConstantRowId = 0;
				}
				else if (rowId == LocalScopeTable.NumberOfRows)
				{
					lastConstantRowId = LocalConstantTable.NumberOfRows;
				}
				else
				{
					lastConstantRowId = LocalScopeTable.GetConstantStart(rowId + 1) - 1;
				}
			}

			public AssemblyDefinition GetAssemblyDefinition()
			{
				if (!IsAssembly)
				{
					throw new InvalidOperationException(MDCFR.Properties.Resources.MetadataImageDoesNotRepresentAnAssembly);
				}
				return new AssemblyDefinition(this);
			}

			public string GetString(StringHandle handle)
			{
				return StringHeap.GetString(handle, UTF8Decoder);
			}

			public string GetString(NamespaceDefinitionHandle handle)
			{
				if (handle.HasFullName)
				{
					return StringHeap.GetString(handle.GetFullName(), UTF8Decoder);
				}
				return NamespaceCache.GetFullName(handle);
			}

			public byte[] GetBlobBytes(BlobHandle handle)
			{
				return BlobHeap.GetBytes(handle);
			}

			public System.Collections.Immutable.ImmutableArray<byte> GetBlobContent(BlobHandle handle)
			{
				byte[] array = GetBlobBytes(handle);
				return ImmutableByteArrayInterop.DangerousCreateFromUnderlyingArray(ref array);
			}

			public BlobReader GetBlobReader(BlobHandle handle)
			{
				return BlobHeap.GetBlobReader(handle);
			}

			public BlobReader GetBlobReader(StringHandle handle)
			{
				return StringHeap.GetBlobReader(handle);
			}

			public string GetUserString(UserStringHandle handle)
			{
				return UserStringHeap.GetString(handle);
			}

			public Guid GetGuid(GuidHandle handle)
			{
				return GuidHeap.GetGuid(handle);
			}

			public ModuleDefinition GetModuleDefinition()
			{
				if (_debugMetadataHeader != null)
				{
					throw new InvalidOperationException(MDCFR.Properties.Resources.StandaloneDebugMetadataImageDoesNotContainModuleTable);
				}
				return new ModuleDefinition(this);
			}

			public AssemblyReference GetAssemblyReference(AssemblyReferenceHandle handle)
			{
				return new AssemblyReference(this, handle.Value);
			}

			public TypeDefinition GetTypeDefinition(TypeDefinitionHandle handle)
			{
				return new TypeDefinition(this, GetTypeDefTreatmentAndRowId(handle));
			}

			public NamespaceDefinition GetNamespaceDefinitionRoot()
			{
				NamespaceData rootNamespace = NamespaceCache.GetRootNamespace();
				return new NamespaceDefinition(rootNamespace);
			}

			public NamespaceDefinition GetNamespaceDefinition(NamespaceDefinitionHandle handle)
			{
				NamespaceData namespaceData = NamespaceCache.GetNamespaceData(handle);
				return new NamespaceDefinition(namespaceData);
			}

			private uint GetTypeDefTreatmentAndRowId(TypeDefinitionHandle handle)
			{
				if (_metadataKind == MetadataKind.Ecma335)
				{
					return (uint)handle.RowId;
				}
				return CalculateTypeDefTreatmentAndRowId(handle);
			}

			public TypeReference GetTypeReference(TypeReferenceHandle handle)
			{
				return new TypeReference(this, GetTypeRefTreatmentAndRowId(handle));
			}

			private uint GetTypeRefTreatmentAndRowId(TypeReferenceHandle handle)
			{
				if (_metadataKind == MetadataKind.Ecma335)
				{
					return (uint)handle.RowId;
				}
				return CalculateTypeRefTreatmentAndRowId(handle);
			}

			public ExportedType GetExportedType(ExportedTypeHandle handle)
			{
				return new ExportedType(this, handle.RowId);
			}

			public CustomAttributeHandleCollection GetCustomAttributes(EntityHandle handle)
			{
				return new CustomAttributeHandleCollection(this, handle);
			}

			public CustomAttribute GetCustomAttribute(CustomAttributeHandle handle)
			{
				return new CustomAttribute(this, GetCustomAttributeTreatmentAndRowId(handle));
			}

			private uint GetCustomAttributeTreatmentAndRowId(CustomAttributeHandle handle)
			{
				if (_metadataKind == MetadataKind.Ecma335)
				{
					return (uint)handle.RowId;
				}
				return TreatmentAndRowId(1, handle.RowId);
			}

			public DeclarativeSecurityAttribute GetDeclarativeSecurityAttribute(DeclarativeSecurityAttributeHandle handle)
			{
				return new DeclarativeSecurityAttribute(this, handle.RowId);
			}

			public Constant GetConstant(ConstantHandle handle)
			{
				return new Constant(this, handle.RowId);
			}

			public MethodDefinition GetMethodDefinition(MethodDefinitionHandle handle)
			{
				return new MethodDefinition(this, GetMethodDefTreatmentAndRowId(handle));
			}

			private uint GetMethodDefTreatmentAndRowId(MethodDefinitionHandle handle)
			{
				if (_metadataKind == MetadataKind.Ecma335)
				{
					return (uint)handle.RowId;
				}
				return CalculateMethodDefTreatmentAndRowId(handle);
			}

			public FieldDefinition GetFieldDefinition(FieldDefinitionHandle handle)
			{
				return new FieldDefinition(this, GetFieldDefTreatmentAndRowId(handle));
			}

			private uint GetFieldDefTreatmentAndRowId(FieldDefinitionHandle handle)
			{
				if (_metadataKind == MetadataKind.Ecma335)
				{
					return (uint)handle.RowId;
				}
				return CalculateFieldDefTreatmentAndRowId(handle);
			}

			public PropertyDefinition GetPropertyDefinition(PropertyDefinitionHandle handle)
			{
				return new PropertyDefinition(this, handle);
			}

			public EventDefinition GetEventDefinition(EventDefinitionHandle handle)
			{
				return new EventDefinition(this, handle);
			}

			public MethodImplementation GetMethodImplementation(MethodImplementationHandle handle)
			{
				return new MethodImplementation(this, handle);
			}

			public MemberReference GetMemberReference(MemberReferenceHandle handle)
			{
				return new MemberReference(this, GetMemberRefTreatmentAndRowId(handle));
			}

			private uint GetMemberRefTreatmentAndRowId(MemberReferenceHandle handle)
			{
				if (_metadataKind == MetadataKind.Ecma335)
				{
					return (uint)handle.RowId;
				}
				return CalculateMemberRefTreatmentAndRowId(handle);
			}

			public MethodSpecification GetMethodSpecification(MethodSpecificationHandle handle)
			{
				return new MethodSpecification(this, handle);
			}

			public Parameter GetParameter(ParameterHandle handle)
			{
				return new Parameter(this, handle);
			}

			public GenericParameter GetGenericParameter(GenericParameterHandle handle)
			{
				return new GenericParameter(this, handle);
			}

			public GenericParameterConstraint GetGenericParameterConstraint(GenericParameterConstraintHandle handle)
			{
				return new GenericParameterConstraint(this, handle);
			}

			public ManifestResource GetManifestResource(ManifestResourceHandle handle)
			{
				return new ManifestResource(this, handle);
			}

			public AssemblyFile GetAssemblyFile(AssemblyFileHandle handle)
			{
				return new AssemblyFile(this, handle);
			}

			public StandaloneSignature GetStandaloneSignature(StandaloneSignatureHandle handle)
			{
				return new StandaloneSignature(this, handle);
			}

			public TypeSpecification GetTypeSpecification(TypeSpecificationHandle handle)
			{
				return new TypeSpecification(this, handle);
			}

			public ModuleReference GetModuleReference(ModuleReferenceHandle handle)
			{
				return new ModuleReference(this, handle);
			}

			public InterfaceImplementation GetInterfaceImplementation(InterfaceImplementationHandle handle)
			{
				return new InterfaceImplementation(this, handle);
			}

			internal TypeDefinitionHandle GetDeclaringType(MethodDefinitionHandle methodDef)
			{
				int methodDefOrPtrRowId = ((!UseMethodPtrTable) ? methodDef.RowId : MethodPtrTable.GetRowIdForMethodDefRow(methodDef.RowId));
				return TypeDefTable.FindTypeContainingMethod(methodDefOrPtrRowId, MethodDefTable.NumberOfRows);
			}

			internal TypeDefinitionHandle GetDeclaringType(FieldDefinitionHandle fieldDef)
			{
				int fieldDefOrPtrRowId = ((!UseFieldPtrTable) ? fieldDef.RowId : FieldPtrTable.GetRowIdForFieldDefRow(fieldDef.RowId));
				return TypeDefTable.FindTypeContainingField(fieldDefOrPtrRowId, FieldTable.NumberOfRows);
			}

			public string GetString(DocumentNameBlobHandle handle)
			{
				return BlobHeap.GetDocumentName(handle);
			}

			public Document GetDocument(DocumentHandle handle)
			{
				return new Document(this, handle);
			}

			public MethodDebugInformation GetMethodDebugInformation(MethodDebugInformationHandle handle)
			{
				return new MethodDebugInformation(this, handle);
			}

			public MethodDebugInformation GetMethodDebugInformation(MethodDefinitionHandle handle)
			{
				return new MethodDebugInformation(this, MethodDebugInformationHandle.FromRowId(handle.RowId));
			}

			public LocalScope GetLocalScope(LocalScopeHandle handle)
			{
				return new LocalScope(this, handle);
			}

			public LocalVariable GetLocalVariable(LocalVariableHandle handle)
			{
				return new LocalVariable(this, handle);
			}

			public LocalConstant GetLocalConstant(LocalConstantHandle handle)
			{
				return new LocalConstant(this, handle);
			}

			public ImportScope GetImportScope(ImportScopeHandle handle)
			{
				return new ImportScope(this, handle);
			}

			public CustomDebugInformation GetCustomDebugInformation(CustomDebugInformationHandle handle)
			{
				return new CustomDebugInformation(this, handle);
			}

			public CustomDebugInformationHandleCollection GetCustomDebugInformation(EntityHandle handle)
			{
				return new CustomDebugInformationHandleCollection(this, handle);
			}

			public LocalScopeHandleCollection GetLocalScopes(MethodDefinitionHandle handle)
			{
				return new LocalScopeHandleCollection(this, handle.RowId);
			}

			public LocalScopeHandleCollection GetLocalScopes(MethodDebugInformationHandle handle)
			{
				return new LocalScopeHandleCollection(this, handle.RowId);
			}

			private void InitializeNestedTypesMap()
			{
				Dictionary<TypeDefinitionHandle, System.Collections.Immutable.ImmutableArray<TypeDefinitionHandle>.Builder> dictionary = new Dictionary<TypeDefinitionHandle, System.Collections.Immutable.ImmutableArray<TypeDefinitionHandle>.Builder>();
				int numberOfRows = NestedClassTable.NumberOfRows;
				System.Collections.Immutable.ImmutableArray<TypeDefinitionHandle>.Builder value = null;
				TypeDefinitionHandle typeDefinitionHandle = default(TypeDefinitionHandle);
				for (int i = 1; i <= numberOfRows; i++)
				{
					TypeDefinitionHandle enclosingClass = NestedClassTable.GetEnclosingClass(i);
					if (enclosingClass != typeDefinitionHandle)
					{
						if (!dictionary.TryGetValue(enclosingClass, out value))
						{
							value = System.Collections.Immutable.ImmutableArray.CreateBuilder<TypeDefinitionHandle>();
							dictionary.Add(enclosingClass, value);
						}
						typeDefinitionHandle = enclosingClass;
					}
					value.Add(NestedClassTable.GetNestedClass(i));
				}
				Dictionary<TypeDefinitionHandle, System.Collections.Immutable.ImmutableArray<TypeDefinitionHandle>> dictionary2 = new Dictionary<TypeDefinitionHandle, System.Collections.Immutable.ImmutableArray<TypeDefinitionHandle>>();
				foreach (KeyValuePair<TypeDefinitionHandle, System.Collections.Immutable.ImmutableArray<TypeDefinitionHandle>.Builder> item in dictionary)
				{
					dictionary2.Add(item.Key, item.Value.ToImmutable());
				}
				_lazyNestedTypesMap = dictionary2;
			}

			/// <summary>
			/// Returns an array of types nested in the specified type.
			/// </summary>
			internal System.Collections.Immutable.ImmutableArray<TypeDefinitionHandle> GetNestedTypes(TypeDefinitionHandle typeDef)
			{
				if (_lazyNestedTypesMap == null)
				{
					InitializeNestedTypesMap();
				}
				if (_lazyNestedTypesMap.TryGetValue(typeDef, out var value))
				{
					return value;
				}
				return System.Collections.Immutable.ImmutableArray<TypeDefinitionHandle>.Empty;
			}

			private TypeDefTreatment GetWellKnownTypeDefinitionTreatment(TypeDefinitionHandle typeDef)
			{
				InitializeProjectedTypes();
				StringHandle name = TypeDefTable.GetName(typeDef);
				int num = StringHeap.BinarySearchRaw(s_projectedTypeNames, name);
				if (num < 0)
				{
					return TypeDefTreatment.None;
				}
				StringHandle @namespace = TypeDefTable.GetNamespace(typeDef);
				if (StringHeap.EqualsRaw(@namespace, StringHeap.GetVirtualString(s_projectionInfos[num].ClrNamespace)))
				{
					return s_projectionInfos[num].Treatment;
				}
				if (StringHeap.EqualsRaw(@namespace, s_projectionInfos[num].WinRTNamespace))
				{
					return s_projectionInfos[num].Treatment | TypeDefTreatment.MarkInternalFlag;
				}
				return TypeDefTreatment.None;
			}

			private int GetProjectionIndexForTypeReference(TypeReferenceHandle typeRef, out bool isIDisposable)
			{
				InitializeProjectedTypes();
				int num = StringHeap.BinarySearchRaw(s_projectedTypeNames, TypeRefTable.GetName(typeRef));
				if (num >= 0 && StringHeap.EqualsRaw(TypeRefTable.GetNamespace(typeRef), s_projectionInfos[num].WinRTNamespace))
				{
					isIDisposable = s_projectionInfos[num].IsIDisposable;
					return num;
				}
				isIDisposable = false;
				return -1;
			}

			internal static AssemblyReferenceHandle GetProjectedAssemblyRef(int projectionIndex)
			{
				return AssemblyReferenceHandle.FromVirtualIndex(s_projectionInfos[projectionIndex].AssemblyRef);
			}

			internal static StringHandle GetProjectedName(int projectionIndex)
			{
				return StringHandle.FromVirtualIndex(s_projectionInfos[projectionIndex].ClrName);
			}

			internal static StringHandle GetProjectedNamespace(int projectionIndex)
			{
				return StringHandle.FromVirtualIndex(s_projectionInfos[projectionIndex].ClrNamespace);
			}

			internal static TypeRefSignatureTreatment GetProjectedSignatureTreatment(int projectionIndex)
			{
				return s_projectionInfos[projectionIndex].SignatureTreatment;
			}

			private static void InitializeProjectedTypes()
			{
				if (s_projectedTypeNames == null || s_projectionInfos == null)
				{
					AssemblyReferenceHandle.VirtualIndex clrAssembly = AssemblyReferenceHandle.VirtualIndex.System_Runtime_WindowsRuntime;
					AssemblyReferenceHandle.VirtualIndex clrAssembly2 = AssemblyReferenceHandle.VirtualIndex.System_Runtime;
					AssemblyReferenceHandle.VirtualIndex clrAssembly3 = AssemblyReferenceHandle.VirtualIndex.System_ObjectModel;
					AssemblyReferenceHandle.VirtualIndex clrAssembly4 = AssemblyReferenceHandle.VirtualIndex.System_Runtime_WindowsRuntime_UI_Xaml;
					AssemblyReferenceHandle.VirtualIndex clrAssembly5 = AssemblyReferenceHandle.VirtualIndex.System_Runtime_InteropServices_WindowsRuntime;
					AssemblyReferenceHandle.VirtualIndex clrAssembly6 = AssemblyReferenceHandle.VirtualIndex.System_Numerics_Vectors;
					string[] array = new string[50];
					ProjectionInfo[] array2 = new ProjectionInfo[50];
					int num = 0;
					int num2 = 0;
					array[num++] = "AttributeTargets";
					array2[num2++] = new ProjectionInfo("Windows.Foundation.Metadata", StringHandle.VirtualIndex.System, StringHandle.VirtualIndex.AttributeTargets, clrAssembly2);
					array[num++] = "AttributeUsageAttribute";
					array2[num2++] = new ProjectionInfo("Windows.Foundation.Metadata", StringHandle.VirtualIndex.System, StringHandle.VirtualIndex.AttributeUsageAttribute, clrAssembly2, TypeDefTreatment.RedirectedToClrAttribute);
					array[num++] = "Color";
					array2[num2++] = new ProjectionInfo("Windows.UI", StringHandle.VirtualIndex.Windows_UI, StringHandle.VirtualIndex.Color, clrAssembly);
					array[num++] = "CornerRadius";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml", StringHandle.VirtualIndex.Windows_UI_Xaml, StringHandle.VirtualIndex.CornerRadius, clrAssembly4);
					array[num++] = "DateTime";
					array2[num2++] = new ProjectionInfo("Windows.Foundation", StringHandle.VirtualIndex.System, StringHandle.VirtualIndex.DateTimeOffset, clrAssembly2);
					array[num++] = "Duration";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml", StringHandle.VirtualIndex.Windows_UI_Xaml, StringHandle.VirtualIndex.Duration, clrAssembly4);
					array[num++] = "DurationType";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml", StringHandle.VirtualIndex.Windows_UI_Xaml, StringHandle.VirtualIndex.DurationType, clrAssembly4);
					array[num++] = "EventHandler`1";
					array2[num2++] = new ProjectionInfo("Windows.Foundation", StringHandle.VirtualIndex.System, StringHandle.VirtualIndex.EventHandler1, clrAssembly2);
					array[num++] = "EventRegistrationToken";
					array2[num2++] = new ProjectionInfo("Windows.Foundation", StringHandle.VirtualIndex.System_Runtime_InteropServices_WindowsRuntime, StringHandle.VirtualIndex.EventRegistrationToken, clrAssembly5);
					array[num++] = "GeneratorPosition";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml.Controls.Primitives", StringHandle.VirtualIndex.Windows_UI_Xaml_Controls_Primitives, StringHandle.VirtualIndex.GeneratorPosition, clrAssembly4);
					array[num++] = "GridLength";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml", StringHandle.VirtualIndex.Windows_UI_Xaml, StringHandle.VirtualIndex.GridLength, clrAssembly4);
					array[num++] = "GridUnitType";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml", StringHandle.VirtualIndex.Windows_UI_Xaml, StringHandle.VirtualIndex.GridUnitType, clrAssembly4);
					array[num++] = "HResult";
					array2[num2++] = new ProjectionInfo("Windows.Foundation", StringHandle.VirtualIndex.System, StringHandle.VirtualIndex.Exception, clrAssembly2, TypeDefTreatment.RedirectedToClrType, TypeRefSignatureTreatment.ProjectedToClass);
					array[num++] = "IBindableIterable";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml.Interop", StringHandle.VirtualIndex.System_Collections, StringHandle.VirtualIndex.IEnumerable, clrAssembly2);
					array[num++] = "IBindableVector";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml.Interop", StringHandle.VirtualIndex.System_Collections, StringHandle.VirtualIndex.IList, clrAssembly2);
					array[num++] = "IClosable";
					array2[num2++] = new ProjectionInfo("Windows.Foundation", StringHandle.VirtualIndex.System, StringHandle.VirtualIndex.IDisposable, clrAssembly2, TypeDefTreatment.RedirectedToClrType, TypeRefSignatureTreatment.None, isIDisposable: true);
					array[num++] = "ICommand";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml.Input", StringHandle.VirtualIndex.System_Windows_Input, StringHandle.VirtualIndex.ICommand, clrAssembly3);
					array[num++] = "IIterable`1";
					array2[num2++] = new ProjectionInfo("Windows.Foundation.Collections", StringHandle.VirtualIndex.System_Collections_Generic, StringHandle.VirtualIndex.IEnumerable1, clrAssembly2);
					array[num++] = "IKeyValuePair`2";
					array2[num2++] = new ProjectionInfo("Windows.Foundation.Collections", StringHandle.VirtualIndex.System_Collections_Generic, StringHandle.VirtualIndex.KeyValuePair2, clrAssembly2, TypeDefTreatment.RedirectedToClrType, TypeRefSignatureTreatment.ProjectedToValueType);
					array[num++] = "IMapView`2";
					array2[num2++] = new ProjectionInfo("Windows.Foundation.Collections", StringHandle.VirtualIndex.System_Collections_Generic, StringHandle.VirtualIndex.IReadOnlyDictionary2, clrAssembly2);
					array[num++] = "IMap`2";
					array2[num2++] = new ProjectionInfo("Windows.Foundation.Collections", StringHandle.VirtualIndex.System_Collections_Generic, StringHandle.VirtualIndex.IDictionary2, clrAssembly2);
					array[num++] = "INotifyCollectionChanged";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml.Interop", StringHandle.VirtualIndex.System_Collections_Specialized, StringHandle.VirtualIndex.INotifyCollectionChanged, clrAssembly3);
					array[num++] = "INotifyPropertyChanged";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml.Data", StringHandle.VirtualIndex.System_ComponentModel, StringHandle.VirtualIndex.INotifyPropertyChanged, clrAssembly3);
					array[num++] = "IReference`1";
					array2[num2++] = new ProjectionInfo("Windows.Foundation", StringHandle.VirtualIndex.System, StringHandle.VirtualIndex.Nullable1, clrAssembly2, TypeDefTreatment.RedirectedToClrType, TypeRefSignatureTreatment.ProjectedToValueType);
					array[num++] = "IVectorView`1";
					array2[num2++] = new ProjectionInfo("Windows.Foundation.Collections", StringHandle.VirtualIndex.System_Collections_Generic, StringHandle.VirtualIndex.IReadOnlyList1, clrAssembly2);
					array[num++] = "IVector`1";
					array2[num2++] = new ProjectionInfo("Windows.Foundation.Collections", StringHandle.VirtualIndex.System_Collections_Generic, StringHandle.VirtualIndex.IList1, clrAssembly2);
					array[num++] = "KeyTime";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml.Media.Animation", StringHandle.VirtualIndex.Windows_UI_Xaml_Media_Animation, StringHandle.VirtualIndex.KeyTime, clrAssembly4);
					array[num++] = "Matrix";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml.Media", StringHandle.VirtualIndex.Windows_UI_Xaml_Media, StringHandle.VirtualIndex.Matrix, clrAssembly4);
					array[num++] = "Matrix3D";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml.Media.Media3D", StringHandle.VirtualIndex.Windows_UI_Xaml_Media_Media3D, StringHandle.VirtualIndex.Matrix3D, clrAssembly4);
					array[num++] = "Matrix3x2";
					array2[num2++] = new ProjectionInfo("Windows.Foundation.Numerics", StringHandle.VirtualIndex.System_Numerics, StringHandle.VirtualIndex.Matrix3x2, clrAssembly6);
					array[num++] = "Matrix4x4";
					array2[num2++] = new ProjectionInfo("Windows.Foundation.Numerics", StringHandle.VirtualIndex.System_Numerics, StringHandle.VirtualIndex.Matrix4x4, clrAssembly6);
					array[num++] = "NotifyCollectionChangedAction";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml.Interop", StringHandle.VirtualIndex.System_Collections_Specialized, StringHandle.VirtualIndex.NotifyCollectionChangedAction, clrAssembly3);
					array[num++] = "NotifyCollectionChangedEventArgs";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml.Interop", StringHandle.VirtualIndex.System_Collections_Specialized, StringHandle.VirtualIndex.NotifyCollectionChangedEventArgs, clrAssembly3);
					array[num++] = "NotifyCollectionChangedEventHandler";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml.Interop", StringHandle.VirtualIndex.System_Collections_Specialized, StringHandle.VirtualIndex.NotifyCollectionChangedEventHandler, clrAssembly3);
					array[num++] = "Plane";
					array2[num2++] = new ProjectionInfo("Windows.Foundation.Numerics", StringHandle.VirtualIndex.System_Numerics, StringHandle.VirtualIndex.Plane, clrAssembly6);
					array[num++] = "Point";
					array2[num2++] = new ProjectionInfo("Windows.Foundation", StringHandle.VirtualIndex.Windows_Foundation, StringHandle.VirtualIndex.Point, clrAssembly);
					array[num++] = "PropertyChangedEventArgs";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml.Data", StringHandle.VirtualIndex.System_ComponentModel, StringHandle.VirtualIndex.PropertyChangedEventArgs, clrAssembly3);
					array[num++] = "PropertyChangedEventHandler";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml.Data", StringHandle.VirtualIndex.System_ComponentModel, StringHandle.VirtualIndex.PropertyChangedEventHandler, clrAssembly3);
					array[num++] = "Quaternion";
					array2[num2++] = new ProjectionInfo("Windows.Foundation.Numerics", StringHandle.VirtualIndex.System_Numerics, StringHandle.VirtualIndex.Quaternion, clrAssembly6);
					array[num++] = "Rect";
					array2[num2++] = new ProjectionInfo("Windows.Foundation", StringHandle.VirtualIndex.Windows_Foundation, StringHandle.VirtualIndex.Rect, clrAssembly);
					array[num++] = "RepeatBehavior";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml.Media.Animation", StringHandle.VirtualIndex.Windows_UI_Xaml_Media_Animation, StringHandle.VirtualIndex.RepeatBehavior, clrAssembly4);
					array[num++] = "RepeatBehaviorType";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml.Media.Animation", StringHandle.VirtualIndex.Windows_UI_Xaml_Media_Animation, StringHandle.VirtualIndex.RepeatBehaviorType, clrAssembly4);
					array[num++] = "Size";
					array2[num2++] = new ProjectionInfo("Windows.Foundation", StringHandle.VirtualIndex.Windows_Foundation, StringHandle.VirtualIndex.Size, clrAssembly);
					array[num++] = "Thickness";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml", StringHandle.VirtualIndex.Windows_UI_Xaml, StringHandle.VirtualIndex.Thickness, clrAssembly4);
					array[num++] = "TimeSpan";
					array2[num2++] = new ProjectionInfo("Windows.Foundation", StringHandle.VirtualIndex.System, StringHandle.VirtualIndex.TimeSpan, clrAssembly2);
					array[num++] = "TypeName";
					array2[num2++] = new ProjectionInfo("Windows.UI.Xaml.Interop", StringHandle.VirtualIndex.System, StringHandle.VirtualIndex.Type, clrAssembly2, TypeDefTreatment.RedirectedToClrType, TypeRefSignatureTreatment.ProjectedToClass);
					array[num++] = "Uri";
					array2[num2++] = new ProjectionInfo("Windows.Foundation", StringHandle.VirtualIndex.System, StringHandle.VirtualIndex.Uri, clrAssembly2);
					array[num++] = "Vector2";
					array2[num2++] = new ProjectionInfo("Windows.Foundation.Numerics", StringHandle.VirtualIndex.System_Numerics, StringHandle.VirtualIndex.Vector2, clrAssembly6);
					array[num++] = "Vector3";
					array2[num2++] = new ProjectionInfo("Windows.Foundation.Numerics", StringHandle.VirtualIndex.System_Numerics, StringHandle.VirtualIndex.Vector3, clrAssembly6);
					array[num++] = "Vector4";
					array2[num2++] = new ProjectionInfo("Windows.Foundation.Numerics", StringHandle.VirtualIndex.System_Numerics, StringHandle.VirtualIndex.Vector4, clrAssembly6);
					s_projectedTypeNames = array;
					s_projectionInfos = array2;
				}
			}

			[Conditional("DEBUG")]
			private static void AssertSorted(string[] keys)
			{
				for (int i = 0; i < keys.Length - 1; i++)
				{
				}
			}

			internal static string[] GetProjectedTypeNames()
			{
				InitializeProjectedTypes();
				return s_projectedTypeNames;
			}

			private static uint TreatmentAndRowId(byte treatment, int rowId)
			{
				return (uint)((treatment << 24) | rowId);
			}

			[MethodImpl(MethodImplOptions.NoInlining)]
			internal uint CalculateTypeDefTreatmentAndRowId(TypeDefinitionHandle handle)
			{
				TypeAttributes flags = TypeDefTable.GetFlags(handle);
				EntityHandle extends = TypeDefTable.GetExtends(handle);
				TypeDefTreatment typeDefTreatment;
				if ((flags & TypeAttributes.WindowsRuntime) == 0)
				{
					typeDefTreatment = ((_metadataKind == MetadataKind.ManagedWindowsMetadata && IsClrImplementationType(handle)) ? TypeDefTreatment.UnmangleWinRTName : TypeDefTreatment.None);
				}
				else
				{
					if (_metadataKind != MetadataKind.WindowsMetadata)
					{
						typeDefTreatment = ((_metadataKind == MetadataKind.ManagedWindowsMetadata && NeedsWinRTPrefix(flags, extends)) ? TypeDefTreatment.PrefixWinRTName : TypeDefTreatment.None);
					}
					else
					{
						typeDefTreatment = GetWellKnownTypeDefinitionTreatment(handle);
						if (typeDefTreatment != 0)
						{
							return TreatmentAndRowId((byte)typeDefTreatment, handle.RowId);
						}
						typeDefTreatment = ((extends.Kind != HandleKind.TypeReference || !IsSystemAttribute((TypeReferenceHandle)extends)) ? TypeDefTreatment.NormalNonAttribute : TypeDefTreatment.NormalAttribute);
					}
					if ((typeDefTreatment == TypeDefTreatment.PrefixWinRTName || typeDefTreatment == TypeDefTreatment.NormalNonAttribute) && (flags & TypeAttributes.ClassSemanticsMask) == 0 && HasAttribute(handle, "Windows.UI.Xaml", "TreatAsAbstractComposableClassAttribute"))
					{
						typeDefTreatment |= TypeDefTreatment.MarkAbstractFlag;
					}
				}
				return TreatmentAndRowId((byte)typeDefTreatment, handle.RowId);
			}

			private bool IsClrImplementationType(TypeDefinitionHandle typeDef)
			{
				TypeAttributes flags = TypeDefTable.GetFlags(typeDef);
				if ((flags & (TypeAttributes.VisibilityMask | TypeAttributes.SpecialName)) != TypeAttributes.SpecialName)
				{
					return false;
				}
				return StringHeap.StartsWithRaw(TypeDefTable.GetName(typeDef), "<CLR>");
			}

			internal uint CalculateTypeRefTreatmentAndRowId(TypeReferenceHandle handle)
			{
				bool isIDisposable;
				int projectionIndexForTypeReference = GetProjectionIndexForTypeReference(handle, out isIDisposable);
				if (projectionIndexForTypeReference >= 0)
				{
					return TreatmentAndRowId(3, projectionIndexForTypeReference);
				}
				return TreatmentAndRowId((byte)GetSpecialTypeRefTreatment(handle), handle.RowId);
			}

			private TypeRefTreatment GetSpecialTypeRefTreatment(TypeReferenceHandle handle)
			{
				if (StringHeap.EqualsRaw(TypeRefTable.GetNamespace(handle), "System"))
				{
					StringHandle name = TypeRefTable.GetName(handle);
					if (StringHeap.EqualsRaw(name, "MulticastDelegate"))
					{
						return TypeRefTreatment.SystemDelegate;
					}
					if (StringHeap.EqualsRaw(name, "Attribute"))
					{
						return TypeRefTreatment.SystemAttribute;
					}
				}
				return TypeRefTreatment.None;
			}

			private bool IsSystemAttribute(TypeReferenceHandle handle)
			{
				if (StringHeap.EqualsRaw(TypeRefTable.GetNamespace(handle), "System"))
				{
					return StringHeap.EqualsRaw(TypeRefTable.GetName(handle), "Attribute");
				}
				return false;
			}

			private bool NeedsWinRTPrefix(TypeAttributes flags, EntityHandle extends)
			{
				if ((flags & (TypeAttributes.VisibilityMask | TypeAttributes.ClassSemanticsMask)) != TypeAttributes.Public)
				{
					return false;
				}
				if (extends.Kind != HandleKind.TypeReference)
				{
					return false;
				}
				TypeReferenceHandle handle = (TypeReferenceHandle)extends;
				if (StringHeap.EqualsRaw(TypeRefTable.GetNamespace(handle), "System"))
				{
					StringHandle name = TypeRefTable.GetName(handle);
					if (StringHeap.EqualsRaw(name, "MulticastDelegate") || StringHeap.EqualsRaw(name, "ValueType") || StringHeap.EqualsRaw(name, "Attribute"))
					{
						return false;
					}
				}
				return true;
			}

			private uint CalculateMethodDefTreatmentAndRowId(MethodDefinitionHandle methodDef)
			{
				MethodDefTreatment methodDefTreatment = MethodDefTreatment.Implementation;
				TypeDefinitionHandle declaringType = GetDeclaringType(methodDef);
				TypeAttributes flags = TypeDefTable.GetFlags(declaringType);
				if ((flags & TypeAttributes.WindowsRuntime) != 0)
				{
					if (IsClrImplementationType(declaringType))
					{
						methodDefTreatment = MethodDefTreatment.Implementation;
					}
					else if (flags.IsNested())
					{
						methodDefTreatment = MethodDefTreatment.Implementation;
					}
					else if ((flags & TypeAttributes.ClassSemanticsMask) != 0)
					{
						methodDefTreatment = MethodDefTreatment.InterfaceMethod;
					}
					else if (_metadataKind == MetadataKind.ManagedWindowsMetadata && (flags & TypeAttributes.Public) == 0)
					{
						methodDefTreatment = MethodDefTreatment.Implementation;
					}
					else
					{
						methodDefTreatment = MethodDefTreatment.Other;
						EntityHandle extends = TypeDefTable.GetExtends(declaringType);
						if (extends.Kind == HandleKind.TypeReference)
						{
							switch (GetSpecialTypeRefTreatment((TypeReferenceHandle)extends))
							{
								case TypeRefTreatment.SystemAttribute:
									methodDefTreatment = MethodDefTreatment.AttributeMethod;
									break;
								case TypeRefTreatment.SystemDelegate:
									methodDefTreatment = MethodDefTreatment.DelegateMethod | MethodDefTreatment.MarkPublicFlag;
									break;
							}
						}
					}
				}
				if (methodDefTreatment == MethodDefTreatment.Other)
				{
					bool flag = false;
					bool flag2 = false;
					bool isIDisposable = false;
					foreach (MethodImplementationHandle item in new MethodImplementationHandleCollection(this, declaringType))
					{
						MethodImplementation methodImplementation = GetMethodImplementation(item);
						if (!(methodImplementation.MethodBody == methodDef))
						{
							continue;
						}
						EntityHandle methodDeclaration = methodImplementation.MethodDeclaration;
						if (methodDeclaration.Kind == HandleKind.MemberReference && ImplementsRedirectedInterface((MemberReferenceHandle)methodDeclaration, out isIDisposable))
						{
							flag = true;
							if (isIDisposable)
							{
								break;
							}
						}
						else
						{
							flag2 = true;
						}
					}
					if (isIDisposable)
					{
						methodDefTreatment = MethodDefTreatment.DisposeMethod;
					}
					else if (flag && !flag2)
					{
						methodDefTreatment = MethodDefTreatment.HiddenInterfaceImplementation;
					}
				}
				if (methodDefTreatment == MethodDefTreatment.Other)
				{
					methodDefTreatment |= GetMethodTreatmentFromCustomAttributes(methodDef);
				}
				return TreatmentAndRowId((byte)methodDefTreatment, methodDef.RowId);
			}

			private MethodDefTreatment GetMethodTreatmentFromCustomAttributes(MethodDefinitionHandle methodDef)
			{
				MethodDefTreatment methodDefTreatment = MethodDefTreatment.None;
				foreach (CustomAttributeHandle customAttribute in GetCustomAttributes(methodDef))
				{
					if (GetAttributeTypeNameRaw(customAttribute, out var namespaceName, out var typeName) && StringHeap.EqualsRaw(namespaceName, "Windows.UI.Xaml"))
					{
						if (StringHeap.EqualsRaw(typeName, "TreatAsPublicMethodAttribute"))
						{
							methodDefTreatment |= MethodDefTreatment.MarkPublicFlag;
						}
						if (StringHeap.EqualsRaw(typeName, "TreatAsAbstractMethodAttribute"))
						{
							methodDefTreatment |= MethodDefTreatment.MarkAbstractFlag;
						}
					}
				}
				return methodDefTreatment;
			}

			/// <summary>
			/// The backing field of a WinRT enumeration type is not public although the backing fields
			/// of managed enumerations are. To allow managed languages to directly access this field,
			/// it is made public by the metadata adapter.
			/// </summary>
			private uint CalculateFieldDefTreatmentAndRowId(FieldDefinitionHandle handle)
			{
				FieldAttributes flags = FieldTable.GetFlags(handle);
				FieldDefTreatment treatment = FieldDefTreatment.None;
				if ((flags & FieldAttributes.RTSpecialName) != 0 && StringHeap.EqualsRaw(FieldTable.GetName(handle), "value__"))
				{
					TypeDefinitionHandle declaringType = GetDeclaringType(handle);
					EntityHandle extends = TypeDefTable.GetExtends(declaringType);
					if (extends.Kind == HandleKind.TypeReference)
					{
						TypeReferenceHandle handle2 = (TypeReferenceHandle)extends;
						if (StringHeap.EqualsRaw(TypeRefTable.GetName(handle2), "Enum") && StringHeap.EqualsRaw(TypeRefTable.GetNamespace(handle2), "System"))
						{
							treatment = FieldDefTreatment.EnumValue;
						}
					}
				}
				return TreatmentAndRowId((byte)treatment, handle.RowId);
			}

			private uint CalculateMemberRefTreatmentAndRowId(MemberReferenceHandle handle)
			{
				bool isIDisposable;
				MemberRefTreatment treatment = ((ImplementsRedirectedInterface(handle, out isIDisposable) && isIDisposable) ? MemberRefTreatment.Dispose : MemberRefTreatment.None);
				return TreatmentAndRowId((byte)treatment, handle.RowId);
			}

			/// <summary>
			/// We want to know if a given method implements a redirected interface.
			/// For example, if we are given the method RemoveAt on a class "A"
			/// which implements the IVector interface (which is redirected
			/// to IList in .NET) then this method would return true. The most
			/// likely reason why we would want to know this is that we wish to hide
			/// (mark private) all methods which implement methods on a redirected
			/// interface.
			/// </summary>
			/// <param name="memberRef">The declaration token for the method</param>
			/// <param name="isIDisposable">
			/// Returns true if the redirected interface is <see cref="T:System.IDisposable" />.
			/// </param>
			/// <returns>True if the method implements a method on a redirected interface.
			/// False otherwise.</returns>
			private bool ImplementsRedirectedInterface(MemberReferenceHandle memberRef, out bool isIDisposable)
			{
				isIDisposable = false;
				EntityHandle @class = MemberRefTable.GetClass(memberRef);
				TypeReferenceHandle typeRef;
				if (@class.Kind == HandleKind.TypeReference)
				{
					typeRef = (TypeReferenceHandle)@class;
				}
				else
				{
					if (@class.Kind != HandleKind.TypeSpecification)
					{
						return false;
					}
					BlobHandle signature = TypeSpecTable.GetSignature((TypeSpecificationHandle)@class);
					BlobReader blobReader = new BlobReader(BlobHeap.GetMemoryBlock(signature));
					if (blobReader.Length < 2 || blobReader.ReadByte() != 21 || blobReader.ReadByte() != 18)
					{
						return false;
					}
					EntityHandle entityHandle = blobReader.ReadTypeHandle();
					if (entityHandle.Kind != HandleKind.TypeReference)
					{
						return false;
					}
					typeRef = (TypeReferenceHandle)entityHandle;
				}
				return GetProjectionIndexForTypeReference(typeRef, out isIDisposable) >= 0;
			}

			private int FindMscorlibAssemblyRefNoProjection()
			{
				for (int i = 1; i <= AssemblyRefTable.NumberOfNonVirtualRows; i++)
				{
					if (StringHeap.EqualsRaw(AssemblyRefTable.GetName(i), "mscorlib"))
					{
						return i;
					}
				}
				throw new BadImageFormatException(MDCFR.Properties.Resources.WinMDMissingMscorlibRef);
			}

			internal CustomAttributeValueTreatment CalculateCustomAttributeValueTreatment(CustomAttributeHandle handle)
			{
				EntityHandle parent = CustomAttributeTable.GetParent(handle);
				if (!IsWindowsAttributeUsageAttribute(parent, handle))
				{
					return CustomAttributeValueTreatment.None;
				}
				TypeDefinitionHandle typeDefinitionHandle = (TypeDefinitionHandle)parent;
				if (StringHeap.EqualsRaw(TypeDefTable.GetNamespace(typeDefinitionHandle), "Windows.Foundation.Metadata"))
				{
					if (StringHeap.EqualsRaw(TypeDefTable.GetName(typeDefinitionHandle), "VersionAttribute"))
					{
						return CustomAttributeValueTreatment.AttributeUsageVersionAttribute;
					}
					if (StringHeap.EqualsRaw(TypeDefTable.GetName(typeDefinitionHandle), "DeprecatedAttribute"))
					{
						return CustomAttributeValueTreatment.AttributeUsageDeprecatedAttribute;
					}
				}
				if (!HasAttribute(typeDefinitionHandle, "Windows.Foundation.Metadata", "AllowMultipleAttribute"))
				{
					return CustomAttributeValueTreatment.AttributeUsageAllowSingle;
				}
				return CustomAttributeValueTreatment.AttributeUsageAllowMultiple;
			}

			private bool IsWindowsAttributeUsageAttribute(EntityHandle targetType, CustomAttributeHandle attributeHandle)
			{
				if (targetType.Kind != HandleKind.TypeDefinition)
				{
					return false;
				}
				EntityHandle constructor = CustomAttributeTable.GetConstructor(attributeHandle);
				if (constructor.Kind != HandleKind.MemberReference)
				{
					return false;
				}
				EntityHandle @class = MemberRefTable.GetClass((MemberReferenceHandle)constructor);
				if (@class.Kind != HandleKind.TypeReference)
				{
					return false;
				}
				TypeReferenceHandle handle = (TypeReferenceHandle)@class;
				if (StringHeap.EqualsRaw(TypeRefTable.GetName(handle), "AttributeUsageAttribute"))
				{
					return StringHeap.EqualsRaw(TypeRefTable.GetNamespace(handle), "Windows.Foundation.Metadata");
				}
				return false;
			}

			private bool HasAttribute(EntityHandle token, string asciiNamespaceName, string asciiTypeName)
			{
				foreach (CustomAttributeHandle customAttribute in GetCustomAttributes(token))
				{
					if (GetAttributeTypeNameRaw(customAttribute, out var namespaceName, out var typeName) && StringHeap.EqualsRaw(typeName, asciiTypeName) && StringHeap.EqualsRaw(namespaceName, asciiNamespaceName))
					{
						return true;
					}
				}
				return false;
			}

			private bool GetAttributeTypeNameRaw(CustomAttributeHandle caHandle, out StringHandle namespaceName, out StringHandle typeName)
			{
				namespaceName = (typeName = default(StringHandle));
				EntityHandle attributeTypeRaw = GetAttributeTypeRaw(caHandle);
				if (attributeTypeRaw.IsNil)
				{
					return false;
				}
				if (attributeTypeRaw.Kind == HandleKind.TypeReference)
				{
					TypeReferenceHandle handle = (TypeReferenceHandle)attributeTypeRaw;
					EntityHandle resolutionScope = TypeRefTable.GetResolutionScope(handle);
					if (!resolutionScope.IsNil && resolutionScope.Kind == HandleKind.TypeReference)
					{
						return false;
					}
					typeName = TypeRefTable.GetName(handle);
					namespaceName = TypeRefTable.GetNamespace(handle);
				}
				else
				{
					if (attributeTypeRaw.Kind != HandleKind.TypeDefinition)
					{
						return false;
					}
					TypeDefinitionHandle handle2 = (TypeDefinitionHandle)attributeTypeRaw;
					if (TypeDefTable.GetFlags(handle2).IsNested())
					{
						return false;
					}
					typeName = TypeDefTable.GetName(handle2);
					namespaceName = TypeDefTable.GetNamespace(handle2);
				}
				return true;
			}

			/// <summary>
			/// Returns the type definition or reference handle of the attribute type.
			/// </summary>
			/// <returns><see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> or nil token if the metadata is invalid and the type can't be determined.</returns>
			private EntityHandle GetAttributeTypeRaw(CustomAttributeHandle handle)
			{
				EntityHandle constructor = CustomAttributeTable.GetConstructor(handle);
				if (constructor.Kind == HandleKind.MethodDefinition)
				{
					return GetDeclaringType((MethodDefinitionHandle)constructor);
				}
				if (constructor.Kind == HandleKind.MemberReference)
				{
					EntityHandle @class = MemberRefTable.GetClass((MemberReferenceHandle)constructor);
					HandleKind kind = @class.Kind;
					if (kind == HandleKind.TypeReference || kind == HandleKind.TypeDefinition)
					{
						return @class;
					}
				}
				return default(EntityHandle);
			}
		}

		[Flags]
		public enum MetadataReaderOptions
		{
			/// <summary>
			/// All options are disabled.
			/// </summary>
			None = 0,
			/// <summary>
			/// The options that are used when a <see cref="T:System.Reflection.Metadata.MetadataReader" /> is obtained
			/// via an overload that does not take a <see cref="T:System.Reflection.Metadata.MetadataReaderOptions" />
			/// argument.
			/// </summary>
			Default = 1,
			/// <summary>
			/// Windows Runtime projections are enabled (on by default).
			/// </summary>
			ApplyWindowsRuntimeProjections = 1
		}

		/// <summary>
		/// Provides a <see cref="System.Reflection.Metadata.MetadataReader" /> metadata stored in an array of bytes, a memory block, or a stream.
		/// </summary>
		/// <remarks>
		/// Supported formats:
		/// - ECMA-335 CLI (Common Language Infrastructure) metadata (<see cref="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Byte*,System.Int32)" />)
		/// - Edit and Continue metadata delta (<see cref="M:System.Reflection.Metadata.MetadataReaderProvider.FromMetadataImage(System.Byte*,System.Int32)" />)
		/// - Portable PDB metadata (<see cref="M:System.Reflection.Metadata.MetadataReaderProvider.FromPortablePdbImage(System.Byte*,System.Int32)" />)
		/// </remarks>
		public sealed class MetadataReaderProvider : IDisposable
		{
			private System.Reflection.Internal.MemoryBlockProvider _blockProviderOpt;

			private System.Reflection.Internal.AbstractMemoryBlock _lazyMetadataBlock;

			private MetadataReader _lazyMetadataReader;

			private readonly object _metadataReaderGuard = new object();

			internal MetadataReaderProvider(System.Reflection.Internal.AbstractMemoryBlock metadataBlock)
			{
				_lazyMetadataBlock = metadataBlock;
			}

			private MetadataReaderProvider(System.Reflection.Internal.MemoryBlockProvider blockProvider)
			{
				_blockProviderOpt = blockProvider;
			}

			/// <summary>
			/// Creates a Portable PDB metadata provider over a blob stored in memory.
			/// </summary>
			/// <param name="start">Pointer to the start of the Portable PDB blob.</param>
			/// <param name="size">The size of the Portable PDB blob.</param>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="start" /> is <see cref="F:System.IntPtr.Zero" />.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> is negative.</exception>
			/// <remarks>
			/// The memory is owned by the caller and not released on disposal of the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.
			/// The caller is responsible for keeping the memory alive and unmodified throughout the lifetime of the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.
			/// The content of the blob is not read during the construction of the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />
			/// </remarks>
			public unsafe static MetadataReaderProvider FromPortablePdbImage(byte* start, int size)
			{
				return FromMetadataImage(start, size);
			}

			/// <summary>
			/// Creates a metadata provider over an image stored in memory.
			/// </summary>
			/// <param name="start">Pointer to the start of the metadata blob.</param>
			/// <param name="size">The size of the metadata blob.</param>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="start" /> is <see cref="F:System.IntPtr.Zero" />.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> is negative.</exception>
			/// <remarks>
			/// The memory is owned by the caller and not released on disposal of the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.
			/// The caller is responsible for keeping the memory alive and unmodified throughout the lifetime of the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.
			/// The content of the blob is not read during the construction of the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />
			/// </remarks>
			public unsafe static MetadataReaderProvider FromMetadataImage(byte* start, int size)
			{
				if (start == null)
				{
					System.Reflection.Throw.ArgumentNull("start");
				}
				if (size < 0)
				{
					throw new ArgumentOutOfRangeException("size");
				}
				return new MetadataReaderProvider(new System.Reflection.Internal.ExternalMemoryBlockProvider(start, size));
			}

			/// <summary>
			/// Creates a Portable PDB metadata provider over a byte array.
			/// </summary>
			/// <param name="image">Portable PDB image.</param>
			/// <remarks>
			/// The content of the image is not read during the construction of the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />
			/// </remarks>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="image" /> is null.</exception>
			public static MetadataReaderProvider FromPortablePdbImage(System.Collections.Immutable.ImmutableArray<byte> image)
			{
				return FromMetadataImage(image);
			}

			/// <summary>
			/// Creates a provider over a byte array.
			/// </summary>
			/// <param name="image">Metadata image.</param>
			/// <remarks>
			/// The content of the image is not read during the construction of the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />
			/// </remarks>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="image" /> is null.</exception>
			public static MetadataReaderProvider FromMetadataImage(System.Collections.Immutable.ImmutableArray<byte> image)
			{
				if (image.IsDefault)
				{
					System.Reflection.Throw.ArgumentNull("image");
				}
				return new MetadataReaderProvider(new System.Reflection.Internal.ByteArrayMemoryProvider(image));
			}

			/// <summary>
			/// Creates a provider for a stream of the specified size beginning at its current position.
			/// </summary>
			/// <param name="stream">Stream.</param>
			/// <param name="size">Size of the metadata blob in the stream. If not specified the metadata blob is assumed to span to the end of the stream.</param>
			/// <param name="options">
			/// Options specifying how sections of the image are read from the stream.
			///
			/// Unless <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" /> is specified, ownership of the stream is transferred to the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />
			/// upon successful argument validation. It will be disposed by the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> and the caller must not manipulate it.
			///
			/// Unless <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" /> is specified no data
			/// is read from the stream during the construction of the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />. Furthermore, the stream must not be manipulated
			/// by caller while the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> is alive and undisposed.
			///
			/// If <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" />, the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />
			/// will have read all of the data requested during construction. As such, if <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" /> is also
			/// specified, the caller retains full ownership of the stream and is assured that it will not be manipulated by the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />
			/// after construction.
			/// </param>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> is null.</exception>
			/// <exception cref="T:System.ArgumentException"><paramref name="stream" /> doesn't support read and seek operations.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException">Size is negative or extends past the end of the stream.</exception>
			public static MetadataReaderProvider FromPortablePdbStream(Stream stream, MetadataStreamOptions options = MetadataStreamOptions.Default, int size = 0)
			{
				return FromMetadataStream(stream, options, size);
			}

			/// <summary>
			/// Creates a provider for a stream of the specified size beginning at its current position.
			/// </summary>
			/// <param name="stream">Stream.</param>
			/// <param name="size">Size of the metadata blob in the stream. If not specified the metadata blob is assumed to span to the end of the stream.</param>
			/// <param name="options">
			/// Options specifying how sections of the image are read from the stream.
			///
			/// Unless <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" /> is specified, ownership of the stream is transferred to the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />
			/// upon successful argument validation. It will be disposed by the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> and the caller must not manipulate it.
			///
			/// Unless <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" /> is specified no data
			/// is read from the stream during the construction of the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />. Furthermore, the stream must not be manipulated
			/// by caller while the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> is alive and undisposed.
			///
			/// If <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" />, the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />
			/// will have read all of the data requested during construction. As such, if <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" /> is also
			/// specified, the caller retains full ownership of the stream and is assured that it will not be manipulated by the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />
			/// after construction.
			/// </param>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="stream" /> is null.</exception>
			/// <exception cref="T:System.ArgumentException"><paramref name="stream" /> doesn't support read and seek operations.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException">Size is negative or extends past the end of the stream.</exception>
			/// <exception cref="T:System.IO.IOException">Error reading from the stream (only when <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.PrefetchMetadata" /> is specified).</exception>
			public static MetadataReaderProvider FromMetadataStream(Stream stream, MetadataStreamOptions options = MetadataStreamOptions.Default, int size = 0)
			{
				if (stream == null)
				{
					System.Reflection.Throw.ArgumentNull("stream");
				}
				if (!stream.CanRead || !stream.CanSeek)
				{
					throw new ArgumentException(MDCFR.Properties.Resources.StreamMustSupportReadAndSeek, "stream");
				}
				if (!options.IsValid())
				{
					throw new ArgumentOutOfRangeException("options");
				}
				long position = stream.Position;
				int andValidateSize = System.Reflection.Internal.StreamExtensions.GetAndValidateSize(stream, size, "stream");
				bool flag = true;
				MetadataReaderProvider result;
				try
				{
					if ((options & MetadataStreamOptions.PrefetchMetadata) == 0)
					{
						result = new MetadataReaderProvider(new System.Reflection.Internal.StreamMemoryBlockProvider(stream, position, andValidateSize, (options & MetadataStreamOptions.LeaveOpen) != 0));
						flag = false;
					}
					else
					{
						result = new MetadataReaderProvider(System.Reflection.Internal.StreamMemoryBlockProvider.ReadMemoryBlockNoLock(stream, position, andValidateSize));
					}
				}
				finally
				{
					if (flag && (options & MetadataStreamOptions.LeaveOpen) == 0)
					{
						stream.Dispose();
					}
				}
				return result;
			}

			/// <summary>
			/// Disposes all memory allocated by the reader.
			/// </summary>
			/// <remarks>
			/// <see cref="M:System.Reflection.Metadata.MetadataReaderProvider.Dispose" />  can be called multiple times (but not in parallel).
			/// It is not safe to call <see cref="M:System.Reflection.Metadata.MetadataReaderProvider.Dispose" /> in parallel with any other operation on the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />
			/// or reading from the underlying memory.
			/// </remarks>
			public void Dispose()
			{
				_blockProviderOpt?.Dispose();
				_blockProviderOpt = null;
				_lazyMetadataBlock?.Dispose();
				_lazyMetadataBlock = null;
				_lazyMetadataReader = null;
			}

			/// <summary>
			/// Gets a <see cref="T:System.Reflection.Metadata.MetadataReader" /> from a <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" />.
			/// </summary>
			/// <remarks>
			/// The caller must keep the <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> undisposed throughout the lifetime of the metadata reader.
			///
			/// If this method is called multiple times each call with arguments equal to the arguments passed to the previous successful call
			/// returns the same instance of <see cref="T:System.Reflection.Metadata.MetadataReader" /> as the previous call.
			/// </remarks>
			/// <exception cref="T:System.ArgumentException">The encoding of <paramref name="utf8Decoder" /> is not <see cref="T:System.Text.UTF8Encoding" />.</exception>
			/// <exception cref="T:System.PlatformNotSupportedException">The current platform is big-endian.</exception>
			/// <exception cref="T:System.IO.IOException">IO error while reading from the underlying stream.</exception>
			/// <exception cref="T:System.ObjectDisposedException">Provider has been disposed.</exception>
			public unsafe MetadataReader GetMetadataReader(MetadataReaderOptions options = MetadataReaderOptions.Default, MetadataStringDecoder? utf8Decoder = null)
			{
				MetadataReader lazyMetadataReader = _lazyMetadataReader;
				if (CanReuseReader(lazyMetadataReader, options, utf8Decoder))
				{
					return lazyMetadataReader;
				}
				lock (_metadataReaderGuard)
				{
					lazyMetadataReader = _lazyMetadataReader;
					if (CanReuseReader(lazyMetadataReader, options, utf8Decoder))
					{
						return lazyMetadataReader;
					}
					System.Reflection.Internal.AbstractMemoryBlock metadataBlock = GetMetadataBlock();
					return _lazyMetadataReader = new MetadataReader(metadataBlock.Pointer, metadataBlock.Size, options, utf8Decoder, this);
				}
			}

			private static bool CanReuseReader(MetadataReader reader, MetadataReaderOptions options, MetadataStringDecoder utf8DecoderOpt)
			{
				if (reader != null && reader.Options == options)
				{
					return reader.UTF8Decoder == (utf8DecoderOpt ?? MetadataStringDecoder.DefaultUTF8);
				}
				return false;
			}

			/// <exception cref="T:System.IO.IOException">IO error while reading from the underlying stream.</exception>
			/// <exception cref="T:System.ObjectDisposedException">Provider has been disposed.</exception>
			internal System.Reflection.Internal.AbstractMemoryBlock GetMetadataBlock()
			{
				if (_lazyMetadataBlock == null)
				{
					if (_blockProviderOpt == null)
					{
						throw new ObjectDisposedException("MetadataReaderProvider");
					}
					System.Reflection.Internal.AbstractMemoryBlock memoryBlock = _blockProviderOpt.GetMemoryBlock(0, _blockProviderOpt.Size);
					if (Interlocked.CompareExchange(ref _lazyMetadataBlock, memoryBlock, null) != null)
					{
						memoryBlock.Dispose();
					}
				}
				return _lazyMetadataBlock;
			}
		}

		[Flags]
		public enum MetadataStreamOptions
		{
			/// <summary>
			/// By default the stream is disposed when <see cref="System.Reflection.Metadata.MetadataReaderProvider" /> is disposed and sections of the PE image are read lazily.
			/// </summary>
			Default = 0,
			/// <summary>
			/// Keep the stream open when the <see cref="System.Reflection.Metadata.MetadataReaderProvider" /> is disposed.
			/// </summary>
			LeaveOpen = 1,
			/// <summary>
			/// Reads PDB metadata into memory right away.
			/// </summary>
			/// <remarks>
			/// The underlying file may be closed and even deleted after <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> is constructed.
			/// <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> closes the stream automatically by the time the constructor returns unless <see cref="F:System.Reflection.Metadata.MetadataStreamOptions.LeaveOpen" /> is specified.
			/// </remarks>
			PrefetchMetadata = 2
		}

		internal static class MetadataStreamOptionsExtensions
		{
			public static bool IsValid(this MetadataStreamOptions options)
			{
				return (options & ~(MetadataStreamOptions.LeaveOpen | MetadataStreamOptions.PrefetchMetadata)) == 0;
			}
		}

		/// <summary>
		/// Provides string comparison helpers to query strings in metadata while
		/// avoiding allocation where possible.
		/// </summary>
		///
		/// <remarks>
		/// No allocation is performed unless both the handle argument and the
		/// value argument contain non-ascii text.
		///
		/// Obtain instances using <see cref="P:System.Reflection.Metadata.MetadataReader.StringComparer" />.
		///
		/// A default-initialized instance is useless and behaves as a null reference.
		///
		/// The code is optimized such that there is no additional overhead in
		/// re-obtaining a comparer over hoisting it in to a local.
		///
		/// That is to say that a construct like:
		///
		/// <code>
		/// if (reader.StringComparer.Equals(typeDef.Namespace, "System") &amp;&amp;
		///     reader.StringComparer.Equals(typeDef.Name, "Object")
		/// {
		///     // found System.Object
		/// }
		/// </code>
		///
		/// is no less efficient than:
		///
		/// <code>
		/// var comparer = reader.StringComparer;
		/// if (comparer.Equals(typeDef.Namespace, "System") &amp;&amp;
		///     comparer.Equals(typeDef.Name, "Object")
		/// {
		///     // found System.Object
		/// }
		/// </code>
		///
		/// The choice between them is therefore one of style and not performance.
		/// </remarks>
		public readonly struct MetadataStringComparer
		{
			private readonly MetadataReader _reader;

			internal MetadataStringComparer(MetadataReader reader)
			{
				_reader = reader;
			}

			public bool Equals(StringHandle handle, string value)
			{
				return Equals(handle, value, ignoreCase: false);
			}

			public bool Equals(StringHandle handle, string value, bool ignoreCase)
			{
				if (value == null)
				{
					System.Reflection.Throw.ValueArgumentNull();
				}
				return _reader.StringHeap.Equals(handle, value, _reader.UTF8Decoder, ignoreCase);
			}

			public bool Equals(NamespaceDefinitionHandle handle, string value)
			{
				return Equals(handle, value, ignoreCase: false);
			}

			public bool Equals(NamespaceDefinitionHandle handle, string value, bool ignoreCase)
			{
				if (value == null)
				{
					System.Reflection.Throw.ValueArgumentNull();
				}
				if (handle.HasFullName)
				{
					return _reader.StringHeap.Equals(handle.GetFullName(), value, _reader.UTF8Decoder, ignoreCase);
				}
				return value == _reader.NamespaceCache.GetFullName(handle);
			}

			public bool Equals(DocumentNameBlobHandle handle, string value)
			{
				return Equals(handle, value, ignoreCase: false);
			}

			public bool Equals(DocumentNameBlobHandle handle, string value, bool ignoreCase)
			{
				if (value == null)
				{
					System.Reflection.Throw.ValueArgumentNull();
				}
				return _reader.BlobHeap.DocumentNameEquals(handle, value, ignoreCase);
			}

			public bool StartsWith(StringHandle handle, string value)
			{
				return StartsWith(handle, value, ignoreCase: false);
			}

			public bool StartsWith(StringHandle handle, string value, bool ignoreCase)
			{
				if (value == null)
				{
					System.Reflection.Throw.ValueArgumentNull();
				}
				return _reader.StringHeap.StartsWith(handle, value, _reader.UTF8Decoder, ignoreCase);
			}
		}

		/// <summary>
		/// Provides the <see cref="System.Reflection.Metadata.MetadataReader" /> with a custom mechanism for decoding
		/// byte sequences in metadata that represent text.
		/// </summary>
		/// <remarks>
		/// This can be used for the following purposes:
		///
		/// 1) To customize the treatment of invalid input. When no decoder is provided,
		///    the <see cref="System.Reflection.Metadata.MetadataReader" /> uses the default fallback replacement
		///    with \uFFFD)
		///
		/// 2) To reuse existing strings instead of allocating a new one for each decoding
		///    operation.
		/// </remarks>
		public class MetadataStringDecoder
		{
			/// <summary>
			/// Gets the encoding used by this instance.
			/// </summary>
			public Encoding Encoding { get; }

			/// <summary>
			/// The default decoder used by <see cref="T:System.Reflection.Metadata.MetadataReader" /> to decode UTF-8 when
			/// no decoder is provided to the constructor.
			/// </summary>
			public static MetadataStringDecoder DefaultUTF8 { get; } = new MetadataStringDecoder(System.Text.Encoding.UTF8);


			/// <summary>
			/// Creates a <see cref="T:System.Reflection.Metadata.MetadataStringDecoder" /> for the given encoding.
			/// </summary>
			/// <param name="encoding">The encoding to use.</param>
			/// <remarks>
			/// To cache and reuse existing strings. Create a derived class and override <see cref="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)" />
			/// </remarks>
			public MetadataStringDecoder(Encoding encoding)
			{
				if (encoding == null)
				{
					System.Reflection.Throw.ArgumentNull("encoding");
				}
				Encoding = encoding;
			}

			/// <summary>
			/// The mechanism through which the <see cref="T:System.Reflection.Metadata.MetadataReader" /> obtains strings
			/// for byte sequences in metadata. Override this to cache strings if required.
			/// Otherwise, it is implemented by forwarding straight to <see cref="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding" />
			/// and every call will allocate a new string.
			/// </summary>
			/// <param name="bytes">Pointer to bytes to decode.</param>
			/// <param name="byteCount">Number of bytes to decode.</param>
			/// <returns>The decoded string.</returns>
			public unsafe virtual string GetString(byte* bytes, int byteCount)
			{
				return Encoding.GetString(bytes, byteCount);
			}
		}

		public sealed class MethodBodyBlock
		{
			private readonly System.Reflection.Internal.MemoryBlock _il;

			private readonly int _size;

			private readonly ushort _maxStack;

			private readonly bool _localVariablesInitialized;

			private readonly StandaloneSignatureHandle _localSignature;

			private readonly System.Collections.Immutable.ImmutableArray<ExceptionRegion> _exceptionRegions;

			private const byte ILTinyFormat = 2;

			private const byte ILFatFormat = 3;

			private const byte ILFormatMask = 3;

			private const int ILTinyFormatSizeShift = 2;

			private const byte ILMoreSects = 8;

			private const byte ILInitLocals = 16;

			private const byte ILFatFormatHeaderSize = 3;

			private const int ILFatFormatHeaderSizeShift = 4;

			private const byte SectEHTable = 1;

			private const byte SectFatFormat = 64;

			/// <summary>
			/// Size of the method body - includes the header, IL and exception regions.
			/// </summary>
			public int Size => _size;

			public int MaxStack => _maxStack;

			public bool LocalVariablesInitialized => _localVariablesInitialized;

			public StandaloneSignatureHandle LocalSignature => _localSignature;

			public System.Collections.Immutable.ImmutableArray<ExceptionRegion> ExceptionRegions => _exceptionRegions;

			private MethodBodyBlock(bool localVariablesInitialized, ushort maxStack, StandaloneSignatureHandle localSignatureHandle, System.Reflection.Internal.MemoryBlock il, System.Collections.Immutable.ImmutableArray<ExceptionRegion> exceptionRegions, int size)
			{
				_localVariablesInitialized = localVariablesInitialized;
				_maxStack = maxStack;
				_localSignature = localSignatureHandle;
				_il = il;
				_exceptionRegions = exceptionRegions;
				_size = size;
			}

			public byte[]? GetILBytes()
			{
				return _il.ToArray();
			}

			public System.Collections.Immutable.ImmutableArray<byte> GetILContent()
			{
				byte[] array = GetILBytes();
				return ImmutableByteArrayInterop.DangerousCreateFromUnderlyingArray(ref array);
			}

			public BlobReader GetILReader()
			{
				return new BlobReader(_il);
			}

			public static MethodBodyBlock Create(BlobReader reader)
			{
				int offset = reader.Offset;
				byte b = reader.ReadByte();
				int num;
				if ((b & 3) == 2)
				{
					num = b >> 2;
					return new MethodBodyBlock(localVariablesInitialized: false, 8, default(StandaloneSignatureHandle), reader.GetMemoryBlockAt(0, num), System.Collections.Immutable.ImmutableArray<ExceptionRegion>.Empty, 1 + num);
				}
				if ((b & 3) != 3)
				{
					throw new BadImageFormatException(System.SR.Format(MDCFR.Properties.Resources.InvalidMethodHeader1, b));
				}
				byte b2 = reader.ReadByte();
				if (b2 >> 4 != 3)
				{
					throw new BadImageFormatException(System.SR.Format(MDCFR.Properties.Resources.InvalidMethodHeader2, b, b2));
				}
				bool localVariablesInitialized = (b & 0x10) == 16;
				bool flag = (b & 8) == 8;
				ushort maxStack = reader.ReadUInt16();
				num = reader.ReadInt32();
				int num2 = reader.ReadInt32();
				StandaloneSignatureHandle localSignatureHandle;
				if (num2 == 0)
				{
					localSignatureHandle = default(StandaloneSignatureHandle);
				}
				else
				{
					if (((ulong)num2 & 0x7F000000uL) != 285212672)
					{
						throw new BadImageFormatException(System.SR.Format(MDCFR.Properties.Resources.InvalidLocalSignatureToken, (uint)num2));
					}
					localSignatureHandle = StandaloneSignatureHandle.FromRowId(num2 & 0xFFFFFF);
				}
				System.Reflection.Internal.MemoryBlock memoryBlockAt = reader.GetMemoryBlockAt(0, num);
				reader.Offset += num;
				System.Collections.Immutable.ImmutableArray<ExceptionRegion> exceptionRegions;
				if (flag)
				{
					reader.Align(4);
					byte b3 = reader.ReadByte();
					if ((b3 & 1) != 1)
					{
						throw new BadImageFormatException(System.SR.Format(MDCFR.Properties.Resources.InvalidSehHeader, b3));
					}
					bool flag2 = (b3 & 0x40) == 64;
					int num3 = reader.ReadByte();
					if (flag2)
					{
						num3 += reader.ReadUInt16() << 8;
						exceptionRegions = ReadFatExceptionHandlers(ref reader, num3 / 24);
					}
					else
					{
						reader.Offset += 2;
						exceptionRegions = ReadSmallExceptionHandlers(ref reader, num3 / 12);
					}
				}
				else
				{
					exceptionRegions = System.Collections.Immutable.ImmutableArray<ExceptionRegion>.Empty;
				}
				return new MethodBodyBlock(localVariablesInitialized, maxStack, localSignatureHandle, memoryBlockAt, exceptionRegions, reader.Offset - offset);
			}

			private static System.Collections.Immutable.ImmutableArray<ExceptionRegion> ReadSmallExceptionHandlers(ref BlobReader memReader, int count)
			{
				ExceptionRegion[] array = new ExceptionRegion[count];
				for (int i = 0; i < array.Length; i++)
				{
					ExceptionRegionKind kind = (ExceptionRegionKind)memReader.ReadUInt16();
					ushort tryOffset = memReader.ReadUInt16();
					byte tryLength = memReader.ReadByte();
					ushort handlerOffset = memReader.ReadUInt16();
					byte handlerLength = memReader.ReadByte();
					int classTokenOrFilterOffset = memReader.ReadInt32();
					array[i] = new ExceptionRegion(kind, tryOffset, tryLength, handlerOffset, handlerLength, classTokenOrFilterOffset);
				}
				return System.Collections.Immutable.ImmutableArray.Create<ExceptionRegion>(array);
			}

			private static System.Collections.Immutable.ImmutableArray<ExceptionRegion> ReadFatExceptionHandlers(ref BlobReader memReader, int count)
			{
				ExceptionRegion[] array = new ExceptionRegion[count];
				for (int i = 0; i < array.Length; i++)
				{
					ExceptionRegionKind kind = (ExceptionRegionKind)memReader.ReadUInt32();
					int tryOffset = memReader.ReadInt32();
					int tryLength = memReader.ReadInt32();
					int handlerOffset = memReader.ReadInt32();
					int handlerLength = memReader.ReadInt32();
					int classTokenOrFilterOffset = memReader.ReadInt32();
					array[i] = new ExceptionRegion(kind, tryOffset, tryLength, handlerOffset, handlerLength, classTokenOrFilterOffset);
				}
				return System.Collections.Immutable.ImmutableArray.Create<ExceptionRegion>(array);
			}
		}

		/// <summary>
		/// Debug information associated with a method definition. Stored in debug metadata.
		/// </summary>
		/// <remarks>
		/// See https://github.com/dotnet/runtime/blob/main/src/libraries/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#methoddebuginformation-table-0x31.
		/// </remarks>
		public readonly struct MethodDebugInformation
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private MethodDebugInformationHandle Handle => MethodDebugInformationHandle.FromRowId(_rowId);

			/// <summary>
			/// Returns a blob encoding sequence points, or nil if the method doesn't have sequence points.
			/// Use <see cref="M:System.Reflection.Metadata.MethodDebugInformation.GetSequencePoints" /> to decode the blob.
			/// </summary>
			public BlobHandle SequencePointsBlob => _reader.MethodDebugInformationTable.GetSequencePoints(Handle);

			/// <summary>
			/// Handle of the single document containing all sequence points of the method,
			/// or nil if the method doesn't have sequence points or spans multiple documents.
			/// </summary>
			public DocumentHandle Document => _reader.MethodDebugInformationTable.GetDocument(Handle);

			/// <summary>
			/// Returns local signature handle, or nil if the method doesn't define any local variables.
			/// </summary>
			public StandaloneSignatureHandle LocalSignature
			{
				get
				{
					if (SequencePointsBlob.IsNil)
					{
						return default(StandaloneSignatureHandle);
					}
					return StandaloneSignatureHandle.FromRowId(_reader.GetBlobReader(SequencePointsBlob).ReadCompressedInteger());
				}
			}

			internal MethodDebugInformation(MetadataReader reader, MethodDebugInformationHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}

			/// <summary>
			/// Returns a collection of sequence points decoded from <see cref="P:System.Reflection.Metadata.MethodDebugInformation.SequencePointsBlob" />.
			/// </summary>
			public SequencePointCollection GetSequencePoints()
			{
				return new SequencePointCollection(_reader.BlobHeap.GetMemoryBlock(SequencePointsBlob), Document);
			}

			/// <summary>
			/// If the method is a MoveNext method of a state machine returns the kickoff method of the state machine, otherwise returns nil handle.
			/// </summary>
			public MethodDefinitionHandle GetStateMachineKickoffMethod()
			{
				return _reader.StateMachineMethodTable.FindKickoffMethod(_rowId);
			}
		}

		public readonly struct MethodDebugInformationHandle : IEquatable<MethodDebugInformationHandle>
		{
			private const uint tokenType = 822083584u;

			private const byte tokenTypeSmall = 49;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private MethodDebugInformationHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static MethodDebugInformationHandle FromRowId(int rowId)
			{
				return new MethodDebugInformationHandle(rowId);
			}

			public static implicit operator Handle(MethodDebugInformationHandle handle)
			{
				return new Handle(49, handle._rowId);
			}

			public static implicit operator EntityHandle(MethodDebugInformationHandle handle)
			{
				return new EntityHandle((uint)(0x31000000uL | (ulong)handle._rowId));
			}

			public static explicit operator MethodDebugInformationHandle(Handle handle)
			{
				if (handle.VType != 49)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new MethodDebugInformationHandle(handle.RowId);
			}

			public static explicit operator MethodDebugInformationHandle(EntityHandle handle)
			{
				if (handle.VType != 822083584)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new MethodDebugInformationHandle(handle.RowId);
			}

			public static bool operator ==(MethodDebugInformationHandle left, MethodDebugInformationHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is MethodDebugInformationHandle methodDebugInformationHandle)
				{
					return methodDebugInformationHandle._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(MethodDebugInformationHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(MethodDebugInformationHandle left, MethodDebugInformationHandle right)
			{
				return left._rowId != right._rowId;
			}

			/// <summary>
			/// Returns a handle to <see cref="T:System.Reflection.Metadata.MethodDefinition" /> corresponding to this handle.
			/// </summary>
			/// <remarks>
			/// The resulting handle is only valid within the context of a <see cref="T:System.Reflection.Metadata.MetadataReader" /> open on the type system metadata blob,
			/// which in case of standalone PDB file is a different reader than the one containing this method debug information.
			/// </remarks>
			public MethodDefinitionHandle ToDefinitionHandle()
			{
				return MethodDefinitionHandle.FromRowId(_rowId);
			}
		}

		public readonly struct MethodDebugInformationHandleCollection : IReadOnlyCollection<MethodDebugInformationHandle>, IEnumerable<MethodDebugInformationHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<MethodDebugInformationHandle>, IDisposable, IEnumerator
			{
				private readonly MetadataReader _reader;

				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public MethodDebugInformationHandle Current => MethodDebugInformationHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal Enumerator(MetadataReader reader, int firstRowId, int lastRowId)
				{
					_reader = reader;
					_lastRowId = lastRowId;
					_currentRowId = firstRowId - 1;
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly MetadataReader _reader;

			private readonly int _firstRowId;

			private readonly int _lastRowId;

			public int Count => _lastRowId - _firstRowId + 1;

			internal MethodDebugInformationHandleCollection(MetadataReader reader)
			{
				_reader = reader;
				_firstRowId = 1;
				_lastRowId = reader.MethodDebugInformationTable.NumberOfRows;
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_reader, _firstRowId, _lastRowId);
			}

			IEnumerator<MethodDebugInformationHandle> IEnumerable<MethodDebugInformationHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public readonly struct MethodDefinition
		{
			private readonly MetadataReader _reader;

			private readonly uint _treatmentAndRowId;

			private int RowId => (int)(_treatmentAndRowId & 0xFFFFFF);

			private MethodDefTreatment Treatment => (MethodDefTreatment)(_treatmentAndRowId >> 24);

			private MethodDefinitionHandle Handle => MethodDefinitionHandle.FromRowId(RowId);

			public StringHandle Name
			{
				get
				{
					if (Treatment == MethodDefTreatment.None)
					{
						return _reader.MethodDefTable.GetName(Handle);
					}
					return GetProjectedName();
				}
			}

			public BlobHandle Signature
			{
				get
				{
					if (Treatment == MethodDefTreatment.None)
					{
						return _reader.MethodDefTable.GetSignature(Handle);
					}
					return GetProjectedSignature();
				}
			}

			public int RelativeVirtualAddress
			{
				get
				{
					if (Treatment == MethodDefTreatment.None)
					{
						return _reader.MethodDefTable.GetRva(Handle);
					}
					return GetProjectedRelativeVirtualAddress();
				}
			}

			public MethodAttributes Attributes
			{
				get
				{
					if (Treatment == MethodDefTreatment.None)
					{
						return _reader.MethodDefTable.GetFlags(Handle);
					}
					return GetProjectedFlags();
				}
			}

			public MethodImplAttributes ImplAttributes
			{
				get
				{
					if (Treatment == MethodDefTreatment.None)
					{
						return _reader.MethodDefTable.GetImplFlags(Handle);
					}
					return GetProjectedImplFlags();
				}
			}

			internal MethodDefinition(MetadataReader reader, uint treatmentAndRowId)
			{
				_reader = reader;
				_treatmentAndRowId = treatmentAndRowId;
			}

			public MethodSignature<TType> DecodeSignature<TType, TGenericContext>(ISignatureTypeProvider<TType, TGenericContext> provider, TGenericContext genericContext)
			{
				SignatureDecoder<TType, TGenericContext> signatureDecoder = new SignatureDecoder<TType, TGenericContext>(provider, _reader, genericContext);
				BlobReader blobReader = _reader.GetBlobReader(Signature);
				return signatureDecoder.DecodeMethodSignature(ref blobReader);
			}

			public TypeDefinitionHandle GetDeclaringType()
			{
				return _reader.GetDeclaringType(Handle);
			}

			public ParameterHandleCollection GetParameters()
			{
				return new ParameterHandleCollection(_reader, Handle);
			}

			public GenericParameterHandleCollection GetGenericParameters()
			{
				return _reader.GenericParamTable.FindGenericParametersForMethod(Handle);
			}

			public MethodImport GetImport()
			{
				int num = _reader.ImplMapTable.FindImplForMethod(Handle);
				if (num == 0)
				{
					return default(MethodImport);
				}
				return _reader.ImplMapTable.GetImport(num);
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, Handle);
			}

			public DeclarativeSecurityAttributeHandleCollection GetDeclarativeSecurityAttributes()
			{
				return new DeclarativeSecurityAttributeHandleCollection(_reader, Handle);
			}

			private StringHandle GetProjectedName()
			{
				if ((Treatment & MethodDefTreatment.KindMask) == MethodDefTreatment.DisposeMethod)
				{
					return StringHandle.FromVirtualIndex(StringHandle.VirtualIndex.Dispose);
				}
				return _reader.MethodDefTable.GetName(Handle);
			}

			private MethodAttributes GetProjectedFlags()
			{
				MethodAttributes methodAttributes = _reader.MethodDefTable.GetFlags(Handle);
				MethodDefTreatment treatment = Treatment;
				if ((treatment & MethodDefTreatment.KindMask) == MethodDefTreatment.HiddenInterfaceImplementation)
				{
					methodAttributes = (methodAttributes & ~MethodAttributes.MemberAccessMask) | MethodAttributes.Private;
				}
				if ((treatment & MethodDefTreatment.MarkAbstractFlag) != 0)
				{
					methodAttributes |= MethodAttributes.Abstract;
				}
				if ((treatment & MethodDefTreatment.MarkPublicFlag) != 0)
				{
					methodAttributes = (methodAttributes & ~MethodAttributes.MemberAccessMask) | MethodAttributes.Public;
				}
				return methodAttributes | MethodAttributes.HideBySig;
			}

			private MethodImplAttributes GetProjectedImplFlags()
			{
				MethodImplAttributes methodImplAttributes = _reader.MethodDefTable.GetImplFlags(Handle);
				switch (Treatment & MethodDefTreatment.KindMask)
				{
					case MethodDefTreatment.DelegateMethod:
						methodImplAttributes |= MethodImplAttributes.CodeTypeMask;
						break;
					case MethodDefTreatment.Other:
					case MethodDefTreatment.AttributeMethod:
					case MethodDefTreatment.InterfaceMethod:
					case MethodDefTreatment.HiddenInterfaceImplementation:
					case MethodDefTreatment.DisposeMethod:
						methodImplAttributes |= (MethodImplAttributes)4099;
						break;
				}
				return methodImplAttributes;
			}

			private BlobHandle GetProjectedSignature()
			{
				return _reader.MethodDefTable.GetSignature(Handle);
			}

			private static int GetProjectedRelativeVirtualAddress()
			{
				return 0;
			}
		}

		public readonly struct MethodDefinitionHandle : IEquatable<MethodDefinitionHandle>
		{
			private const uint tokenType = 100663296u;

			private const byte tokenTypeSmall = 6;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private MethodDefinitionHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static MethodDefinitionHandle FromRowId(int rowId)
			{
				return new MethodDefinitionHandle(rowId);
			}

			public static implicit operator Handle(MethodDefinitionHandle handle)
			{
				return new Handle(6, handle._rowId);
			}

			public static implicit operator EntityHandle(MethodDefinitionHandle handle)
			{
				return new EntityHandle((uint)(0x6000000uL | (ulong)handle._rowId));
			}

			public static explicit operator MethodDefinitionHandle(Handle handle)
			{
				if (handle.VType != 6)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new MethodDefinitionHandle(handle.RowId);
			}

			public static explicit operator MethodDefinitionHandle(EntityHandle handle)
			{
				if (handle.VType != 100663296)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new MethodDefinitionHandle(handle.RowId);
			}

			public static bool operator ==(MethodDefinitionHandle left, MethodDefinitionHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is MethodDefinitionHandle)
				{
					return ((MethodDefinitionHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(MethodDefinitionHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(MethodDefinitionHandle left, MethodDefinitionHandle right)
			{
				return left._rowId != right._rowId;
			}

			/// <summary>
			/// Returns a handle to <see cref="T:System.Reflection.Metadata.MethodDebugInformation" /> corresponding to this handle.
			/// </summary>
			/// <remarks>
			/// The resulting handle is only valid within the context of a <see cref="T:System.Reflection.Metadata.MetadataReader" /> open on the Portable PDB blob,
			/// which in case of standalone PDB file is a different reader than the one containing this method definition.
			/// </remarks>
			public MethodDebugInformationHandle ToDebugInformationHandle()
			{
				return MethodDebugInformationHandle.FromRowId(_rowId);
			}
		}

		public readonly struct MethodDefinitionHandleCollection : IReadOnlyCollection<MethodDefinitionHandle>, IEnumerable<MethodDefinitionHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<MethodDefinitionHandle>, IDisposable, IEnumerator
			{
				private readonly MetadataReader _reader;

				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public MethodDefinitionHandle Current
				{
					get
					{
						if (_reader.UseMethodPtrTable)
						{
							return GetCurrentMethodIndirect();
						}
						return MethodDefinitionHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));
					}
				}

				object IEnumerator.Current => Current;

				internal Enumerator(MetadataReader reader, int firstRowId, int lastRowId)
				{
					_reader = reader;
					_currentRowId = firstRowId - 1;
					_lastRowId = lastRowId;
				}

				private MethodDefinitionHandle GetCurrentMethodIndirect()
				{
					return _reader.MethodPtrTable.GetMethodFor(_currentRowId & 0xFFFFFF);
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly MetadataReader _reader;

			private readonly int _firstRowId;

			private readonly int _lastRowId;

			public int Count => _lastRowId - _firstRowId + 1;

			internal MethodDefinitionHandleCollection(MetadataReader reader)
			{
				_reader = reader;
				_firstRowId = 1;
				_lastRowId = reader.MethodDefTable.NumberOfRows;
			}

			internal MethodDefinitionHandleCollection(MetadataReader reader, TypeDefinitionHandle containingType)
			{
				_reader = reader;
				reader.GetMethodRange(containingType, out _firstRowId, out _lastRowId);
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_reader, _firstRowId, _lastRowId);
			}

			IEnumerator<MethodDefinitionHandle> IEnumerable<MethodDefinitionHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public readonly struct MethodImplementation
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private MethodImplementationHandle Handle => MethodImplementationHandle.FromRowId(_rowId);

			public TypeDefinitionHandle Type => _reader.MethodImplTable.GetClass(Handle);

			public EntityHandle MethodBody => _reader.MethodImplTable.GetMethodBody(Handle);

			public EntityHandle MethodDeclaration => _reader.MethodImplTable.GetMethodDeclaration(Handle);

			internal MethodImplementation(MetadataReader reader, MethodImplementationHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, Handle);
			}
		}

		public readonly struct MethodImplementationHandle : IEquatable<MethodImplementationHandle>
		{
			private const uint tokenType = 419430400u;

			private const byte tokenTypeSmall = 25;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private MethodImplementationHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static MethodImplementationHandle FromRowId(int rowId)
			{
				return new MethodImplementationHandle(rowId);
			}

			public static implicit operator Handle(MethodImplementationHandle handle)
			{
				return new Handle(25, handle._rowId);
			}

			public static implicit operator EntityHandle(MethodImplementationHandle handle)
			{
				return new EntityHandle((uint)(0x19000000uL | (ulong)handle._rowId));
			}

			public static explicit operator MethodImplementationHandle(Handle handle)
			{
				if (handle.VType != 25)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new MethodImplementationHandle(handle.RowId);
			}

			public static explicit operator MethodImplementationHandle(EntityHandle handle)
			{
				if (handle.VType != 419430400)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new MethodImplementationHandle(handle.RowId);
			}

			public static bool operator ==(MethodImplementationHandle left, MethodImplementationHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is MethodImplementationHandle)
				{
					return ((MethodImplementationHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(MethodImplementationHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(MethodImplementationHandle left, MethodImplementationHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		public readonly struct MethodImplementationHandleCollection : IReadOnlyCollection<MethodImplementationHandle>, IEnumerable<MethodImplementationHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<MethodImplementationHandle>, IDisposable, IEnumerator
			{
				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public MethodImplementationHandle Current => MethodImplementationHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal Enumerator(int firstRowId, int lastRowId)
				{
					_currentRowId = firstRowId - 1;
					_lastRowId = lastRowId;
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly int _firstRowId;

			private readonly int _lastRowId;

			public int Count => _lastRowId - _firstRowId + 1;

			internal MethodImplementationHandleCollection(MetadataReader reader, TypeDefinitionHandle containingType)
			{
				if (containingType.IsNil)
				{
					_firstRowId = 1;
					_lastRowId = reader.MethodImplTable.NumberOfRows;
				}
				else
				{
					reader.MethodImplTable.GetMethodImplRange(containingType, out _firstRowId, out _lastRowId);
				}
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_firstRowId, _lastRowId);
			}

			IEnumerator<MethodImplementationHandle> IEnumerable<MethodImplementationHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public readonly struct MethodImport
		{
			private readonly MethodImportAttributes _attributes;

			private readonly StringHandle _name;

			private readonly ModuleReferenceHandle _module;

			public MethodImportAttributes Attributes => _attributes;

			public StringHandle Name => _name;

			public ModuleReferenceHandle Module => _module;

			internal MethodImport(MethodImportAttributes attributes, StringHandle name, ModuleReferenceHandle module)
			{
				_attributes = attributes;
				_name = name;
				_module = module;
			}
		}

		/// <summary>
		/// Represents a method (definition, reference, or standalone) or property signature.
		/// In the case of properties, the signature matches that of a getter with a distinguishing <see cref="System.Reflection.Metadata.SignatureHeader" />.
		/// </summary>
		public readonly struct MethodSignature<TType>
		{
			/// <summary>
			/// Represents the information in the leading byte of the signature (kind, calling convention, flags).
			/// </summary>
			public SignatureHeader Header { get; }

			/// <summary>
			/// Gets the method's return type.
			/// </summary>
			public TType ReturnType { get; }

			/// <summary>
			/// Gets the number of parameters that are required. Will be equal to the length <see cref="P:System.Reflection.Metadata.MethodSignature`1.ParameterTypes" /> of
			/// unless this signature represents the standalone call site of a vararg method, in which case the entries
			/// extra entries in <see cref="P:System.Reflection.Metadata.MethodSignature`1.ParameterTypes" /> are the types used for the optional parameters.
			/// </summary>
			public int RequiredParameterCount { get; }

			/// <summary>
			/// Gets the number of generic type parameters of the method. Will be 0 for non-generic methods.
			/// </summary>
			public int GenericParameterCount { get; }

			/// <summary>
			/// Gets the method's parameter types.
			/// </summary>
			public System.Collections.Immutable.ImmutableArray<TType> ParameterTypes { get; }

			public MethodSignature(SignatureHeader header, TType returnType, int requiredParameterCount, int genericParameterCount, System.Collections.Immutable.ImmutableArray<TType> parameterTypes)
			{
				Header = header;
				ReturnType = returnType;
				GenericParameterCount = genericParameterCount;
				RequiredParameterCount = requiredParameterCount;
				ParameterTypes = parameterTypes;
			}
		}

		public readonly struct MethodSpecification
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private MethodSpecificationHandle Handle => MethodSpecificationHandle.FromRowId(_rowId);

			/// <summary>
			/// MethodDef or MemberRef handle specifying to which generic method this <see cref="T:System.Reflection.Metadata.MethodSpecification" /> refers,
			/// that is which generic method is it an instantiation of.
			/// </summary>
			public EntityHandle Method => _reader.MethodSpecTable.GetMethod(Handle);

			/// <summary>
			/// Gets a handle to the signature blob.
			/// </summary>
			public BlobHandle Signature => _reader.MethodSpecTable.GetInstantiation(Handle);

			internal MethodSpecification(MetadataReader reader, MethodSpecificationHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}

			public System.Collections.Immutable.ImmutableArray<TType> DecodeSignature<TType, TGenericContext>(ISignatureTypeProvider<TType, TGenericContext> provider, TGenericContext genericContext)
			{
				SignatureDecoder<TType, TGenericContext> signatureDecoder = new SignatureDecoder<TType, TGenericContext>(provider, _reader, genericContext);
				BlobReader blobReader = _reader.GetBlobReader(Signature);
				return signatureDecoder.DecodeMethodSpecificationSignature(ref blobReader);
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, Handle);
			}
		}

		public readonly struct MethodSpecificationHandle : IEquatable<MethodSpecificationHandle>
		{
			private const uint tokenType = 721420288u;

			private const byte tokenTypeSmall = 43;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private MethodSpecificationHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static MethodSpecificationHandle FromRowId(int rowId)
			{
				return new MethodSpecificationHandle(rowId);
			}

			public static implicit operator Handle(MethodSpecificationHandle handle)
			{
				return new Handle(43, handle._rowId);
			}

			public static implicit operator EntityHandle(MethodSpecificationHandle handle)
			{
				return new EntityHandle((uint)(0x2B000000uL | (ulong)handle._rowId));
			}

			public static explicit operator MethodSpecificationHandle(Handle handle)
			{
				if (handle.VType != 43)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new MethodSpecificationHandle(handle.RowId);
			}

			public static explicit operator MethodSpecificationHandle(EntityHandle handle)
			{
				if (handle.VType != 721420288)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new MethodSpecificationHandle(handle.RowId);
			}

			public static bool operator ==(MethodSpecificationHandle left, MethodSpecificationHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is MethodSpecificationHandle)
				{
					return ((MethodSpecificationHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(MethodSpecificationHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(MethodSpecificationHandle left, MethodSpecificationHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		public readonly struct ModuleDefinition
		{
			private readonly MetadataReader _reader;

			public int Generation => _reader.ModuleTable.GetGeneration();

			public StringHandle Name => _reader.ModuleTable.GetName();

			public GuidHandle Mvid => _reader.ModuleTable.GetMvid();

			public GuidHandle GenerationId => _reader.ModuleTable.GetEncId();

			public GuidHandle BaseGenerationId => _reader.ModuleTable.GetEncBaseId();

			internal ModuleDefinition(MetadataReader reader)
			{
				_reader = reader;
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, EntityHandle.ModuleDefinition);
			}
		}

		public readonly struct ModuleDefinitionHandle : IEquatable<ModuleDefinitionHandle>
		{
			private const uint tokenType = 0u;

			private const byte tokenTypeSmall = 0;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			internal ModuleDefinitionHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static ModuleDefinitionHandle FromRowId(int rowId)
			{
				return new ModuleDefinitionHandle(rowId);
			}

			public static implicit operator Handle(ModuleDefinitionHandle handle)
			{
				return new Handle(0, handle._rowId);
			}

			public static implicit operator EntityHandle(ModuleDefinitionHandle handle)
			{
				return new EntityHandle((uint)(0uL | (ulong)handle._rowId));
			}

			public static explicit operator ModuleDefinitionHandle(Handle handle)
			{
				if (handle.VType != 0)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new ModuleDefinitionHandle(handle.RowId);
			}

			public static explicit operator ModuleDefinitionHandle(EntityHandle handle)
			{
				if (handle.VType != 0)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new ModuleDefinitionHandle(handle.RowId);
			}

			public static bool operator ==(ModuleDefinitionHandle left, ModuleDefinitionHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is ModuleDefinitionHandle moduleDefinitionHandle)
				{
					return moduleDefinitionHandle._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(ModuleDefinitionHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(ModuleDefinitionHandle left, ModuleDefinitionHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		public readonly struct ModuleReference
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private ModuleReferenceHandle Handle => ModuleReferenceHandle.FromRowId(_rowId);

			public StringHandle Name => _reader.ModuleRefTable.GetName(Handle);

			internal ModuleReference(MetadataReader reader, ModuleReferenceHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, Handle);
			}
		}

		public readonly struct ModuleReferenceHandle : IEquatable<ModuleReferenceHandle>
		{
			private const uint tokenType = 436207616u;

			private const byte tokenTypeSmall = 26;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private ModuleReferenceHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static ModuleReferenceHandle FromRowId(int rowId)
			{
				return new ModuleReferenceHandle(rowId);
			}

			public static implicit operator Handle(ModuleReferenceHandle handle)
			{
				return new Handle(26, handle._rowId);
			}

			public static implicit operator EntityHandle(ModuleReferenceHandle handle)
			{
				return new EntityHandle((uint)(0x1A000000uL | (ulong)handle._rowId));
			}

			public static explicit operator ModuleReferenceHandle(Handle handle)
			{
				if (handle.VType != 26)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new ModuleReferenceHandle(handle.RowId);
			}

			public static explicit operator ModuleReferenceHandle(EntityHandle handle)
			{
				if (handle.VType != 436207616)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new ModuleReferenceHandle(handle.RowId);
			}

			public static bool operator ==(ModuleReferenceHandle left, ModuleReferenceHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is ModuleReferenceHandle)
				{
					return ((ModuleReferenceHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(ModuleReferenceHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(ModuleReferenceHandle left, ModuleReferenceHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		public struct NamespaceDefinition
		{
			private readonly NamespaceData _data;

			/// <summary>
			/// Gets the unqualified name of the NamespaceDefinition.
			/// </summary>
			public StringHandle Name => _data.Name;

			/// <summary>
			/// Gets the parent namespace.
			/// </summary>
			public NamespaceDefinitionHandle Parent => _data.Parent;

			/// <summary>
			/// Gets the namespace definitions that are direct children of the current
			/// namespace definition.
			///
			/// System.Collections and System.Linq are direct children of System.
			/// System.Collections.Generic is a direct child of System.Collections.
			/// System.Collections.Generic is *not* a direct child of System.
			/// </summary>
			public System.Collections.Immutable.ImmutableArray<NamespaceDefinitionHandle> NamespaceDefinitions => _data.NamespaceDefinitions;

			/// <summary>
			/// Gets all type definitions that reside directly in a namespace.
			/// </summary>
			public System.Collections.Immutable.ImmutableArray<TypeDefinitionHandle> TypeDefinitions => _data.TypeDefinitions;

			/// <summary>
			/// Gets all exported types that reside directly in a namespace.
			/// </summary>
			public System.Collections.Immutable.ImmutableArray<ExportedTypeHandle> ExportedTypes => _data.ExportedTypes;

			internal NamespaceDefinition(NamespaceData data)
			{
				_data = data;
			}
		}

		/// <summary>
		/// A handle that represents a namespace definition.
		/// </summary>
		public readonly struct NamespaceDefinitionHandle : IEquatable<NamespaceDefinitionHandle>
		{
			private readonly uint _value;

			public bool IsNil => _value == 0;

			internal bool IsVirtual => (_value & 0x80000000u) != 0;

			internal bool HasFullName => !IsVirtual;

			private NamespaceDefinitionHandle(uint value)
			{
				_value = value;
			}

			internal static NamespaceDefinitionHandle FromFullNameOffset(int stringHeapOffset)
			{
				return new NamespaceDefinitionHandle((uint)stringHeapOffset);
			}

			internal static NamespaceDefinitionHandle FromVirtualIndex(uint virtualIndex)
			{
				if (!System.Reflection.Metadata.Ecma335.HeapHandleType.IsValidHeapOffset(virtualIndex))
				{
					System.Reflection.Throw.TooManySubnamespaces();
				}
				return new NamespaceDefinitionHandle(0x80000000u | virtualIndex);
			}

			public static implicit operator Handle(NamespaceDefinitionHandle handle)
			{
				return new Handle((byte)(((handle._value & 0x80000000u) >> 24) | 0x7Cu), (int)(handle._value & 0x1FFFFFFF));
			}

			public static explicit operator NamespaceDefinitionHandle(Handle handle)
			{
				if ((handle.VType & 0x7F) != 124)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new NamespaceDefinitionHandle((uint)(((handle.VType & 0x80) << 24) | handle.Offset));
			}

			internal int GetHeapOffset()
			{
				return (int)(_value & 0x1FFFFFFF);
			}

			internal StringHandle GetFullName()
			{
				return StringHandle.FromOffset(GetHeapOffset());
			}

			public override bool Equals([NotNullWhen(true)] object? obj)
			{
				if (obj is NamespaceDefinitionHandle other)
				{
					return Equals(other);
				}
				return false;
			}

			public bool Equals(NamespaceDefinitionHandle other)
			{
				return _value == other._value;
			}

			public override int GetHashCode()
			{
				return (int)_value;
			}

			public static bool operator ==(NamespaceDefinitionHandle left, NamespaceDefinitionHandle right)
			{
				return left.Equals(right);
			}

			public static bool operator !=(NamespaceDefinitionHandle left, NamespaceDefinitionHandle right)
			{
				return !left.Equals(right);
			}
		}

		public readonly struct Parameter
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private ParameterHandle Handle => ParameterHandle.FromRowId(_rowId);

			public ParameterAttributes Attributes => _reader.ParamTable.GetFlags(Handle);

			public int SequenceNumber => _reader.ParamTable.GetSequence(Handle);

			public StringHandle Name => _reader.ParamTable.GetName(Handle);

			internal Parameter(MetadataReader reader, ParameterHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}

			public ConstantHandle GetDefaultValue()
			{
				return _reader.ConstantTable.FindConstant(Handle);
			}

			public BlobHandle GetMarshallingDescriptor()
			{
				int num = _reader.FieldMarshalTable.FindFieldMarshalRowId(Handle);
				if (num == 0)
				{
					return default(BlobHandle);
				}
				return _reader.FieldMarshalTable.GetNativeType(num);
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, Handle);
			}
		}

		public readonly struct ParameterHandle : IEquatable<ParameterHandle>
		{
			private const uint tokenType = 134217728u;

			private const byte tokenTypeSmall = 8;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private ParameterHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static ParameterHandle FromRowId(int rowId)
			{
				return new ParameterHandle(rowId);
			}

			public static implicit operator Handle(ParameterHandle handle)
			{
				return new Handle(8, handle._rowId);
			}

			public static implicit operator EntityHandle(ParameterHandle handle)
			{
				return new EntityHandle((uint)(0x8000000uL | (ulong)handle._rowId));
			}

			public static explicit operator ParameterHandle(Handle handle)
			{
				if (handle.VType != 8)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new ParameterHandle(handle.RowId);
			}

			public static explicit operator ParameterHandle(EntityHandle handle)
			{
				if (handle.VType != 134217728)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new ParameterHandle(handle.RowId);
			}

			public static bool operator ==(ParameterHandle left, ParameterHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is ParameterHandle)
				{
					return ((ParameterHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(ParameterHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(ParameterHandle left, ParameterHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		/// <summary>
		/// Collection of parameters of a specified method.
		/// </summary>
		public readonly struct ParameterHandleCollection : IReadOnlyCollection<ParameterHandle>, IEnumerable<ParameterHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<ParameterHandle>, IDisposable, IEnumerator
			{
				private readonly MetadataReader _reader;

				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public ParameterHandle Current
				{
					get
					{
						if (_reader.UseParamPtrTable)
						{
							return GetCurrentParameterIndirect();
						}
						return ParameterHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));
					}
				}

				object IEnumerator.Current => Current;

				internal Enumerator(MetadataReader reader, int firstRowId, int lastRowId)
				{
					_reader = reader;
					_lastRowId = lastRowId;
					_currentRowId = firstRowId - 1;
				}

				private ParameterHandle GetCurrentParameterIndirect()
				{
					return _reader.ParamPtrTable.GetParamFor(_currentRowId & 0xFFFFFF);
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly MetadataReader _reader;

			private readonly int _firstRowId;

			private readonly int _lastRowId;

			public int Count => _lastRowId - _firstRowId + 1;

			internal ParameterHandleCollection(MetadataReader reader, MethodDefinitionHandle containingMethod)
			{
				_reader = reader;
				reader.GetParameterRange(containingMethod, out _firstRowId, out _lastRowId);
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_reader, _firstRowId, _lastRowId);
			}

			IEnumerator<ParameterHandle> IEnumerable<ParameterHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		internal static class PathUtilities
		{
			private const char DirectorySeparatorChar = '\\';

			private const char AltDirectorySeparatorChar = '/';

			private const char VolumeSeparatorChar = ':';

			private static string s_platformSpecificDirectorySeparator;

			private static string PlatformSpecificDirectorySeparator => s_platformSpecificDirectorySeparator ?? (s_platformSpecificDirectorySeparator = ((Array.IndexOf(Path.GetInvalidFileNameChars(), '*') >= 0) ? '\\' : '/').ToString());

			/// <summary>
			/// Returns the position in given path where the file name starts.
			/// </summary>
			/// <returns>-1 if path is null.</returns>
			internal static int IndexOfFileName(string path)
			{
				if (path == null)
				{
					return -1;
				}
				for (int num = path.Length - 1; num >= 0; num--)
				{
					char c = path[num];
					if (c == '\\' || c == '/' || c == ':')
					{
						return num + 1;
					}
				}
				return 0;
			}

			/// <summary>
			/// Get file name from path.
			/// </summary>
			/// <remarks>Unlike <see cref="M:System.IO.Path.GetFileName(System.String)" /> this method doesn't check for invalid path characters.</remarks>
			internal static string GetFileName(string path, bool includeExtension = true)
			{
				int num = IndexOfFileName(path);
				if (num > 0)
				{
					return path.Substring(num);
				}
				return path;
			}

			internal static string CombinePathWithRelativePath(string root, string relativePath)
			{
				if (root.Length == 0)
				{
					return relativePath;
				}
				char c = root[root.Length - 1];
				if (c == '\\' || c == '/' || c == ':')
				{
					return root + relativePath;
				}
				return root + PlatformSpecificDirectorySeparator + relativePath;
			}
		}

		[EditorBrowsable(EditorBrowsableState.Never)]
		public static class PEReaderExtensions
		{
			/// <summary>
			/// Returns a body block of a method with specified Relative Virtual Address (RVA);
			/// </summary>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="peReader" /> is null.</exception>
			/// <exception cref="T:System.BadImageFormatException">The body is not found in the metadata or is invalid.</exception>
			/// <exception cref="T:System.InvalidOperationException">Section where the method is stored is not available.</exception>
			/// <exception cref="T:System.IO.IOException">IO error while reading from the underlying stream.</exception>
			public static MethodBodyBlock GetMethodBody(this PEReader peReader, int relativeVirtualAddress)
			{
				if (peReader == null)
				{
					System.Reflection.Throw.ArgumentNull("peReader");
				}
				PEMemoryBlock sectionData = peReader.GetSectionData(relativeVirtualAddress);
				if (sectionData.Length == 0)
				{
					throw new BadImageFormatException(System.SR.Format(MDCFR.Properties.Resources.InvalidMethodRva, relativeVirtualAddress));
				}
				return MethodBodyBlock.Create(sectionData.GetReader());
			}

			/// <summary>
			/// Gets a <see cref="T:System.Reflection.Metadata.MetadataReader" /> from a <see cref="T:System.Reflection.PortableExecutable.PEReader" />.
			/// </summary>
			/// <remarks>
			/// The caller must keep the <see cref="T:System.Reflection.PortableExecutable.PEReader" /> alive and undisposed throughout the lifetime of the metadata reader.
			/// </remarks>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="peReader" /> is null</exception>
			/// <exception cref="T:System.PlatformNotSupportedException">The current platform is big-endian.</exception>
			/// <exception cref="T:System.IO.IOException">IO error while reading from the underlying stream.</exception>
			public static MetadataReader GetMetadataReader(this PEReader peReader)
			{
				return peReader.GetMetadataReader(MetadataReaderOptions.Default, null);
			}

			/// <summary>
			/// Gets a <see cref="T:System.Reflection.Metadata.MetadataReader" /> from a <see cref="T:System.Reflection.PortableExecutable.PEReader" />.
			/// </summary>
			/// <remarks>
			/// The caller must keep the <see cref="T:System.Reflection.PortableExecutable.PEReader" /> alive and undisposed throughout the lifetime of the metadata reader.
			/// </remarks>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="peReader" /> is null</exception>
			/// <exception cref="T:System.PlatformNotSupportedException">The current platform is big-endian.</exception>
			/// <exception cref="T:System.IO.IOException">IO error while reading from the underlying stream.</exception>
			public static MetadataReader GetMetadataReader(this PEReader peReader, MetadataReaderOptions options)
			{
				return peReader.GetMetadataReader(options, null);
			}

			/// <summary>
			/// Gets a <see cref="T:System.Reflection.Metadata.MetadataReader" /> from a <see cref="T:System.Reflection.PortableExecutable.PEReader" />.
			/// </summary>
			/// <remarks>
			/// The caller must keep the <see cref="T:System.Reflection.PortableExecutable.PEReader" /> undisposed throughout the lifetime of the metadata reader.
			/// </remarks>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="peReader" /> is null</exception>
			/// <exception cref="T:System.ArgumentException">The encoding of <paramref name="utf8Decoder" /> is not <see cref="T:System.Text.UTF8Encoding" />.</exception>
			/// <exception cref="T:System.PlatformNotSupportedException">The current platform is big-endian.</exception>
			/// <exception cref="T:System.IO.IOException">IO error while reading from the underlying stream.</exception>
			public unsafe static MetadataReader GetMetadataReader(this PEReader peReader, MetadataReaderOptions options, MetadataStringDecoder? utf8Decoder)
			{
				if (peReader == null)
				{
					System.Reflection.Throw.ArgumentNull("peReader");
				}
				PEMemoryBlock metadata = peReader.GetMetadata();
				return new MetadataReader(metadata.Pointer, metadata.Length, options, utf8Decoder, peReader);
			}
		}

		internal sealed class PooledBlobBuilder : BlobBuilder
		{
			private const int PoolSize = 128;

			private const int ChunkSize = 1024;

			private static readonly System.Reflection.Internal.ObjectPool<PooledBlobBuilder> s_chunkPool = new System.Reflection.Internal.ObjectPool<PooledBlobBuilder>(() => new PooledBlobBuilder(1024), 128);

			private PooledBlobBuilder(int size)
				: base(size)
			{
			}

			public static PooledBlobBuilder GetInstance()
			{
				return s_chunkPool.Allocate();
			}

			protected override BlobBuilder AllocateChunk(int minimalSize)
			{
				if (minimalSize <= 1024)
				{
					return s_chunkPool.Allocate();
				}
				return new BlobBuilder(minimalSize);
			}

			protected override void FreeChunk()
			{
				s_chunkPool.Free(this);
			}

			public new void Free()
			{
				base.Free();
			}
		}

		internal static class PortablePdbVersions
		{
			/// <summary>
			/// Version of Portable PDB format emitted by the writer by default. Metadata version string.
			/// </summary>
			internal const string DefaultMetadataVersion = "PDB v1.0";

			/// <summary>
			/// Version of Portable PDB format emitted by the writer by default.
			/// </summary>
			internal const ushort DefaultFormatVersion = 256;

			/// <summary>
			/// Minimal supported version of Portable PDB format.
			/// </summary>
			internal const ushort MinFormatVersion = 256;

			/// <summary>
			/// Minimal supported version of Embedded Portable PDB blob.
			/// </summary>
			internal const ushort MinEmbeddedVersion = 256;

			/// <summary>
			/// Version of Embedded Portable PDB blob format emitted by the writer by default.
			/// </summary>
			internal const ushort DefaultEmbeddedVersion = 256;

			/// <summary>
			/// Minimal version of the Embedded Portable PDB blob that the current reader can't interpret.
			/// </summary>
			internal const ushort MinUnsupportedEmbeddedVersion = 512;

			internal const uint DebugDirectoryEmbeddedSignature = 1111773261u;

			internal const ushort PortableCodeViewVersionMagic = 20557;

			internal static uint DebugDirectoryEntryVersion(ushort portablePdbVersion)
			{
				return 0x504D0000u | portablePdbVersion;
			}

			internal static uint DebugDirectoryEmbeddedVersion(ushort portablePdbVersion)
			{
				return 0x1000000u | portablePdbVersion;
			}

			internal static string Format(ushort version)
			{
				return (version >> 8) + "." + (version & 0xFF);
			}
		}

		/// <summary>
		/// Type codes used to encode types of primitive values in Custom Attribute value blob.
		/// </summary>
		public enum PrimitiveSerializationTypeCode : byte
		{
			Boolean = 2,
			Byte = 5,
			SByte = 4,
			Char = 3,
			Int16 = 6,
			UInt16 = 7,
			Int32 = 8,
			UInt32 = 9,
			Int64 = 10,
			UInt64 = 11,
			Single = 12,
			Double = 13,
			String = 14
		}

		/// <summary>
		/// Represents a primitive type found in metadata signatures.
		/// </summary>
		public enum PrimitiveTypeCode : byte
		{
			Boolean = 2,
			Byte = 5,
			SByte = 4,
			Char = 3,
			Int16 = 6,
			UInt16 = 7,
			Int32 = 8,
			UInt32 = 9,
			Int64 = 10,
			UInt64 = 11,
			Single = 12,
			Double = 13,
			IntPtr = 24,
			UIntPtr = 25,
			Object = 28,
			String = 14,
			TypedReference = 22,
			Void = 1
		}

		public readonly struct PropertyAccessors
		{
			private readonly int _getterRowId;

			private readonly int _setterRowId;

			private readonly System.Collections.Immutable.ImmutableArray<MethodDefinitionHandle> _others;

			public MethodDefinitionHandle Getter => MethodDefinitionHandle.FromRowId(_getterRowId);

			public MethodDefinitionHandle Setter => MethodDefinitionHandle.FromRowId(_setterRowId);

			public System.Collections.Immutable.ImmutableArray<MethodDefinitionHandle> Others => _others;

			internal PropertyAccessors(int getterRowId, int setterRowId, System.Collections.Immutable.ImmutableArray<MethodDefinitionHandle> others)
			{
				_getterRowId = getterRowId;
				_setterRowId = setterRowId;
				_others = others;
			}
		}

		public readonly struct PropertyDefinition
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private PropertyDefinitionHandle Handle => PropertyDefinitionHandle.FromRowId(_rowId);

			public StringHandle Name => _reader.PropertyTable.GetName(Handle);

			public PropertyAttributes Attributes => _reader.PropertyTable.GetFlags(Handle);

			public BlobHandle Signature => _reader.PropertyTable.GetSignature(Handle);

			internal PropertyDefinition(MetadataReader reader, PropertyDefinitionHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}

			public MethodSignature<TType> DecodeSignature<TType, TGenericContext>(ISignatureTypeProvider<TType, TGenericContext> provider, TGenericContext genericContext)
			{
				SignatureDecoder<TType, TGenericContext> signatureDecoder = new SignatureDecoder<TType, TGenericContext>(provider, _reader, genericContext);
				BlobReader blobReader = _reader.GetBlobReader(Signature);
				return signatureDecoder.DecodeMethodSignature(ref blobReader);
			}

			public ConstantHandle GetDefaultValue()
			{
				return _reader.ConstantTable.FindConstant(Handle);
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, Handle);
			}

			public PropertyAccessors GetAccessors()
			{
				int getterRowId = 0;
				int setterRowId = 0;
				System.Collections.Immutable.ImmutableArray<MethodDefinitionHandle>.Builder builder = null;
				ushort methodCount;
				int num = _reader.MethodSemanticsTable.FindSemanticMethodsForProperty(Handle, out methodCount);
				for (ushort num2 = 0; num2 < methodCount; num2 = (ushort)(num2 + 1))
				{
					int rowId = num + num2;
					switch (_reader.MethodSemanticsTable.GetSemantics(rowId))
					{
						case MethodSemanticsAttributes.Getter:
							getterRowId = _reader.MethodSemanticsTable.GetMethod(rowId).RowId;
							break;
						case MethodSemanticsAttributes.Setter:
							setterRowId = _reader.MethodSemanticsTable.GetMethod(rowId).RowId;
							break;
						case MethodSemanticsAttributes.Other:
							if (builder == null)
							{
								builder = System.Collections.Immutable.ImmutableArray.CreateBuilder<MethodDefinitionHandle>();
							}
							builder.Add(_reader.MethodSemanticsTable.GetMethod(rowId));
							break;
					}
				}
				System.Collections.Immutable.ImmutableArray<MethodDefinitionHandle> others = builder?.ToImmutable() ?? System.Collections.Immutable.ImmutableArray<MethodDefinitionHandle>.Empty;
				return new PropertyAccessors(getterRowId, setterRowId, others);
			}
		}

		public readonly struct PropertyDefinitionHandle : IEquatable<PropertyDefinitionHandle>
		{
			private const uint tokenType = 385875968u;

			private const byte tokenTypeSmall = 23;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private PropertyDefinitionHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static PropertyDefinitionHandle FromRowId(int rowId)
			{
				return new PropertyDefinitionHandle(rowId);
			}

			public static implicit operator Handle(PropertyDefinitionHandle handle)
			{
				return new Handle(23, handle._rowId);
			}

			public static implicit operator EntityHandle(PropertyDefinitionHandle handle)
			{
				return new EntityHandle((uint)(0x17000000uL | (ulong)handle._rowId));
			}

			public static explicit operator PropertyDefinitionHandle(Handle handle)
			{
				if (handle.VType != 23)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new PropertyDefinitionHandle(handle.RowId);
			}

			public static explicit operator PropertyDefinitionHandle(EntityHandle handle)
			{
				if (handle.VType != 385875968)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new PropertyDefinitionHandle(handle.RowId);
			}

			public static bool operator ==(PropertyDefinitionHandle left, PropertyDefinitionHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is PropertyDefinitionHandle)
				{
					return ((PropertyDefinitionHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(PropertyDefinitionHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(PropertyDefinitionHandle left, PropertyDefinitionHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		public readonly struct PropertyDefinitionHandleCollection : IReadOnlyCollection<PropertyDefinitionHandle>, IEnumerable<PropertyDefinitionHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<PropertyDefinitionHandle>, IDisposable, IEnumerator
			{
				private readonly MetadataReader _reader;

				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public PropertyDefinitionHandle Current
				{
					get
					{
						if (_reader.UsePropertyPtrTable)
						{
							return GetCurrentPropertyIndirect();
						}
						return PropertyDefinitionHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));
					}
				}

				object IEnumerator.Current => Current;

				internal Enumerator(MetadataReader reader, int firstRowId, int lastRowId)
				{
					_reader = reader;
					_currentRowId = firstRowId - 1;
					_lastRowId = lastRowId;
				}

				private PropertyDefinitionHandle GetCurrentPropertyIndirect()
				{
					return _reader.PropertyPtrTable.GetPropertyFor(_currentRowId & 0xFFFFFF);
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly MetadataReader _reader;

			private readonly int _firstRowId;

			private readonly int _lastRowId;

			public int Count => _lastRowId - _firstRowId + 1;

			internal PropertyDefinitionHandleCollection(MetadataReader reader)
			{
				_reader = reader;
				_firstRowId = 1;
				_lastRowId = reader.PropertyTable.NumberOfRows;
			}

			internal PropertyDefinitionHandleCollection(MetadataReader reader, TypeDefinitionHandle containingType)
			{
				_reader = reader;
				reader.GetPropertyRange(containingType, out _firstRowId, out _lastRowId);
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_reader, _firstRowId, _lastRowId);
			}

			IEnumerator<PropertyDefinitionHandle> IEnumerable<PropertyDefinitionHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		/// <summary>
		/// Represents a handle and a corresponding blob on a metadata heap that was reserved for future content update.
		/// </summary>
		public readonly struct ReservedBlob<THandle> where THandle : struct
		{
			public THandle Handle { get; }

			public Blob Content { get; }

			internal ReservedBlob(THandle handle, Blob content)
			{
				Handle = handle;
				Content = content;
			}

			/// <summary>
			/// Returns a <see cref="T:System.Reflection.Metadata.BlobWriter" /> to be used to update the content.
			/// </summary>
			public BlobWriter CreateWriter()
			{
				return new BlobWriter(Content);
			}
		}

		[DebuggerDisplay("{GetDebuggerDisplay(),nq}")]
		public readonly struct SequencePoint : IEquatable<SequencePoint>
		{
			public const int HiddenLine = 16707566;

			public DocumentHandle Document { get; }

			public int Offset { get; }

			public int StartLine { get; }

			public int EndLine { get; }

			public int StartColumn { get; }

			public int EndColumn { get; }

			public bool IsHidden => StartLine == 16707566;

			internal SequencePoint(DocumentHandle document, int offset)
			{
				Document = document;
				Offset = offset;
				StartLine = 16707566;
				StartColumn = 0;
				EndLine = 16707566;
				EndColumn = 0;
			}

			internal SequencePoint(DocumentHandle document, int offset, int startLine, ushort startColumn, int endLine, ushort endColumn)
			{
				Document = document;
				Offset = offset;
				StartLine = startLine;
				StartColumn = startColumn;
				EndLine = endLine;
				EndColumn = endColumn;
			}

			public override int GetHashCode()
			{
				return System.Reflection.Internal.Hash.Combine(Document.RowId, System.Reflection.Internal.Hash.Combine(Offset, System.Reflection.Internal.Hash.Combine(StartLine, System.Reflection.Internal.Hash.Combine(StartColumn, System.Reflection.Internal.Hash.Combine(EndLine, EndColumn)))));
			}

			public override bool Equals([NotNullWhen(true)] object? obj)
			{
				if (obj is SequencePoint other)
				{
					return Equals(other);
				}
				return false;
			}

			public bool Equals(SequencePoint other)
			{
				if (Document == other.Document && Offset == other.Offset && StartLine == other.StartLine && StartColumn == other.StartColumn && EndLine == other.EndLine)
				{
					return EndColumn == other.EndColumn;
				}
				return false;
			}

			private string GetDebuggerDisplay()
			{
				if (!IsHidden)
				{
					return $"{Offset}: ({StartLine}, {StartColumn}) - ({EndLine}, {EndColumn})";
				}
				return "<hidden>";
			}
		}

		public readonly struct SequencePointCollection : IEnumerable<SequencePoint>, IEnumerable
		{
			public struct Enumerator : IEnumerator<SequencePoint>, IDisposable, IEnumerator
			{
				private BlobReader _reader;

				private SequencePoint _current;

				private int _previousNonHiddenStartLine;

				private ushort _previousNonHiddenStartColumn;

				public SequencePoint Current => _current;

				object IEnumerator.Current => _current;

				internal Enumerator(System.Reflection.Internal.MemoryBlock block, DocumentHandle document)
				{
					_reader = new BlobReader(block);
					_current = new SequencePoint(document, -1);
					_previousNonHiddenStartLine = -1;
					_previousNonHiddenStartColumn = 0;
				}

				public bool MoveNext()
				{
					if (_reader.RemainingBytes == 0)
					{
						return false;
					}
					DocumentHandle document = _current.Document;
					int offset;
					if (_reader.Offset == 0)
					{
						_reader.ReadCompressedInteger();
						if (document.IsNil)
						{
							document = ReadDocumentHandle();
						}
						offset = _reader.ReadCompressedInteger();
					}
					else
					{
						int delta;
						while ((delta = _reader.ReadCompressedInteger()) == 0)
						{
							document = ReadDocumentHandle();
						}
						offset = AddOffsets(_current.Offset, delta);
					}
					ReadDeltaLinesAndColumns(out var deltaLines, out var deltaColumns);
					if (deltaLines == 0 && deltaColumns == 0)
					{
						_current = new SequencePoint(document, offset);
						return true;
					}
					int num;
					ushort num2;
					if (_previousNonHiddenStartLine < 0)
					{
						num = ReadLine();
						num2 = ReadColumn();
					}
					else
					{
						num = AddLines(_previousNonHiddenStartLine, _reader.ReadCompressedSignedInteger());
						num2 = AddColumns(_previousNonHiddenStartColumn, _reader.ReadCompressedSignedInteger());
					}
					_previousNonHiddenStartLine = num;
					_previousNonHiddenStartColumn = num2;
					_current = new SequencePoint(document, offset, num, num2, AddLines(num, deltaLines), AddColumns(num2, deltaColumns));
					return true;
				}

				private void ReadDeltaLinesAndColumns(out int deltaLines, out int deltaColumns)
				{
					deltaLines = _reader.ReadCompressedInteger();
					deltaColumns = ((deltaLines == 0) ? _reader.ReadCompressedInteger() : _reader.ReadCompressedSignedInteger());
				}

				private int ReadLine()
				{
					return _reader.ReadCompressedInteger();
				}

				private ushort ReadColumn()
				{
					int num = _reader.ReadCompressedInteger();
					if (num > 65535)
					{
						System.Reflection.Throw.SequencePointValueOutOfRange();
					}
					return (ushort)num;
				}

				private static int AddOffsets(int value, int delta)
				{
					int num = value + delta;
					if (num < 0)
					{
						System.Reflection.Throw.SequencePointValueOutOfRange();
					}
					return num;
				}

				private static int AddLines(int value, int delta)
				{
					int num = value + delta;
					if (num < 0 || num >= 16707566)
					{
						System.Reflection.Throw.SequencePointValueOutOfRange();
					}
					return num;
				}

				private static ushort AddColumns(ushort value, int delta)
				{
					int num = value + delta;
					if (num < 0 || num >= 65535)
					{
						System.Reflection.Throw.SequencePointValueOutOfRange();
					}
					return (ushort)num;
				}

				private DocumentHandle ReadDocumentHandle()
				{
					int num = _reader.ReadCompressedInteger();
					if (num == 0 || !System.Reflection.Metadata.Ecma335.TokenTypeIds.IsValidRowId(num))
					{
						System.Reflection.Throw.InvalidHandle();
					}
					return DocumentHandle.FromRowId(num);
				}

				public void Reset()
				{
					_reader.Reset();
					_current = default(SequencePoint);
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly System.Reflection.Internal.MemoryBlock _block;

			private readonly DocumentHandle _document;

			internal SequencePointCollection(System.Reflection.Internal.MemoryBlock block, DocumentHandle document)
			{
				_block = block;
				_document = document;
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_block, _document);
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator<SequencePoint> IEnumerable<SequencePoint>.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		/// <summary>
		/// Type codes used to encode types of values in Custom Attribute value blob.
		/// </summary>
		public enum SerializationTypeCode : byte
		{
			/// <summary>
			/// Equivalent to <see cref="System.Reflection.Metadata.SignatureTypeCode.Invalid" />.
			/// </summary>
			Invalid = 0,
			/// <summary>
			/// Equivalent to <see cref="System.Reflection.Metadata.SignatureTypeCode.Boolean" />.
			/// </summary>
			Boolean = 2,
			/// <summary>
			/// Equivalent to <see cref="System.Reflection.Metadata.SignatureTypeCode.Char" />.
			/// </summary>
			Char = 3,
			/// <summary>
			/// Equivalent to <see cref="System.Reflection.Metadata.SignatureTypeCode.SByte" />.
			/// </summary>
			SByte = 4,
			/// <summary>
			/// Equivalent to <see cref="System.Reflection.Metadata.SignatureTypeCode.Byte" />.
			/// </summary>
			Byte = 5,
			/// <summary>
			/// Equivalent to <see cref="System.Reflection.Metadata.SignatureTypeCode.Int16" />.
			/// </summary>
			Int16 = 6,
			/// <summary>
			/// Equivalent to <see cref="System.Reflection.Metadata.SignatureTypeCode.UInt16" />.
			/// </summary>
			UInt16 = 7,
			/// <summary>
			/// Equivalent to <see cref="System.Reflection.Metadata.SignatureTypeCode.Int32" />.
			/// </summary>
			Int32 = 8,
			/// <summary>
			/// Equivalent to <see cref="System.Reflection.Metadata.SignatureTypeCode.UInt32" />.
			/// </summary>
			UInt32 = 9,
			/// <summary>
			/// Equivalent to <see cref="System.Reflection.Metadata.SignatureTypeCode.Int64" />.
			/// </summary>
			Int64 = 10,
			/// <summary>
			/// Equivalent to <see cref="System.Reflection.Metadata.SignatureTypeCode.UInt64" />.
			/// </summary>
			UInt64 = 11,
			/// <summary>
			/// Equivalent to <see cref="System.Reflection.Metadata.SignatureTypeCode.Single" />.
			/// </summary>
			Single = 12,
			/// <summary>
			/// Equivalent to <see cref="System.Reflection.Metadata.SignatureTypeCode.Double" />.
			/// </summary>
			Double = 13,
			/// <summary>
			/// Equivalent to <see cref="System.Reflection.Metadata.SignatureTypeCode.String" />.
			/// </summary>
			String = 14,
			/// <summary>
			/// Equivalent to <see cref="System.Reflection.Metadata.SignatureTypeCode.SZArray" />.
			/// </summary>
			SZArray = 29,
			/// <summary>
			/// The attribute argument is a System.Type instance.
			/// </summary>
			Type = 80,
			/// <summary>
			/// The attribute argument is "boxed" (passed to a parameter, field, or property of type object) and carries type information in the attribute blob.
			/// </summary>
			TaggedObject = 81,
			/// <summary>
			/// The attribute argument is an Enum instance.
			/// </summary>
			Enum = 85
		}

		/// <summary>
		/// Specified additional flags that can be applied to method signatures.
		/// Underlying values correspond to the representation in the leading signature
		/// byte represented by <see cref="T:System.Reflection.Metadata.SignatureHeader" />.
		/// </summary>
		[Flags]
		public enum SignatureAttributes : byte
		{
			/// <summary>
			/// No flags.
			/// </summary>
			None = 0,
			/// <summary>
			/// Generic method.
			/// </summary>
			Generic = 0x10,
			/// <summary>
			/// Instance method.
			/// </summary>
			/// <remarks>Ecma 335 CLI Specification refers to this flag as HAS_THIS.</remarks>
			Instance = 0x20,
			/// <summary>
			/// The first explicitly declared parameter represents the instance pointer.
			/// </summary>
			ExplicitThis = 0x40
		}

		/// <summary>
		/// Specifies how arguments in a given signature are passed from the caller to the callee.
		/// Underlying values correspond to the representation in the leading signature byte
		/// represented by <see cref="System.Reflection.Metadata.SignatureHeader" />.
		/// </summary>
		public enum SignatureCallingConvention : byte
		{
			/// <summary>
			/// Managed calling convention with fixed-length argument list.
			/// </summary>
			Default = 0,
			/// <summary>
			/// Unmanaged C/C++-style calling convention where the call stack is cleaned by the caller.
			/// </summary>
			CDecl = 1,
			/// <summary>
			/// Unmanaged calling convention where call stack is cleaned up by the callee.
			/// </summary>
			StdCall = 2,
			/// <summary>
			/// Unmanaged C++-style calling convention for calling instance member functions with a fixed argument list.
			/// </summary>
			ThisCall = 3,
			/// <summary>
			/// Unmanaged calling convention where arguments are passed in registers when possible.
			/// </summary>
			FastCall = 4,
			/// <summary>
			/// Managed calling convention for passing extra arguments.
			/// </summary>
			VarArgs = 5,
			/// <summary>
			/// Indicating the specifics of the unmanaged calling convention are encoded as modopts.
			/// </summary>
			Unmanaged = 9
		}

		/// <summary>
		/// Represents the signature characteristics specified by the leading byte of signature blobs.
		/// </summary>
		/// <remarks>
		/// This header byte is present in all method definition, method reference, standalone method, field,
		/// property, and local variable signatures, but not in type specification signatures.
		/// </remarks>
		public struct SignatureHeader : IEquatable<SignatureHeader>
		{
			private readonly byte _rawValue;

			public const byte CallingConventionOrKindMask = 15;

			private const byte maxCallingConvention = 5;

			public byte RawValue => _rawValue;

			public SignatureCallingConvention CallingConvention
			{
				get
				{
					int num = _rawValue & 0xF;
					if (num > 5 && num != 9)
					{
						return SignatureCallingConvention.Default;
					}
					return (SignatureCallingConvention)num;
				}
			}

			public SignatureKind Kind
			{
				get
				{
					int num = _rawValue & 0xF;
					if (num <= 5 || num == 9)
					{
						return SignatureKind.Method;
					}
					return (SignatureKind)num;
				}
			}

			public SignatureAttributes Attributes => (SignatureAttributes)(_rawValue & 0xFFFFFFF0u);

			public bool HasExplicitThis => (_rawValue & 0x40) != 0;

			public bool IsInstance => (_rawValue & 0x20) != 0;

			public bool IsGeneric => (_rawValue & 0x10) != 0;

			public SignatureHeader(byte rawValue)
			{
				_rawValue = rawValue;
			}

			public SignatureHeader(SignatureKind kind, SignatureCallingConvention convention, SignatureAttributes attributes)
				: this((byte)((uint)kind | (uint)convention | (uint)attributes))
			{
			}

			public override bool Equals([NotNullWhen(true)] object? obj)
			{
				if (obj is SignatureHeader other)
				{
					return Equals(other);
				}
				return false;
			}

			public bool Equals(SignatureHeader other)
			{
				return _rawValue == other._rawValue;
			}

			public override int GetHashCode()
			{
				return _rawValue;
			}

			public static bool operator ==(SignatureHeader left, SignatureHeader right)
			{
				return left._rawValue == right._rawValue;
			}

			public static bool operator !=(SignatureHeader left, SignatureHeader right)
			{
				return left._rawValue != right._rawValue;
			}

			public override string ToString()
			{
				StringBuilder stringBuilder = new StringBuilder();
				stringBuilder.Append(Kind.ToString());
				if (Kind == SignatureKind.Method)
				{
					stringBuilder.Append(',');
					stringBuilder.Append(CallingConvention.ToString());
				}
				if (Attributes != 0)
				{
					stringBuilder.Append(',');
					stringBuilder.Append(Attributes.ToString());
				}
				return stringBuilder.ToString();
			}
		}

		/// <summary>
		/// Specifies the signature kind. Underlying values correspond to the representation
		/// in the leading signature byte represented by <see cref="T:System.Reflection.Metadata.SignatureHeader" />.
		/// </summary>
		public enum SignatureKind : byte
		{
			/// <summary>
			/// Method reference, method definition, or standalone method signature.
			/// </summary>
			Method = 0,
			/// <summary>
			/// Field signature.
			/// </summary>
			Field = 6,
			/// <summary>
			/// Local variables signature.
			/// </summary>
			LocalVariables = 7,
			/// <summary>
			/// Property signature.
			/// </summary>
			Property = 8,
			/// <summary>
			/// Method specification signature.
			/// </summary>
			MethodSpecification = 10
		}

		/// <summary>
		/// Represents the type codes that are used in signature encoding.
		/// </summary>
		public enum SignatureTypeCode : byte
		{
			/// <summary>
			/// Represents an invalid or uninitialized type code. It will not appear in valid signatures.
			/// </summary>
			Invalid = 0,
			/// <summary>
			/// Represents <see cref="T:System.Void" /> in signatures.
			/// </summary>
			Void = 1,
			/// <summary>
			/// Represents <see cref="T:System.Boolean" /> in signatures.
			/// </summary>
			Boolean = 2,
			/// <summary>
			/// Represents <see cref="T:System.Char" /> in signatures.
			/// </summary>
			Char = 3,
			/// <summary>
			/// Represents <see cref="T:System.SByte" /> in signatures.
			/// </summary>
			SByte = 4,
			/// <summary>
			/// Represents <see cref="T:System.Byte" /> in signatures.
			/// </summary>
			Byte = 5,
			/// <summary>
			/// Represents <see cref="T:System.Int16" /> in signatures.
			/// </summary>
			Int16 = 6,
			/// <summary>
			/// Represents <see cref="T:System.UInt16" /> in signatures.
			/// </summary>
			UInt16 = 7,
			/// <summary>
			/// Represents <see cref="T:System.Int32" /> in signatures.
			/// </summary>
			Int32 = 8,
			/// <summary>
			/// Represents <see cref="T:System.UInt32" /> in signatures.
			/// </summary>
			UInt32 = 9,
			/// <summary>
			/// Represents <see cref="T:System.Int64" /> in signatures.
			/// </summary>
			Int64 = 10,
			/// <summary>
			/// Represents <see cref="T:System.UInt64" /> in signatures.
			/// </summary>
			UInt64 = 11,
			/// <summary>
			/// Represents <see cref="T:System.Single" /> in signatures.
			/// </summary>
			Single = 12,
			/// <summary>
			/// Represents <see cref="T:System.Double" /> in signatures.
			/// </summary>
			Double = 13,
			/// <summary>
			/// Represents <see cref="T:System.String" /> in signatures.
			/// </summary>
			String = 14,
			/// <summary>
			/// Represents a unmanaged pointers in signatures.
			/// It is followed in the blob by the signature encoding of the underlying type.
			/// </summary>
			Pointer = 15,
			/// <summary>
			/// Represents managed pointers (byref return values and parameters) in signatures.
			/// It is followed in the blob by the signature encoding of the underlying type.
			/// </summary>
			ByReference = 16,
			/// <summary>
			/// Represents a generic type parameter used within a signature.
			/// </summary>
			GenericTypeParameter = 19,
			/// <summary>
			/// Represents a generalized <see cref="T:System.Array" /> in signatures.
			/// </summary>
			Array = 20,
			/// <summary>
			/// Represents the instantiation of a generic type in signatures.
			/// </summary>
			GenericTypeInstance = 21,
			/// <summary>
			/// Represents a System.TypedReference in signatures.
			/// </summary>
			TypedReference = 22,
			/// <summary>
			/// Represents a <see cref="T:System.IntPtr" /> in signatures.
			/// </summary>
			IntPtr = 24,
			/// <summary>
			/// Represents a <see cref="T:System.UIntPtr" /> in signatures.
			/// </summary>
			UIntPtr = 25,
			/// <summary>
			/// Represents function pointer types in signatures.
			/// </summary>
			FunctionPointer = 27,
			/// <summary>
			/// Represents <see cref="T:System.Object" />
			/// </summary>
			Object = 28,
			/// <summary>
			/// Represents a single dimensional <see cref="T:System.Array" /> with 0 lower bound.
			/// </summary>
			SZArray = 29,
			/// <summary>
			/// Represents a generic method parameter used within a signature.
			/// </summary>
			GenericMethodParameter = 30,
			/// <summary>
			/// Represents a custom modifier applied to a type within a signature that the caller must understand.
			/// </summary>
			RequiredModifier = 31,
			/// <summary>
			/// Represents a custom modifier applied to a type within a signature that the caller can ignore.
			/// </summary>
			OptionalModifier = 32,
			/// <summary>
			/// Precedes a type <see cref="T:System.Reflection.Metadata.EntityHandle" /> in signatures.
			/// </summary>
			/// <remarks>
			/// In raw metadata, this will be encoded as either ELEMENT_TYPE_CLASS (0x12) for reference
			/// types and ELEMENT_TYPE_VALUETYPE (0x11) for value types. This is collapsed to a single
			/// code because Windows Runtime projections can project from class to value type or vice-versa
			/// and the raw code is misleading in those cases.
			/// </remarks>
			TypeHandle = 64,
			/// <summary>
			/// Represents a marker to indicate the end of fixed arguments and the beginning of variable arguments.
			/// </summary>
			Sentinel = 65,
			/// <summary>
			/// Represents a local variable that is pinned by garbage collector
			/// </summary>
			Pinned = 69
		}

		public enum SignatureTypeKind : byte
		{
			/// <summary>
			/// It is not known in the current context if the type reference or definition is a class or value type.
			/// </summary>
			Unknown = 0,
			/// <summary>
			/// The type definition or reference refers to a class.
			/// </summary>
			Class = 18,
			/// <summary>
			/// The type definition or reference refers to a value type.
			/// </summary>
			ValueType = 17
		}

		public readonly struct StandaloneSignature
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private StandaloneSignatureHandle Handle => StandaloneSignatureHandle.FromRowId(_rowId);

			/// <summary>
			/// Gets a handle to the signature blob.
			/// </summary>
			public BlobHandle Signature => _reader.StandAloneSigTable.GetSignature(_rowId);

			internal StandaloneSignature(MetadataReader reader, StandaloneSignatureHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}

			public MethodSignature<TType> DecodeMethodSignature<TType, TGenericContext>(ISignatureTypeProvider<TType, TGenericContext> provider, TGenericContext genericContext)
			{
				SignatureDecoder<TType, TGenericContext> signatureDecoder = new SignatureDecoder<TType, TGenericContext>(provider, _reader, genericContext);
				BlobReader blobReader = _reader.GetBlobReader(Signature);
				return signatureDecoder.DecodeMethodSignature(ref blobReader);
			}

			public System.Collections.Immutable.ImmutableArray<TType> DecodeLocalSignature<TType, TGenericContext>(ISignatureTypeProvider<TType, TGenericContext> provider, TGenericContext genericContext)
			{
				SignatureDecoder<TType, TGenericContext> signatureDecoder = new SignatureDecoder<TType, TGenericContext>(provider, _reader, genericContext);
				BlobReader blobReader = _reader.GetBlobReader(Signature);
				return signatureDecoder.DecodeLocalSignature(ref blobReader);
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, Handle);
			}

			/// <summary>
			/// Determines the kind of signature, which can be <see cref="F:System.Reflection.Metadata.SignatureKind.Method" /> or <see cref="F:System.Reflection.Metadata.SignatureKind.LocalVariables" />
			/// </summary>
			/// <exception cref="T:System.BadImageFormatException">The signature is invalid.</exception>
			public StandaloneSignatureKind GetKind()
			{
				return _reader.GetBlobReader(Signature).ReadSignatureHeader().Kind switch
				{
					SignatureKind.Method => StandaloneSignatureKind.Method,
					SignatureKind.LocalVariables => StandaloneSignatureKind.LocalVariables,
					_ => throw new BadImageFormatException(),
				};
			}
		}

		public readonly struct StandaloneSignatureHandle : IEquatable<StandaloneSignatureHandle>
		{
			private const uint tokenType = 285212672u;

			private const byte tokenTypeSmall = 17;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private StandaloneSignatureHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static StandaloneSignatureHandle FromRowId(int rowId)
			{
				return new StandaloneSignatureHandle(rowId);
			}

			public static implicit operator Handle(StandaloneSignatureHandle handle)
			{
				return new Handle(17, handle._rowId);
			}

			public static implicit operator EntityHandle(StandaloneSignatureHandle handle)
			{
				return new EntityHandle((uint)(0x11000000uL | (ulong)handle._rowId));
			}

			public static explicit operator StandaloneSignatureHandle(Handle handle)
			{
				if (handle.VType != 17)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new StandaloneSignatureHandle(handle.RowId);
			}

			public static explicit operator StandaloneSignatureHandle(EntityHandle handle)
			{
				if (handle.VType != 285212672)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new StandaloneSignatureHandle(handle.RowId);
			}

			public static bool operator ==(StandaloneSignatureHandle left, StandaloneSignatureHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is StandaloneSignatureHandle)
				{
					return ((StandaloneSignatureHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(StandaloneSignatureHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(StandaloneSignatureHandle left, StandaloneSignatureHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		/// <summary>
		/// Indicates whether a <see cref="System.Reflection.Metadata.StandaloneSignature" /> represents a standalone method or local variable signature.
		/// </summary>
		public enum StandaloneSignatureKind
		{
			/// <summary>
			/// The <see cref="T:System.Reflection.Metadata.StandaloneSignature" /> represents a standalone method signature.
			/// </summary>
			Method,
			/// <summary>
			/// The <see cref="T:System.Reflection.Metadata.MemberReference" /> references a local variable signature.
			/// </summary>
			LocalVariables
		}

		public readonly struct StringHandle : IEquatable<StringHandle>
		{
			internal enum VirtualIndex
			{
				System_Runtime_WindowsRuntime,
				System_Runtime,
				System_ObjectModel,
				System_Runtime_WindowsRuntime_UI_Xaml,
				System_Runtime_InteropServices_WindowsRuntime,
				System_Numerics_Vectors,
				Dispose,
				AttributeTargets,
				AttributeUsageAttribute,
				Color,
				CornerRadius,
				DateTimeOffset,
				Duration,
				DurationType,
				EventHandler1,
				EventRegistrationToken,
				Exception,
				GeneratorPosition,
				GridLength,
				GridUnitType,
				ICommand,
				IDictionary2,
				IDisposable,
				IEnumerable,
				IEnumerable1,
				IList,
				IList1,
				INotifyCollectionChanged,
				INotifyPropertyChanged,
				IReadOnlyDictionary2,
				IReadOnlyList1,
				KeyTime,
				KeyValuePair2,
				Matrix,
				Matrix3D,
				Matrix3x2,
				Matrix4x4,
				NotifyCollectionChangedAction,
				NotifyCollectionChangedEventArgs,
				NotifyCollectionChangedEventHandler,
				Nullable1,
				Plane,
				Point,
				PropertyChangedEventArgs,
				PropertyChangedEventHandler,
				Quaternion,
				Rect,
				RepeatBehavior,
				RepeatBehaviorType,
				Size,
				System,
				System_Collections,
				System_Collections_Generic,
				System_Collections_Specialized,
				System_ComponentModel,
				System_Numerics,
				System_Windows_Input,
				Thickness,
				TimeSpan,
				Type,
				Uri,
				Vector2,
				Vector3,
				Vector4,
				Windows_Foundation,
				Windows_UI,
				Windows_UI_Xaml,
				Windows_UI_Xaml_Controls_Primitives,
				Windows_UI_Xaml_Media,
				Windows_UI_Xaml_Media_Animation,
				Windows_UI_Xaml_Media_Media3D,
				Count
			}

			private readonly uint _value;

			internal uint RawValue => _value;

			internal bool IsVirtual => (_value & 0x80000000u) != 0;

			public bool IsNil => (_value & 0x9FFFFFFFu) == 0;

			internal System.Reflection.Metadata.Ecma335.StringKind StringKind => (System.Reflection.Metadata.Ecma335.StringKind)(_value >> 29);

			private StringHandle(uint value)
			{
				_value = value;
			}

			internal static StringHandle FromOffset(int heapOffset)
			{
				return new StringHandle(0u | (uint)heapOffset);
			}

			internal static StringHandle FromVirtualIndex(VirtualIndex virtualIndex)
			{
				return new StringHandle(0x80000000u | (uint)virtualIndex);
			}

			internal static StringHandle FromWriterVirtualIndex(int virtualIndex)
			{
				return new StringHandle(0x80000000u | (uint)virtualIndex);
			}

			internal StringHandle WithWinRTPrefix()
			{
				return new StringHandle(0xA0000000u | _value);
			}

			internal StringHandle WithDotTermination()
			{
				return new StringHandle(0x20000000u | _value);
			}

			internal StringHandle SuffixRaw(int prefixByteLength)
			{
				return new StringHandle(0u | (_value + (uint)prefixByteLength));
			}

			public static implicit operator Handle(StringHandle handle)
			{
				return new Handle((byte)(((handle._value & 0x80000000u) >> 24) | 0x78u | ((handle._value & 0x60000000) >> 29)), (int)(handle._value & 0x1FFFFFFF));
			}

			public static explicit operator StringHandle(Handle handle)
			{
				if ((handle.VType & -132) != 120)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new StringHandle((uint)(((handle.VType & 0x80) << 24) | ((handle.VType & 3) << 29) | handle.Offset));
			}

			internal int GetHeapOffset()
			{
				return (int)(_value & 0x1FFFFFFF);
			}

			internal VirtualIndex GetVirtualIndex()
			{
				return (VirtualIndex)((int)_value & 0x1FFFFFFF);
			}

			internal int GetWriterVirtualIndex()
			{
				return (int)(_value & 0x1FFFFFFF);
			}

			public override bool Equals(object? obj)
			{
				if (obj is StringHandle)
				{
					return Equals((StringHandle)obj);
				}
				return false;
			}

			public bool Equals(StringHandle other)
			{
				return _value == other._value;
			}

			public override int GetHashCode()
			{
				return (int)_value;
			}

			public static bool operator ==(StringHandle left, StringHandle right)
			{
				return left.Equals(right);
			}

			public static bool operator !=(StringHandle left, StringHandle right)
			{
				return !left.Equals(right);
			}
		}

		internal static class StringUtils
		{
			internal static int IgnoreCaseMask(bool ignoreCase) { if (!ignoreCase) { return 255; } return 32; }

			internal static bool IsEqualAscii(int a, int b, int ignoreCaseMask)
			{
				if (a != b)
				{
					if ((a | 0x20) == (b | 0x20))
					{
						return (uint)((a | ignoreCaseMask) - 97) <= 25u;
					}
					return false;
				}
				return true;
			}
		}

		public readonly struct TypeDefinition
		{
			private readonly MetadataReader _reader;

			private readonly uint _treatmentAndRowId;

			private int RowId => (int)(_treatmentAndRowId & 0xFFFFFF);

			private TypeDefTreatment Treatment => (TypeDefTreatment)(_treatmentAndRowId >> 24);

			private TypeDefinitionHandle Handle => TypeDefinitionHandle.FromRowId(RowId);

			public TypeAttributes Attributes
			{
				get
				{
					if (Treatment == TypeDefTreatment.None)
					{
						return _reader.TypeDefTable.GetFlags(Handle);
					}
					return GetProjectedFlags();
				}
			}

			/// <summary>
			/// Indicates whether this is a nested type.
			/// </summary>
			public bool IsNested => Attributes.IsNested();

			/// <summary>
			/// Name of the type.
			/// </summary>
			public StringHandle Name
			{
				get
				{
					if (Treatment == TypeDefTreatment.None)
					{
						return _reader.TypeDefTable.GetName(Handle);
					}
					return GetProjectedName();
				}
			}

			/// <summary>
			/// Full name of the namespace where the type is defined, or nil if the type is nested or defined in a root namespace.
			/// </summary>
			public StringHandle Namespace
			{
				get
				{
					if (Treatment == TypeDefTreatment.None)
					{
						return _reader.TypeDefTable.GetNamespace(Handle);
					}
					return GetProjectedNamespaceString();
				}
			}

			/// <summary>
			/// The definition handle of the namespace where the type is defined, or nil if the type is nested or defined in a root namespace.
			/// </summary>
			public NamespaceDefinitionHandle NamespaceDefinition
			{
				get
				{
					if (Treatment == TypeDefTreatment.None)
					{
						return _reader.TypeDefTable.GetNamespaceDefinition(Handle);
					}
					return GetProjectedNamespace();
				}
			}

			/// <summary>
			/// The base type of the type definition: either
			/// <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> or <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />.
			/// </summary>
			public EntityHandle BaseType
			{
				get
				{
					if (Treatment == TypeDefTreatment.None)
					{
						return _reader.TypeDefTable.GetExtends(Handle);
					}
					return GetProjectedBaseType();
				}
			}

			internal TypeDefinition(MetadataReader reader, uint treatmentAndRowId)
			{
				_reader = reader;
				_treatmentAndRowId = treatmentAndRowId;
			}

			public TypeLayout GetLayout()
			{
				int num = _reader.ClassLayoutTable.FindRow(Handle);
				if (num == 0)
				{
					return default(TypeLayout);
				}
				uint classSize = _reader.ClassLayoutTable.GetClassSize(num);
				if ((int)classSize != classSize)
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.InvalidTypeSize);
				}
				int packingSize = _reader.ClassLayoutTable.GetPackingSize(num);
				return new TypeLayout((int)classSize, packingSize);
			}

			/// <summary>
			/// Returns the enclosing type of a specified nested type or nil handle if the type is not nested.
			/// </summary>
			public TypeDefinitionHandle GetDeclaringType()
			{
				return _reader.NestedClassTable.FindEnclosingType(Handle);
			}

			public GenericParameterHandleCollection GetGenericParameters()
			{
				return _reader.GenericParamTable.FindGenericParametersForType(Handle);
			}

			public MethodDefinitionHandleCollection GetMethods()
			{
				return new MethodDefinitionHandleCollection(_reader, Handle);
			}

			public FieldDefinitionHandleCollection GetFields()
			{
				return new FieldDefinitionHandleCollection(_reader, Handle);
			}

			public PropertyDefinitionHandleCollection GetProperties()
			{
				return new PropertyDefinitionHandleCollection(_reader, Handle);
			}

			public EventDefinitionHandleCollection GetEvents()
			{
				return new EventDefinitionHandleCollection(_reader, Handle);
			}

			/// <summary>
			/// Returns an array of types nested in the specified type.
			/// </summary>
			public System.Collections.Immutable.ImmutableArray<TypeDefinitionHandle> GetNestedTypes()
			{
				return _reader.GetNestedTypes(Handle);
			}

			public MethodImplementationHandleCollection GetMethodImplementations()
			{
				return new MethodImplementationHandleCollection(_reader, Handle);
			}

			public InterfaceImplementationHandleCollection GetInterfaceImplementations()
			{
				return new InterfaceImplementationHandleCollection(_reader, Handle);
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, Handle);
			}

			public DeclarativeSecurityAttributeHandleCollection GetDeclarativeSecurityAttributes()
			{
				return new DeclarativeSecurityAttributeHandleCollection(_reader, Handle);
			}

			private TypeAttributes GetProjectedFlags()
			{
				TypeAttributes typeAttributes = _reader.TypeDefTable.GetFlags(Handle);
				TypeDefTreatment treatment = Treatment;
				switch (treatment & TypeDefTreatment.KindMask)
				{
					case TypeDefTreatment.NormalNonAttribute:
						typeAttributes |= TypeAttributes.Import | TypeAttributes.WindowsRuntime;
						break;
					case TypeDefTreatment.NormalAttribute:
						typeAttributes |= TypeAttributes.Sealed | TypeAttributes.WindowsRuntime;
						break;
					case TypeDefTreatment.UnmangleWinRTName:
						typeAttributes = (typeAttributes & ~TypeAttributes.SpecialName) | TypeAttributes.Public;
						break;
					case TypeDefTreatment.PrefixWinRTName:
						typeAttributes = (typeAttributes & ~TypeAttributes.Public) | TypeAttributes.Import;
						break;
					case TypeDefTreatment.RedirectedToClrType:
						typeAttributes = (typeAttributes & ~TypeAttributes.Public) | TypeAttributes.Import;
						break;
					case TypeDefTreatment.RedirectedToClrAttribute:
						typeAttributes &= ~TypeAttributes.Public;
						break;
				}
				if ((treatment & TypeDefTreatment.MarkAbstractFlag) != 0)
				{
					typeAttributes |= TypeAttributes.Abstract;
				}
				if ((treatment & TypeDefTreatment.MarkInternalFlag) != 0)
				{
					typeAttributes &= ~TypeAttributes.Public;
				}
				return typeAttributes;
			}

			private StringHandle GetProjectedName()
			{
				StringHandle name = _reader.TypeDefTable.GetName(Handle);
				return (Treatment & TypeDefTreatment.KindMask) switch
				{
					TypeDefTreatment.UnmangleWinRTName => name.SuffixRaw("<CLR>".Length),
					TypeDefTreatment.PrefixWinRTName => name.WithWinRTPrefix(),
					_ => name,
				};
			}

			private NamespaceDefinitionHandle GetProjectedNamespace()
			{
				return _reader.TypeDefTable.GetNamespaceDefinition(Handle);
			}

			private StringHandle GetProjectedNamespaceString()
			{
				return _reader.TypeDefTable.GetNamespace(Handle);
			}

			private EntityHandle GetProjectedBaseType()
			{
				return _reader.TypeDefTable.GetExtends(Handle);
			}
		}

		public readonly struct TypeDefinitionHandle : IEquatable<TypeDefinitionHandle>
		{
			private const uint tokenType = 33554432u;

			private const byte tokenTypeSmall = 2;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private TypeDefinitionHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static TypeDefinitionHandle FromRowId(int rowId)
			{
				return new TypeDefinitionHandle(rowId);
			}

			public static implicit operator Handle(TypeDefinitionHandle handle)
			{
				return new Handle(2, handle._rowId);
			}

			public static implicit operator EntityHandle(TypeDefinitionHandle handle)
			{
				return new EntityHandle((uint)(0x2000000uL | (ulong)handle._rowId));
			}

			public static explicit operator TypeDefinitionHandle(Handle handle)
			{
				if (handle.VType != 2)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new TypeDefinitionHandle(handle.RowId);
			}

			public static explicit operator TypeDefinitionHandle(EntityHandle handle)
			{
				if (handle.VType != 33554432)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new TypeDefinitionHandle(handle.RowId);
			}

			public static bool operator ==(TypeDefinitionHandle left, TypeDefinitionHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is TypeDefinitionHandle)
				{
					return ((TypeDefinitionHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(TypeDefinitionHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(TypeDefinitionHandle left, TypeDefinitionHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		/// <summary>
		/// Represents a collection of <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />.
		/// </summary>
		public readonly struct TypeDefinitionHandleCollection : IReadOnlyCollection<TypeDefinitionHandle>, IEnumerable<TypeDefinitionHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<TypeDefinitionHandle>, IDisposable, IEnumerator
			{
				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public TypeDefinitionHandle Current => TypeDefinitionHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal Enumerator(int lastRowId)
				{
					_lastRowId = lastRowId;
					_currentRowId = 0;
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly int _lastRowId;

			public int Count => _lastRowId;

			internal TypeDefinitionHandleCollection(int lastRowId)
			{
				_lastRowId = lastRowId;
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_lastRowId);
			}

			IEnumerator<TypeDefinitionHandle> IEnumerable<TypeDefinitionHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public readonly struct TypeLayout
		{
			private readonly int _size;

			private readonly int _packingSize;

			public int Size => _size;

			public int PackingSize => _packingSize;

			public bool IsDefault
			{
				get
				{
					if (_size == 0)
					{
						return _packingSize == 0;
					}
					return false;
				}
			}

			public TypeLayout(int size, int packingSize)
			{
				_size = size;
				_packingSize = packingSize;
			}
		}

		public readonly struct TypeReference
		{
			private readonly MetadataReader _reader;

			private readonly uint _treatmentAndRowId;

			private int RowId => (int)(_treatmentAndRowId & 0xFFFFFF);

			private TypeRefTreatment Treatment => (TypeRefTreatment)(_treatmentAndRowId >> 24);

			private TypeReferenceHandle Handle => TypeReferenceHandle.FromRowId(RowId);

			/// <summary>
			/// Resolution scope in which the target type is defined and is uniquely identified by the specified <see cref="P:System.Reflection.Metadata.TypeReference.Namespace" /> and <see cref="P:System.Reflection.Metadata.TypeReference.Name" />.
			/// </summary>
			/// <remarks>
			/// Resolution scope can be one of the following handles:
			/// <list type="bullet">
			/// <item><description><see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> of the enclosing type, if the target type is a nested type.</description></item>
			/// <item><description><see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, if the target type is defined in another module within the same assembly as this one.</description></item>
			/// <item><description><see cref="F:System.Reflection.Metadata.EntityHandle.ModuleDefinition" />, if the target type is defined in the current module. This should not occur in a CLI compressed metadata module.</description></item>
			/// <item><description><see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, if the target type is defined in a different assembly from the current module.</description></item>
			/// <item><description>Nil handle if the target type must be resolved by searching the <see cref="P:System.Reflection.Metadata.MetadataReader.ExportedTypes" /> for a matching <see cref="P:System.Reflection.Metadata.TypeReference.Namespace" /> and <see cref="P:System.Reflection.Metadata.TypeReference.Name" />.</description></item>
			/// </list>
			/// </remarks>
			public EntityHandle ResolutionScope
			{
				get
				{
					if (Treatment == TypeRefTreatment.None)
					{
						return _reader.TypeRefTable.GetResolutionScope(Handle);
					}
					return GetProjectedResolutionScope();
				}
			}

			/// <summary>
			/// Name of the target type.
			/// </summary>
			public StringHandle Name
			{
				get
				{
					if (Treatment == TypeRefTreatment.None)
					{
						return _reader.TypeRefTable.GetName(Handle);
					}
					return GetProjectedName();
				}
			}

			/// <summary>
			/// Full name of the namespace where the target type is defined, or nil if the type is nested or defined in a root namespace.
			/// </summary>
			public StringHandle Namespace
			{
				get
				{
					if (Treatment == TypeRefTreatment.None)
					{
						return _reader.TypeRefTable.GetNamespace(Handle);
					}
					return GetProjectedNamespace();
				}
			}

			internal TypeRefSignatureTreatment SignatureTreatment
			{
				get
				{
					if (Treatment == TypeRefTreatment.None)
					{
						return TypeRefSignatureTreatment.None;
					}
					return GetProjectedSignatureTreatment();
				}
			}

			internal TypeReference(MetadataReader reader, uint treatmentAndRowId)
			{
				_reader = reader;
				_treatmentAndRowId = treatmentAndRowId;
			}

			private EntityHandle GetProjectedResolutionScope()
			{
				switch (Treatment)
				{
					case TypeRefTreatment.SystemDelegate:
					case TypeRefTreatment.SystemAttribute:
						return AssemblyReferenceHandle.FromVirtualIndex(AssemblyReferenceHandle.VirtualIndex.System_Runtime);
					case TypeRefTreatment.UseProjectionInfo:
						return MetadataReader.GetProjectedAssemblyRef(RowId);
					default:
						return default(AssemblyReferenceHandle);
				}
			}

			private StringHandle GetProjectedName()
			{
				if (Treatment == TypeRefTreatment.UseProjectionInfo)
				{
					return MetadataReader.GetProjectedName(RowId);
				}
				return _reader.TypeRefTable.GetName(Handle);
			}

			private StringHandle GetProjectedNamespace()
			{
				switch (Treatment)
				{
					case TypeRefTreatment.SystemDelegate:
					case TypeRefTreatment.SystemAttribute:
						return StringHandle.FromVirtualIndex(StringHandle.VirtualIndex.System);
					case TypeRefTreatment.UseProjectionInfo:
						return MetadataReader.GetProjectedNamespace(RowId);
					default:
						return default(StringHandle);
				}
			}

			private TypeRefSignatureTreatment GetProjectedSignatureTreatment()
			{
				if (Treatment == TypeRefTreatment.UseProjectionInfo)
				{
					return MetadataReader.GetProjectedSignatureTreatment(RowId);
				}
				return TypeRefSignatureTreatment.None;
			}
		}

		public readonly struct TypeReferenceHandle : IEquatable<TypeReferenceHandle>
		{
			private const uint tokenType = 16777216u;

			private const byte tokenTypeSmall = 1;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private TypeReferenceHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static TypeReferenceHandle FromRowId(int rowId)
			{
				return new TypeReferenceHandle(rowId);
			}

			public static implicit operator Handle(TypeReferenceHandle handle)
			{
				return new Handle(1, handle._rowId);
			}

			public static implicit operator EntityHandle(TypeReferenceHandle handle)
			{
				return new EntityHandle((uint)(0x1000000uL | (ulong)handle._rowId));
			}

			public static explicit operator TypeReferenceHandle(Handle handle)
			{
				if (handle.VType != 1)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new TypeReferenceHandle(handle.RowId);
			}

			public static explicit operator TypeReferenceHandle(EntityHandle handle)
			{
				if (handle.VType != 16777216)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new TypeReferenceHandle(handle.RowId);
			}

			public static bool operator ==(TypeReferenceHandle left, TypeReferenceHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is TypeReferenceHandle)
				{
					return ((TypeReferenceHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(TypeReferenceHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(TypeReferenceHandle left, TypeReferenceHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		/// <summary>
		/// Represents a collection of <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.
		/// </summary>
		public readonly struct TypeReferenceHandleCollection : IReadOnlyCollection<TypeReferenceHandle>, IEnumerable<TypeReferenceHandle>, IEnumerable
		{
			public struct Enumerator : IEnumerator<TypeReferenceHandle>, IDisposable, IEnumerator
			{
				private readonly int _lastRowId;

				private int _currentRowId;

				private const int EnumEnded = 16777216;

				public TypeReferenceHandle Current => TypeReferenceHandle.FromRowId((int)((long)_currentRowId & 0xFFFFFFL));

				object IEnumerator.Current => Current;

				internal Enumerator(int lastRowId)
				{
					_lastRowId = lastRowId;
					_currentRowId = 0;
				}

				public bool MoveNext()
				{
					if (_currentRowId >= _lastRowId)
					{
						_currentRowId = 16777216;
						return false;
					}
					_currentRowId++;
					return true;
				}

				void IEnumerator.Reset()
				{
					throw new NotSupportedException();
				}

				void IDisposable.Dispose()
				{
				}
			}

			private readonly int _lastRowId;

			public int Count => _lastRowId;

			internal TypeReferenceHandleCollection(int lastRowId)
			{
				_lastRowId = lastRowId;
			}

			public Enumerator GetEnumerator()
			{
				return new Enumerator(_lastRowId);
			}

			IEnumerator<TypeReferenceHandle> IEnumerable<TypeReferenceHandle>.GetEnumerator()
			{
				return GetEnumerator();
			}

			IEnumerator IEnumerable.GetEnumerator()
			{
				return GetEnumerator();
			}
		}

		public readonly struct TypeSpecification
		{
			private readonly MetadataReader _reader;

			private readonly int _rowId;

			private TypeSpecificationHandle Handle => TypeSpecificationHandle.FromRowId(_rowId);

			public BlobHandle Signature => _reader.TypeSpecTable.GetSignature(Handle);

			internal TypeSpecification(MetadataReader reader, TypeSpecificationHandle handle)
			{
				_reader = reader;
				_rowId = handle.RowId;
			}

			public TType DecodeSignature<TType, TGenericContext>(ISignatureTypeProvider<TType, TGenericContext> provider, TGenericContext genericContext)
			{
				SignatureDecoder<TType, TGenericContext> signatureDecoder = new SignatureDecoder<TType, TGenericContext>(provider, _reader, genericContext);
				BlobReader blobReader = _reader.GetBlobReader(Signature);
				return signatureDecoder.DecodeType(ref blobReader);
			}

			public CustomAttributeHandleCollection GetCustomAttributes()
			{
				return new CustomAttributeHandleCollection(_reader, Handle);
			}
		}

		public readonly struct TypeSpecificationHandle : IEquatable<TypeSpecificationHandle>
		{
			private const uint tokenType = 452984832u;

			private const byte tokenTypeSmall = 27;

			private readonly int _rowId;

			public bool IsNil => RowId == 0;

			internal int RowId => _rowId;

			private TypeSpecificationHandle(int rowId)
			{
				_rowId = rowId;
			}

			internal static TypeSpecificationHandle FromRowId(int rowId)
			{
				return new TypeSpecificationHandle(rowId);
			}

			public static implicit operator Handle(TypeSpecificationHandle handle)
			{
				return new Handle(27, handle._rowId);
			}

			public static implicit operator EntityHandle(TypeSpecificationHandle handle)
			{
				return new EntityHandle((uint)(0x1B000000uL | (ulong)handle._rowId));
			}

			public static explicit operator TypeSpecificationHandle(Handle handle)
			{
				if (handle.VType != 27)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new TypeSpecificationHandle(handle.RowId);
			}

			public static explicit operator TypeSpecificationHandle(EntityHandle handle)
			{
				if (handle.VType != 452984832)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new TypeSpecificationHandle(handle.RowId);
			}

			public static bool operator ==(TypeSpecificationHandle left, TypeSpecificationHandle right)
			{
				return left._rowId == right._rowId;
			}

			public override bool Equals(object? obj)
			{
				if (obj is TypeSpecificationHandle)
				{
					return ((TypeSpecificationHandle)obj)._rowId == _rowId;
				}
				return false;
			}

			public bool Equals(TypeSpecificationHandle other)
			{
				return _rowId == other._rowId;
			}

			public override int GetHashCode()
			{
				return _rowId.GetHashCode();
			}

			public static bool operator !=(TypeSpecificationHandle left, TypeSpecificationHandle right)
			{
				return left._rowId != right._rowId;
			}
		}

		/// <summary>
		/// #UserString heap handle.
		/// </summary>
		/// <remarks>
		/// The handle is 32-bit wide.
		/// </remarks>
		public readonly struct UserStringHandle : IEquatable<UserStringHandle>
		{
			private readonly int _offset;

			public bool IsNil => _offset == 0;

			private UserStringHandle(int offset)
			{
				_offset = offset;
			}

			internal static UserStringHandle FromOffset(int heapOffset)
			{
				return new UserStringHandle(heapOffset);
			}

			public static implicit operator Handle(UserStringHandle handle)
			{
				return new Handle(112, handle._offset);
			}

			public static explicit operator UserStringHandle(Handle handle)
			{
				if (handle.VType != 112)
				{
					System.Reflection.Throw.InvalidCast();
				}
				return new UserStringHandle(handle.Offset);
			}

			internal int GetHeapOffset()
			{
				return _offset;
			}

			public static bool operator ==(UserStringHandle left, UserStringHandle right)
			{
				return left._offset == right._offset;
			}

			public override bool Equals(object? obj)
			{
				if (obj is UserStringHandle)
				{
					return ((UserStringHandle)obj)._offset == _offset;
				}
				return false;
			}

			public bool Equals(UserStringHandle other)
			{
				return _offset == other._offset;
			}

			public override int GetHashCode()
			{
				return _offset.GetHashCode();
			}

			public static bool operator !=(UserStringHandle left, UserStringHandle right)
			{
				return left._offset != right._offset;
			}
		}

		namespace Ecma335
		{
			using System.Reflection.Internal;
			public readonly struct ArrayShapeEncoder
			{
				public BlobBuilder Builder { get; }

				public ArrayShapeEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				/// <summary>
				/// Encodes array shape.
				/// </summary>
				/// <param name="rank">The number of dimensions in the array (shall be 1 or more).</param>
				/// <param name="sizes">
				/// Dimension sizes. The array may be shorter than <paramref name="rank" /> but not longer.
				/// </param>
				/// <param name="lowerBounds">
				/// Dimension lower bounds, or <c>default(<see cref="T:System.Collections.Immutable.ImmutableArray`1" />)</c> to set all <paramref name="rank" /> lower bounds to 0.
				/// The array may be shorter than <paramref name="rank" /> but not longer.
				/// </param>
				/// <exception cref="T:System.ArgumentOutOfRangeException">
				/// <paramref name="rank" /> is outside of range [1, 0xffff],
				/// smaller than <paramref name="sizes" />.Length, or
				/// smaller than <paramref name="lowerBounds" />.Length.
				/// </exception>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="sizes" /> is null.</exception>
				public void Shape(int rank, System.Collections.Immutable.ImmutableArray<int> sizes, System.Collections.Immutable.ImmutableArray<int> lowerBounds)
				{
					//IL_005b: Unknown result type (might be due to invalid IL or missing references)
					//IL_0060: Unknown result type (might be due to invalid IL or missing references)
					//IL_00d6: Unknown result type (might be due to invalid IL or missing references)
					//IL_00db: Unknown result type (might be due to invalid IL or missing references)
					if ((uint)(rank - 1) > 65534u)
					{
						System.Reflection.Throw.ArgumentOutOfRange("rank");
					}
					if (sizes.IsDefault)
					{
						System.Reflection.Throw.ArgumentNull("sizes");
					}
					Builder.WriteCompressedInteger(rank);
					if (sizes.Length > rank)
					{
						System.Reflection.Throw.ArgumentOutOfRange("rank");
					}
					Builder.WriteCompressedInteger(sizes.Length);
                    ImmutableArray<int>.Enumerator enumerator = sizes.GetEnumerator();
					while (enumerator.MoveNext())
					{
						int current = enumerator.Current;
						Builder.WriteCompressedInteger(current);
					}
					if (lowerBounds.IsDefault)
					{
						Builder.WriteCompressedInteger(rank);
						for (int i = 0; i < rank; i++)
						{
							Builder.WriteCompressedSignedInteger(0);
						}
						return;
					}
					if (lowerBounds.Length > rank)
					{
						System.Reflection.Throw.ArgumentOutOfRange("rank");
					}
					Builder.WriteCompressedInteger(lowerBounds.Length);
                    ImmutableArray<int>.Enumerator enumerator2 = lowerBounds.GetEnumerator();
					while (enumerator2.MoveNext())
					{
						int current2 = enumerator2.Current;
						Builder.WriteCompressedSignedInteger(current2);
					}
				}
			}

			internal readonly struct AssemblyOSTableReader
			{
				internal readonly int NumberOfRows;

				private readonly int _OSPlatformIdOffset;

				private readonly int _OSMajorVersionIdOffset;

				private readonly int _OSMinorVersionIdOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal AssemblyOSTableReader(int numberOfRows, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_OSPlatformIdOffset = 0;
					_OSMajorVersionIdOffset = _OSPlatformIdOffset + 4;
					_OSMinorVersionIdOffset = _OSMajorVersionIdOffset + 4;
					RowSize = _OSMinorVersionIdOffset + 4;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}
			}

			internal readonly struct AssemblyProcessorTableReader
			{
				internal readonly int NumberOfRows;

				private readonly int _ProcessorOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal AssemblyProcessorTableReader(int numberOfRows, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_ProcessorOffset = 0;
					RowSize = _ProcessorOffset + 4;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}
			}

			internal readonly struct AssemblyRefOSTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsAssemblyRefTableRowRefSizeSmall;

				private readonly int _OSPlatformIdOffset;

				private readonly int _OSMajorVersionIdOffset;

				private readonly int _OSMinorVersionIdOffset;

				private readonly int _AssemblyRefOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal AssemblyRefOSTableReader(int numberOfRows, int assemblyRefTableRowRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsAssemblyRefTableRowRefSizeSmall = assemblyRefTableRowRefSize == 2;
					_OSPlatformIdOffset = 0;
					_OSMajorVersionIdOffset = _OSPlatformIdOffset + 4;
					_OSMinorVersionIdOffset = _OSMajorVersionIdOffset + 4;
					_AssemblyRefOffset = _OSMinorVersionIdOffset + 4;
					RowSize = _AssemblyRefOffset + assemblyRefTableRowRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}
			}

			internal readonly struct AssemblyRefProcessorTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsAssemblyRefTableRowSizeSmall;

				private readonly int _ProcessorOffset;

				private readonly int _AssemblyRefOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal AssemblyRefProcessorTableReader(int numberOfRows, int assemblyRefTableRowRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsAssemblyRefTableRowSizeSmall = assemblyRefTableRowRefSize == 2;
					_ProcessorOffset = 0;
					_AssemblyRefOffset = _ProcessorOffset + 4;
					RowSize = _AssemblyRefOffset + assemblyRefTableRowRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}
			}

			internal readonly struct AssemblyRefTableReader
			{
				/// <summary>
				/// In CLI metadata equal to the actual number of entries in AssemblyRef table.
				/// In WinMD metadata it includes synthesized AssemblyRefs in addition.
				/// </summary>
				internal readonly int NumberOfNonVirtualRows;

				internal readonly int NumberOfVirtualRows;

				private readonly bool _IsStringHeapRefSizeSmall;

				private readonly bool _IsBlobHeapRefSizeSmall;

				private readonly int _MajorVersionOffset;

				private readonly int _MinorVersionOffset;

				private readonly int _BuildNumberOffset;

				private readonly int _RevisionNumberOffset;

				private readonly int _FlagsOffset;

				private readonly int _PublicKeyOrTokenOffset;

				private readonly int _NameOffset;

				private readonly int _CultureOffset;

				private readonly int _HashValueOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal AssemblyRefTableReader(int numberOfRows, int stringHeapRefSize, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset, MetadataKind metadataKind)
				{
					NumberOfNonVirtualRows = numberOfRows;
					NumberOfVirtualRows = ((metadataKind != 0) ? 6 : 0);
					_IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_MajorVersionOffset = 0;
					_MinorVersionOffset = _MajorVersionOffset + 2;
					_BuildNumberOffset = _MinorVersionOffset + 2;
					_RevisionNumberOffset = _BuildNumberOffset + 2;
					_FlagsOffset = _RevisionNumberOffset + 2;
					_PublicKeyOrTokenOffset = _FlagsOffset + 4;
					_NameOffset = _PublicKeyOrTokenOffset + blobHeapRefSize;
					_CultureOffset = _NameOffset + stringHeapRefSize;
					_HashValueOffset = _CultureOffset + stringHeapRefSize;
					RowSize = _HashValueOffset + blobHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal Version GetVersion(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return new Version(Block.PeekUInt16(num + _MajorVersionOffset), Block.PeekUInt16(num + _MinorVersionOffset), Block.PeekUInt16(num + _BuildNumberOffset), Block.PeekUInt16(num + _RevisionNumberOffset));
				}

				internal AssemblyFlags GetFlags(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return (AssemblyFlags)Block.PeekUInt32(num + _FlagsOffset);
				}

				internal BlobHandle GetPublicKeyOrToken(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _PublicKeyOrTokenOffset, _IsBlobHeapRefSizeSmall));
				}

				internal StringHandle GetName(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _NameOffset, _IsStringHeapRefSizeSmall));
				}

				internal StringHandle GetCulture(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _CultureOffset, _IsStringHeapRefSizeSmall));
				}

				internal BlobHandle GetHashValue(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _HashValueOffset, _IsBlobHeapRefSizeSmall));
				}
			}

			internal readonly struct AssemblyTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsStringHeapRefSizeSmall;

				private readonly bool _IsBlobHeapRefSizeSmall;

				private readonly int _HashAlgIdOffset;

				private readonly int _MajorVersionOffset;

				private readonly int _MinorVersionOffset;

				private readonly int _BuildNumberOffset;

				private readonly int _RevisionNumberOffset;

				private readonly int _FlagsOffset;

				private readonly int _PublicKeyOffset;

				private readonly int _NameOffset;

				private readonly int _CultureOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal AssemblyTableReader(int numberOfRows, int stringHeapRefSize, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = ((numberOfRows > 1) ? 1 : numberOfRows);
					_IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_HashAlgIdOffset = 0;
					_MajorVersionOffset = _HashAlgIdOffset + 4;
					_MinorVersionOffset = _MajorVersionOffset + 2;
					_BuildNumberOffset = _MinorVersionOffset + 2;
					_RevisionNumberOffset = _BuildNumberOffset + 2;
					_FlagsOffset = _RevisionNumberOffset + 2;
					_PublicKeyOffset = _FlagsOffset + 4;
					_NameOffset = _PublicKeyOffset + blobHeapRefSize;
					_CultureOffset = _NameOffset + stringHeapRefSize;
					RowSize = _CultureOffset + stringHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal AssemblyHashAlgorithm GetHashAlgorithm()
				{
					return (AssemblyHashAlgorithm)Block.PeekUInt32(_HashAlgIdOffset);
				}

				internal Version GetVersion()
				{
					return new Version(Block.PeekUInt16(_MajorVersionOffset), Block.PeekUInt16(_MinorVersionOffset), Block.PeekUInt16(_BuildNumberOffset), Block.PeekUInt16(_RevisionNumberOffset));
				}

				internal AssemblyFlags GetFlags()
				{
					return (AssemblyFlags)Block.PeekUInt32(_FlagsOffset);
				}

				internal BlobHandle GetPublicKey()
				{
					return BlobHandle.FromOffset(Block.PeekHeapReference(_PublicKeyOffset, _IsBlobHeapRefSizeSmall));
				}

				internal StringHandle GetName()
				{
					return StringHandle.FromOffset(Block.PeekHeapReference(_NameOffset, _IsStringHeapRefSizeSmall));
				}

				internal StringHandle GetCulture()
				{
					return StringHandle.FromOffset(Block.PeekHeapReference(_CultureOffset, _IsStringHeapRefSizeSmall));
				}
			}

			public readonly struct BlobEncoder
			{
				public BlobBuilder Builder { get; }

				public BlobEncoder(BlobBuilder builder)
				{
					if (builder == null)
					{
						System.Reflection.Throw.ArgumentNull("builder");
					}
					Builder = builder;
				}

				/// <summary>
				/// Encodes Field Signature blob, with additional support for
				/// encoding ref fields, custom modifiers and typed references.
				/// </summary>
				/// <returns>Encoder of the field type.</returns>
				public FieldTypeEncoder Field()
				{
					Builder.WriteByte(6);
					return new FieldTypeEncoder(Builder);
				}

				/// <summary>
				/// Encodes Field Signature blob.
				/// </summary>
				/// <returns>Encoder of the field type.</returns>
				/// <remarks>To encode byref fields, custom modifiers or typed
				/// references use <see cref="M:System.Reflection.Metadata.Ecma335.BlobEncoder.Field" /> instead.</remarks>
				public SignatureTypeEncoder FieldSignature()
				{
					return Field().Type();
				}

				/// <summary>
				/// Encodes Method Specification Signature blob.
				/// </summary>
				/// <param name="genericArgumentCount">Number of generic arguments.</param>
				/// <returns>Encoder of generic arguments.</returns>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="genericArgumentCount" /> is not in range [0, 0xffff].</exception>
				public GenericTypeArgumentsEncoder MethodSpecificationSignature(int genericArgumentCount)
				{
					if ((uint)genericArgumentCount > 65535u)
					{
						System.Reflection.Throw.ArgumentOutOfRange("genericArgumentCount");
					}
					Builder.WriteByte(10);
					Builder.WriteCompressedInteger(genericArgumentCount);
					return new GenericTypeArgumentsEncoder(Builder);
				}

				/// <summary>
				/// Encodes Method Signature blob.
				/// </summary>
				/// <param name="convention">Calling convention.</param>
				/// <param name="genericParameterCount">Number of generic parameters.</param>
				/// <param name="isInstanceMethod">True to encode an instance method signature, false to encode a static method signature.</param>
				/// <returns>An Encoder of the rest of the signature including return value and parameters.</returns>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="genericParameterCount" /> is not in range [0, 0xffff].</exception>
				public MethodSignatureEncoder MethodSignature(SignatureCallingConvention convention = SignatureCallingConvention.Default, int genericParameterCount = 0, bool isInstanceMethod = false)
				{
					if ((uint)genericParameterCount > 65535u)
					{
						System.Reflection.Throw.ArgumentOutOfRange("genericParameterCount");
					}
					SignatureAttributes attributes = ((genericParameterCount != 0) ? SignatureAttributes.Generic : SignatureAttributes.None) | (isInstanceMethod ? SignatureAttributes.Instance : SignatureAttributes.None);
					Builder.WriteByte(new SignatureHeader(SignatureKind.Method, convention, attributes).RawValue);
					if (genericParameterCount != 0)
					{
						Builder.WriteCompressedInteger(genericParameterCount);
					}
					return new MethodSignatureEncoder(Builder, convention == SignatureCallingConvention.VarArgs);
				}

				/// <summary>
				/// Encodes Property Signature blob.
				/// </summary>
				/// <param name="isInstanceProperty">True to encode an instance property signature, false to encode a static property signature.</param>
				/// <returns>An Encoder of the rest of the signature including return value and parameters, which has the same structure as Method Signature.</returns>
				public MethodSignatureEncoder PropertySignature(bool isInstanceProperty = false)
				{
					Builder.WriteByte(new SignatureHeader(SignatureKind.Property, SignatureCallingConvention.Default, isInstanceProperty ? SignatureAttributes.Instance : SignatureAttributes.None).RawValue);
					return new MethodSignatureEncoder(Builder, hasVarArgs: false);
				}

				/// <summary>
				/// Encodes Custom Attribute Signature blob.
				/// Returns a pair of encoders that must be used in the order they appear in the parameter list.
				/// </summary>
				/// <param name="fixedArguments">Use first, to encode fixed arguments.</param>
				/// <param name="namedArguments">Use second, to encode named arguments.</param>
				public void CustomAttributeSignature(out FixedArgumentsEncoder fixedArguments, out CustomAttributeNamedArgumentsEncoder namedArguments)
				{
					Builder.WriteUInt16(1);
					fixedArguments = new FixedArgumentsEncoder(Builder);
					namedArguments = new CustomAttributeNamedArgumentsEncoder(Builder);
				}

				/// <summary>
				/// Encodes Custom Attribute Signature blob.
				/// </summary>
				/// <param name="fixedArguments">Called first, to encode fixed arguments.</param>
				/// <param name="namedArguments">Called second, to encode named arguments.</param>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="fixedArguments" /> or <paramref name="namedArguments" /> is null.</exception>
				public void CustomAttributeSignature(Action<FixedArgumentsEncoder> fixedArguments, Action<CustomAttributeNamedArgumentsEncoder> namedArguments)
				{
					if (fixedArguments == null)
					{
						System.Reflection.Throw.ArgumentNull("fixedArguments");
					}
					if (namedArguments == null)
					{
						System.Reflection.Throw.ArgumentNull("namedArguments");
					}
					CustomAttributeSignature(out var fixedArguments2, out var namedArguments2);
					fixedArguments(fixedArguments2);
					namedArguments(namedArguments2);
				}

				/// <summary>
				/// Encodes Local Variable Signature.
				/// </summary>
				/// <param name="variableCount">Number of local variables.</param>
				/// <returns>Encoder of a sequence of local variables.</returns>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="variableCount" /> is not in range [0, 0x1fffffff].</exception>
				public LocalVariablesEncoder LocalVariableSignature(int variableCount)
				{
					if ((uint)variableCount > 536870911u)
					{
						System.Reflection.Throw.ArgumentOutOfRange("variableCount");
					}
					Builder.WriteByte(7);
					Builder.WriteCompressedInteger(variableCount);
					return new LocalVariablesEncoder(Builder);
				}

				/// <summary>
				/// Encodes Type Specification Signature.
				/// </summary>
				/// <returns>
				/// Type encoder of the structured type represented by the Type Specification (it shall not encode a primitive type).
				/// </returns>
				public SignatureTypeEncoder TypeSpecificationSignature()
				{
					return new SignatureTypeEncoder(Builder);
				}

				/// <summary>
				/// Encodes a Permission Set blob.
				/// </summary>
				/// <param name="attributeCount">Number of attributes in the set.</param>
				/// <returns>Permission Set encoder.</returns>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="attributeCount" /> is not in range [0, 0x1fffffff].</exception>
				public PermissionSetEncoder PermissionSetBlob(int attributeCount)
				{
					if ((uint)attributeCount > 536870911u)
					{
						System.Reflection.Throw.ArgumentOutOfRange("attributeCount");
					}
					Builder.WriteByte(46);
					Builder.WriteCompressedInteger(attributeCount);
					return new PermissionSetEncoder(Builder);
				}

				/// <summary>
				/// Encodes Permission Set arguments.
				/// </summary>
				/// <param name="argumentCount">Number of arguments in the set.</param>
				/// <returns>Encoder of the arguments of the set.</returns>
				public NamedArgumentsEncoder PermissionSetArguments(int argumentCount)
				{
					if ((uint)argumentCount > 536870911u)
					{
						System.Reflection.Throw.ArgumentOutOfRange("argumentCount");
					}
					Builder.WriteCompressedInteger(argumentCount);
					return new NamedArgumentsEncoder(Builder);
				}
			}

			internal struct BlobHeap
			{
				private static byte[][] s_virtualValues;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				private VirtualHeap _lazyVirtualHeap;

				internal BlobHeap(System.Reflection.Internal.MemoryBlock block, MetadataKind metadataKind)
				{
					_lazyVirtualHeap = null;
					Block = block;
					if (s_virtualValues == null && metadataKind != 0)
					{
						s_virtualValues = new byte[5][]
						{
					null,
					new byte[8] { 176, 63, 95, 127, 17, 213, 10, 58 },
					new byte[160]
					{
						0, 36, 0, 0, 4, 128, 0, 0, 148, 0,
						0, 0, 6, 2, 0, 0, 0, 36, 0, 0,
						82, 83, 65, 49, 0, 4, 0, 0, 1, 0,
						1, 0, 7, 209, 250, 87, 196, 174, 217, 240,
						163, 46, 132, 170, 15, 174, 253, 13, 233, 232,
						253, 106, 236, 143, 135, 251, 3, 118, 108, 131,
						76, 153, 146, 30, 178, 59, 231, 154, 217, 213,
						220, 193, 221, 154, 210, 54, 19, 33, 2, 144,
						11, 114, 60, 249, 128, 149, 127, 196, 225, 119,
						16, 143, 198, 7, 119, 79, 41, 232, 50, 14,
						146, 234, 5, 236, 228, 232, 33, 192, 165, 239,
						232, 241, 100, 92, 76, 12, 147, 193, 171, 153,
						40, 93, 98, 44, 170, 101, 44, 29, 250, 214,
						61, 116, 93, 111, 45, 229, 241, 126, 94, 175,
						15, 196, 150, 61, 38, 28, 138, 18, 67, 101,
						24, 32, 109, 192, 147, 52, 77, 90, 210, 147
					},
					new byte[25]
					{
						1, 0, 0, 0, 0, 0, 1, 0, 84, 2,
						13, 65, 108, 108, 111, 119, 77, 117, 108, 116,
						105, 112, 108, 101, 0
					},
					new byte[25]
					{
						1, 0, 0, 0, 0, 0, 1, 0, 84, 2,
						13, 65, 108, 108, 111, 119, 77, 117, 108, 116,
						105, 112, 108, 101, 1
					}
						};
					}
				}

				internal byte[] GetBytes(BlobHandle handle)
				{
					if (handle.IsVirtual)
					{
						return GetVirtualBlobBytes(handle, unique: true);
					}
					int heapOffset = handle.GetHeapOffset();
					int numberOfBytesRead;
					int num = Block.PeekCompressedInteger(heapOffset, out numberOfBytesRead);
					if (num == int.MaxValue)
					{
						return Array.Empty<byte>();
					}
					return Block.PeekBytes(heapOffset + numberOfBytesRead, num);
				}

				internal System.Reflection.Internal.MemoryBlock GetMemoryBlock(BlobHandle handle)
				{
					if (handle.IsVirtual)
					{
						return GetVirtualHandleMemoryBlock(handle);
					}
					Block.PeekHeapValueOffsetAndSize(handle.GetHeapOffset(), out var offset, out var size);
					return Block.GetMemoryBlockAt(offset, size);
				}

				private System.Reflection.Internal.MemoryBlock GetVirtualHandleMemoryBlock(BlobHandle handle)
				{
					VirtualHeap orCreateVirtualHeap = VirtualHeap.GetOrCreateVirtualHeap(ref _lazyVirtualHeap);
					lock (orCreateVirtualHeap)
					{
						if (!orCreateVirtualHeap.TryGetMemoryBlock(handle.RawValue, out var block))
						{
							return orCreateVirtualHeap.AddBlob(handle.RawValue, GetVirtualBlobBytes(handle, unique: false));
						}
						return block;
					}
				}

				internal BlobReader GetBlobReader(BlobHandle handle)
				{
					return new BlobReader(GetMemoryBlock(handle));
				}

				internal BlobHandle GetNextHandle(BlobHandle handle)
				{
					if (handle.IsVirtual)
					{
						return default(BlobHandle);
					}
					if (!Block.PeekHeapValueOffsetAndSize(handle.GetHeapOffset(), out var offset, out var size))
					{
						return default(BlobHandle);
					}
					int num = offset + size;
					if (num >= Block.Length)
					{
						return default(BlobHandle);
					}
					return BlobHandle.FromOffset(num);
				}

				internal static byte[] GetVirtualBlobBytes(BlobHandle handle, bool unique)
				{
					BlobHandle.VirtualIndex virtualIndex = handle.GetVirtualIndex();
					byte[] array = s_virtualValues[(uint)virtualIndex];
					if (virtualIndex - 3 <= BlobHandle.VirtualIndex.ContractPublicKeyToken)
					{
						array = (byte[])array.Clone();
						handle.SubstituteTemplateParameters(array);
					}
					else if (unique)
					{
						array = (byte[])array.Clone();
					}
					return array;
				}

				public string GetDocumentName(DocumentNameBlobHandle handle)
				{
					BlobReader blobReader = GetBlobReader(handle);
					int num = blobReader.ReadByte();
					if (num > 127)
					{
						throw new BadImageFormatException(MDCFR.Properties.Resources.InvalidDocumentName);
					}
					System.Reflection.Internal.PooledStringBuilder instance = System.Reflection.Internal.PooledStringBuilder.GetInstance();
					StringBuilder builder = instance.Builder;
					bool flag = true;
					while (blobReader.RemainingBytes > 0)
					{
						if (num != 0 && !flag)
						{
							builder.Append((char)num);
						}
						BlobReader blobReader2 = GetBlobReader(blobReader.ReadBlobHandle());
						builder.Append(blobReader2.ReadUTF8(blobReader2.Length));
						flag = false;
					}
					return instance.ToStringAndFree();
				}

				internal bool DocumentNameEquals(DocumentNameBlobHandle handle, string other, bool ignoreCase)
				{
					BlobReader blobReader = GetBlobReader(handle);
					int num = blobReader.ReadByte();
					if (num > 127)
					{
						return false;
					}
					int ignoreCaseMask = StringUtils.IgnoreCaseMask(ignoreCase);
					int num2 = 0;
					int firstDifferenceIndex;
					for (bool flag = true; blobReader.RemainingBytes > 0; num2 = firstDifferenceIndex, flag = false)
					{
						if (num != 0 && !flag)
						{
							if (num2 == other.Length || !StringUtils.IsEqualAscii(other[num2], num, ignoreCaseMask))
							{
								return false;
							}
							num2++;
						}
						System.Reflection.Internal.MemoryBlock memoryBlock = GetMemoryBlock(blobReader.ReadBlobHandle());
						switch (memoryBlock.Utf8NullTerminatedFastCompare(0, other, num2, out firstDifferenceIndex, '\0', ignoreCase))
						{
							case System.Reflection.Internal.MemoryBlock.FastComparisonResult.Inconclusive:
								return GetDocumentName(handle).Equals(other, ignoreCase ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);
							default:
								if (firstDifferenceIndex - num2 == memoryBlock.Length)
								{
									continue;
								}
								break;
							case System.Reflection.Internal.MemoryBlock.FastComparisonResult.Unequal:
								break;
						}
						return false;
					}
					return num2 == other.Length;
				}
			}

			internal struct ClassLayoutTableReader
			{
				internal int NumberOfRows;

				private readonly bool _IsTypeDefTableRowRefSizeSmall;

				private readonly int _PackagingSizeOffset;

				private readonly int _ClassSizeOffset;

				private readonly int _ParentOffset;

				internal readonly int RowSize;

				internal System.Reflection.Internal.MemoryBlock Block;

				internal ClassLayoutTableReader(int numberOfRows, bool declaredSorted, int typeDefTableRowRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;
					_PackagingSizeOffset = 0;
					_ClassSizeOffset = _PackagingSizeOffset + 2;
					_ParentOffset = _ClassSizeOffset + 4;
					RowSize = _ParentOffset + typeDefTableRowRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
					if (!declaredSorted && !CheckSorted())
					{
						System.Reflection.Throw.TableNotSorted(TableIndex.ClassLayout);
					}
				}

				internal TypeDefinitionHandle GetParent(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return TypeDefinitionHandle.FromRowId(Block.PeekReference(num + _ParentOffset, _IsTypeDefTableRowRefSizeSmall));
				}

				internal ushort GetPackingSize(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return Block.PeekUInt16(num + _PackagingSizeOffset);
				}

				internal uint GetClassSize(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return Block.PeekUInt32(num + _ClassSizeOffset);
				}

				internal int FindRow(TypeDefinitionHandle typeDef)
				{
					return 1 + Block.BinarySearchReference(NumberOfRows, RowSize, _ParentOffset, (uint)typeDef.RowId, _IsTypeDefTableRowRefSizeSmall);
				}

				private bool CheckSorted()
				{
					return Block.IsOrderedByReferenceAscending(RowSize, _ParentOffset, _IsTypeDefTableRowRefSizeSmall);
				}
			}

			public static class CodedIndex
			{
				private enum HasCustomAttributeTag
				{
					MethodDef = 0,
					Field = 1,
					TypeRef = 2,
					TypeDef = 3,
					Param = 4,
					InterfaceImpl = 5,
					MemberRef = 6,
					Module = 7,
					DeclSecurity = 8,
					Property = 9,
					Event = 10,
					StandAloneSig = 11,
					ModuleRef = 12,
					TypeSpec = 13,
					Assembly = 14,
					AssemblyRef = 15,
					File = 16,
					ExportedType = 17,
					ManifestResource = 18,
					GenericParam = 19,
					GenericParamConstraint = 20,
					MethodSpec = 21,
					BitCount = 5
				}

				private enum HasConstantTag
				{
					Field = 0,
					Param = 1,
					Property = 2,
					BitCount = 2
				}

				private enum CustomAttributeTypeTag
				{
					MethodDef = 2,
					MemberRef = 3,
					BitCount = 3
				}

				private enum HasDeclSecurityTag
				{
					TypeDef = 0,
					MethodDef = 1,
					Assembly = 2,
					BitCount = 2
				}

				private enum HasFieldMarshalTag
				{
					Field = 0,
					Param = 1,
					BitCount = 1
				}

				private enum HasSemanticsTag
				{
					Event = 0,
					Property = 1,
					BitCount = 1
				}

				private enum ImplementationTag
				{
					File = 0,
					AssemblyRef = 1,
					ExportedType = 2,
					BitCount = 2
				}

				private enum MemberForwardedTag
				{
					Field = 0,
					MethodDef = 1,
					BitCount = 1
				}

				private enum MemberRefParentTag
				{
					TypeDef = 0,
					TypeRef = 1,
					ModuleRef = 2,
					MethodDef = 3,
					TypeSpec = 4,
					BitCount = 3
				}

				private enum MethodDefOrRefTag
				{
					MethodDef = 0,
					MemberRef = 1,
					BitCount = 1
				}

				private enum ResolutionScopeTag
				{
					Module = 0,
					ModuleRef = 1,
					AssemblyRef = 2,
					TypeRef = 3,
					BitCount = 2
				}

				private enum TypeDefOrRefOrSpecTag
				{
					TypeDef = 0,
					TypeRef = 1,
					TypeSpec = 2,
					BitCount = 2
				}

				private enum TypeDefOrRefTag
				{
					TypeDef,
					TypeRef,
					BitCount
				}

				private enum TypeOrMethodDefTag
				{
					TypeDef = 0,
					MethodDef = 1,
					BitCount = 1
				}

				private enum HasCustomDebugInformationTag
				{
					MethodDef = 0,
					Field = 1,
					TypeRef = 2,
					TypeDef = 3,
					Param = 4,
					InterfaceImpl = 5,
					MemberRef = 6,
					Module = 7,
					DeclSecurity = 8,
					Property = 9,
					Event = 10,
					StandAloneSig = 11,
					ModuleRef = 12,
					TypeSpec = 13,
					Assembly = 14,
					AssemblyRef = 15,
					File = 16,
					ExportedType = 17,
					ManifestResource = 18,
					GenericParam = 19,
					GenericParamConstraint = 20,
					MethodSpec = 21,
					Document = 22,
					LocalScope = 23,
					LocalVariable = 24,
					LocalConstant = 25,
					ImportScope = 26,
					BitCount = 5
				}

				/// <summary>
				/// Calculates a HasCustomAttribute coded index for the specified handle.
				/// </summary>
				/// <param name="handle">
				/// <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ParameterHandle" />,
				/// <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />,
				/// <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />,
				/// <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />,
				/// <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />,
				/// <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> or
				/// <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.
				/// </param>
				/// <exception cref="T:System.ArgumentException">Unexpected handle kind.</exception>
				public static int HasCustomAttribute(EntityHandle handle)
				{
					return (handle.RowId << 5) | (int)ToHasCustomAttributeTag(handle.Kind);
				}

				/// <summary>
				/// Calculates a HasConstant coded index for the specified handle.
				/// </summary>
				/// <param name="handle"><see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, or <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
				/// <exception cref="T:System.ArgumentException">Unexpected handle kind.</exception>
				public static int HasConstant(EntityHandle handle)
				{
					return (handle.RowId << 2) | (int)ToHasConstantTag(handle.Kind);
				}

				/// <summary>
				/// Calculates a CustomAttributeType coded index for the specified handle.
				/// </summary>
				/// <param name="handle"><see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
				/// <exception cref="T:System.ArgumentException">Unexpected handle kind.</exception>
				public static int CustomAttributeType(EntityHandle handle)
				{
					return (handle.RowId << 3) | (int)ToCustomAttributeTypeTag(handle.Kind);
				}

				/// <summary>
				/// Calculates a HasDeclSecurity coded index for the specified handle.
				/// </summary>
				/// <param name="handle"><see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, or <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" /></param>
				/// <exception cref="T:System.ArgumentException">Unexpected handle kind.</exception>
				public static int HasDeclSecurity(EntityHandle handle)
				{
					return (handle.RowId << 2) | (int)ToHasDeclSecurityTag(handle.Kind);
				}

				/// <summary>
				/// Calculates a HasFieldMarshal coded index for the specified handle.
				/// </summary>
				/// <param name="handle"><see cref="T:System.Reflection.Metadata.ParameterHandle" /> or <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" /></param>
				/// <exception cref="T:System.ArgumentException">Unexpected handle kind.</exception>
				public static int HasFieldMarshal(EntityHandle handle)
				{
					return (handle.RowId << 1) | (int)ToHasFieldMarshalTag(handle.Kind);
				}

				/// <summary>
				/// Calculates a HasSemantics coded index for the specified handle.
				/// </summary>
				/// <param name="handle"><see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
				/// <exception cref="T:System.ArgumentException">Unexpected handle kind.</exception>
				public static int HasSemantics(EntityHandle handle)
				{
					return (handle.RowId << 1) | (int)ToHasSemanticsTag(handle.Kind);
				}

				/// <summary>
				/// Calculates a Implementation coded index for the specified handle.
				/// </summary>
				/// <param name="handle"><see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> or <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /></param>
				/// <exception cref="T:System.ArgumentException">Unexpected handle kind.</exception>
				public static int Implementation(EntityHandle handle)
				{
					return (handle.RowId << 2) | (int)ToImplementationTag(handle.Kind);
				}

				/// <summary>
				/// Calculates a MemberForwarded coded index for the specified handle.
				/// </summary>
				/// <param name="handle"><see cref="T:System.Reflection.Metadata.FieldDefinition" />, <see cref="T:System.Reflection.Metadata.MethodDefinition" /></param>
				/// <exception cref="T:System.ArgumentException">Unexpected handle kind.</exception>
				public static int MemberForwarded(EntityHandle handle)
				{
					return (handle.RowId << 1) | (int)ToMemberForwardedTag(handle.Kind);
				}

				/// <summary>
				/// Calculates a MemberRefParent coded index for the specified handle.
				/// </summary>
				/// <param name="handle">
				/// <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, or
				/// <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.
				/// </param>
				/// <exception cref="T:System.ArgumentException">Unexpected handle kind.</exception>
				public static int MemberRefParent(EntityHandle handle)
				{
					return (handle.RowId << 3) | (int)ToMemberRefParentTag(handle.Kind);
				}

				/// <summary>
				/// Calculates a MethodDefOrRef coded index for the specified handle.
				/// </summary>
				/// <param name="handle"><see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
				/// <exception cref="T:System.ArgumentException">Unexpected handle kind.</exception>
				public static int MethodDefOrRef(EntityHandle handle)
				{
					return (handle.RowId << 1) | (int)ToMethodDefOrRefTag(handle.Kind);
				}

				/// <summary>
				/// Calculates a ResolutionScope coded index for the specified handle.
				/// </summary>
				/// <param name="handle"><see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /> or <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
				/// <exception cref="T:System.ArgumentException">Unexpected handle kind.</exception>
				public static int ResolutionScope(EntityHandle handle)
				{
					return (handle.RowId << 2) | (int)ToResolutionScopeTag(handle.Kind);
				}

				/// <summary>
				/// Calculates a TypeDefOrRef coded index for the specified handle.
				/// </summary>
				/// <param name="handle"><see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /></param>
				/// <exception cref="T:System.ArgumentException">Unexpected handle kind.</exception>
				public static int TypeDefOrRef(EntityHandle handle)
				{
					return (handle.RowId << 2) | (int)ToTypeDefOrRefTag(handle.Kind);
				}

				/// <summary>
				/// Calculates a TypeDefOrRefOrSpec coded index for the specified handle.
				/// </summary>
				/// <param name="handle"><see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> or <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /></param>
				/// <exception cref="T:System.ArgumentException">Unexpected handle kind.</exception>
				public static int TypeDefOrRefOrSpec(EntityHandle handle)
				{
					return (handle.RowId << 2) | (int)ToTypeDefOrRefOrSpecTag(handle.Kind);
				}

				/// <summary>
				/// Calculates a TypeOrMethodDef coded index for the specified handle.
				/// </summary>
				/// <param name="handle"><see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /></param>
				/// <exception cref="T:System.ArgumentException">Unexpected handle kind.</exception>
				public static int TypeOrMethodDef(EntityHandle handle)
				{
					return (handle.RowId << 1) | (int)ToTypeOrMethodDefTag(handle.Kind);
				}

				/// <summary>
				/// Calculates a HasCustomDebugInformation coded index for the specified handle.
				/// </summary>
				/// <param name="handle">
				/// <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ParameterHandle" />,
				/// <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />,
				/// <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />,
				/// <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />,
				/// <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />,
				/// <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />,
				/// <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />,
				/// <see cref="T:System.Reflection.Metadata.DocumentHandle" />,
				/// <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />,
				/// <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />,
				/// <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> or
				/// <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.
				/// </param>
				/// <exception cref="T:System.ArgumentException">Unexpected handle kind.</exception>
				public static int HasCustomDebugInformation(EntityHandle handle)
				{
					return (handle.RowId << 5) | (int)ToHasCustomDebugInformationTag(handle.Kind);
				}

				private static HasCustomAttributeTag ToHasCustomAttributeTag(HandleKind kind)
				{
					switch (kind)
					{
						case HandleKind.MethodDefinition:
							return HasCustomAttributeTag.MethodDef;
						case HandleKind.FieldDefinition:
							return HasCustomAttributeTag.Field;
						case HandleKind.TypeReference:
							return HasCustomAttributeTag.TypeRef;
						case HandleKind.TypeDefinition:
							return HasCustomAttributeTag.TypeDef;
						case HandleKind.Parameter:
							return HasCustomAttributeTag.Param;
						case HandleKind.InterfaceImplementation:
							return HasCustomAttributeTag.InterfaceImpl;
						case HandleKind.MemberReference:
							return HasCustomAttributeTag.MemberRef;
						case HandleKind.ModuleDefinition:
							return HasCustomAttributeTag.Module;
						case HandleKind.DeclarativeSecurityAttribute:
							return HasCustomAttributeTag.DeclSecurity;
						case HandleKind.PropertyDefinition:
							return HasCustomAttributeTag.Property;
						case HandleKind.EventDefinition:
							return HasCustomAttributeTag.Event;
						case HandleKind.StandaloneSignature:
							return HasCustomAttributeTag.StandAloneSig;
						case HandleKind.ModuleReference:
							return HasCustomAttributeTag.ModuleRef;
						case HandleKind.TypeSpecification:
							return HasCustomAttributeTag.TypeSpec;
						case HandleKind.AssemblyDefinition:
							return HasCustomAttributeTag.Assembly;
						case HandleKind.AssemblyReference:
							return HasCustomAttributeTag.AssemblyRef;
						case HandleKind.AssemblyFile:
							return HasCustomAttributeTag.File;
						case HandleKind.ExportedType:
							return HasCustomAttributeTag.ExportedType;
						case HandleKind.ManifestResource:
							return HasCustomAttributeTag.ManifestResource;
						case HandleKind.GenericParameter:
							return HasCustomAttributeTag.GenericParam;
						case HandleKind.GenericParameterConstraint:
							return HasCustomAttributeTag.GenericParamConstraint;
						case HandleKind.MethodSpecification:
							return HasCustomAttributeTag.MethodSpec;
						default:
							System.Reflection.Throw.InvalidArgument_UnexpectedHandleKind(kind);
							return HasCustomAttributeTag.MethodDef;
					}
				}

				private static HasConstantTag ToHasConstantTag(HandleKind kind)
				{
					switch (kind)
					{
						case HandleKind.FieldDefinition:
							return HasConstantTag.Field;
						case HandleKind.Parameter:
							return HasConstantTag.Param;
						case HandleKind.PropertyDefinition:
							return HasConstantTag.Property;
						default:
							System.Reflection.Throw.InvalidArgument_UnexpectedHandleKind(kind);
							return HasConstantTag.Field;
					}
				}

				private static CustomAttributeTypeTag ToCustomAttributeTypeTag(HandleKind kind)
				{
					switch (kind)
					{
						case HandleKind.MethodDefinition:
							return CustomAttributeTypeTag.MethodDef;
						case HandleKind.MemberReference:
							return CustomAttributeTypeTag.MemberRef;
						default:
							System.Reflection.Throw.InvalidArgument_UnexpectedHandleKind(kind);
							return (CustomAttributeTypeTag)0;
					}
				}

				private static HasDeclSecurityTag ToHasDeclSecurityTag(HandleKind kind)
				{
					switch (kind)
					{
						case HandleKind.TypeDefinition:
							return HasDeclSecurityTag.TypeDef;
						case HandleKind.MethodDefinition:
							return HasDeclSecurityTag.MethodDef;
						case HandleKind.AssemblyDefinition:
							return HasDeclSecurityTag.Assembly;
						default:
							System.Reflection.Throw.InvalidArgument_UnexpectedHandleKind(kind);
							return HasDeclSecurityTag.TypeDef;
					}
				}

				private static HasFieldMarshalTag ToHasFieldMarshalTag(HandleKind kind)
				{
					switch (kind)
					{
						case HandleKind.FieldDefinition:
							return HasFieldMarshalTag.Field;
						case HandleKind.Parameter:
							return HasFieldMarshalTag.Param;
						default:
							System.Reflection.Throw.InvalidArgument_UnexpectedHandleKind(kind);
							return HasFieldMarshalTag.Field;
					}
				}

				private static HasSemanticsTag ToHasSemanticsTag(HandleKind kind)
				{
					switch (kind)
					{
						case HandleKind.EventDefinition:
							return HasSemanticsTag.Event;
						case HandleKind.PropertyDefinition:
							return HasSemanticsTag.Property;
						default:
							System.Reflection.Throw.InvalidArgument_UnexpectedHandleKind(kind);
							return HasSemanticsTag.Event;
					}
				}

				private static ImplementationTag ToImplementationTag(HandleKind kind)
				{
					switch (kind)
					{
						case HandleKind.AssemblyFile:
							return ImplementationTag.File;
						case HandleKind.AssemblyReference:
							return ImplementationTag.AssemblyRef;
						case HandleKind.ExportedType:
							return ImplementationTag.ExportedType;
						default:
							System.Reflection.Throw.InvalidArgument_UnexpectedHandleKind(kind);
							return ImplementationTag.File;
					}
				}

				private static MemberForwardedTag ToMemberForwardedTag(HandleKind kind)
				{
					switch (kind)
					{
						case HandleKind.FieldDefinition:
							return MemberForwardedTag.Field;
						case HandleKind.MethodDefinition:
							return MemberForwardedTag.MethodDef;
						default:
							System.Reflection.Throw.InvalidArgument_UnexpectedHandleKind(kind);
							return MemberForwardedTag.Field;
					}
				}

				private static MemberRefParentTag ToMemberRefParentTag(HandleKind kind)
				{
					switch (kind)
					{
						case HandleKind.TypeDefinition:
							return MemberRefParentTag.TypeDef;
						case HandleKind.TypeReference:
							return MemberRefParentTag.TypeRef;
						case HandleKind.ModuleReference:
							return MemberRefParentTag.ModuleRef;
						case HandleKind.MethodDefinition:
							return MemberRefParentTag.MethodDef;
						case HandleKind.TypeSpecification:
							return MemberRefParentTag.TypeSpec;
						default:
							System.Reflection.Throw.InvalidArgument_UnexpectedHandleKind(kind);
							return MemberRefParentTag.TypeDef;
					}
				}

				private static MethodDefOrRefTag ToMethodDefOrRefTag(HandleKind kind)
				{
					switch (kind)
					{
						case HandleKind.MethodDefinition:
							return MethodDefOrRefTag.MethodDef;
						case HandleKind.MemberReference:
							return MethodDefOrRefTag.MemberRef;
						default:
							System.Reflection.Throw.InvalidArgument_UnexpectedHandleKind(kind);
							return MethodDefOrRefTag.MethodDef;
					}
				}

				private static ResolutionScopeTag ToResolutionScopeTag(HandleKind kind)
				{
					switch (kind)
					{
						case HandleKind.TypeReference:
							if (kind != HandleKind.TypeReference)
							{
								break;
							}
							return ResolutionScopeTag.TypeRef;
						case HandleKind.ModuleDefinition:
							return ResolutionScopeTag.Module;
						case HandleKind.ModuleReference:
							return ResolutionScopeTag.ModuleRef;
						case HandleKind.AssemblyReference:
							return ResolutionScopeTag.AssemblyRef;
					}
					System.Reflection.Throw.InvalidArgument_UnexpectedHandleKind(kind);
					return ResolutionScopeTag.Module;
				}

				private static TypeDefOrRefOrSpecTag ToTypeDefOrRefOrSpecTag(HandleKind kind)
				{
					switch (kind)
					{
						case HandleKind.TypeDefinition:
							return TypeDefOrRefOrSpecTag.TypeDef;
						case HandleKind.TypeReference:
							return TypeDefOrRefOrSpecTag.TypeRef;
						case HandleKind.TypeSpecification:
							return TypeDefOrRefOrSpecTag.TypeSpec;
						default:
							System.Reflection.Throw.InvalidArgument_UnexpectedHandleKind(kind);
							return TypeDefOrRefOrSpecTag.TypeDef;
					}
				}

				private static TypeDefOrRefTag ToTypeDefOrRefTag(HandleKind kind)
				{
					switch (kind)
					{
						case HandleKind.TypeDefinition:
							return TypeDefOrRefTag.TypeDef;
						case HandleKind.TypeReference:
							return TypeDefOrRefTag.TypeRef;
						default:
							System.Reflection.Throw.InvalidArgument_UnexpectedHandleKind(kind);
							return TypeDefOrRefTag.TypeDef;
					}
				}

				private static TypeOrMethodDefTag ToTypeOrMethodDefTag(HandleKind kind)
				{
					switch (kind)
					{
						case HandleKind.TypeDefinition:
							return TypeOrMethodDefTag.TypeDef;
						case HandleKind.MethodDefinition:
							return TypeOrMethodDefTag.MethodDef;
						default:
							System.Reflection.Throw.InvalidArgument_UnexpectedHandleKind(kind);
							return TypeOrMethodDefTag.TypeDef;
					}
				}

				private static HasCustomDebugInformationTag ToHasCustomDebugInformationTag(HandleKind kind)
				{
					switch (kind)
					{
						case HandleKind.MethodDefinition:
							return HasCustomDebugInformationTag.MethodDef;
						case HandleKind.FieldDefinition:
							return HasCustomDebugInformationTag.Field;
						case HandleKind.TypeReference:
							return HasCustomDebugInformationTag.TypeRef;
						case HandleKind.TypeDefinition:
							return HasCustomDebugInformationTag.TypeDef;
						case HandleKind.Parameter:
							return HasCustomDebugInformationTag.Param;
						case HandleKind.InterfaceImplementation:
							return HasCustomDebugInformationTag.InterfaceImpl;
						case HandleKind.MemberReference:
							return HasCustomDebugInformationTag.MemberRef;
						case HandleKind.ModuleDefinition:
							return HasCustomDebugInformationTag.Module;
						case HandleKind.DeclarativeSecurityAttribute:
							return HasCustomDebugInformationTag.DeclSecurity;
						case HandleKind.PropertyDefinition:
							return HasCustomDebugInformationTag.Property;
						case HandleKind.EventDefinition:
							return HasCustomDebugInformationTag.Event;
						case HandleKind.StandaloneSignature:
							return HasCustomDebugInformationTag.StandAloneSig;
						case HandleKind.ModuleReference:
							return HasCustomDebugInformationTag.ModuleRef;
						case HandleKind.TypeSpecification:
							return HasCustomDebugInformationTag.TypeSpec;
						case HandleKind.AssemblyDefinition:
							return HasCustomDebugInformationTag.Assembly;
						case HandleKind.AssemblyReference:
							return HasCustomDebugInformationTag.AssemblyRef;
						case HandleKind.AssemblyFile:
							return HasCustomDebugInformationTag.File;
						case HandleKind.ExportedType:
							return HasCustomDebugInformationTag.ExportedType;
						case HandleKind.ManifestResource:
							return HasCustomDebugInformationTag.ManifestResource;
						case HandleKind.GenericParameter:
							return HasCustomDebugInformationTag.GenericParam;
						case HandleKind.GenericParameterConstraint:
							return HasCustomDebugInformationTag.GenericParamConstraint;
						case HandleKind.MethodSpecification:
							return HasCustomDebugInformationTag.MethodSpec;
						case HandleKind.Document:
							return HasCustomDebugInformationTag.Document;
						case HandleKind.LocalScope:
							return HasCustomDebugInformationTag.LocalScope;
						case HandleKind.LocalVariable:
							return HasCustomDebugInformationTag.LocalVariable;
						case HandleKind.LocalConstant:
							return HasCustomDebugInformationTag.LocalConstant;
						case HandleKind.ImportScope:
							return HasCustomDebugInformationTag.ImportScope;
						default:
							System.Reflection.Throw.InvalidArgument_UnexpectedHandleKind(kind);
							return HasCustomDebugInformationTag.MethodDef;
					}
				}
			}

			internal readonly struct ConstantTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsHasConstantRefSizeSmall;

				private readonly bool _IsBlobHeapRefSizeSmall;

				private readonly int _TypeOffset;

				private readonly int _ParentOffset;

				private readonly int _ValueOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal ConstantTableReader(int numberOfRows, bool declaredSorted, int hasConstantRefSize, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsHasConstantRefSizeSmall = hasConstantRefSize == 2;
					_IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_TypeOffset = 0;
					_ParentOffset = _TypeOffset + 1 + 1;
					_ValueOffset = _ParentOffset + hasConstantRefSize;
					RowSize = _ValueOffset + blobHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
					if (!declaredSorted && !CheckSorted())
					{
						System.Reflection.Throw.TableNotSorted(TableIndex.Constant);
					}
				}

				internal ConstantTypeCode GetType(ConstantHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return (ConstantTypeCode)Block.PeekByte(num + _TypeOffset);
				}

				internal BlobHandle GetValue(ConstantHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _ValueOffset, _IsBlobHeapRefSizeSmall));
				}

				internal EntityHandle GetParent(ConstantHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return HasConstantTag.ConvertToHandle(Block.PeekTaggedReference(num + _ParentOffset, _IsHasConstantRefSizeSmall));
				}

				internal ConstantHandle FindConstant(EntityHandle parentHandle)
				{
					int num = Block.BinarySearchReference(NumberOfRows, RowSize, _ParentOffset, HasConstantTag.ConvertToTag(parentHandle), _IsHasConstantRefSizeSmall);
					return ConstantHandle.FromRowId(num + 1);
				}

				private bool CheckSorted()
				{
					return Block.IsOrderedByReferenceAscending(RowSize, _ParentOffset, _IsHasConstantRefSizeSmall);
				}
			}

			public sealed class ControlFlowBuilder
			{
				internal readonly struct BranchInfo
				{
					internal readonly int ILOffset;

					internal readonly LabelHandle Label;

					private readonly byte _opCode;

					internal ILOpCode OpCode => (ILOpCode)_opCode;

					internal BranchInfo(int ilOffset, LabelHandle label, ILOpCode opCode)
					{
						ILOffset = ilOffset;
						Label = label;
						_opCode = (byte)opCode;
					}

					internal int GetBranchDistance(System.Collections.Immutable.ImmutableArray<int>.Builder labels, ILOpCode branchOpCode, int branchILOffset, bool isShortBranch)
					{
						int num = labels[Label.Id - 1];
						if (num < 0)
						{
							System.Reflection.Throw.InvalidOperation_LabelNotMarked(Label.Id);
						}
						int num2 = 1 + (isShortBranch ? 1 : 4);
						int num3 = num - (ILOffset + num2);
						if (isShortBranch && (sbyte)num3 != num3)
						{
							throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.DistanceBetweenInstructionAndLabelTooBig, branchOpCode, branchILOffset, num3));
						}
						return num3;
					}
				}

				internal readonly struct ExceptionHandlerInfo
				{
					public readonly ExceptionRegionKind Kind;

					public readonly LabelHandle TryStart;

					public readonly LabelHandle TryEnd;

					public readonly LabelHandle HandlerStart;

					public readonly LabelHandle HandlerEnd;

					public readonly LabelHandle FilterStart;

					public readonly EntityHandle CatchType;

					public ExceptionHandlerInfo(ExceptionRegionKind kind, LabelHandle tryStart, LabelHandle tryEnd, LabelHandle handlerStart, LabelHandle handlerEnd, LabelHandle filterStart, EntityHandle catchType)
					{
						Kind = kind;
						TryStart = tryStart;
						TryEnd = tryEnd;
						HandlerStart = handlerStart;
						HandlerEnd = handlerEnd;
						FilterStart = filterStart;
						CatchType = catchType;
					}
				}

				private readonly System.Collections.Immutable.ImmutableArray<BranchInfo>.Builder _branches;

				private readonly System.Collections.Immutable.ImmutableArray<int>.Builder _labels;

				private System.Collections.Immutable.ImmutableArray<ExceptionHandlerInfo>.Builder _lazyExceptionHandlers;

				internal IEnumerable<BranchInfo> Branches => (IEnumerable<BranchInfo>)(object)_branches;

				internal IEnumerable<int> Labels => (IEnumerable<int>)(object)_labels;

				internal int BranchCount => _branches.Count;

				internal int ExceptionHandlerCount => _lazyExceptionHandlers?.Count ?? 0;

				public ControlFlowBuilder()
				{
					_branches = System.Collections.Immutable.ImmutableArray.CreateBuilder<BranchInfo>();
					_labels = System.Collections.Immutable.ImmutableArray.CreateBuilder<int>();
				}

				/// <summary>
				/// Clears the object's internal state, allowing the same instance to be reused.
				/// </summary>
				public void Clear()
				{
					_branches.Clear();
					_labels.Clear();
					_lazyExceptionHandlers?.Clear();
				}

				internal LabelHandle AddLabel()
				{
					_labels.Add(-1);
					return new LabelHandle(_labels.Count);
				}

				internal void AddBranch(int ilOffset, LabelHandle label, ILOpCode opCode)
				{
					ValidateLabel(label, "label");
					_branches.Add(new BranchInfo(ilOffset, label, opCode));
				}

				internal void MarkLabel(int ilOffset, LabelHandle label)
				{
					ValidateLabel(label, "label");
					_labels[label.Id - 1] = ilOffset;
				}

				private int GetLabelOffsetChecked(LabelHandle label)
				{
					int num = _labels[label.Id - 1];
					if (num < 0)
					{
						System.Reflection.Throw.InvalidOperation_LabelNotMarked(label.Id);
					}
					return num;
				}

				private void ValidateLabel(LabelHandle label, string parameterName)
				{
					if (label.IsNil)
					{
						System.Reflection.Throw.ArgumentNull(parameterName);
					}
					if (label.Id > _labels.Count)
					{
						System.Reflection.Throw.LabelDoesntBelongToBuilder(parameterName);
					}
				}

				/// <summary>
				/// Adds finally region.
				/// </summary>
				/// <param name="tryStart">Label marking the first instruction of the try block.</param>
				/// <param name="tryEnd">Label marking the instruction immediately following the try block.</param>
				/// <param name="handlerStart">Label marking the first instruction of the handler.</param>
				/// <param name="handlerEnd">Label marking the instruction immediately following the handler.</param>
				/// <exception cref="T:System.ArgumentException">A label was not defined by an instruction encoder this builder is associated with.</exception>
				/// <exception cref="T:System.ArgumentNullException">A label has default value.</exception>
				public void AddFinallyRegion(LabelHandle tryStart, LabelHandle tryEnd, LabelHandle handlerStart, LabelHandle handlerEnd)
				{
					AddExceptionRegion(ExceptionRegionKind.Finally, tryStart, tryEnd, handlerStart, handlerEnd);
				}

				/// <summary>
				/// Adds fault region.
				/// </summary>
				/// <param name="tryStart">Label marking the first instruction of the try block.</param>
				/// <param name="tryEnd">Label marking the instruction immediately following the try block.</param>
				/// <param name="handlerStart">Label marking the first instruction of the handler.</param>
				/// <param name="handlerEnd">Label marking the instruction immediately following the handler.</param>
				/// <exception cref="T:System.ArgumentException">A label was not defined by an instruction encoder this builder is associated with.</exception>
				/// <exception cref="T:System.ArgumentNullException">A label has default value.</exception>
				public void AddFaultRegion(LabelHandle tryStart, LabelHandle tryEnd, LabelHandle handlerStart, LabelHandle handlerEnd)
				{
					AddExceptionRegion(ExceptionRegionKind.Fault, tryStart, tryEnd, handlerStart, handlerEnd);
				}

				/// <summary>
				/// Adds catch region.
				/// </summary>
				/// <param name="tryStart">Label marking the first instruction of the try block.</param>
				/// <param name="tryEnd">Label marking the instruction immediately following the try block.</param>
				/// <param name="handlerStart">Label marking the first instruction of the handler.</param>
				/// <param name="handlerEnd">Label marking the instruction immediately following the handler.</param>
				/// <param name="catchType">The type of exception to be caught: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> or <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
				/// <exception cref="T:System.ArgumentException">A label was not defined by an instruction encoder this builder is associated with.</exception>
				/// <exception cref="T:System.ArgumentException"><paramref name="catchType" /> is not a valid type handle.</exception>
				/// <exception cref="T:System.ArgumentNullException">A label has default value.</exception>
				public void AddCatchRegion(LabelHandle tryStart, LabelHandle tryEnd, LabelHandle handlerStart, LabelHandle handlerEnd, EntityHandle catchType)
				{
					if (!ExceptionRegionEncoder.IsValidCatchTypeHandle(catchType))
					{
						System.Reflection.Throw.InvalidArgument_Handle("catchType");
					}
					AddExceptionRegion(ExceptionRegionKind.Catch, tryStart, tryEnd, handlerStart, handlerEnd, default(LabelHandle), catchType);
				}

				/// <summary>
				/// Adds catch region.
				/// </summary>
				/// <param name="tryStart">Label marking the first instruction of the try block.</param>
				/// <param name="tryEnd">Label marking the instruction immediately following the try block.</param>
				/// <param name="handlerStart">Label marking the first instruction of the handler.</param>
				/// <param name="handlerEnd">Label marking the instruction immediately following the handler.</param>
				/// <param name="filterStart">Label marking the first instruction of the filter block.</param>
				/// <exception cref="T:System.ArgumentException">A label was not defined by an instruction encoder this builder is associated with.</exception>
				/// <exception cref="T:System.ArgumentNullException">A label has default value.</exception>
				public void AddFilterRegion(LabelHandle tryStart, LabelHandle tryEnd, LabelHandle handlerStart, LabelHandle handlerEnd, LabelHandle filterStart)
				{
					ValidateLabel(filterStart, "filterStart");
					AddExceptionRegion(ExceptionRegionKind.Filter, tryStart, tryEnd, handlerStart, handlerEnd, filterStart);
				}

				private void AddExceptionRegion(ExceptionRegionKind kind, LabelHandle tryStart, LabelHandle tryEnd, LabelHandle handlerStart, LabelHandle handlerEnd, LabelHandle filterStart = default(LabelHandle), EntityHandle catchType = default(EntityHandle))
				{
					ValidateLabel(tryStart, "tryStart");
					ValidateLabel(tryEnd, "tryEnd");
					ValidateLabel(handlerStart, "handlerStart");
					ValidateLabel(handlerEnd, "handlerEnd");
					if (_lazyExceptionHandlers == null)
					{
						_lazyExceptionHandlers = System.Collections.Immutable.ImmutableArray.CreateBuilder<ExceptionHandlerInfo>();
					}
					_lazyExceptionHandlers.Add(new ExceptionHandlerInfo(kind, tryStart, tryEnd, handlerStart, handlerEnd, filterStart, catchType));
				}

				/// <exception cref="T:System.InvalidOperationException" />
				internal void CopyCodeAndFixupBranches(BlobBuilder srcBuilder, BlobBuilder dstBuilder)
				{
					BranchInfo branchInfo = _branches[0];
					int num = 0;
					int num2 = 0;
					int num3 = 0;
					foreach (Blob blob in srcBuilder.GetBlobs())
					{
						while (true)
						{
							int num4 = Math.Min(branchInfo.ILOffset - num2, blob.Length - num3);
							dstBuilder.WriteBytes(blob.Buffer, num3, num4);
							num2 += num4;
							num3 += num4;
							if (num3 == blob.Length)
							{
								num3 = 0;
								break;
							}
							int branchOperandSize = branchInfo.OpCode.GetBranchOperandSize();
							bool flag = branchOperandSize == 1;
							dstBuilder.WriteByte(blob.Buffer[num3]);
							int branchDistance = branchInfo.GetBranchDistance(_labels, branchInfo.OpCode, num2, flag);
							if (flag)
							{
								dstBuilder.WriteSByte((sbyte)branchDistance);
							}
							else
							{
								dstBuilder.WriteInt32(branchDistance);
							}
							num2 += 1 + branchOperandSize;
							num++;
							branchInfo = ((num != _branches.Count) ? _branches[num] : new BranchInfo(int.MaxValue, default(LabelHandle), ILOpCode.Nop));
							if (num3 == blob.Length - 1)
							{
								num3 = branchOperandSize;
								break;
							}
							num3 += 1 + branchOperandSize;
						}
					}
				}

				internal void SerializeExceptionTable(BlobBuilder builder)
				{
					if (_lazyExceptionHandlers == null || _lazyExceptionHandlers.Count == 0)
					{
						return;
					}
					ExceptionRegionEncoder exceptionRegionEncoder = ExceptionRegionEncoder.SerializeTableHeader(builder, _lazyExceptionHandlers.Count, HasSmallExceptionRegions());
					foreach (ExceptionHandlerInfo lazyExceptionHandler in _lazyExceptionHandlers)
					{
						int labelOffsetChecked = GetLabelOffsetChecked(lazyExceptionHandler.TryStart);
						int labelOffsetChecked2 = GetLabelOffsetChecked(lazyExceptionHandler.TryEnd);
						int labelOffsetChecked3 = GetLabelOffsetChecked(lazyExceptionHandler.HandlerStart);
						int labelOffsetChecked4 = GetLabelOffsetChecked(lazyExceptionHandler.HandlerEnd);
						if (labelOffsetChecked > labelOffsetChecked2)
						{
							System.Reflection.Throw.InvalidOperation(System.SR.Format(MDCFR.Properties.Resources.InvalidExceptionRegionBounds, labelOffsetChecked, labelOffsetChecked2));
						}
						if (labelOffsetChecked3 > labelOffsetChecked4)
						{
							System.Reflection.Throw.InvalidOperation(System.SR.Format(MDCFR.Properties.Resources.InvalidExceptionRegionBounds, labelOffsetChecked3, labelOffsetChecked4));
						}
						int catchTokenOrOffset = lazyExceptionHandler.Kind switch
						{
							ExceptionRegionKind.Catch => MetadataTokens.GetToken(lazyExceptionHandler.CatchType),
							ExceptionRegionKind.Filter => GetLabelOffsetChecked(lazyExceptionHandler.FilterStart),
							_ => 0,
						};
						exceptionRegionEncoder.AddUnchecked(lazyExceptionHandler.Kind, labelOffsetChecked, labelOffsetChecked2 - labelOffsetChecked, labelOffsetChecked3, labelOffsetChecked4 - labelOffsetChecked3, catchTokenOrOffset);
					}
				}

				private bool HasSmallExceptionRegions()
				{
					if (!ExceptionRegionEncoder.IsSmallRegionCount(_lazyExceptionHandlers.Count))
					{
						return false;
					}
					foreach (ExceptionHandlerInfo lazyExceptionHandler in _lazyExceptionHandlers)
					{
						if (!ExceptionRegionEncoder.IsSmallExceptionRegionFromBounds(GetLabelOffsetChecked(lazyExceptionHandler.TryStart), GetLabelOffsetChecked(lazyExceptionHandler.TryEnd)) || !ExceptionRegionEncoder.IsSmallExceptionRegionFromBounds(GetLabelOffsetChecked(lazyExceptionHandler.HandlerStart), GetLabelOffsetChecked(lazyExceptionHandler.HandlerEnd)))
						{
							return false;
						}
					}
					return true;
				}
			}

			internal static class COR20Constants
			{
				internal const int SizeOfCorHeader = 72;

				internal const uint COR20MetadataSignature = 1112167234u;

				internal const int MinimumSizeofMetadataHeader = 16;

				internal const int SizeofStorageHeader = 4;

				internal const int MinimumSizeofStreamHeader = 8;

				internal const string StringStreamName = "#Strings";

				internal const string BlobStreamName = "#Blob";

				internal const string GUIDStreamName = "#GUID";

				internal const string UserStringStreamName = "#US";

				internal const string CompressedMetadataTableStreamName = "#~";

				internal const string UncompressedMetadataTableStreamName = "#-";

				internal const string MinimalDeltaMetadataTableStreamName = "#JTD";

				internal const string StandalonePdbStreamName = "#Pdb";

				internal const int LargeStreamHeapSize = 4096;
			}

			internal enum CorElementType : byte
			{
				Invalid = 0,
				ELEMENT_TYPE_VOID = 1,
				ELEMENT_TYPE_BOOLEAN = 2,
				ELEMENT_TYPE_CHAR = 3,
				ELEMENT_TYPE_I1 = 4,
				ELEMENT_TYPE_U1 = 5,
				ELEMENT_TYPE_I2 = 6,
				ELEMENT_TYPE_U2 = 7,
				ELEMENT_TYPE_I4 = 8,
				ELEMENT_TYPE_U4 = 9,
				ELEMENT_TYPE_I8 = 10,
				ELEMENT_TYPE_U8 = 11,
				ELEMENT_TYPE_R4 = 12,
				ELEMENT_TYPE_R8 = 13,
				ELEMENT_TYPE_STRING = 14,
				ELEMENT_TYPE_PTR = 15,
				ELEMENT_TYPE_BYREF = 16,
				ELEMENT_TYPE_VALUETYPE = 17,
				ELEMENT_TYPE_CLASS = 18,
				ELEMENT_TYPE_VAR = 19,
				ELEMENT_TYPE_ARRAY = 20,
				ELEMENT_TYPE_GENERICINST = 21,
				ELEMENT_TYPE_TYPEDBYREF = 22,
				ELEMENT_TYPE_I = 24,
				ELEMENT_TYPE_U = 25,
				ELEMENT_TYPE_FNPTR = 27,
				ELEMENT_TYPE_OBJECT = 28,
				ELEMENT_TYPE_SZARRAY = 29,
				ELEMENT_TYPE_MVAR = 30,
				ELEMENT_TYPE_CMOD_REQD = 31,
				ELEMENT_TYPE_CMOD_OPT = 32,
				ELEMENT_TYPE_HANDLE = 64,
				ELEMENT_TYPE_SENTINEL = 65,
				ELEMENT_TYPE_PINNED = 69
			}

			public readonly struct CustomAttributeArrayTypeEncoder
			{
				public BlobBuilder Builder { get; }

				public CustomAttributeArrayTypeEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				public void ObjectArray()
				{
					Builder.WriteByte(29);
					Builder.WriteByte(81);
				}

				public CustomAttributeElementTypeEncoder ElementType()
				{
					Builder.WriteByte(29);
					return new CustomAttributeElementTypeEncoder(Builder);
				}
			}

			/// <summary>
			/// Decodes custom attribute blobs.
			/// </summary>
			internal readonly struct CustomAttributeDecoder<TType>
			{
				private struct ArgumentTypeInfo
				{
					public TType Type;

					public TType ElementType;

					public SerializationTypeCode TypeCode;

					public SerializationTypeCode ElementTypeCode;
				}

				private readonly ICustomAttributeTypeProvider<TType> _provider;

				private readonly MetadataReader _reader;

				public CustomAttributeDecoder(ICustomAttributeTypeProvider<TType> provider, MetadataReader reader)
				{
					_reader = reader;
					_provider = provider;
				}

				public CustomAttributeValue<TType> DecodeValue(EntityHandle constructor, BlobHandle value)
				{
					BlobHandle handle = default(BlobHandle);
					BlobHandle signature;
					switch (constructor.Kind)
					{
						case HandleKind.MethodDefinition:
							signature = _reader.GetMethodDefinition((MethodDefinitionHandle)constructor).Signature;
							break;
						case HandleKind.MemberReference:
							{
								MemberReference memberReference = _reader.GetMemberReference((MemberReferenceHandle)constructor);
								signature = memberReference.Signature;
								if (memberReference.Parent.Kind == HandleKind.TypeSpecification)
								{
									handle = _reader.GetTypeSpecification((TypeSpecificationHandle)memberReference.Parent).Signature;
								}
								break;
							}
						default:
							throw new BadImageFormatException();
					}
					BlobReader signatureReader = _reader.GetBlobReader(signature);
					BlobReader valueReader = _reader.GetBlobReader(value);
					ushort num = valueReader.ReadUInt16();
					if (num != 1)
					{
						throw new BadImageFormatException();
					}
					SignatureHeader signatureHeader = signatureReader.ReadSignatureHeader();
					if (signatureHeader.Kind != 0 || signatureHeader.IsGeneric)
					{
						throw new BadImageFormatException();
					}
					int count = signatureReader.ReadCompressedInteger();
					SignatureTypeCode signatureTypeCode = signatureReader.ReadSignatureTypeCode();
					if (signatureTypeCode != SignatureTypeCode.Void)
					{
						throw new BadImageFormatException();
					}
					BlobReader genericContextReader = default(BlobReader);
					if (!handle.IsNil)
					{
						genericContextReader = _reader.GetBlobReader(handle);
						if (genericContextReader.ReadSignatureTypeCode() == SignatureTypeCode.GenericTypeInstance)
						{
							int num2 = genericContextReader.ReadCompressedInteger();
							if (num2 != 18 && num2 != 17)
							{
								throw new BadImageFormatException();
							}
							genericContextReader.ReadTypeHandle();
						}
						else
						{
							genericContextReader = default(BlobReader);
						}
					}
					System.Collections.Immutable.ImmutableArray<CustomAttributeTypedArgument<TType>> fixedArguments = DecodeFixedArguments(ref signatureReader, ref valueReader, count, genericContextReader);
					System.Collections.Immutable.ImmutableArray<CustomAttributeNamedArgument<TType>> namedArguments = DecodeNamedArguments(ref valueReader);
					return new CustomAttributeValue<TType>(fixedArguments, namedArguments);
				}

				private System.Collections.Immutable.ImmutableArray<CustomAttributeTypedArgument<TType>> DecodeFixedArguments(ref BlobReader signatureReader, ref BlobReader valueReader, int count, BlobReader genericContextReader)
				{
					if (count == 0)
					{
						return System.Collections.Immutable.ImmutableArray<CustomAttributeTypedArgument<TType>>.Empty;
					}
					System.Collections.Immutable.ImmutableArray<CustomAttributeTypedArgument<TType>>.Builder builder = System.Collections.Immutable.ImmutableArray.CreateBuilder<CustomAttributeTypedArgument<TType>>(count);
					for (int i = 0; i < count; i++)
					{
						ArgumentTypeInfo info = DecodeFixedArgumentType(ref signatureReader, genericContextReader);
						builder.Add(DecodeArgument(ref valueReader, info));
					}
					return builder.MoveToImmutable();
				}

				private System.Collections.Immutable.ImmutableArray<CustomAttributeNamedArgument<TType>> DecodeNamedArguments(ref BlobReader valueReader)
				{
					int num = valueReader.ReadUInt16();
					if (num == 0)
					{
						return System.Collections.Immutable.ImmutableArray<CustomAttributeNamedArgument<TType>>.Empty;
					}
					System.Collections.Immutable.ImmutableArray<CustomAttributeNamedArgument<TType>>.Builder builder = System.Collections.Immutable.ImmutableArray.CreateBuilder<CustomAttributeNamedArgument<TType>>(num);
					for (int i = 0; i < num; i++)
					{
						CustomAttributeNamedArgumentKind customAttributeNamedArgumentKind = (CustomAttributeNamedArgumentKind)valueReader.ReadSerializationTypeCode();
						if (customAttributeNamedArgumentKind != CustomAttributeNamedArgumentKind.Field && customAttributeNamedArgumentKind != CustomAttributeNamedArgumentKind.Property)
						{
							throw new BadImageFormatException();
						}
						ArgumentTypeInfo info = DecodeNamedArgumentType(ref valueReader);
						string name = valueReader.ReadSerializedString();
						CustomAttributeTypedArgument<TType> customAttributeTypedArgument = DecodeArgument(ref valueReader, info);
						builder.Add(new CustomAttributeNamedArgument<TType>(name, customAttributeNamedArgumentKind, customAttributeTypedArgument.Type, customAttributeTypedArgument.Value));
					}
					return builder.MoveToImmutable();
				}

				private ArgumentTypeInfo DecodeFixedArgumentType(ref BlobReader signatureReader, BlobReader genericContextReader, bool isElementType = false)
				{
					SignatureTypeCode signatureTypeCode = signatureReader.ReadSignatureTypeCode();
					ArgumentTypeInfo argumentTypeInfo = default(ArgumentTypeInfo);
					argumentTypeInfo.TypeCode = (SerializationTypeCode)signatureTypeCode;
					ArgumentTypeInfo result = argumentTypeInfo;
					switch (signatureTypeCode)
					{
						case SignatureTypeCode.Boolean:
						case SignatureTypeCode.Char:
						case SignatureTypeCode.SByte:
						case SignatureTypeCode.Byte:
						case SignatureTypeCode.Int16:
						case SignatureTypeCode.UInt16:
						case SignatureTypeCode.Int32:
						case SignatureTypeCode.UInt32:
						case SignatureTypeCode.Int64:
						case SignatureTypeCode.UInt64:
						case SignatureTypeCode.Single:
						case SignatureTypeCode.Double:
						case SignatureTypeCode.String:
							result.Type = _provider.GetPrimitiveType((PrimitiveTypeCode)signatureTypeCode);
							break;
						case SignatureTypeCode.Object:
							result.TypeCode = SerializationTypeCode.TaggedObject;
							result.Type = _provider.GetPrimitiveType(PrimitiveTypeCode.Object);
							break;
						case SignatureTypeCode.TypeHandle:
							{
								EntityHandle handle = signatureReader.ReadTypeHandle();
								result.Type = GetTypeFromHandle(handle);
								result.TypeCode = (SerializationTypeCode)(_provider.IsSystemType(result.Type) ? ((PrimitiveTypeCode)80) : _provider.GetUnderlyingEnumType(result.Type));
								break;
							}
						case SignatureTypeCode.SZArray:
							{
								if (isElementType)
								{
									throw new BadImageFormatException();
								}
								ArgumentTypeInfo argumentTypeInfo2 = DecodeFixedArgumentType(ref signatureReader, genericContextReader, isElementType: true);
								result.ElementType = argumentTypeInfo2.Type;
								result.ElementTypeCode = argumentTypeInfo2.TypeCode;
								result.Type = _provider.GetSZArrayType(result.ElementType);
								break;
							}
						case SignatureTypeCode.GenericTypeParameter:
							{
								if (genericContextReader.Length == 0)
								{
									throw new BadImageFormatException();
								}
								int num = signatureReader.ReadCompressedInteger();
								int num2 = genericContextReader.ReadCompressedInteger();
								if (num >= num2)
								{
									throw new BadImageFormatException();
								}
								while (num > 0)
								{
									SkipType(ref genericContextReader);
									num--;
								}
								return DecodeFixedArgumentType(ref genericContextReader, default(BlobReader), isElementType);
							}
						default:
							throw new BadImageFormatException();
					}
					return result;
				}

				private ArgumentTypeInfo DecodeNamedArgumentType(ref BlobReader valueReader, bool isElementType = false)
				{
					ArgumentTypeInfo argumentTypeInfo = default(ArgumentTypeInfo);
					argumentTypeInfo.TypeCode = valueReader.ReadSerializationTypeCode();
					ArgumentTypeInfo result = argumentTypeInfo;
					switch (result.TypeCode)
					{
						case SerializationTypeCode.Boolean:
						case SerializationTypeCode.Char:
						case SerializationTypeCode.SByte:
						case SerializationTypeCode.Byte:
						case SerializationTypeCode.Int16:
						case SerializationTypeCode.UInt16:
						case SerializationTypeCode.Int32:
						case SerializationTypeCode.UInt32:
						case SerializationTypeCode.Int64:
						case SerializationTypeCode.UInt64:
						case SerializationTypeCode.Single:
						case SerializationTypeCode.Double:
						case SerializationTypeCode.String:
							result.Type = _provider.GetPrimitiveType((PrimitiveTypeCode)result.TypeCode);
							break;
						case SerializationTypeCode.Type:
							result.Type = _provider.GetSystemType();
							break;
						case SerializationTypeCode.TaggedObject:
							result.Type = _provider.GetPrimitiveType(PrimitiveTypeCode.Object);
							break;
						case SerializationTypeCode.SZArray:
							{
								if (isElementType)
								{
									throw new BadImageFormatException();
								}
								ArgumentTypeInfo argumentTypeInfo2 = DecodeNamedArgumentType(ref valueReader, isElementType: true);
								result.ElementType = argumentTypeInfo2.Type;
								result.ElementTypeCode = argumentTypeInfo2.TypeCode;
								result.Type = _provider.GetSZArrayType(result.ElementType);
								break;
							}
						case SerializationTypeCode.Enum:
							{
								string name = valueReader.ReadSerializedString();
								result.Type = _provider.GetTypeFromSerializedName(name);
								result.TypeCode = (SerializationTypeCode)_provider.GetUnderlyingEnumType(result.Type);
								break;
							}
						default:
							throw new BadImageFormatException();
					}
					return result;
				}

				private CustomAttributeTypedArgument<TType> DecodeArgument(ref BlobReader valueReader, ArgumentTypeInfo info)
				{
					if (info.TypeCode == SerializationTypeCode.TaggedObject)
					{
						info = DecodeNamedArgumentType(ref valueReader);
					}
					object value;
					switch (info.TypeCode)
					{
						case SerializationTypeCode.Boolean:
							value = valueReader.ReadBoolean();
							break;
						case SerializationTypeCode.Byte:
							value = valueReader.ReadByte();
							break;
						case SerializationTypeCode.Char:
							value = valueReader.ReadChar();
							break;
						case SerializationTypeCode.Double:
							value = valueReader.ReadDouble();
							break;
						case SerializationTypeCode.Int16:
							value = valueReader.ReadInt16();
							break;
						case SerializationTypeCode.Int32:
							value = valueReader.ReadInt32();
							break;
						case SerializationTypeCode.Int64:
							value = valueReader.ReadInt64();
							break;
						case SerializationTypeCode.SByte:
							value = valueReader.ReadSByte();
							break;
						case SerializationTypeCode.Single:
							value = valueReader.ReadSingle();
							break;
						case SerializationTypeCode.UInt16:
							value = valueReader.ReadUInt16();
							break;
						case SerializationTypeCode.UInt32:
							value = valueReader.ReadUInt32();
							break;
						case SerializationTypeCode.UInt64:
							value = valueReader.ReadUInt64();
							break;
						case SerializationTypeCode.String:
							value = valueReader.ReadSerializedString();
							break;
						case SerializationTypeCode.Type:
							{
								string name = valueReader.ReadSerializedString();
								value = _provider.GetTypeFromSerializedName(name);
								break;
							}
						case SerializationTypeCode.SZArray:
							value = DecodeArrayArgument(ref valueReader, info);
							break;
						default:
							throw new BadImageFormatException();
					}
					return new CustomAttributeTypedArgument<TType>(info.Type, value);
				}

				private System.Collections.Immutable.ImmutableArray<CustomAttributeTypedArgument<TType>>? DecodeArrayArgument(ref BlobReader blobReader, ArgumentTypeInfo info)
				{
					int num = blobReader.ReadInt32();
					if (num == -1)
					{
						return null;
					}
					if (num == 0)
					{
						return System.Collections.Immutable.ImmutableArray<CustomAttributeTypedArgument<TType>>.Empty;
					}
					if (num < 0)
					{
						throw new BadImageFormatException();
					}
					ArgumentTypeInfo argumentTypeInfo = default(ArgumentTypeInfo);
					argumentTypeInfo.Type = info.ElementType;
					argumentTypeInfo.TypeCode = info.ElementTypeCode;
					ArgumentTypeInfo info2 = argumentTypeInfo;
					System.Collections.Immutable.ImmutableArray<CustomAttributeTypedArgument<TType>>.Builder builder = System.Collections.Immutable.ImmutableArray.CreateBuilder<CustomAttributeTypedArgument<TType>>(num);
					for (int i = 0; i < num; i++)
					{
						builder.Add(DecodeArgument(ref blobReader, info2));
					}
					return builder.MoveToImmutable();
				}

				private TType GetTypeFromHandle(EntityHandle handle)
				{
					return handle.Kind switch
					{
						HandleKind.TypeDefinition => _provider.GetTypeFromDefinition(_reader, (TypeDefinitionHandle)handle, 0),
						HandleKind.TypeReference => _provider.GetTypeFromReference(_reader, (TypeReferenceHandle)handle, 0),
						_ => throw new BadImageFormatException(MDCFR.Properties.Resources.NotTypeDefOrRefHandle),
					};
				}

				private static void SkipType(ref BlobReader blobReader)
				{
					switch (blobReader.ReadCompressedInteger())
					{
						case 1:
						case 2:
						case 3:
						case 4:
						case 5:
						case 6:
						case 7:
						case 8:
						case 9:
						case 10:
						case 11:
						case 12:
						case 13:
						case 14:
						case 22:
						case 24:
						case 25:
						case 28:
							break;
						case 15:
						case 16:
						case 29:
						case 69:
							SkipType(ref blobReader);
							break;
						case 27:
							{
								if (blobReader.ReadSignatureHeader().IsGeneric)
								{
									blobReader.ReadCompressedInteger();
								}
								int num2 = blobReader.ReadCompressedInteger();
								SkipType(ref blobReader);
								for (int j = 0; j < num2; j++)
								{
									SkipType(ref blobReader);
								}
								break;
							}
						case 20:
							{
								SkipType(ref blobReader);
								blobReader.ReadCompressedInteger();
								int num3 = blobReader.ReadCompressedInteger();
								for (int k = 0; k < num3; k++)
								{
									blobReader.ReadCompressedInteger();
								}
								int num4 = blobReader.ReadCompressedInteger();
								for (int l = 0; l < num4; l++)
								{
									blobReader.ReadCompressedSignedInteger();
								}
								break;
							}
						case 31:
						case 32:
							blobReader.ReadTypeHandle();
							SkipType(ref blobReader);
							break;
						case 21:
							{
								SkipType(ref blobReader);
								int num = blobReader.ReadCompressedInteger();
								for (int i = 0; i < num; i++)
								{
									SkipType(ref blobReader);
								}
								break;
							}
						case 19:
							blobReader.ReadCompressedInteger();
							break;
						case 17:
						case 18:
							SkipType(ref blobReader);
							break;
						default:
							throw new BadImageFormatException();
					}
				}
			}

			public readonly struct CustomAttributeElementTypeEncoder
			{
				public BlobBuilder Builder { get; }

				public CustomAttributeElementTypeEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				private void WriteTypeCode(SerializationTypeCode value)
				{
					Builder.WriteByte((byte)value);
				}

				public void Boolean()
				{
					WriteTypeCode(SerializationTypeCode.Boolean);
				}

				public void Char()
				{
					WriteTypeCode(SerializationTypeCode.Char);
				}

				public void SByte()
				{
					WriteTypeCode(SerializationTypeCode.SByte);
				}

				public void Byte()
				{
					WriteTypeCode(SerializationTypeCode.Byte);
				}

				public void Int16()
				{
					WriteTypeCode(SerializationTypeCode.Int16);
				}

				public void UInt16()
				{
					WriteTypeCode(SerializationTypeCode.UInt16);
				}

				public void Int32()
				{
					WriteTypeCode(SerializationTypeCode.Int32);
				}

				public void UInt32()
				{
					WriteTypeCode(SerializationTypeCode.UInt32);
				}

				public void Int64()
				{
					WriteTypeCode(SerializationTypeCode.Int64);
				}

				public void UInt64()
				{
					WriteTypeCode(SerializationTypeCode.UInt64);
				}

				public void Single()
				{
					WriteTypeCode(SerializationTypeCode.Single);
				}

				public void Double()
				{
					WriteTypeCode(SerializationTypeCode.Double);
				}

				public void String()
				{
					WriteTypeCode(SerializationTypeCode.String);
				}

				public void PrimitiveType(PrimitiveSerializationTypeCode type)
				{
					if (type - 2 <= PrimitiveSerializationTypeCode.Single)
					{
						WriteTypeCode((SerializationTypeCode)type);
					}
					else
					{
						System.Reflection.Throw.ArgumentOutOfRange("type");
					}
				}

				public void SystemType()
				{
					WriteTypeCode(SerializationTypeCode.Type);
				}

				public void Enum(string enumTypeName)
				{
					if (enumTypeName == null)
					{
						System.Reflection.Throw.ArgumentNull("enumTypeName");
					}
					if (enumTypeName.Length == 0)
					{
						System.Reflection.Throw.ArgumentEmptyString("enumTypeName");
					}
					WriteTypeCode(SerializationTypeCode.Enum);
					Builder.WriteSerializedString(enumTypeName);
				}
			}

			public readonly struct CustomAttributeNamedArgumentsEncoder
			{
				public BlobBuilder Builder { get; }

				public CustomAttributeNamedArgumentsEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				public NamedArgumentsEncoder Count(int count)
				{
					if ((uint)count > 65535u)
					{
						System.Reflection.Throw.ArgumentOutOfRange("count");
					}
					Builder.WriteUInt16((ushort)count);
					return new NamedArgumentsEncoder(Builder);
				}
			}

			internal readonly struct CustomAttributeTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsHasCustomAttributeRefSizeSmall;

				private readonly bool _IsCustomAttributeTypeRefSizeSmall;

				private readonly bool _IsBlobHeapRefSizeSmall;

				private readonly int _ParentOffset;

				private readonly int _TypeOffset;

				private readonly int _ValueOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal readonly int[]? PtrTable;

				internal CustomAttributeTableReader(int numberOfRows, bool declaredSorted, int hasCustomAttributeRefSize, int customAttributeTypeRefSize, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsHasCustomAttributeRefSizeSmall = hasCustomAttributeRefSize == 2;
					_IsCustomAttributeTypeRefSizeSmall = customAttributeTypeRefSize == 2;
					_IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_ParentOffset = 0;
					_TypeOffset = _ParentOffset + hasCustomAttributeRefSize;
					_ValueOffset = _TypeOffset + customAttributeTypeRefSize;
					RowSize = _ValueOffset + blobHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
					PtrTable = null;
					if (!declaredSorted && !CheckSorted())
					{
						PtrTable = Block.BuildPtrTable(numberOfRows, RowSize, _ParentOffset, _IsHasCustomAttributeRefSizeSmall);
					}
				}

				internal EntityHandle GetParent(CustomAttributeHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return HasCustomAttributeTag.ConvertToHandle(Block.PeekTaggedReference(num + _ParentOffset, _IsHasCustomAttributeRefSizeSmall));
				}

				internal EntityHandle GetConstructor(CustomAttributeHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return CustomAttributeTypeTag.ConvertToHandle(Block.PeekTaggedReference(num + _TypeOffset, _IsCustomAttributeTypeRefSizeSmall));
				}

				internal BlobHandle GetValue(CustomAttributeHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _ValueOffset, _IsBlobHeapRefSizeSmall));
				}

				internal void GetAttributeRange(EntityHandle parentHandle, out int firstImplRowId, out int lastImplRowId)
				{
					int startRowNumber;
					int endRowNumber;
					if (PtrTable != null)
					{
						Block.BinarySearchReferenceRange(PtrTable, RowSize, _ParentOffset, HasCustomAttributeTag.ConvertToTag(parentHandle), _IsHasCustomAttributeRefSizeSmall, out startRowNumber, out endRowNumber);
					}
					else
					{
						Block.BinarySearchReferenceRange(NumberOfRows, RowSize, _ParentOffset, HasCustomAttributeTag.ConvertToTag(parentHandle), _IsHasCustomAttributeRefSizeSmall, out startRowNumber, out endRowNumber);
					}
					if (startRowNumber == -1)
					{
						firstImplRowId = 1;
						lastImplRowId = 0;
					}
					else
					{
						firstImplRowId = startRowNumber + 1;
						lastImplRowId = endRowNumber + 1;
					}
				}

				private bool CheckSorted()
				{
					return Block.IsOrderedByReferenceAscending(RowSize, _ParentOffset, _IsHasCustomAttributeRefSizeSmall);
				}
			}

			[Flags]
			internal enum CustomAttributeTreatment : byte { None = 0, WinMD = 1 }

			internal static class CustomAttributeTypeTag
			{
				internal const int NumberOfBits = 3;

				internal const int LargeRowSize = 8192;

				internal const uint MethodDef = 2u;

				internal const uint MemberRef = 3u;

				internal const uint TagMask = 7u;

				internal const ulong TagToTokenTypeByteVector = 168165376uL;

				internal const System.Reflection.Metadata.Ecma335.TableMask TablesReferenced = System.Reflection.Metadata.Ecma335.TableMask.MethodDef | System.Reflection.Metadata.Ecma335.TableMask.MemberRef;

				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				internal static EntityHandle ConvertToHandle(uint customAttributeType)
				{
					uint num = (uint)((int)(168165376uL >> (int)((customAttributeType & 7) << 3)) << 24);
					uint num2 = customAttributeType >> 3;
					if (num == 0 || (num2 & 0xFF000000u) != 0)
					{
						System.Reflection.Throw.InvalidCodedIndex();
					}
					return new EntityHandle(num | num2);
				}
			}

			[Flags]
			internal enum CustomAttributeValueTreatment : byte
			{
				None = 0,
				AttributeUsageAllowSingle = 1,
				AttributeUsageAllowMultiple = 2,
				AttributeUsageVersionAttribute = 3,
				AttributeUsageDeprecatedAttribute = 4
			}

			internal readonly struct CustomDebugInformationTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _isHasCustomDebugInformationRefSizeSmall;

				private readonly bool _isGuidHeapRefSizeSmall;

				private readonly bool _isBlobHeapRefSizeSmall;

				private const int ParentOffset = 0;

				private readonly int _kindOffset;

				private readonly int _valueOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal CustomDebugInformationTableReader(int numberOfRows, bool declaredSorted, int hasCustomDebugInformationRefSize, int guidHeapRefSize, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_isHasCustomDebugInformationRefSizeSmall = hasCustomDebugInformationRefSize == 2;
					_isGuidHeapRefSizeSmall = guidHeapRefSize == 2;
					_isBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_kindOffset = hasCustomDebugInformationRefSize;
					_valueOffset = _kindOffset + guidHeapRefSize;
					RowSize = _valueOffset + blobHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
					if (numberOfRows > 0 && !declaredSorted)
					{
						System.Reflection.Throw.TableNotSorted(TableIndex.CustomDebugInformation);
					}
				}

				internal EntityHandle GetParent(CustomDebugInformationHandle handle)
				{
					int offset = (handle.RowId - 1) * RowSize;
					return HasCustomDebugInformationTag.ConvertToHandle(Block.PeekTaggedReference(offset, _isHasCustomDebugInformationRefSizeSmall));
				}

				internal GuidHandle GetKind(CustomDebugInformationHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return GuidHandle.FromIndex(Block.PeekHeapReference(num + _kindOffset, _isGuidHeapRefSizeSmall));
				}

				internal BlobHandle GetValue(CustomDebugInformationHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _valueOffset, _isBlobHeapRefSizeSmall));
				}

				internal void GetRange(EntityHandle parentHandle, out int firstImplRowId, out int lastImplRowId)
				{
					Block.BinarySearchReferenceRange(NumberOfRows, RowSize, 0, HasCustomDebugInformationTag.ConvertToTag(parentHandle), _isHasCustomDebugInformationRefSizeSmall, out var startRowNumber, out var endRowNumber);
					if (startRowNumber == -1)
					{
						firstImplRowId = 1;
						lastImplRowId = 0;
					}
					else
					{
						firstImplRowId = startRowNumber + 1;
						lastImplRowId = endRowNumber + 1;
					}
				}
			}

			public readonly struct CustomModifiersEncoder
			{
				public BlobBuilder Builder { get; }

				public CustomModifiersEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				/// <summary>
				/// Encodes a custom modifier.
				/// </summary>
				/// <param name="type"><see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> or <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.</param>
				/// <param name="isOptional">Is optional modifier.</param>
				/// <returns>Encoder of subsequent modifiers.</returns>
				/// <exception cref="T:System.ArgumentException"><paramref name="type" /> is nil or of an unexpected kind.</exception>
				public CustomModifiersEncoder AddModifier(EntityHandle type, bool isOptional)
				{
					if (type.IsNil)
					{
						System.Reflection.Throw.InvalidArgument_Handle("type");
					}
					if (isOptional)
					{
						Builder.WriteByte(32);
					}
					else
					{
						Builder.WriteByte(31);
					}
					Builder.WriteCompressedInteger(CodedIndex.TypeDefOrRefOrSpec(type));
					return this;
				}
			}

			internal readonly struct DeclSecurityTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsHasDeclSecurityRefSizeSmall;

				private readonly bool _IsBlobHeapRefSizeSmall;

				private readonly int _ActionOffset;

				private readonly int _ParentOffset;

				private readonly int _PermissionSetOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal DeclSecurityTableReader(int numberOfRows, bool declaredSorted, int hasDeclSecurityRefSize, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsHasDeclSecurityRefSizeSmall = hasDeclSecurityRefSize == 2;
					_IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_ActionOffset = 0;
					_ParentOffset = _ActionOffset + 2;
					_PermissionSetOffset = _ParentOffset + hasDeclSecurityRefSize;
					RowSize = _PermissionSetOffset + blobHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
					if (!declaredSorted && !CheckSorted())
					{
						System.Reflection.Throw.TableNotSorted(TableIndex.DeclSecurity);
					}
				}

				internal DeclarativeSecurityAction GetAction(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return (DeclarativeSecurityAction)Block.PeekUInt16(num + _ActionOffset);
				}

				internal EntityHandle GetParent(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return HasDeclSecurityTag.ConvertToHandle(Block.PeekTaggedReference(num + _ParentOffset, _IsHasDeclSecurityRefSizeSmall));
				}

				internal BlobHandle GetPermissionSet(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _PermissionSetOffset, _IsBlobHeapRefSizeSmall));
				}

				internal void GetAttributeRange(EntityHandle parentToken, out int firstImplRowId, out int lastImplRowId)
				{
					Block.BinarySearchReferenceRange(NumberOfRows, RowSize, _ParentOffset, HasDeclSecurityTag.ConvertToTag(parentToken), _IsHasDeclSecurityRefSizeSmall, out var startRowNumber, out var endRowNumber);
					if (startRowNumber == -1)
					{
						firstImplRowId = 1;
						lastImplRowId = 0;
					}
					else
					{
						firstImplRowId = startRowNumber + 1;
						lastImplRowId = endRowNumber + 1;
					}
				}

				private bool CheckSorted()
				{
					return Block.IsOrderedByReferenceAscending(RowSize, _ParentOffset, _IsHasDeclSecurityRefSizeSmall);
				}
			}

			internal readonly struct DocumentTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _isGuidHeapRefSizeSmall;

				private readonly bool _isBlobHeapRefSizeSmall;

				private const int NameOffset = 0;

				private readonly int _hashAlgorithmOffset;

				private readonly int _hashOffset;

				private readonly int _languageOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal DocumentTableReader(int numberOfRows, int guidHeapRefSize, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_isGuidHeapRefSizeSmall = guidHeapRefSize == 2;
					_isBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_hashAlgorithmOffset = blobHeapRefSize;
					_hashOffset = _hashAlgorithmOffset + guidHeapRefSize;
					_languageOffset = _hashOffset + blobHeapRefSize;
					RowSize = _languageOffset + guidHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal DocumentNameBlobHandle GetName(DocumentHandle handle)
				{
					int offset = (handle.RowId - 1) * RowSize;
					return DocumentNameBlobHandle.FromOffset(Block.PeekHeapReference(offset, _isBlobHeapRefSizeSmall));
				}

				internal GuidHandle GetHashAlgorithm(DocumentHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return GuidHandle.FromIndex(Block.PeekHeapReference(num + _hashAlgorithmOffset, _isGuidHeapRefSizeSmall));
				}

				internal BlobHandle GetHash(DocumentHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _hashOffset, _isBlobHeapRefSizeSmall));
				}

				internal GuidHandle GetLanguage(DocumentHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return GuidHandle.FromIndex(Block.PeekHeapReference(num + _languageOffset, _isGuidHeapRefSizeSmall));
				}
			}

			public readonly struct EditAndContinueLogEntry : IEquatable<EditAndContinueLogEntry>
			{
				public EntityHandle Handle { get; }

				public EditAndContinueOperation Operation { get; }

				public EditAndContinueLogEntry(EntityHandle handle, EditAndContinueOperation operation)
				{
					Handle = handle;
					Operation = operation;
				}

				public override bool Equals([NotNullWhen(true)] object? obj)
				{
					if (obj is EditAndContinueLogEntry other)
					{
						return Equals(other);
					}
					return false;
				}

				public bool Equals(EditAndContinueLogEntry other)
				{
					if (Operation == other.Operation)
					{
						return Handle == other.Handle;
					}
					return false;
				}

				public override int GetHashCode()
				{
					return (int)Operation ^ Handle.GetHashCode();
				}
			}

			public enum EditAndContinueOperation { Default, AddMethod, AddField, AddParameter, AddProperty, AddEvent }

			internal readonly struct EnCLogTableReader
			{
				internal readonly int NumberOfRows;

				private readonly int _TokenOffset;

				private readonly int _FuncCodeOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal EnCLogTableReader(int numberOfRows, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset, System.Reflection.Metadata.Ecma335.MetadataStreamKind metadataStreamKind)
				{
					NumberOfRows = ((metadataStreamKind != System.Reflection.Metadata.Ecma335.MetadataStreamKind.Compressed) ? numberOfRows : 0);
					_TokenOffset = 0;
					_FuncCodeOffset = _TokenOffset + 4;
					RowSize = _FuncCodeOffset + 4;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal uint GetToken(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return Block.PeekUInt32(num + _TokenOffset);
				}

				internal EditAndContinueOperation GetFuncCode(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return (EditAndContinueOperation)Block.PeekUInt32(num + _FuncCodeOffset);
				}
			}

			internal readonly struct EnCMapTableReader
			{
				internal readonly int NumberOfRows;

				private readonly int _TokenOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal EnCMapTableReader(int numberOfRows, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_TokenOffset = 0;
					RowSize = _TokenOffset + 4;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal uint GetToken(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return Block.PeekUInt32(num + _TokenOffset);
				}
			}

			internal readonly struct EventMapTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsTypeDefTableRowRefSizeSmall;

				private readonly bool _IsEventRefSizeSmall;

				private readonly int _ParentOffset;

				private readonly int _EventListOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal EventMapTableReader(int numberOfRows, int typeDefTableRowRefSize, int eventRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;
					_IsEventRefSizeSmall = eventRefSize == 2;
					_ParentOffset = 0;
					_EventListOffset = _ParentOffset + typeDefTableRowRefSize;
					RowSize = _EventListOffset + eventRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal int FindEventMapRowIdFor(TypeDefinitionHandle typeDef)
				{
					int num = Block.LinearSearchReference(RowSize, _ParentOffset, (uint)typeDef.RowId, _IsTypeDefTableRowRefSizeSmall);
					return num + 1;
				}

				internal TypeDefinitionHandle GetParentType(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return TypeDefinitionHandle.FromRowId(Block.PeekReference(num + _ParentOffset, _IsTypeDefTableRowRefSizeSmall));
				}

				internal int GetEventListStartFor(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return Block.PeekReference(num + _EventListOffset, _IsEventRefSizeSmall);
				}
			}

			internal readonly struct EventPtrTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsEventTableRowRefSizeSmall;

				private readonly int _EventOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal EventPtrTableReader(int numberOfRows, int eventTableRowRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsEventTableRowRefSizeSmall = eventTableRowRefSize == 2;
					_EventOffset = 0;
					RowSize = _EventOffset + eventTableRowRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal EventDefinitionHandle GetEventFor(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return EventDefinitionHandle.FromRowId(Block.PeekReference(num + _EventOffset, _IsEventTableRowRefSizeSmall));
				}
			}

			internal struct EventTableReader
			{
				internal int NumberOfRows;

				private readonly bool _IsTypeDefOrRefRefSizeSmall;

				private readonly bool _IsStringHeapRefSizeSmall;

				private readonly int _FlagsOffset;

				private readonly int _NameOffset;

				private readonly int _EventTypeOffset;

				internal readonly int RowSize;

				internal System.Reflection.Internal.MemoryBlock Block;

				internal EventTableReader(int numberOfRows, int typeDefOrRefRefSize, int stringHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsTypeDefOrRefRefSizeSmall = typeDefOrRefRefSize == 2;
					_IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_FlagsOffset = 0;
					_NameOffset = _FlagsOffset + 2;
					_EventTypeOffset = _NameOffset + stringHeapRefSize;
					RowSize = _EventTypeOffset + typeDefOrRefRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal EventAttributes GetFlags(EventDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return (EventAttributes)Block.PeekUInt16(num + _FlagsOffset);
				}

				internal StringHandle GetName(EventDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _NameOffset, _IsStringHeapRefSizeSmall));
				}

				internal EntityHandle GetEventType(EventDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return TypeDefOrRefTag.ConvertToHandle(Block.PeekTaggedReference(num + _EventTypeOffset, _IsTypeDefOrRefRefSizeSmall));
				}
			}

			public readonly struct ExceptionRegionEncoder
			{
				private const int TableHeaderSize = 4;

				private const int SmallRegionSize = 12;

				private const int FatRegionSize = 24;

				private const int ThreeBytesMaxValue = 16777215;

				internal const int MaxSmallExceptionRegions = 20;

				internal const int MaxExceptionRegions = 699050;

				/// <summary>
				/// The underlying builder.
				/// </summary>
				public BlobBuilder Builder { get; }

				/// <summary>
				/// True if the encoder uses small format.
				/// </summary>
				public bool HasSmallFormat { get; }

				internal ExceptionRegionEncoder(BlobBuilder builder, bool hasSmallFormat)
				{
					Builder = builder;
					HasSmallFormat = hasSmallFormat;
				}

				/// <summary>
				/// Returns true if the number of exception regions first small format.
				/// </summary>
				/// <param name="exceptionRegionCount">Number of exception regions.</param>
				public static bool IsSmallRegionCount(int exceptionRegionCount)
				{
					return (uint)exceptionRegionCount <= 20u;
				}

				/// <summary>
				/// Returns true if the region fits small format.
				/// </summary>
				/// <param name="startOffset">Start offset of the region.</param>
				/// <param name="length">Length of the region.</param>
				public static bool IsSmallExceptionRegion(int startOffset, int length)
				{
					if ((uint)startOffset <= 65535u)
					{
						return (uint)length <= 255u;
					}
					return false;
				}

				internal static bool IsSmallExceptionRegionFromBounds(int startOffset, int endOffset)
				{
					return IsSmallExceptionRegion(startOffset, endOffset - startOffset);
				}

				internal static int GetExceptionTableSize(int exceptionRegionCount, bool isSmallFormat)
				{
					return 4 + exceptionRegionCount * (isSmallFormat ? 12 : 24);
				}

				internal static bool IsExceptionRegionCountInBounds(int exceptionRegionCount)
				{
					return (uint)exceptionRegionCount <= 699050u;
				}

				internal static bool IsValidCatchTypeHandle(EntityHandle catchType)
				{
					if (!catchType.IsNil)
					{
						if (catchType.Kind != HandleKind.TypeDefinition && catchType.Kind != HandleKind.TypeSpecification)
						{
							return catchType.Kind == HandleKind.TypeReference;
						}
						return true;
					}
					return false;
				}

				internal static ExceptionRegionEncoder SerializeTableHeader(BlobBuilder builder, int exceptionRegionCount, bool hasSmallRegions)
				{
					bool flag = hasSmallRegions && IsSmallRegionCount(exceptionRegionCount);
					int exceptionTableSize = GetExceptionTableSize(exceptionRegionCount, flag);
					builder.Align(4);
					if (flag)
					{
						builder.WriteByte(1);
						builder.WriteByte((byte)exceptionTableSize);
						builder.WriteInt16(0);
					}
					else
					{
						builder.WriteByte(65);
						builder.WriteByte((byte)exceptionTableSize);
						builder.WriteUInt16((ushort)(exceptionTableSize >> 8));
					}
					return new ExceptionRegionEncoder(builder, flag);
				}

				/// <summary>
				/// Adds a finally clause.
				/// </summary>
				/// <param name="tryOffset">Try block start offset.</param>
				/// <param name="tryLength">Try block length.</param>
				/// <param name="handlerOffset">Handler start offset.</param>
				/// <param name="handlerLength">Handler length.</param>
				/// <returns>Encoder for the next clause.</returns>
				/// <exception cref="T:System.ArgumentOutOfRangeException">
				/// <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> or <paramref name="handlerLength" /> is out of range.
				/// </exception>
				/// <exception cref="T:System.InvalidOperationException">Method body was not declared to have exception regions.</exception>
				public ExceptionRegionEncoder AddFinally(int tryOffset, int tryLength, int handlerOffset, int handlerLength)
				{
					return Add(ExceptionRegionKind.Finally, tryOffset, tryLength, handlerOffset, handlerLength);
				}

				/// <summary>
				/// Adds a fault clause.
				/// </summary>
				/// <param name="tryOffset">Try block start offset.</param>
				/// <param name="tryLength">Try block length.</param>
				/// <param name="handlerOffset">Handler start offset.</param>
				/// <param name="handlerLength">Handler length.</param>
				/// <returns>Encoder for the next clause.</returns>
				/// <exception cref="T:System.ArgumentOutOfRangeException">
				/// <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> or <paramref name="handlerLength" /> is out of range.
				/// </exception>
				/// <exception cref="T:System.InvalidOperationException">Method body was not declared to have exception regions.</exception>
				public ExceptionRegionEncoder AddFault(int tryOffset, int tryLength, int handlerOffset, int handlerLength)
				{
					return Add(ExceptionRegionKind.Fault, tryOffset, tryLength, handlerOffset, handlerLength);
				}

				/// <summary>
				/// Adds a fault clause.
				/// </summary>
				/// <param name="tryOffset">Try block start offset.</param>
				/// <param name="tryLength">Try block length.</param>
				/// <param name="handlerOffset">Handler start offset.</param>
				/// <param name="handlerLength">Handler length.</param>
				/// <param name="catchType">
				/// <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> or <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.
				/// </param>
				/// <returns>Encoder for the next clause.</returns>
				/// <exception cref="T:System.ArgumentException"><paramref name="catchType" /> is invalid.</exception>
				/// <exception cref="T:System.ArgumentOutOfRangeException">
				/// <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> or <paramref name="handlerLength" /> is out of range.
				/// </exception>
				/// <exception cref="T:System.InvalidOperationException">Method body was not declared to have exception regions.</exception>
				public ExceptionRegionEncoder AddCatch(int tryOffset, int tryLength, int handlerOffset, int handlerLength, EntityHandle catchType)
				{
					return Add(ExceptionRegionKind.Catch, tryOffset, tryLength, handlerOffset, handlerLength, catchType);
				}

				/// <summary>
				/// Adds a fault clause.
				/// </summary>
				/// <param name="tryOffset">Try block start offset.</param>
				/// <param name="tryLength">Try block length.</param>
				/// <param name="handlerOffset">Handler start offset.</param>
				/// <param name="handlerLength">Handler length.</param>
				/// <param name="filterOffset">Offset of the filter block.</param>
				/// <returns>Encoder for the next clause.</returns>
				/// <exception cref="T:System.ArgumentOutOfRangeException">
				/// <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> or <paramref name="handlerLength" /> is out of range.
				/// </exception>
				/// <exception cref="T:System.InvalidOperationException">Method body was not declared to have exception regions.</exception>
				public ExceptionRegionEncoder AddFilter(int tryOffset, int tryLength, int handlerOffset, int handlerLength, int filterOffset)
				{
					return Add(ExceptionRegionKind.Filter, tryOffset, tryLength, handlerOffset, handlerLength, default(EntityHandle), filterOffset);
				}

				/// <summary>
				/// Adds an exception clause.
				/// </summary>
				/// <param name="kind">Clause kind.</param>
				/// <param name="tryOffset">Try block start offset.</param>
				/// <param name="tryLength">Try block length.</param>
				/// <param name="handlerOffset">Handler start offset.</param>
				/// <param name="handlerLength">Handler length.</param>
				/// <param name="catchType">
				/// <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> or <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />,
				/// or nil if <paramref name="kind" /> is not <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Catch" />
				/// </param>
				/// <param name="filterOffset">
				/// Offset of the filter block, or 0 if the <paramref name="kind" /> is not <see cref="F:System.Reflection.Metadata.ExceptionRegionKind.Filter" />.
				/// </param>
				/// <returns>Encoder for the next clause.</returns>
				/// <exception cref="T:System.ArgumentException"><paramref name="catchType" /> is invalid.</exception>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="kind" /> has invalid value.</exception>
				/// <exception cref="T:System.ArgumentOutOfRangeException">
				/// <paramref name="tryOffset" />, <paramref name="tryLength" />, <paramref name="handlerOffset" /> or <paramref name="handlerLength" /> is out of range.
				/// </exception>
				/// <exception cref="T:System.InvalidOperationException">Method body was not declared to have exception regions.</exception>
				public ExceptionRegionEncoder Add(ExceptionRegionKind kind, int tryOffset, int tryLength, int handlerOffset, int handlerLength, EntityHandle catchType = default(EntityHandle), int filterOffset = 0)
				{
					if (Builder == null)
					{
						System.Reflection.Throw.InvalidOperation(MDCFR.Properties.Resources.MethodHasNoExceptionRegions);
					}
					if (HasSmallFormat)
					{
						if ((ushort)tryOffset != tryOffset)
						{
							System.Reflection.Throw.ArgumentOutOfRange("tryOffset");
						}
						if ((byte)tryLength != tryLength)
						{
							System.Reflection.Throw.ArgumentOutOfRange("tryLength");
						}
						if ((ushort)handlerOffset != handlerOffset)
						{
							System.Reflection.Throw.ArgumentOutOfRange("handlerOffset");
						}
						if ((byte)handlerLength != handlerLength)
						{
							System.Reflection.Throw.ArgumentOutOfRange("handlerLength");
						}
					}
					else
					{
						if (tryOffset < 0)
						{
							System.Reflection.Throw.ArgumentOutOfRange("tryOffset");
						}
						if (tryLength < 0)
						{
							System.Reflection.Throw.ArgumentOutOfRange("tryLength");
						}
						if (handlerOffset < 0)
						{
							System.Reflection.Throw.ArgumentOutOfRange("handlerOffset");
						}
						if (handlerLength < 0)
						{
							System.Reflection.Throw.ArgumentOutOfRange("handlerLength");
						}
					}
					int catchTokenOrOffset;
					switch (kind)
					{
						case ExceptionRegionKind.Catch:
							if (!IsValidCatchTypeHandle(catchType))
							{
								System.Reflection.Throw.InvalidArgument_Handle("catchType");
							}
							catchTokenOrOffset = MetadataTokens.GetToken(catchType);
							break;
						case ExceptionRegionKind.Filter:
							if (filterOffset < 0)
							{
								System.Reflection.Throw.ArgumentOutOfRange("filterOffset");
							}
							catchTokenOrOffset = filterOffset;
							break;
						case ExceptionRegionKind.Finally:
						case ExceptionRegionKind.Fault:
							catchTokenOrOffset = 0;
							break;
						default:
							throw new ArgumentOutOfRangeException("kind");
					}
					AddUnchecked(kind, tryOffset, tryLength, handlerOffset, handlerLength, catchTokenOrOffset);
					return this;
				}

				internal void AddUnchecked(ExceptionRegionKind kind, int tryOffset, int tryLength, int handlerOffset, int handlerLength, int catchTokenOrOffset)
				{
					if (HasSmallFormat)
					{
						Builder.WriteUInt16((ushort)kind);
						Builder.WriteUInt16((ushort)tryOffset);
						Builder.WriteByte((byte)tryLength);
						Builder.WriteUInt16((ushort)handlerOffset);
						Builder.WriteByte((byte)handlerLength);
					}
					else
					{
						Builder.WriteInt32((int)kind);
						Builder.WriteInt32(tryOffset);
						Builder.WriteInt32(tryLength);
						Builder.WriteInt32(handlerOffset);
						Builder.WriteInt32(handlerLength);
					}
					Builder.WriteInt32(catchTokenOrOffset);
				}
			}

			/// <summary>
			/// Provides an extension method to access the TypeDefinitionId column of the ExportedType table.
			/// </summary>
			public static class ExportedTypeExtensions
			{
				/// <summary>
				/// Gets a hint at the likely row number of the target type in the TypeDef table of its module.
				/// If the namespaces and names do not match, resolution falls back to a full search of the
				/// target TypeDef table. Ignored and should be zero if <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder" /> is
				/// true.
				/// </summary>
				public static int GetTypeDefinitionId(this ExportedType exportedType)
				{
					return exportedType.reader.ExportedTypeTable.GetTypeDefId(exportedType.rowId);
				}
			}

			internal readonly struct ExportedTypeTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsImplementationRefSizeSmall;

				private readonly bool _IsStringHeapRefSizeSmall;

				private readonly int _FlagsOffset;

				private readonly int _TypeDefIdOffset;

				private readonly int _TypeNameOffset;

				private readonly int _TypeNamespaceOffset;

				private readonly int _ImplementationOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal ExportedTypeTableReader(int numberOfRows, int implementationRefSize, int stringHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsImplementationRefSizeSmall = implementationRefSize == 2;
					_IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_FlagsOffset = 0;
					_TypeDefIdOffset = _FlagsOffset + 4;
					_TypeNameOffset = _TypeDefIdOffset + 4;
					_TypeNamespaceOffset = _TypeNameOffset + stringHeapRefSize;
					_ImplementationOffset = _TypeNamespaceOffset + stringHeapRefSize;
					RowSize = _ImplementationOffset + implementationRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal StringHandle GetTypeName(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _TypeNameOffset, _IsStringHeapRefSizeSmall));
				}

				internal StringHandle GetTypeNamespaceString(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _TypeNamespaceOffset, _IsStringHeapRefSizeSmall));
				}

				internal NamespaceDefinitionHandle GetTypeNamespace(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return NamespaceDefinitionHandle.FromFullNameOffset(Block.PeekHeapReference(num + _TypeNamespaceOffset, _IsStringHeapRefSizeSmall));
				}

				internal EntityHandle GetImplementation(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return ImplementationTag.ConvertToHandle(Block.PeekTaggedReference(num + _ImplementationOffset, _IsImplementationRefSizeSmall));
				}

				internal TypeAttributes GetFlags(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return (TypeAttributes)Block.PeekUInt32(num + _FlagsOffset);
				}

				internal int GetTypeDefId(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return Block.PeekInt32(num + _TypeDefIdOffset);
				}

				internal int GetNamespace(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return Block.PeekReference(num + _TypeNamespaceOffset, _IsStringHeapRefSizeSmall);
				}
			}

			[Flags]
			internal enum FieldDefTreatment : byte { None = 0, EnumValue = 1 }

			internal readonly struct FieldLayoutTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsFieldTableRowRefSizeSmall;

				private readonly int _OffsetOffset;

				private readonly int _FieldOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal FieldLayoutTableReader(int numberOfRows, bool declaredSorted, int fieldTableRowRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsFieldTableRowRefSizeSmall = fieldTableRowRefSize == 2;
					_OffsetOffset = 0;
					_FieldOffset = _OffsetOffset + 4;
					RowSize = _FieldOffset + fieldTableRowRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
					if (!declaredSorted && !CheckSorted())
					{
						System.Reflection.Throw.TableNotSorted(TableIndex.FieldLayout);
					}
				}

				/// <summary>
				/// Returns field offset for given field RowId, or -1 if not available.
				/// </summary>
				internal int FindFieldLayoutRowId(FieldDefinitionHandle handle)
				{
					int num = Block.BinarySearchReference(NumberOfRows, RowSize, _FieldOffset, (uint)handle.RowId, _IsFieldTableRowRefSizeSmall);
					return num + 1;
				}

				internal uint GetOffset(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return Block.PeekUInt32(num + _OffsetOffset);
				}

				internal FieldDefinitionHandle GetField(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return FieldDefinitionHandle.FromRowId(Block.PeekReference(num + _FieldOffset, _IsFieldTableRowRefSizeSmall));
				}

				private bool CheckSorted()
				{
					return Block.IsOrderedByReferenceAscending(RowSize, _FieldOffset, _IsFieldTableRowRefSizeSmall);
				}
			}

			internal readonly struct FieldMarshalTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsHasFieldMarshalRefSizeSmall;

				private readonly bool _IsBlobHeapRefSizeSmall;

				private readonly int _ParentOffset;

				private readonly int _NativeTypeOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal FieldMarshalTableReader(int numberOfRows, bool declaredSorted, int hasFieldMarshalRefSize, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsHasFieldMarshalRefSizeSmall = hasFieldMarshalRefSize == 2;
					_IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_ParentOffset = 0;
					_NativeTypeOffset = _ParentOffset + hasFieldMarshalRefSize;
					RowSize = _NativeTypeOffset + blobHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
					if (!declaredSorted && !CheckSorted())
					{
						System.Reflection.Throw.TableNotSorted(TableIndex.FieldMarshal);
					}
				}

				internal EntityHandle GetParent(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return HasFieldMarshalTag.ConvertToHandle(Block.PeekTaggedReference(num + _ParentOffset, _IsHasFieldMarshalRefSizeSmall));
				}

				internal BlobHandle GetNativeType(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _NativeTypeOffset, _IsBlobHeapRefSizeSmall));
				}

				internal int FindFieldMarshalRowId(EntityHandle handle)
				{
					int num = Block.BinarySearchReference(NumberOfRows, RowSize, _ParentOffset, HasFieldMarshalTag.ConvertToTag(handle), _IsHasFieldMarshalRefSizeSmall);
					return num + 1;
				}

				private bool CheckSorted()
				{
					return Block.IsOrderedByReferenceAscending(RowSize, _ParentOffset, _IsHasFieldMarshalRefSizeSmall);
				}
			}

			internal readonly struct FieldPtrTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsFieldTableRowRefSizeSmall;

				private readonly int _FieldOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal FieldPtrTableReader(int numberOfRows, int fieldTableRowRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsFieldTableRowRefSizeSmall = fieldTableRowRefSize == 2;
					_FieldOffset = 0;
					RowSize = _FieldOffset + fieldTableRowRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal FieldDefinitionHandle GetFieldFor(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return FieldDefinitionHandle.FromRowId(Block.PeekReference(num + _FieldOffset, _IsFieldTableRowRefSizeSmall));
				}

				internal int GetRowIdForFieldDefRow(int fieldDefRowId)
				{
					return Block.LinearSearchReference(RowSize, _FieldOffset, (uint)fieldDefRowId, _IsFieldTableRowRefSizeSmall) + 1;
				}
			}

			internal readonly struct FieldRVATableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsFieldTableRowRefSizeSmall;

				private readonly int _RvaOffset;

				private readonly int _FieldOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal FieldRVATableReader(int numberOfRows, bool declaredSorted, int fieldTableRowRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsFieldTableRowRefSizeSmall = fieldTableRowRefSize == 2;
					_RvaOffset = 0;
					_FieldOffset = _RvaOffset + 4;
					RowSize = _FieldOffset + fieldTableRowRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
					if (!declaredSorted && !CheckSorted())
					{
						System.Reflection.Throw.TableNotSorted(TableIndex.FieldRva);
					}
				}

				internal int GetRva(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return Block.PeekInt32(num + _RvaOffset);
				}

				internal int FindFieldRvaRowId(int fieldDefRowId)
				{
					int num = Block.BinarySearchReference(NumberOfRows, RowSize, _FieldOffset, (uint)fieldDefRowId, _IsFieldTableRowRefSizeSmall);
					return num + 1;
				}

				private bool CheckSorted()
				{
					return Block.IsOrderedByReferenceAscending(RowSize, _FieldOffset, _IsFieldTableRowRefSizeSmall);
				}
			}

			internal readonly struct FieldTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsStringHeapRefSizeSmall;

				private readonly bool _IsBlobHeapRefSizeSmall;

				private readonly int _FlagsOffset;

				private readonly int _NameOffset;

				private readonly int _SignatureOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal FieldTableReader(int numberOfRows, int stringHeapRefSize, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_FlagsOffset = 0;
					_NameOffset = _FlagsOffset + 2;
					_SignatureOffset = _NameOffset + stringHeapRefSize;
					RowSize = _SignatureOffset + blobHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal StringHandle GetName(FieldDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _NameOffset, _IsStringHeapRefSizeSmall));
				}

				internal FieldAttributes GetFlags(FieldDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return (FieldAttributes)Block.PeekUInt16(num + _FlagsOffset);
				}

				internal BlobHandle GetSignature(FieldDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _SignatureOffset, _IsBlobHeapRefSizeSmall));
				}
			}

			public readonly struct FieldTypeEncoder
			{
				public BlobBuilder Builder { get; }

				public FieldTypeEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				public CustomModifiersEncoder CustomModifiers()
				{
					return new CustomModifiersEncoder(Builder);
				}

				public SignatureTypeEncoder Type(bool isByRef = false)
				{
					if (isByRef)
					{
						Builder.WriteByte(16);
					}
					return new SignatureTypeEncoder(Builder);
				}

				public void TypedReference()
				{
					Builder.WriteByte(22);
				}
			}

			internal readonly struct FileTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsStringHeapRefSizeSmall;

				private readonly bool _IsBlobHeapRefSizeSmall;

				private readonly int _FlagsOffset;

				private readonly int _NameOffset;

				private readonly int _HashValueOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal FileTableReader(int numberOfRows, int stringHeapRefSize, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_FlagsOffset = 0;
					_NameOffset = _FlagsOffset + 4;
					_HashValueOffset = _NameOffset + stringHeapRefSize;
					RowSize = _HashValueOffset + blobHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal BlobHandle GetHashValue(AssemblyFileHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _HashValueOffset, _IsBlobHeapRefSizeSmall));
				}

				internal uint GetFlags(AssemblyFileHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return Block.PeekUInt32(num + _FlagsOffset);
				}

				internal StringHandle GetName(AssemblyFileHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _NameOffset, _IsStringHeapRefSizeSmall));
				}
			}

			public readonly struct FixedArgumentsEncoder
			{
				public BlobBuilder Builder { get; }

				public FixedArgumentsEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				public LiteralEncoder AddArgument()
				{
					return new LiteralEncoder(Builder);
				}
			}

			public enum FunctionPointerAttributes { None = 0, HasThis = 32, HasExplicitThis = 96 }

			internal readonly struct GenericParamConstraintTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsGenericParamTableRowRefSizeSmall;

				private readonly bool _IsTypeDefOrRefRefSizeSmall;

				private readonly int _OwnerOffset;

				private readonly int _ConstraintOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal GenericParamConstraintTableReader(int numberOfRows, bool declaredSorted, int genericParamTableRowRefSize, int typeDefOrRefRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsGenericParamTableRowRefSizeSmall = genericParamTableRowRefSize == 2;
					_IsTypeDefOrRefRefSizeSmall = typeDefOrRefRefSize == 2;
					_OwnerOffset = 0;
					_ConstraintOffset = _OwnerOffset + genericParamTableRowRefSize;
					RowSize = _ConstraintOffset + typeDefOrRefRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
					if (!declaredSorted && !CheckSorted())
					{
						System.Reflection.Throw.TableNotSorted(TableIndex.GenericParamConstraint);
					}
				}

				internal GenericParameterConstraintHandleCollection FindConstraintsForGenericParam(GenericParameterHandle genericParameter)
				{
					Block.BinarySearchReferenceRange(NumberOfRows, RowSize, _OwnerOffset, (uint)genericParameter.RowId, _IsGenericParamTableRowRefSizeSmall, out var startRowNumber, out var endRowNumber);
					if (startRowNumber == -1)
					{
						return default(GenericParameterConstraintHandleCollection);
					}
					return new GenericParameterConstraintHandleCollection(startRowNumber + 1, (ushort)(endRowNumber - startRowNumber + 1));
				}

				private bool CheckSorted()
				{
					return Block.IsOrderedByReferenceAscending(RowSize, _OwnerOffset, _IsGenericParamTableRowRefSizeSmall);
				}

				internal EntityHandle GetConstraint(GenericParameterConstraintHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return TypeDefOrRefTag.ConvertToHandle(Block.PeekTaggedReference(num + _ConstraintOffset, _IsTypeDefOrRefRefSizeSmall));
				}

				internal GenericParameterHandle GetOwner(GenericParameterConstraintHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return GenericParameterHandle.FromRowId(Block.PeekReference(num + _OwnerOffset, _IsGenericParamTableRowRefSizeSmall));
				}
			}

			internal readonly struct GenericParamTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsTypeOrMethodDefRefSizeSmall;

				private readonly bool _IsStringHeapRefSizeSmall;

				private readonly int _NumberOffset;

				private readonly int _FlagsOffset;

				private readonly int _OwnerOffset;

				private readonly int _NameOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal GenericParamTableReader(int numberOfRows, bool declaredSorted, int typeOrMethodDefRefSize, int stringHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsTypeOrMethodDefRefSizeSmall = typeOrMethodDefRefSize == 2;
					_IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_NumberOffset = 0;
					_FlagsOffset = _NumberOffset + 2;
					_OwnerOffset = _FlagsOffset + 2;
					_NameOffset = _OwnerOffset + typeOrMethodDefRefSize;
					RowSize = _NameOffset + stringHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
					if (!declaredSorted && !CheckSorted())
					{
						System.Reflection.Throw.TableNotSorted(TableIndex.GenericParam);
					}
				}

				internal ushort GetNumber(GenericParameterHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return Block.PeekUInt16(num + _NumberOffset);
				}

				internal GenericParameterAttributes GetFlags(GenericParameterHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return (GenericParameterAttributes)Block.PeekUInt16(num + _FlagsOffset);
				}

				internal StringHandle GetName(GenericParameterHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _NameOffset, _IsStringHeapRefSizeSmall));
				}

				internal EntityHandle GetOwner(GenericParameterHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return TypeOrMethodDefTag.ConvertToHandle(Block.PeekTaggedReference(num + _OwnerOffset, _IsTypeOrMethodDefRefSizeSmall));
				}

				internal GenericParameterHandleCollection FindGenericParametersForType(TypeDefinitionHandle typeDef)
				{
					ushort genericParamCount = 0;
					uint searchCodedTag = TypeOrMethodDefTag.ConvertTypeDefRowIdToTag(typeDef);
					int firstRowId = BinarySearchTag(searchCodedTag, ref genericParamCount);
					return new GenericParameterHandleCollection(firstRowId, genericParamCount);
				}

				internal GenericParameterHandleCollection FindGenericParametersForMethod(MethodDefinitionHandle methodDef)
				{
					ushort genericParamCount = 0;
					uint searchCodedTag = TypeOrMethodDefTag.ConvertMethodDefToTag(methodDef);
					int firstRowId = BinarySearchTag(searchCodedTag, ref genericParamCount);
					return new GenericParameterHandleCollection(firstRowId, genericParamCount);
				}

				private int BinarySearchTag(uint searchCodedTag, ref ushort genericParamCount)
				{
					Block.BinarySearchReferenceRange(NumberOfRows, RowSize, _OwnerOffset, searchCodedTag, _IsTypeOrMethodDefRefSizeSmall, out var startRowNumber, out var endRowNumber);
					if (startRowNumber == -1)
					{
						genericParamCount = 0;
						return 0;
					}
					genericParamCount = (ushort)(endRowNumber - startRowNumber + 1);
					return startRowNumber + 1;
				}

				private bool CheckSorted()
				{
					return Block.IsOrderedByReferenceAscending(RowSize, _OwnerOffset, _IsTypeOrMethodDefRefSizeSmall);
				}
			}

			public readonly struct GenericTypeArgumentsEncoder
			{
				public BlobBuilder Builder { get; }

				public GenericTypeArgumentsEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				public SignatureTypeEncoder AddArgument()
				{
					return new SignatureTypeEncoder(Builder);
				}
			}

			internal readonly struct GuidHeap
			{
				internal readonly System.Reflection.Internal.MemoryBlock Block;

				public GuidHeap(System.Reflection.Internal.MemoryBlock block)
				{
					Block = block;
				}

				internal Guid GetGuid(GuidHandle handle)
				{
					if (handle.IsNil)
					{
						return default(Guid);
					}
					return Block.PeekGuid((handle.Index - 1) * 16);
				}
			}

			/// <summary>
			/// These constants are all in the byte range and apply to the interpretation of <see cref="P:System.Reflection.Metadata.Handle.VType" />,
			/// </summary>
			internal static class HandleType
			{
				internal const uint Module = 0u;

				internal const uint TypeRef = 1u;

				internal const uint TypeDef = 2u;

				internal const uint FieldDef = 4u;

				internal const uint MethodDef = 6u;

				internal const uint ParamDef = 8u;

				internal const uint InterfaceImpl = 9u;

				internal const uint MemberRef = 10u;

				internal const uint Constant = 11u;

				internal const uint CustomAttribute = 12u;

				internal const uint DeclSecurity = 14u;

				internal const uint Signature = 17u;

				internal const uint EventMap = 18u;

				internal const uint Event = 20u;

				internal const uint PropertyMap = 21u;

				internal const uint Property = 23u;

				internal const uint MethodSemantics = 24u;

				internal const uint MethodImpl = 25u;

				internal const uint ModuleRef = 26u;

				internal const uint TypeSpec = 27u;

				internal const uint Assembly = 32u;

				internal const uint AssemblyRef = 35u;

				internal const uint File = 38u;

				internal const uint ExportedType = 39u;

				internal const uint ManifestResource = 40u;

				internal const uint NestedClass = 41u;

				internal const uint GenericParam = 42u;

				internal const uint MethodSpec = 43u;

				internal const uint GenericParamConstraint = 44u;

				internal const uint Document = 48u;

				internal const uint MethodDebugInformation = 49u;

				internal const uint LocalScope = 50u;

				internal const uint LocalVariable = 51u;

				internal const uint LocalConstant = 52u;

				internal const uint ImportScope = 53u;

				internal const uint AsyncMethod = 54u;

				internal const uint CustomDebugInformation = 55u;

				internal const uint UserString = 112u;

				internal const uint Blob = 113u;

				internal const uint Guid = 114u;

				internal const uint String = 120u;

				internal const uint String1 = 121u;

				internal const uint String2 = 122u;

				internal const uint String3 = 123u;

				internal const uint Namespace = 124u;

				internal const uint HeapMask = 112u;

				internal const uint TypeMask = 127u;

				/// <summary>
				/// Use the highest bit to mark tokens that are virtual (synthesized).
				/// We create virtual tokens to represent projected WinMD entities.
				/// </summary>
				internal const uint VirtualBit = 128u;

				/// <summary>
				/// In the case of string handles, the two lower bits that (in addition to the
				/// virtual bit not included in this mask) encode how to obtain the string value.
				/// </summary>
				internal const uint NonVirtualStringTypeMask = 3u;
			}

			internal static class HasConstantTag
			{
				internal const int NumberOfBits = 2;

				internal const int LargeRowSize = 16384;

				internal const uint Field = 0u;

				internal const uint Param = 1u;

				internal const uint Property = 2u;

				internal const uint TagMask = 3u;

				internal const System.Reflection.Metadata.Ecma335.TableMask TablesReferenced = System.Reflection.Metadata.Ecma335.TableMask.Field | System.Reflection.Metadata.Ecma335.TableMask.Param | System.Reflection.Metadata.Ecma335.TableMask.Property;

				internal const uint TagToTokenTypeByteVector = 1509380u;

				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				internal static EntityHandle ConvertToHandle(uint hasConstant)
				{
					uint num = 1509380u >> (int)((hasConstant & 3) << 3) << 24;
					uint num2 = hasConstant >> 2;
					if (num == 0 || (num2 & 0xFF000000u) != 0)
					{
						System.Reflection.Throw.InvalidCodedIndex();
					}
					return new EntityHandle(num | num2);
				}

				internal static uint ConvertToTag(EntityHandle token)
				{
					HandleKind kind = token.Kind;
					uint rowId = (uint)token.RowId;
					return kind switch
					{
						HandleKind.FieldDefinition => (rowId << 2) | 0u,
						HandleKind.Parameter => (rowId << 2) | 1u,
						HandleKind.PropertyDefinition => (rowId << 2) | 2u,
						_ => 0u,
					};
				}
			}

			internal static class HasCustomAttributeTag
			{
				internal const int NumberOfBits = 5;

				internal const int LargeRowSize = 2048;

				internal const uint MethodDef = 0u;

				internal const uint Field = 1u;

				internal const uint TypeRef = 2u;

				internal const uint TypeDef = 3u;

				internal const uint Param = 4u;

				internal const uint InterfaceImpl = 5u;

				internal const uint MemberRef = 6u;

				internal const uint Module = 7u;

				internal const uint DeclSecurity = 8u;

				internal const uint Property = 9u;

				internal const uint Event = 10u;

				internal const uint StandAloneSig = 11u;

				internal const uint ModuleRef = 12u;

				internal const uint TypeSpec = 13u;

				internal const uint Assembly = 14u;

				internal const uint AssemblyRef = 15u;

				internal const uint File = 16u;

				internal const uint ExportedType = 17u;

				internal const uint ManifestResource = 18u;

				internal const uint GenericParam = 19u;

				internal const uint GenericParamConstraint = 20u;

				internal const uint MethodSpec = 21u;

				internal const uint TagMask = 31u;

				internal const uint InvalidTokenType = uint.MaxValue;

				internal static uint[] TagToTokenTypeArray = new uint[32]
				{
			100663296u, 67108864u, 16777216u, 33554432u, 134217728u, 150994944u, 167772160u, 0u, 234881024u, 385875968u,
			335544320u, 285212672u, 436207616u, 452984832u, 536870912u, 587202560u, 637534208u, 654311424u, 671088640u, 704643072u,
			738197504u, 721420288u, 4294967295u, 4294967295u, 4294967295u, 4294967295u, 4294967295u, 4294967295u, 4294967295u, 4294967295u,
			4294967295u, 4294967295u
				};

				internal const System.Reflection.Metadata.Ecma335.TableMask TablesReferenced = System.Reflection.Metadata.Ecma335.TableMask.Module | System.Reflection.Metadata.Ecma335.TableMask.TypeRef | System.Reflection.Metadata.Ecma335.TableMask.TypeDef | System.Reflection.Metadata.Ecma335.TableMask.Field | System.Reflection.Metadata.Ecma335.TableMask.MethodDef | System.Reflection.Metadata.Ecma335.TableMask.Param | System.Reflection.Metadata.Ecma335.TableMask.InterfaceImpl | System.Reflection.Metadata.Ecma335.TableMask.MemberRef | System.Reflection.Metadata.Ecma335.TableMask.DeclSecurity | System.Reflection.Metadata.Ecma335.TableMask.StandAloneSig | System.Reflection.Metadata.Ecma335.TableMask.Event | System.Reflection.Metadata.Ecma335.TableMask.Property | System.Reflection.Metadata.Ecma335.TableMask.ModuleRef | System.Reflection.Metadata.Ecma335.TableMask.TypeSpec | System.Reflection.Metadata.Ecma335.TableMask.Assembly | System.Reflection.Metadata.Ecma335.TableMask.AssemblyRef | System.Reflection.Metadata.Ecma335.TableMask.File | System.Reflection.Metadata.Ecma335.TableMask.ExportedType | System.Reflection.Metadata.Ecma335.TableMask.ManifestResource | System.Reflection.Metadata.Ecma335.TableMask.GenericParam | System.Reflection.Metadata.Ecma335.TableMask.MethodSpec | System.Reflection.Metadata.Ecma335.TableMask.GenericParamConstraint;

				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				internal static EntityHandle ConvertToHandle(uint hasCustomAttribute)
				{
					uint num = TagToTokenTypeArray[hasCustomAttribute & 0x1F];
					uint num2 = hasCustomAttribute >> 5;
					if (num == uint.MaxValue || (num2 & 0xFF000000u) != 0)
					{
						System.Reflection.Throw.InvalidCodedIndex();
					}
					return new EntityHandle(num | num2);
				}

				internal static uint ConvertToTag(EntityHandle handle)
				{
					uint type = handle.Type;
					uint rowId = (uint)handle.RowId;
					return (type >> 24) switch
					{
						6u => (rowId << 5) | 0u,
						4u => (rowId << 5) | 1u,
						1u => (rowId << 5) | 2u,
						2u => (rowId << 5) | 3u,
						8u => (rowId << 5) | 4u,
						9u => (rowId << 5) | 5u,
						10u => (rowId << 5) | 6u,
						0u => (rowId << 5) | 7u,
						14u => (rowId << 5) | 8u,
						23u => (rowId << 5) | 9u,
						20u => (rowId << 5) | 0xAu,
						17u => (rowId << 5) | 0xBu,
						26u => (rowId << 5) | 0xCu,
						27u => (rowId << 5) | 0xDu,
						32u => (rowId << 5) | 0xEu,
						35u => (rowId << 5) | 0xFu,
						38u => (rowId << 5) | 0x10u,
						39u => (rowId << 5) | 0x11u,
						40u => (rowId << 5) | 0x12u,
						42u => (rowId << 5) | 0x13u,
						44u => (rowId << 5) | 0x14u,
						43u => (rowId << 5) | 0x15u,
						_ => 0u,
					};
				}
			}

			internal static class HasCustomDebugInformationTag
			{
				internal const int NumberOfBits = 5;

				internal const int LargeRowSize = 2048;

				internal const uint MethodDef = 0u;

				internal const uint Field = 1u;

				internal const uint TypeRef = 2u;

				internal const uint TypeDef = 3u;

				internal const uint Param = 4u;

				internal const uint InterfaceImpl = 5u;

				internal const uint MemberRef = 6u;

				internal const uint Module = 7u;

				internal const uint DeclSecurity = 8u;

				internal const uint Property = 9u;

				internal const uint Event = 10u;

				internal const uint StandAloneSig = 11u;

				internal const uint ModuleRef = 12u;

				internal const uint TypeSpec = 13u;

				internal const uint Assembly = 14u;

				internal const uint AssemblyRef = 15u;

				internal const uint File = 16u;

				internal const uint ExportedType = 17u;

				internal const uint ManifestResource = 18u;

				internal const uint GenericParam = 19u;

				internal const uint GenericParamConstraint = 20u;

				internal const uint MethodSpec = 21u;

				internal const uint Document = 22u;

				internal const uint LocalScope = 23u;

				internal const uint LocalVariable = 24u;

				internal const uint LocalConstant = 25u;

				internal const uint Import = 26u;

				internal const uint TagMask = 31u;

				internal const uint InvalidTokenType = uint.MaxValue;

				internal static uint[] TagToTokenTypeArray = new uint[32]
				{
			100663296u, 67108864u, 16777216u, 33554432u, 134217728u, 150994944u, 167772160u, 0u, 234881024u, 385875968u,
			335544320u, 285212672u, 436207616u, 452984832u, 536870912u, 587202560u, 637534208u, 654311424u, 671088640u, 704643072u,
			738197504u, 721420288u, 805306368u, 838860800u, 855638016u, 872415232u, 889192448u, 4294967295u, 4294967295u, 4294967295u,
			4294967295u, 4294967295u
				};

				internal const System.Reflection.Metadata.Ecma335.TableMask TablesReferenced = System.Reflection.Metadata.Ecma335.TableMask.Module | System.Reflection.Metadata.Ecma335.TableMask.TypeRef | System.Reflection.Metadata.Ecma335.TableMask.TypeDef | System.Reflection.Metadata.Ecma335.TableMask.Field | System.Reflection.Metadata.Ecma335.TableMask.MethodDef | System.Reflection.Metadata.Ecma335.TableMask.Param | System.Reflection.Metadata.Ecma335.TableMask.InterfaceImpl | System.Reflection.Metadata.Ecma335.TableMask.MemberRef | System.Reflection.Metadata.Ecma335.TableMask.DeclSecurity | System.Reflection.Metadata.Ecma335.TableMask.StandAloneSig | System.Reflection.Metadata.Ecma335.TableMask.Event | System.Reflection.Metadata.Ecma335.TableMask.Property | System.Reflection.Metadata.Ecma335.TableMask.ModuleRef | System.Reflection.Metadata.Ecma335.TableMask.TypeSpec | System.Reflection.Metadata.Ecma335.TableMask.Assembly | System.Reflection.Metadata.Ecma335.TableMask.AssemblyRef | System.Reflection.Metadata.Ecma335.TableMask.File | System.Reflection.Metadata.Ecma335.TableMask.ExportedType | System.Reflection.Metadata.Ecma335.TableMask.ManifestResource | System.Reflection.Metadata.Ecma335.TableMask.GenericParam | System.Reflection.Metadata.Ecma335.TableMask.MethodSpec | System.Reflection.Metadata.Ecma335.TableMask.GenericParamConstraint | System.Reflection.Metadata.Ecma335.TableMask.Document | System.Reflection.Metadata.Ecma335.TableMask.LocalScope | System.Reflection.Metadata.Ecma335.TableMask.LocalVariable | System.Reflection.Metadata.Ecma335.TableMask.LocalConstant | System.Reflection.Metadata.Ecma335.TableMask.ImportScope;

				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				internal static EntityHandle ConvertToHandle(uint taggedReference)
				{
					uint num = TagToTokenTypeArray[taggedReference & 0x1F];
					uint num2 = taggedReference >> 5;
					if (num == uint.MaxValue || (num2 & 0xFF000000u) != 0)
					{
						System.Reflection.Throw.InvalidCodedIndex();
					}
					return new EntityHandle(num | num2);
				}

				internal static uint ConvertToTag(EntityHandle handle)
				{
					uint type = handle.Type;
					uint rowId = (uint)handle.RowId;
					return (type >> 24) switch
					{
						6u => (rowId << 5) | 0u,
						4u => (rowId << 5) | 1u,
						1u => (rowId << 5) | 2u,
						2u => (rowId << 5) | 3u,
						8u => (rowId << 5) | 4u,
						9u => (rowId << 5) | 5u,
						10u => (rowId << 5) | 6u,
						0u => (rowId << 5) | 7u,
						14u => (rowId << 5) | 8u,
						23u => (rowId << 5) | 9u,
						20u => (rowId << 5) | 0xAu,
						17u => (rowId << 5) | 0xBu,
						26u => (rowId << 5) | 0xCu,
						27u => (rowId << 5) | 0xDu,
						32u => (rowId << 5) | 0xEu,
						35u => (rowId << 5) | 0xFu,
						38u => (rowId << 5) | 0x10u,
						39u => (rowId << 5) | 0x11u,
						40u => (rowId << 5) | 0x12u,
						42u => (rowId << 5) | 0x13u,
						44u => (rowId << 5) | 0x14u,
						43u => (rowId << 5) | 0x15u,
						48u => (rowId << 5) | 0x16u,
						50u => (rowId << 5) | 0x17u,
						51u => (rowId << 5) | 0x18u,
						52u => (rowId << 5) | 0x19u,
						53u => (rowId << 5) | 0x1Au,
						_ => 0u,
					};
				}
			}

			internal static class HasDeclSecurityTag
			{
				internal const int NumberOfBits = 2;

				internal const int LargeRowSize = 16384;

				internal const uint TypeDef = 0u;

				internal const uint MethodDef = 1u;

				internal const uint Assembly = 2u;

				internal const uint TagMask = 3u;

				internal const System.Reflection.Metadata.Ecma335.TableMask TablesReferenced = System.Reflection.Metadata.Ecma335.TableMask.TypeDef | System.Reflection.Metadata.Ecma335.TableMask.MethodDef | System.Reflection.Metadata.Ecma335.TableMask.Assembly;

				internal const uint TagToTokenTypeByteVector = 2098690u;

				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				internal static EntityHandle ConvertToHandle(uint hasDeclSecurity)
				{
					uint num = 2098690u >> (int)((hasDeclSecurity & 3) << 3) << 24;
					uint num2 = hasDeclSecurity >> 2;
					if (num == 0 || (num2 & 0xFF000000u) != 0)
					{
						System.Reflection.Throw.InvalidCodedIndex();
					}
					return new EntityHandle(num | num2);
				}

				internal static uint ConvertToTag(EntityHandle handle)
				{
					uint type = handle.Type;
					uint rowId = (uint)handle.RowId;
					return (type >> 24) switch
					{
						2u => (rowId << 2) | 0u,
						6u => (rowId << 2) | 1u,
						32u => (rowId << 2) | 2u,
						_ => 0u,
					};
				}
			}

			internal static class HasFieldMarshalTag
			{
				internal const int NumberOfBits = 1;

				internal const int LargeRowSize = 32768;

				internal const uint Field = 0u;

				internal const uint Param = 1u;

				internal const uint TagMask = 1u;

				internal const System.Reflection.Metadata.Ecma335.TableMask TablesReferenced = System.Reflection.Metadata.Ecma335.TableMask.Field | System.Reflection.Metadata.Ecma335.TableMask.Param;

				internal const uint TagToTokenTypeByteVector = 2052u;

				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				internal static EntityHandle ConvertToHandle(uint hasFieldMarshal)
				{
					uint num = 2052u >> (int)((hasFieldMarshal & 1) << 3) << 24;
					uint num2 = hasFieldMarshal >> 1;
					if ((num2 & 0xFF000000u) != 0)
					{
						System.Reflection.Throw.InvalidCodedIndex();
					}
					return new EntityHandle(num | num2);
				}

				internal static uint ConvertToTag(EntityHandle handle)
				{
					if (handle.Type == 67108864)
					{
						return (uint)(handle.RowId << 1) | 0u;
					}
					if (handle.Type == 134217728)
					{
						return (uint)(handle.RowId << 1) | 1u;
					}
					return 0u;
				}
			}

			internal static class HasSemanticsTag
			{
				internal const int NumberOfBits = 1;

				internal const int LargeRowSize = 32768;

				internal const uint Event = 0u;

				internal const uint Property = 1u;

				internal const uint TagMask = 1u;

				internal const System.Reflection.Metadata.Ecma335.TableMask TablesReferenced = System.Reflection.Metadata.Ecma335.TableMask.Event | System.Reflection.Metadata.Ecma335.TableMask.Property;

				internal const uint TagToTokenTypeByteVector = 5908u;

				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				internal static EntityHandle ConvertToHandle(uint hasSemantic)
				{
					uint num = 5908u >> (int)((hasSemantic & 1) << 3) << 24;
					uint num2 = hasSemantic >> 1;
					if ((num2 & 0xFF000000u) != 0)
					{
						System.Reflection.Throw.InvalidCodedIndex();
					}
					return new EntityHandle(num | num2);
				}

				internal static uint ConvertEventHandleToTag(EventDefinitionHandle eventDef)
				{
					return (uint)(eventDef.RowId << 1) | 0u;
				}

				internal static uint ConvertPropertyHandleToTag(PropertyDefinitionHandle propertyDef)
				{
					return (uint)(propertyDef.RowId << 1) | 1u;
				}
			}

			internal static class HeapHandleType
			{
				internal const int OffsetBitCount = 29;

				internal const uint OffsetMask = 536870911u;

				internal const uint VirtualBit = 2147483648u;

				internal static bool IsValidHeapOffset(uint offset)
				{
					return (offset & 0xE0000000u) == 0;
				}
			}

			public enum HeapIndex { UserString, String, Blob, Guid }

			internal static class HeapIndexExtensions { internal const int Count = 4; }

			internal enum HeapSizeFlag : byte { StringHeapLarge = 1, GuidHeapLarge = 2, BlobHeapLarge = 4, EncDeltas = 0x20, DeletedMarks = 0x80 }

			internal enum HeapSizes : byte { StringHeapLarge = 1, GuidHeapLarge = 2, BlobHeapLarge = 4, ExtraData = 0x40 }

			internal static class ImplementationTag
			{
				internal const int NumberOfBits = 2;

				internal const int LargeRowSize = 16384;

				internal const uint File = 0u;

				internal const uint AssemblyRef = 1u;

				internal const uint ExportedType = 2u;

				internal const uint TagMask = 3u;

				internal const uint TagToTokenTypeByteVector = 2564902u;

				internal const System.Reflection.Metadata.Ecma335.TableMask TablesReferenced = System.Reflection.Metadata.Ecma335.TableMask.AssemblyRef | System.Reflection.Metadata.Ecma335.TableMask.File | System.Reflection.Metadata.Ecma335.TableMask.ExportedType;

				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				internal static EntityHandle ConvertToHandle(uint implementation)
				{
					uint num = 2564902u >> (int)((implementation & 3) << 3) << 24;
					uint num2 = implementation >> 2;
					if (num == 0 || (num2 & 0xFF000000u) != 0)
					{
						System.Reflection.Throw.InvalidCodedIndex();
					}
					return new EntityHandle(num | num2);
				}
			}

			internal readonly struct ImplMapTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsModuleRefTableRowRefSizeSmall;

				private readonly bool _IsMemberForwardRowRefSizeSmall;

				private readonly bool _IsStringHeapRefSizeSmall;

				private readonly int _FlagsOffset;

				private readonly int _MemberForwardedOffset;

				private readonly int _ImportNameOffset;

				private readonly int _ImportScopeOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal ImplMapTableReader(int numberOfRows, bool declaredSorted, int moduleRefTableRowRefSize, int memberForwardedRefSize, int stringHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsModuleRefTableRowRefSizeSmall = moduleRefTableRowRefSize == 2;
					_IsMemberForwardRowRefSizeSmall = memberForwardedRefSize == 2;
					_IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_FlagsOffset = 0;
					_MemberForwardedOffset = _FlagsOffset + 2;
					_ImportNameOffset = _MemberForwardedOffset + memberForwardedRefSize;
					_ImportScopeOffset = _ImportNameOffset + stringHeapRefSize;
					RowSize = _ImportScopeOffset + moduleRefTableRowRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
					if (!declaredSorted && !CheckSorted())
					{
						System.Reflection.Throw.TableNotSorted(TableIndex.ImplMap);
					}
				}

				internal MethodImport GetImport(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					MethodImportAttributes attributes = (MethodImportAttributes)Block.PeekUInt16(num + _FlagsOffset);
					StringHandle name = StringHandle.FromOffset(Block.PeekHeapReference(num + _ImportNameOffset, _IsStringHeapRefSizeSmall));
					ModuleReferenceHandle module = ModuleReferenceHandle.FromRowId(Block.PeekReference(num + _ImportScopeOffset, _IsModuleRefTableRowRefSizeSmall));
					return new MethodImport(attributes, name, module);
				}

				internal EntityHandle GetMemberForwarded(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return MemberForwardedTag.ConvertToHandle(Block.PeekTaggedReference(num + _MemberForwardedOffset, _IsMemberForwardRowRefSizeSmall));
				}

				internal int FindImplForMethod(MethodDefinitionHandle methodDef)
				{
					uint searchCodedTag = MemberForwardedTag.ConvertMethodDefToTag(methodDef);
					return BinarySearchTag(searchCodedTag);
				}

				private int BinarySearchTag(uint searchCodedTag)
				{
					int num = Block.BinarySearchReference(NumberOfRows, RowSize, _MemberForwardedOffset, searchCodedTag, _IsMemberForwardRowRefSizeSmall);
					return num + 1;
				}

				private bool CheckSorted()
				{
					return Block.IsOrderedByReferenceAscending(RowSize, _MemberForwardedOffset, _IsMemberForwardRowRefSizeSmall);
				}
			}

			internal readonly struct ImportScopeTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _isImportScopeRefSizeSmall;

				private readonly bool _isBlobHeapRefSizeSmall;

				private const int ParentOffset = 0;

				private readonly int _importsOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal ImportScopeTableReader(int numberOfRows, int importScopeRefSize, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_isImportScopeRefSizeSmall = importScopeRefSize == 2;
					_isBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_importsOffset = importScopeRefSize;
					RowSize = _importsOffset + blobHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal ImportScopeHandle GetParent(ImportScopeHandle handle)
				{
					int offset = (handle.RowId - 1) * RowSize;
					return ImportScopeHandle.FromRowId(Block.PeekReference(offset, _isImportScopeRefSizeSmall));
				}

				internal BlobHandle GetImports(ImportScopeHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _importsOffset, _isBlobHeapRefSizeSmall));
				}
			}

			/// <summary>
			/// Encodes instructions.
			/// </summary>
			public readonly struct InstructionEncoder
			{
				/// <summary>
				/// Underlying builder where encoded instructions are written to.
				/// </summary>
				public BlobBuilder CodeBuilder { get; }

				/// <summary>
				/// Builder tracking labels, branches and exception handlers.
				/// </summary>
				/// <remarks>
				/// If null the encoder doesn't support construction of control flow.
				/// </remarks>
				public ControlFlowBuilder? ControlFlowBuilder { get; }

				/// <summary>
				/// Offset of the next encoded instruction.
				/// </summary>
				public int Offset => CodeBuilder.Count;

				/// <summary>
				/// Creates an encoder backed by code and control-flow builders.
				/// </summary>
				/// <param name="codeBuilder">Builder to write encoded instructions to.</param>
				/// <param name="controlFlowBuilder">
				/// Builder tracking labels, branches and exception handlers.
				/// Must be specified to be able to use some of the control-flow factory methods of <see cref="T:System.Reflection.Metadata.Ecma335.InstructionEncoder" />,
				/// such as <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.Branch(System.Reflection.Metadata.ILOpCode,System.Reflection.Metadata.Ecma335.LabelHandle)" />, <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.DefineLabel" />, <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.MarkLabel(System.Reflection.Metadata.Ecma335.LabelHandle)" /> etc.
				/// </param>
				public InstructionEncoder(BlobBuilder codeBuilder, ControlFlowBuilder? controlFlowBuilder = null)
				{
					if (codeBuilder == null)
					{
						System.Reflection.Throw.BuilderArgumentNull();
					}
					CodeBuilder = codeBuilder;
					ControlFlowBuilder = controlFlowBuilder;
				}

				/// <summary>
				/// Encodes specified op-code.
				/// </summary>
				public void OpCode(ILOpCode code)
				{
					if ((uint)(byte)code == (uint)code)
					{
						CodeBuilder.WriteByte((byte)code);
					}
					else
					{
						CodeBuilder.WriteUInt16BE((ushort)code);
					}
				}

				/// <summary>
				/// Encodes a token.
				/// </summary>
				public void Token(EntityHandle handle)
				{
					Token(MetadataTokens.GetToken(handle));
				}

				/// <summary>
				/// Encodes a token.
				/// </summary>
				public void Token(int token)
				{
					CodeBuilder.WriteInt32(token);
				}

				/// <summary>
				/// Encodes <code>ldstr</code> instruction and its operand.
				/// </summary>
				public void LoadString(UserStringHandle handle)
				{
					OpCode(ILOpCode.Ldstr);
					Token(MetadataTokens.GetToken(handle));
				}

				/// <summary>
				/// Encodes <code>call</code> instruction and its operand.
				/// </summary>
				public void Call(EntityHandle methodHandle)
				{
					if (methodHandle.Kind != HandleKind.MethodDefinition && methodHandle.Kind != HandleKind.MethodSpecification && methodHandle.Kind != HandleKind.MemberReference)
					{
						System.Reflection.Throw.InvalidArgument_Handle("methodHandle");
					}
					OpCode(ILOpCode.Call);
					Token(methodHandle);
				}

				/// <summary>
				/// Encodes <code>call</code> instruction and its operand.
				/// </summary>
				public void Call(MethodDefinitionHandle methodHandle)
				{
					OpCode(ILOpCode.Call);
					Token(methodHandle);
				}

				/// <summary>
				/// Encodes <code>call</code> instruction and its operand.
				/// </summary>
				public void Call(MethodSpecificationHandle methodHandle)
				{
					OpCode(ILOpCode.Call);
					Token(methodHandle);
				}

				/// <summary>
				/// Encodes <code>call</code> instruction and its operand.
				/// </summary>
				public void Call(MemberReferenceHandle methodHandle)
				{
					OpCode(ILOpCode.Call);
					Token(methodHandle);
				}

				/// <summary>
				/// Encodes <code>calli</code> instruction and its operand.
				/// </summary>
				public void CallIndirect(StandaloneSignatureHandle signature)
				{
					OpCode(ILOpCode.Calli);
					Token(signature);
				}

				/// <summary>
				/// Encodes <see cref="T:System.Int32" /> constant load instruction.
				/// </summary>
				public void LoadConstantI4(int value)
				{
					ILOpCode code;
					switch (value)
					{
						case -1:
							code = ILOpCode.Ldc_i4_m1;
							break;
						case 0:
							code = ILOpCode.Ldc_i4_0;
							break;
						case 1:
							code = ILOpCode.Ldc_i4_1;
							break;
						case 2:
							code = ILOpCode.Ldc_i4_2;
							break;
						case 3:
							code = ILOpCode.Ldc_i4_3;
							break;
						case 4:
							code = ILOpCode.Ldc_i4_4;
							break;
						case 5:
							code = ILOpCode.Ldc_i4_5;
							break;
						case 6:
							code = ILOpCode.Ldc_i4_6;
							break;
						case 7:
							code = ILOpCode.Ldc_i4_7;
							break;
						case 8:
							code = ILOpCode.Ldc_i4_8;
							break;
						default:
							if ((sbyte)value == value)
							{
								OpCode(ILOpCode.Ldc_i4_s);
								CodeBuilder.WriteSByte((sbyte)value);
							}
							else
							{
								OpCode(ILOpCode.Ldc_i4);
								CodeBuilder.WriteInt32(value);
							}
							return;
					}
					OpCode(code);
				}

				/// <summary>
				/// Encodes <see cref="T:System.Int64" /> constant load instruction.
				/// </summary>
				public void LoadConstantI8(long value)
				{
					OpCode(ILOpCode.Ldc_i8);
					CodeBuilder.WriteInt64(value);
				}

				/// <summary>
				/// Encodes <see cref="T:System.Single" /> constant load instruction.
				/// </summary>
				public void LoadConstantR4(float value)
				{
					OpCode(ILOpCode.Ldc_r4);
					CodeBuilder.WriteSingle(value);
				}

				/// <summary>
				/// Encodes <see cref="T:System.Double" /> constant load instruction.
				/// </summary>
				public void LoadConstantR8(double value)
				{
					OpCode(ILOpCode.Ldc_r8);
					CodeBuilder.WriteDouble(value);
				}

				/// <summary>
				/// Encodes local variable load instruction.
				/// </summary>
				/// <param name="slotIndex">Index of the local variable slot.</param>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="slotIndex" /> is negative.</exception>
				public void LoadLocal(int slotIndex)
				{
					switch (slotIndex)
					{
						case 0:
							OpCode(ILOpCode.Ldloc_0);
							return;
						case 1:
							OpCode(ILOpCode.Ldloc_1);
							return;
						case 2:
							OpCode(ILOpCode.Ldloc_2);
							return;
						case 3:
							OpCode(ILOpCode.Ldloc_3);
							return;
					}
					if ((uint)slotIndex <= 255u)
					{
						OpCode(ILOpCode.Ldloc_s);
						CodeBuilder.WriteByte((byte)slotIndex);
					}
					else if (slotIndex > 0)
					{
						OpCode(ILOpCode.Ldloc);
						CodeBuilder.WriteInt32(slotIndex);
					}
					else
					{
						System.Reflection.Throw.ArgumentOutOfRange("slotIndex");
					}
				}

				/// <summary>
				/// Encodes local variable store instruction.
				/// </summary>
				/// <param name="slotIndex">Index of the local variable slot.</param>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="slotIndex" /> is negative.</exception>
				public void StoreLocal(int slotIndex)
				{
					switch (slotIndex)
					{
						case 0:
							OpCode(ILOpCode.Stloc_0);
							return;
						case 1:
							OpCode(ILOpCode.Stloc_1);
							return;
						case 2:
							OpCode(ILOpCode.Stloc_2);
							return;
						case 3:
							OpCode(ILOpCode.Stloc_3);
							return;
					}
					if ((uint)slotIndex <= 255u)
					{
						OpCode(ILOpCode.Stloc_s);
						CodeBuilder.WriteByte((byte)slotIndex);
					}
					else if (slotIndex > 0)
					{
						OpCode(ILOpCode.Stloc);
						CodeBuilder.WriteInt32(slotIndex);
					}
					else
					{
						System.Reflection.Throw.ArgumentOutOfRange("slotIndex");
					}
				}

				/// <summary>
				/// Encodes local variable address load instruction.
				/// </summary>
				/// <param name="slotIndex">Index of the local variable slot.</param>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="slotIndex" /> is negative.</exception>
				public void LoadLocalAddress(int slotIndex)
				{
					if ((uint)slotIndex <= 255u)
					{
						OpCode(ILOpCode.Ldloca_s);
						CodeBuilder.WriteByte((byte)slotIndex);
					}
					else if (slotIndex > 0)
					{
						OpCode(ILOpCode.Ldloca);
						CodeBuilder.WriteInt32(slotIndex);
					}
					else
					{
						System.Reflection.Throw.ArgumentOutOfRange("slotIndex");
					}
				}

				/// <summary>
				/// Encodes argument load instruction.
				/// </summary>
				/// <param name="argumentIndex">Index of the argument.</param>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="argumentIndex" /> is negative.</exception>
				public void LoadArgument(int argumentIndex)
				{
					switch (argumentIndex)
					{
						case 0:
							OpCode(ILOpCode.Ldarg_0);
							return;
						case 1:
							OpCode(ILOpCode.Ldarg_1);
							return;
						case 2:
							OpCode(ILOpCode.Ldarg_2);
							return;
						case 3:
							OpCode(ILOpCode.Ldarg_3);
							return;
					}
					if ((uint)argumentIndex <= 255u)
					{
						OpCode(ILOpCode.Ldarg_s);
						CodeBuilder.WriteByte((byte)argumentIndex);
					}
					else if (argumentIndex > 0)
					{
						OpCode(ILOpCode.Ldarg);
						CodeBuilder.WriteInt32(argumentIndex);
					}
					else
					{
						System.Reflection.Throw.ArgumentOutOfRange("argumentIndex");
					}
				}

				/// <summary>
				/// Encodes argument address load instruction.
				/// </summary>
				/// <param name="argumentIndex">Index of the argument.</param>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="argumentIndex" /> is negative.</exception>
				public void LoadArgumentAddress(int argumentIndex)
				{
					if ((uint)argumentIndex <= 255u)
					{
						OpCode(ILOpCode.Ldarga_s);
						CodeBuilder.WriteByte((byte)argumentIndex);
					}
					else if (argumentIndex > 0)
					{
						OpCode(ILOpCode.Ldarga);
						CodeBuilder.WriteInt32(argumentIndex);
					}
					else
					{
						System.Reflection.Throw.ArgumentOutOfRange("argumentIndex");
					}
				}

				/// <summary>
				/// Encodes argument store instruction.
				/// </summary>
				/// <param name="argumentIndex">Index of the argument.</param>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="argumentIndex" /> is negative.</exception>
				public void StoreArgument(int argumentIndex)
				{
					if ((uint)argumentIndex <= 255u)
					{
						OpCode(ILOpCode.Starg_s);
						CodeBuilder.WriteByte((byte)argumentIndex);
					}
					else if (argumentIndex > 0)
					{
						OpCode(ILOpCode.Starg);
						CodeBuilder.WriteInt32(argumentIndex);
					}
					else
					{
						System.Reflection.Throw.ArgumentOutOfRange("argumentIndex");
					}
				}

				/// <summary>
				/// Defines a label that can later be used to mark and refer to a location in the instruction stream.
				/// </summary>
				/// <returns>Label handle.</returns>
				/// <exception cref="T:System.InvalidOperationException"><see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> is null.</exception>
				public LabelHandle DefineLabel()
				{
					return GetBranchBuilder().AddLabel();
				}

				/// <summary>
				/// Encodes a branch instruction.
				/// </summary>
				/// <param name="code">Branch instruction to encode.</param>
				/// <param name="label">Label of the target location in instruction stream.</param>
				/// <exception cref="T:System.ArgumentException"><paramref name="code" /> is not a branch instruction.</exception>
				/// <exception cref="T:System.ArgumentException"><paramref name="label" /> was not defined by this encoder.</exception>
				/// <exception cref="T:System.InvalidOperationException"><see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> is null.</exception>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="label" /> has default value.</exception>
				public void Branch(ILOpCode code, LabelHandle label)
				{
					int branchOperandSize = code.GetBranchOperandSize();
					GetBranchBuilder().AddBranch(Offset, label, code);
					OpCode(code);
					if (branchOperandSize == 1)
					{
						CodeBuilder.WriteSByte(-1);
					}
					else
					{
						CodeBuilder.WriteInt32(-1);
					}
				}

				/// <summary>
				/// Associates specified label with the current IL offset.
				/// </summary>
				/// <param name="label">Label to mark.</param>
				/// <remarks>
				/// A single label may be marked multiple times, the last offset wins.
				/// </remarks>
				/// <exception cref="T:System.InvalidOperationException"><see cref="P:System.Reflection.Metadata.Ecma335.InstructionEncoder.ControlFlowBuilder" /> is null.</exception>
				/// <exception cref="T:System.ArgumentException"><paramref name="label" /> was not defined by this encoder.</exception>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="label" /> has default value.</exception>
				public void MarkLabel(LabelHandle label)
				{
					GetBranchBuilder().MarkLabel(Offset, label);
				}

				private ControlFlowBuilder GetBranchBuilder()
				{
					if (ControlFlowBuilder == null)
					{
						System.Reflection.Throw.ControlFlowBuilderNotAvailable();
					}
					return ControlFlowBuilder;
				}
			}

			internal readonly struct InterfaceImplTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsTypeDefTableRowRefSizeSmall;

				private readonly bool _IsTypeDefOrRefRefSizeSmall;

				private readonly int _ClassOffset;

				private readonly int _InterfaceOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal InterfaceImplTableReader(int numberOfRows, bool declaredSorted, int typeDefTableRowRefSize, int typeDefOrRefRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;
					_IsTypeDefOrRefRefSizeSmall = typeDefOrRefRefSize == 2;
					_ClassOffset = 0;
					_InterfaceOffset = _ClassOffset + typeDefTableRowRefSize;
					RowSize = _InterfaceOffset + typeDefOrRefRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
					if (!declaredSorted && !CheckSorted())
					{
						System.Reflection.Throw.TableNotSorted(TableIndex.InterfaceImpl);
					}
				}

				private bool CheckSorted()
				{
					return Block.IsOrderedByReferenceAscending(RowSize, _ClassOffset, _IsTypeDefTableRowRefSizeSmall);
				}

				internal void GetInterfaceImplRange(TypeDefinitionHandle typeDef, out int firstImplRowId, out int lastImplRowId)
				{
					int rowId = typeDef.RowId;
					Block.BinarySearchReferenceRange(NumberOfRows, RowSize, _ClassOffset, (uint)rowId, _IsTypeDefTableRowRefSizeSmall, out var startRowNumber, out var endRowNumber);
					if (startRowNumber == -1)
					{
						firstImplRowId = 1;
						lastImplRowId = 0;
					}
					else
					{
						firstImplRowId = startRowNumber + 1;
						lastImplRowId = endRowNumber + 1;
					}
				}

				internal EntityHandle GetInterface(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return TypeDefOrRefTag.ConvertToHandle(Block.PeekTaggedReference(num + _InterfaceOffset, _IsTypeDefOrRefRefSizeSmall));
				}
			}

			public readonly struct LabelHandle : IEquatable<LabelHandle>
			{
				/// <summary>
				/// 1-based id identifying the label within the context of a <see cref="T:System.Reflection.Metadata.Ecma335.ControlFlowBuilder" />.
				/// </summary>
				public int Id { get; }

				public bool IsNil => Id == 0;

				internal LabelHandle(int id)
				{
					Id = id;
				}

				public bool Equals(LabelHandle other)
				{
					return Id == other.Id;
				}

				public override bool Equals([NotNullWhen(true)] object? obj)
				{
					if (obj is LabelHandle other)
					{
						return Equals(other);
					}
					return false;
				}

				public override int GetHashCode()
				{
					return Id.GetHashCode();
				}

				public static bool operator ==(LabelHandle left, LabelHandle right)
				{
					return left.Equals(right);
				}

				public static bool operator !=(LabelHandle left, LabelHandle right)
				{
					return !left.Equals(right);
				}
			}

			public readonly struct LiteralEncoder
			{
				public BlobBuilder Builder { get; }

				public LiteralEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				public VectorEncoder Vector()
				{
					return new VectorEncoder(Builder);
				}

				/// <summary>
				/// Encodes the type and the items of a vector literal.
				/// Returns a pair of encoders that must be used in the order they appear in the parameter list.
				/// </summary>
				/// <param name="arrayType">Use first, to encode the type of the vector.</param>
				/// <param name="vector">Use second, to encode the items of the vector.</param>
				public void TaggedVector(out CustomAttributeArrayTypeEncoder arrayType, out VectorEncoder vector)
				{
					arrayType = new CustomAttributeArrayTypeEncoder(Builder);
					vector = new VectorEncoder(Builder);
				}

				/// <summary>
				/// Encodes the type and the items of a vector literal.
				/// </summary>
				/// <param name="arrayType">Called first, to encode the type of the vector.</param>
				/// <param name="vector">Called second, to encode the items of the vector.</param>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="arrayType" /> or <paramref name="vector" /> is null.</exception>
				public void TaggedVector(Action<CustomAttributeArrayTypeEncoder> arrayType, Action<VectorEncoder> vector)
				{
					if (arrayType == null)
					{
						System.Reflection.Throw.ArgumentNull("arrayType");
					}
					if (vector == null)
					{
						System.Reflection.Throw.ArgumentNull("vector");
					}
					TaggedVector(out var arrayType2, out var vector2);
					arrayType(arrayType2);
					vector(vector2);
				}

				/// <summary>
				/// Encodes a scalar literal.
				/// </summary>
				/// <returns>Encoder of the literal value.</returns>
				public ScalarEncoder Scalar()
				{
					return new ScalarEncoder(Builder);
				}

				/// <summary>
				/// Encodes the type and the value of a literal.
				/// Returns a pair of encoders that must be used in the order they appear in the parameter list.
				/// </summary>
				/// <param name="type">Called first, to encode the type of the literal.</param>
				/// <param name="scalar">Called second, to encode the value of the literal.</param>
				public void TaggedScalar(out CustomAttributeElementTypeEncoder type, out ScalarEncoder scalar)
				{
					type = new CustomAttributeElementTypeEncoder(Builder);
					scalar = new ScalarEncoder(Builder);
				}

				/// <summary>
				/// Encodes the type and the value of a literal.
				/// </summary>
				/// <param name="type">Called first, to encode the type of the literal.</param>
				/// <param name="scalar">Called second, to encode the value of the literal.</param>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="type" /> or <paramref name="scalar" /> is null.</exception>
				public void TaggedScalar(Action<CustomAttributeElementTypeEncoder> type, Action<ScalarEncoder> scalar)
				{
					if (type == null)
					{
						System.Reflection.Throw.ArgumentNull("type");
					}
					if (scalar == null)
					{
						System.Reflection.Throw.ArgumentNull("scalar");
					}
					TaggedScalar(out var type2, out var scalar2);
					type(type2);
					scalar(scalar2);
				}
			}

			public readonly struct LiteralsEncoder
			{
				public BlobBuilder Builder { get; }

				public LiteralsEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				public LiteralEncoder AddLiteral()
				{
					return new LiteralEncoder(Builder);
				}
			}

			internal readonly struct LocalConstantTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _isStringHeapRefSizeSmall;

				private readonly bool _isBlobHeapRefSizeSmall;

				private const int NameOffset = 0;

				private readonly int _signatureOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal LocalConstantTableReader(int numberOfRows, int stringHeapRefSize, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_isStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_isBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_signatureOffset = stringHeapRefSize;
					RowSize = _signatureOffset + blobHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal StringHandle GetName(LocalConstantHandle handle)
				{
					int offset = (handle.RowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(offset, _isStringHeapRefSizeSmall));
				}

				internal BlobHandle GetSignature(LocalConstantHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _signatureOffset, _isBlobHeapRefSizeSmall));
				}
			}

			internal readonly struct LocalScopeTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _isMethodRefSmall;

				private readonly bool _isImportScopeRefSmall;

				private readonly bool _isLocalConstantRefSmall;

				private readonly bool _isLocalVariableRefSmall;

				private const int MethodOffset = 0;

				private readonly int _importScopeOffset;

				private readonly int _variableListOffset;

				private readonly int _constantListOffset;

				private readonly int _startOffsetOffset;

				private readonly int _lengthOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal LocalScopeTableReader(int numberOfRows, bool declaredSorted, int methodRefSize, int importScopeRefSize, int localVariableRefSize, int localConstantRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_isMethodRefSmall = methodRefSize == 2;
					_isImportScopeRefSmall = importScopeRefSize == 2;
					_isLocalVariableRefSmall = localVariableRefSize == 2;
					_isLocalConstantRefSmall = localConstantRefSize == 2;
					_importScopeOffset = methodRefSize;
					_variableListOffset = _importScopeOffset + importScopeRefSize;
					_constantListOffset = _variableListOffset + localVariableRefSize;
					_startOffsetOffset = _constantListOffset + localConstantRefSize;
					_lengthOffset = _startOffsetOffset + 4;
					RowSize = _lengthOffset + 4;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
					if (numberOfRows > 0 && !declaredSorted)
					{
						System.Reflection.Throw.TableNotSorted(TableIndex.LocalScope);
					}
				}

				internal MethodDefinitionHandle GetMethod(int rowId)
				{
					int offset = (rowId - 1) * RowSize;
					return MethodDefinitionHandle.FromRowId(Block.PeekReference(offset, _isMethodRefSmall));
				}

				internal ImportScopeHandle GetImportScope(LocalScopeHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return ImportScopeHandle.FromRowId(Block.PeekReference(num + _importScopeOffset, _isImportScopeRefSmall));
				}

				internal int GetVariableStart(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return Block.PeekReference(num + _variableListOffset, _isLocalVariableRefSmall);
				}

				internal int GetConstantStart(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return Block.PeekReference(num + _constantListOffset, _isLocalConstantRefSmall);
				}

				internal int GetStartOffset(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return Block.PeekInt32(num + _startOffsetOffset);
				}

				internal int GetLength(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return Block.PeekInt32(num + _lengthOffset);
				}

				internal int GetEndOffset(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					long num2 = Block.PeekUInt32(num + _startOffsetOffset) + Block.PeekUInt32(num + _lengthOffset);
					if ((int)num2 != num2)
					{
						System.Reflection.Throw.ValueOverflow();
					}
					return (int)num2;
				}

				internal void GetLocalScopeRange(int methodDefRid, out int firstScopeRowId, out int lastScopeRowId)
				{
					Block.BinarySearchReferenceRange(NumberOfRows, RowSize, 0, (uint)methodDefRid, _isMethodRefSmall, out var startRowNumber, out var endRowNumber);
					if (startRowNumber == -1)
					{
						firstScopeRowId = 1;
						lastScopeRowId = 0;
					}
					else
					{
						firstScopeRowId = startRowNumber + 1;
						lastScopeRowId = endRowNumber + 1;
					}
				}
			}

			public readonly struct LocalVariablesEncoder
			{
				public BlobBuilder Builder { get; }

				public LocalVariablesEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				public LocalVariableTypeEncoder AddVariable()
				{
					return new LocalVariableTypeEncoder(Builder);
				}
			}

			internal readonly struct LocalVariableTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _isStringHeapRefSizeSmall;

				private readonly int _attributesOffset;

				private readonly int _indexOffset;

				private readonly int _nameOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal LocalVariableTableReader(int numberOfRows, int stringHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_isStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_attributesOffset = 0;
					_indexOffset = _attributesOffset + 2;
					_nameOffset = _indexOffset + 2;
					RowSize = _nameOffset + stringHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal LocalVariableAttributes GetAttributes(LocalVariableHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return (LocalVariableAttributes)Block.PeekUInt16(num + _attributesOffset);
				}

				internal ushort GetIndex(LocalVariableHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return Block.PeekUInt16(num + _indexOffset);
				}

				internal StringHandle GetName(LocalVariableHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _nameOffset, _isStringHeapRefSizeSmall));
				}
			}

			public readonly struct LocalVariableTypeEncoder
			{
				public BlobBuilder Builder { get; }

				public LocalVariableTypeEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				public CustomModifiersEncoder CustomModifiers()
				{
					return new CustomModifiersEncoder(Builder);
				}

				public SignatureTypeEncoder Type(bool isByRef = false, bool isPinned = false)
				{
					if (isPinned)
					{
						Builder.WriteByte(69);
					}
					if (isByRef)
					{
						Builder.WriteByte(16);
					}
					return new SignatureTypeEncoder(Builder);
				}

				public void TypedReference()
				{
					Builder.WriteByte(22);
				}
			}

			internal readonly struct ManifestResourceTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsImplementationRefSizeSmall;

				private readonly bool _IsStringHeapRefSizeSmall;

				private readonly int _OffsetOffset;

				private readonly int _FlagsOffset;

				private readonly int _NameOffset;

				private readonly int _ImplementationOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal ManifestResourceTableReader(int numberOfRows, int implementationRefSize, int stringHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsImplementationRefSizeSmall = implementationRefSize == 2;
					_IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_OffsetOffset = 0;
					_FlagsOffset = _OffsetOffset + 4;
					_NameOffset = _FlagsOffset + 4;
					_ImplementationOffset = _NameOffset + stringHeapRefSize;
					RowSize = _ImplementationOffset + implementationRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal StringHandle GetName(ManifestResourceHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _NameOffset, _IsStringHeapRefSizeSmall));
				}

				internal EntityHandle GetImplementation(ManifestResourceHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return ImplementationTag.ConvertToHandle(Block.PeekTaggedReference(num + _ImplementationOffset, _IsImplementationRefSizeSmall));
				}

				internal uint GetOffset(ManifestResourceHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return Block.PeekUInt32(num + _OffsetOffset);
				}

				internal ManifestResourceAttributes GetFlags(ManifestResourceHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return (ManifestResourceAttributes)Block.PeekUInt32(num + _FlagsOffset);
				}
			}

			internal static class MemberForwardedTag
			{
				internal const int NumberOfBits = 1;

				internal const int LargeRowSize = 32768;

				internal const uint Field = 0u;

				internal const uint MethodDef = 1u;

				internal const uint TagMask = 1u;

				internal const System.Reflection.Metadata.Ecma335.TableMask TablesReferenced = System.Reflection.Metadata.Ecma335.TableMask.Field | System.Reflection.Metadata.Ecma335.TableMask.MethodDef;

				internal const uint TagToTokenTypeByteVector = 1540u;

				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				internal static EntityHandle ConvertToHandle(uint memberForwarded)
				{
					uint num = 1540u >> (int)((memberForwarded & 1) << 3) << 24;
					uint num2 = memberForwarded >> 1;
					if ((num2 & 0xFF000000u) != 0)
					{
						System.Reflection.Throw.InvalidCodedIndex();
					}
					return new EntityHandle(num | num2);
				}

				internal static uint ConvertMethodDefToTag(MethodDefinitionHandle methodDef)
				{
					return (uint)(methodDef.RowId << 1) | 1u;
				}
			}

			internal static class MemberRefParentTag
			{
				internal const int NumberOfBits = 3;

				internal const int LargeRowSize = 8192;

				internal const uint TypeDef = 0u;

				internal const uint TypeRef = 1u;

				internal const uint ModuleRef = 2u;

				internal const uint MethodDef = 3u;

				internal const uint TypeSpec = 4u;

				internal const uint TagMask = 7u;

				internal const System.Reflection.Metadata.Ecma335.TableMask TablesReferenced = System.Reflection.Metadata.Ecma335.TableMask.TypeRef | System.Reflection.Metadata.Ecma335.TableMask.TypeDef | System.Reflection.Metadata.Ecma335.TableMask.MethodDef | System.Reflection.Metadata.Ecma335.TableMask.ModuleRef | System.Reflection.Metadata.Ecma335.TableMask.TypeSpec;

				internal const ulong TagToTokenTypeByteVector = 116066484482uL;

				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				internal static EntityHandle ConvertToHandle(uint memberRef)
				{
					uint num = (uint)(116066484482uL >> (int)((memberRef & 7) << 3) << 24);
					uint num2 = memberRef >> 3;
					if (num == 0 || (num2 & 0xFF000000u) != 0)
					{
						System.Reflection.Throw.InvalidCodedIndex();
					}
					return new EntityHandle(num | num2);
				}
			}

			internal struct MemberRefTableReader
			{
				internal int NumberOfRows;

				private readonly bool _IsMemberRefParentRefSizeSmall;

				private readonly bool _IsStringHeapRefSizeSmall;

				private readonly bool _IsBlobHeapRefSizeSmall;

				private readonly int _ClassOffset;

				private readonly int _NameOffset;

				private readonly int _SignatureOffset;

				internal readonly int RowSize;

				internal System.Reflection.Internal.MemoryBlock Block;

				internal MemberRefTableReader(int numberOfRows, int memberRefParentRefSize, int stringHeapRefSize, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsMemberRefParentRefSizeSmall = memberRefParentRefSize == 2;
					_IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_ClassOffset = 0;
					_NameOffset = _ClassOffset + memberRefParentRefSize;
					_SignatureOffset = _NameOffset + stringHeapRefSize;
					RowSize = _SignatureOffset + blobHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal BlobHandle GetSignature(MemberReferenceHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _SignatureOffset, _IsBlobHeapRefSizeSmall));
				}

				internal StringHandle GetName(MemberReferenceHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _NameOffset, _IsStringHeapRefSizeSmall));
				}

				internal EntityHandle GetClass(MemberReferenceHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return MemberRefParentTag.ConvertToHandle(Block.PeekTaggedReference(num + _ClassOffset, _IsMemberRefParentRefSizeSmall));
				}
			}

			[Flags]
			internal enum MemberRefTreatment : byte { None = 0, Dispose = 1 }

			public sealed class MetadataAggregator
			{
				internal struct RowCounts : IComparable<RowCounts>
				{
					public int AggregateInserts;

					public int Updates;

					public int CompareTo(RowCounts other)
					{
						return AggregateInserts - other.AggregateInserts;
					}

					public override string ToString()
					{
						return $"+0x{AggregateInserts:x} ~0x{Updates:x}";
					}
				}

				private readonly System.Collections.Immutable.ImmutableArray<System.Collections.Immutable.ImmutableArray<int>> _heapSizes;

				private readonly System.Collections.Immutable.ImmutableArray<System.Collections.Immutable.ImmutableArray<RowCounts>> _rowCounts;

				public MetadataAggregator(MetadataReader baseReader, IReadOnlyList<MetadataReader> deltaReaders)
					: this(baseReader, null, null, deltaReaders)
				{
				}

				public MetadataAggregator(IReadOnlyList<int>? baseTableRowCounts, IReadOnlyList<int>? baseHeapSizes, IReadOnlyList<MetadataReader>? deltaReaders)
					: this(null, baseTableRowCounts, baseHeapSizes, deltaReaders)
				{
				}

				private MetadataAggregator(MetadataReader baseReader, IReadOnlyList<int> baseTableRowCounts, IReadOnlyList<int> baseHeapSizes, IReadOnlyList<MetadataReader> deltaReaders)
				{
					if (baseTableRowCounts == null)
					{
						if (baseReader == null)
						{
							System.Reflection.Throw.ArgumentNull("baseReader");
						}
						if (baseReader.GetTableRowCount(TableIndex.EncMap) != 0)
						{
							throw new ArgumentException(MDCFR.Properties.Resources.BaseReaderMustBeFullMetadataReader, "baseReader");
						}
						CalculateBaseCounts(baseReader, out baseTableRowCounts, out baseHeapSizes);
					}
					else
					{
						if (baseTableRowCounts.Count != MetadataTokens.TableCount)
						{
							throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.ExpectedListOfSize, MetadataTokens.TableCount), "baseTableRowCounts");
						}
						if (baseHeapSizes == null)
						{
							System.Reflection.Throw.ArgumentNull("baseHeapSizes");
						}
						if (baseHeapSizes.Count != MetadataTokens.HeapCount)
						{
							throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.ExpectedListOfSize, MetadataTokens.HeapCount), "baseTableRowCounts");
						}
					}
					if (deltaReaders == null || deltaReaders.Count == 0)
					{
						throw new ArgumentException(MDCFR.Properties.Resources.ExpectedNonEmptyList, "deltaReaders");
					}
					for (int i = 0; i < deltaReaders.Count; i++)
					{
						if (deltaReaders[i].GetTableRowCount(TableIndex.EncMap) == 0 || !deltaReaders[i].IsMinimalDelta)
						{
							throw new ArgumentException(MDCFR.Properties.Resources.ReadersMustBeDeltaReaders, "deltaReaders");
						}
					}
					_heapSizes = CalculateHeapSizes(baseHeapSizes, deltaReaders);
					_rowCounts = CalculateRowCounts(baseTableRowCounts, deltaReaders);
				}

				internal MetadataAggregator(RowCounts[][] rowCounts, int[][] heapSizes)
				{
					_rowCounts = ToImmutable(rowCounts);
					_heapSizes = ToImmutable(heapSizes);
				}

				private static void CalculateBaseCounts(MetadataReader baseReader, out IReadOnlyList<int> baseTableRowCounts, out IReadOnlyList<int> baseHeapSizes)
				{
					int[] array = new int[MetadataTokens.TableCount];
					int[] array2 = new int[MetadataTokens.HeapCount];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = baseReader.GetTableRowCount((TableIndex)i);
					}
					for (int j = 0; j < array2.Length; j++)
					{
						array2[j] = baseReader.GetHeapSize((HeapIndex)j);
					}
					baseTableRowCounts = array;
					baseHeapSizes = array2;
				}

				private static System.Collections.Immutable.ImmutableArray<System.Collections.Immutable.ImmutableArray<int>> CalculateHeapSizes(IReadOnlyList<int> baseSizes, IReadOnlyList<MetadataReader> deltaReaders)
				{
					int num = 1 + deltaReaders.Count;
					int[] array = new int[num];
					int[] array2 = new int[num];
					int[] array3 = new int[num];
					int[] array4 = new int[num];
					array[0] = baseSizes[0];
					array2[0] = baseSizes[1];
					array3[0] = baseSizes[2];
					array4[0] = baseSizes[3] / 16;
					for (int i = 0; i < deltaReaders.Count; i++)
					{
						array[i + 1] = array[i] + deltaReaders[i].GetHeapSize(HeapIndex.UserString);
						array2[i + 1] = array2[i] + deltaReaders[i].GetHeapSize(HeapIndex.String);
						array3[i + 1] = array3[i] + deltaReaders[i].GetHeapSize(HeapIndex.Blob);
						array4[i + 1] = array4[i] + deltaReaders[i].GetHeapSize(HeapIndex.Guid) / 16;
					}
					return System.Collections.Immutable.ImmutableArray.Create<System.Collections.Immutable.ImmutableArray<int>>(System.Collections.Immutable.ImmutableArray.ToImmutableArray<int>((IEnumerable<int>)array), System.Collections.Immutable.ImmutableArray.ToImmutableArray<int>((IEnumerable<int>)array2), System.Collections.Immutable.ImmutableArray.ToImmutableArray<int>((IEnumerable<int>)array3), System.Collections.Immutable.ImmutableArray.ToImmutableArray<int>((IEnumerable<int>)array4));
				}

				private static System.Collections.Immutable.ImmutableArray<System.Collections.Immutable.ImmutableArray<RowCounts>> CalculateRowCounts(IReadOnlyList<int> baseRowCounts, IReadOnlyList<MetadataReader> deltaReaders)
				{
					RowCounts[][] baseRowCounts2 = GetBaseRowCounts(baseRowCounts, 1 + deltaReaders.Count);
					for (int i = 1; i <= deltaReaders.Count; i++)
					{
						CalculateDeltaRowCountsForGeneration(baseRowCounts2, i, ref deltaReaders[i - 1].EncMapTable);
					}
					return ToImmutable(baseRowCounts2);
				}

				private static System.Collections.Immutable.ImmutableArray<System.Collections.Immutable.ImmutableArray<T>> ToImmutable<T>(T[][] array)
				{
					System.Collections.Immutable.ImmutableArray<T>[] array2 = new System.Collections.Immutable.ImmutableArray<T>[array.Length];
					for (int i = 0; i < array.Length; i++)
					{
						array2[i] = System.Collections.Immutable.ImmutableArray.ToImmutableArray<T>((IEnumerable<T>)array[i]);
					}
					return System.Collections.Immutable.ImmutableArray.ToImmutableArray<System.Collections.Immutable.ImmutableArray<T>>((IEnumerable<System.Collections.Immutable.ImmutableArray<T>>)array2);
				}

				internal static RowCounts[][] GetBaseRowCounts(IReadOnlyList<int> baseRowCounts, int generations)
				{
					RowCounts[][] array = new RowCounts[MetadataTokens.TableCount][];
					for (int i = 0; i < array.Length; i++)
					{
						array[i] = new RowCounts[generations];
						array[i][0].AggregateInserts = baseRowCounts[i];
					}
					return array;
				}

				internal static void CalculateDeltaRowCountsForGeneration(RowCounts[][] rowCounts, int generation, ref EnCMapTableReader encMapTable)
				{
					foreach (RowCounts[] array in rowCounts)
					{
						array[generation].AggregateInserts = array[generation - 1].AggregateInserts;
					}
					int numberOfRows = encMapTable.NumberOfRows;
					for (int j = 1; j <= numberOfRows; j++)
					{
						uint token = encMapTable.GetToken(j);
						int num = (int)(token & 0xFFFFFF);
						RowCounts[] array2 = rowCounts[token >> 24];
						if (num > array2[generation].AggregateInserts)
						{
							if (num != array2[generation].AggregateInserts + 1)
							{
								throw new BadImageFormatException(MDCFR.Properties.Resources.EnCMapNotSorted);
							}
							array2[generation].AggregateInserts = num;
						}
						else
						{
							array2[generation].Updates++;
						}
					}
				}

				/// <summary>
				/// Given a handle of an entity in an aggregate metadata calculates
				/// a handle of the entity within the metadata generation it is defined in.
				/// </summary>
				/// <param name="handle">Handle of an entity in an aggregate metadata.</param>
				/// <param name="generation">The generation the entity is defined in.</param>
				/// <returns>Handle of the entity within the metadata generation <paramref name="generation" />.</returns>
				public Handle GetGenerationHandle(Handle handle, out int generation)
				{
					if (handle.IsVirtual)
					{
						throw new NotSupportedException();
					}
					if (handle.IsHeapHandle)
					{
						int offset = handle.Offset;
						MetadataTokens.TryGetHeapIndex(handle.Kind, out var index);
						System.Collections.Immutable.ImmutableArray<int> immutableArray = _heapSizes[(int)index];
						int num = ((handle.Type == 114) ? (offset - 1) : offset);
						generation = System.Collections.Immutable.ImmutableArray.BinarySearch<int>(immutableArray, num);
						if (generation >= 0)
						{
							do
							{
								generation++;
							}
							while (generation < immutableArray.Length && immutableArray[generation] == num);
						}
						else
						{
							generation = ~generation;
						}
						if (generation >= immutableArray.Length)
						{
							throw new ArgumentException(MDCFR.Properties.Resources.HandleBelongsToFutureGeneration, "handle");
						}
						int value = ((handle.Type == 114 || generation == 0) ? offset : (offset - immutableArray[generation - 1]));
						return new Handle((byte)handle.Type, value);
					}
					int rowId = handle.RowId;
					System.Collections.Immutable.ImmutableArray<RowCounts> immutableArray2 = _rowCounts[(int)handle.Type];
					generation = System.Collections.Immutable.ImmutableArray.BinarySearch<RowCounts>(immutableArray2, new RowCounts
					{
						AggregateInserts = rowId
					});
					if (generation >= 0)
					{
						while (generation > 0 && immutableArray2[generation - 1].AggregateInserts == rowId)
						{
							generation--;
						}
					}
					else
					{
						generation = ~generation;
						if (generation >= immutableArray2.Length)
						{
							throw new ArgumentException(MDCFR.Properties.Resources.HandleBelongsToFutureGeneration, "handle");
						}
					}
					int value2 = ((generation == 0) ? rowId : (rowId - immutableArray2[generation - 1].AggregateInserts + immutableArray2[generation].Updates));
					return new Handle((byte)handle.Type, value2);
				}
			}

			public sealed class MetadataBuilder
			{
				private struct AssemblyRefTableRow
				{
					public Version Version;

					public BlobHandle PublicKeyToken;

					public StringHandle Name;

					public StringHandle Culture;

					public uint Flags;

					public BlobHandle HashValue;
				}

				private struct ModuleRow
				{
					public ushort Generation;

					public StringHandle Name;

					public GuidHandle ModuleVersionId;

					public GuidHandle EncId;

					public GuidHandle EncBaseId;
				}

				private struct AssemblyRow
				{
					public uint HashAlgorithm;

					public Version Version;

					public ushort Flags;

					public BlobHandle AssemblyKey;

					public StringHandle AssemblyName;

					public StringHandle AssemblyCulture;
				}

				private struct ClassLayoutRow
				{
					public ushort PackingSize;

					public uint ClassSize;

					public int Parent;
				}

				private struct ConstantRow
				{
					public byte Type;

					public int Parent;

					public BlobHandle Value;
				}

				private struct CustomAttributeRow
				{
					public int Parent;

					public int Type;

					public BlobHandle Value;
				}

				private struct DeclSecurityRow
				{
					public ushort Action;

					public int Parent;

					public BlobHandle PermissionSet;
				}

				private struct EncLogRow
				{
					public int Token;

					public byte FuncCode;
				}

				private struct EncMapRow
				{
					public int Token;
				}

				private struct EventRow
				{
					public ushort EventFlags;

					public StringHandle Name;

					public int EventType;
				}

				private struct EventMapRow
				{
					public int Parent;

					public int EventList;
				}

				private struct ExportedTypeRow
				{
					public uint Flags;

					public int TypeDefId;

					public StringHandle TypeName;

					public StringHandle TypeNamespace;

					public int Implementation;
				}

				private struct FieldLayoutRow
				{
					public int Offset;

					public int Field;
				}

				private struct FieldMarshalRow
				{
					public int Parent;

					public BlobHandle NativeType;
				}

				private struct FieldRvaRow
				{
					public int Offset;

					public int Field;
				}

				private struct FieldDefRow
				{
					public ushort Flags;

					public StringHandle Name;

					public BlobHandle Signature;
				}

				private struct FileTableRow
				{
					public uint Flags;

					public StringHandle FileName;

					public BlobHandle HashValue;
				}

				private struct GenericParamConstraintRow
				{
					public int Owner;

					public int Constraint;
				}

				private struct GenericParamRow
				{
					public ushort Number;

					public ushort Flags;

					public int Owner;

					public StringHandle Name;
				}

				private struct ImplMapRow
				{
					public ushort MappingFlags;

					public int MemberForwarded;

					public StringHandle ImportName;

					public int ImportScope;
				}

				private struct InterfaceImplRow
				{
					public int Class;

					public int Interface;
				}

				private struct ManifestResourceRow
				{
					public uint Offset;

					public uint Flags;

					public StringHandle Name;

					public int Implementation;
				}

				private struct MemberRefRow
				{
					public int Class;

					public StringHandle Name;

					public BlobHandle Signature;
				}

				private struct MethodImplRow
				{
					public int Class;

					public int MethodBody;

					public int MethodDecl;
				}

				private struct MethodSemanticsRow
				{
					public ushort Semantic;

					public int Method;

					public int Association;
				}

				private struct MethodSpecRow
				{
					public int Method;

					public BlobHandle Instantiation;
				}

				private struct MethodRow
				{
					public int BodyOffset;

					public ushort ImplFlags;

					public ushort Flags;

					public StringHandle Name;

					public BlobHandle Signature;

					public int ParamList;
				}

				private struct ModuleRefRow
				{
					public StringHandle Name;
				}

				private struct NestedClassRow
				{
					public int NestedClass;

					public int EnclosingClass;
				}

				private struct ParamRow
				{
					public ushort Flags;

					public ushort Sequence;

					public StringHandle Name;
				}

				private struct PropertyMapRow
				{
					public int Parent;

					public int PropertyList;
				}

				private struct PropertyRow
				{
					public ushort PropFlags;

					public StringHandle Name;

					public BlobHandle Type;
				}

				private struct TypeDefRow
				{
					public uint Flags;

					public StringHandle Name;

					public StringHandle Namespace;

					public int Extends;

					public int FieldList;

					public int MethodList;
				}

				private struct TypeRefRow
				{
					public int ResolutionScope;

					public StringHandle Name;

					public StringHandle Namespace;
				}

				private struct TypeSpecRow
				{
					public BlobHandle Signature;
				}

				private struct StandaloneSigRow
				{
					public BlobHandle Signature;
				}

				private struct DocumentRow
				{
					public BlobHandle Name;

					public GuidHandle HashAlgorithm;

					public BlobHandle Hash;

					public GuidHandle Language;
				}

				private struct MethodDebugInformationRow
				{
					public int Document;

					public BlobHandle SequencePoints;
				}

				private struct LocalScopeRow
				{
					public int Method;

					public int ImportScope;

					public int VariableList;

					public int ConstantList;

					public int StartOffset;

					public int Length;
				}

				private struct LocalVariableRow
				{
					public ushort Attributes;

					public ushort Index;

					public StringHandle Name;
				}

				private struct LocalConstantRow
				{
					public StringHandle Name;

					public BlobHandle Signature;
				}

				private struct ImportScopeRow
				{
					public int Parent;

					public BlobHandle Imports;
				}

				private struct StateMachineMethodRow
				{
					public int MoveNextMethod;

					public int KickoffMethod;
				}

				private struct CustomDebugInformationRow
				{
					public int Parent;

					public GuidHandle Kind;

					public BlobHandle Value;
				}

				private sealed class HeapBlobBuilder : BlobBuilder
				{
					private int _capacityExpansion;

					public HeapBlobBuilder(int capacity)
						: base(capacity)
					{
					}

					protected override BlobBuilder AllocateChunk(int minimalSize)
					{
						return new HeapBlobBuilder(Math.Max(Math.Max(minimalSize, base.ChunkCapacity), _capacityExpansion));
					}

					internal void SetCapacity(int capacity)
					{
						_capacityExpansion = Math.Max(0, capacity - base.Count - base.FreeBytes);
					}
				}

				/// <summary>
				/// Sorts strings such that a string is followed immediately by all strings
				/// that are a suffix of it.
				/// </summary>
				private sealed class SuffixSort : IComparer<KeyValuePair<string, StringHandle>>
				{
					internal static SuffixSort Instance = new SuffixSort();

					public int Compare(KeyValuePair<string, StringHandle> xPair, KeyValuePair<string, StringHandle> yPair)
					{
						string key = xPair.Key;
						string key2 = yPair.Key;
						int num = key.Length - 1;
						int num2 = key2.Length - 1;
						while (num >= 0 && num2 >= 0)
						{
							if (key[num] < key2[num2])
							{
								return -1;
							}
							if (key[num] > key2[num2])
							{
								return 1;
							}
							num--;
							num2--;
						}
						return key2.Length.CompareTo(key.Length);
					}
				}

				private const byte MetadataFormatMajorVersion = 2;

				private const byte MetadataFormatMinorVersion = 0;

				private ModuleRow? _moduleRow;

				private AssemblyRow? _assemblyRow;

				private readonly List<ClassLayoutRow> _classLayoutTable = new List<ClassLayoutRow>();

				private readonly List<ConstantRow> _constantTable = new List<ConstantRow>();

				private int _constantTableLastParent;

				private bool _constantTableNeedsSorting;

				private readonly List<CustomAttributeRow> _customAttributeTable = new List<CustomAttributeRow>();

				private int _customAttributeTableLastParent;

				private bool _customAttributeTableNeedsSorting;

				private readonly List<DeclSecurityRow> _declSecurityTable = new List<DeclSecurityRow>();

				private int _declSecurityTableLastParent;

				private bool _declSecurityTableNeedsSorting;

				private readonly List<EncLogRow> _encLogTable = new List<EncLogRow>();

				private readonly List<EncMapRow> _encMapTable = new List<EncMapRow>();

				private readonly List<EventRow> _eventTable = new List<EventRow>();

				private readonly List<EventMapRow> _eventMapTable = new List<EventMapRow>();

				private readonly List<ExportedTypeRow> _exportedTypeTable = new List<ExportedTypeRow>();

				private readonly List<FieldLayoutRow> _fieldLayoutTable = new List<FieldLayoutRow>();

				private readonly List<FieldMarshalRow> _fieldMarshalTable = new List<FieldMarshalRow>();

				private int _fieldMarshalTableLastParent;

				private bool _fieldMarshalTableNeedsSorting;

				private readonly List<FieldRvaRow> _fieldRvaTable = new List<FieldRvaRow>();

				private readonly List<FieldDefRow> _fieldTable = new List<FieldDefRow>();

				private readonly List<FileTableRow> _fileTable = new List<FileTableRow>();

				private readonly List<GenericParamConstraintRow> _genericParamConstraintTable = new List<GenericParamConstraintRow>();

				private readonly List<GenericParamRow> _genericParamTable = new List<GenericParamRow>();

				private readonly List<ImplMapRow> _implMapTable = new List<ImplMapRow>();

				private readonly List<InterfaceImplRow> _interfaceImplTable = new List<InterfaceImplRow>();

				private readonly List<ManifestResourceRow> _manifestResourceTable = new List<ManifestResourceRow>();

				private readonly List<MemberRefRow> _memberRefTable = new List<MemberRefRow>();

				private readonly List<MethodImplRow> _methodImplTable = new List<MethodImplRow>();

				private readonly List<MethodSemanticsRow> _methodSemanticsTable = new List<MethodSemanticsRow>();

				private int _methodSemanticsTableLastAssociation;

				private bool _methodSemanticsTableNeedsSorting;

				private readonly List<MethodSpecRow> _methodSpecTable = new List<MethodSpecRow>();

				private readonly List<MethodRow> _methodDefTable = new List<MethodRow>();

				private readonly List<ModuleRefRow> _moduleRefTable = new List<ModuleRefRow>();

				private readonly List<NestedClassRow> _nestedClassTable = new List<NestedClassRow>();

				private readonly List<ParamRow> _paramTable = new List<ParamRow>();

				private readonly List<PropertyMapRow> _propertyMapTable = new List<PropertyMapRow>();

				private readonly List<PropertyRow> _propertyTable = new List<PropertyRow>();

				private readonly List<TypeDefRow> _typeDefTable = new List<TypeDefRow>();

				private readonly List<TypeRefRow> _typeRefTable = new List<TypeRefRow>();

				private readonly List<TypeSpecRow> _typeSpecTable = new List<TypeSpecRow>();

				private readonly List<AssemblyRefTableRow> _assemblyRefTable = new List<AssemblyRefTableRow>();

				private readonly List<StandaloneSigRow> _standAloneSigTable = new List<StandaloneSigRow>();

				private readonly List<DocumentRow> _documentTable = new List<DocumentRow>();

				private readonly List<MethodDebugInformationRow> _methodDebugInformationTable = new List<MethodDebugInformationRow>();

				private readonly List<LocalScopeRow> _localScopeTable = new List<LocalScopeRow>();

				private readonly List<LocalVariableRow> _localVariableTable = new List<LocalVariableRow>();

				private readonly List<LocalConstantRow> _localConstantTable = new List<LocalConstantRow>();

				private readonly List<ImportScopeRow> _importScopeTable = new List<ImportScopeRow>();

				private readonly List<StateMachineMethodRow> _stateMachineMethodTable = new List<StateMachineMethodRow>();

				private readonly List<CustomDebugInformationRow> _customDebugInformationTable = new List<CustomDebugInformationRow>();

				private const int UserStringHeapSizeLimit = 16777216;

				private readonly Dictionary<string, UserStringHandle> _userStrings = new Dictionary<string, UserStringHandle>(256);

				private readonly HeapBlobBuilder _userStringBuilder = new HeapBlobBuilder(4096);

				private readonly int _userStringHeapStartOffset;

				private readonly Dictionary<string, StringHandle> _strings = new Dictionary<string, StringHandle>(256);

				private readonly int _stringHeapStartOffset;

				private int _stringHeapCapacity = 4096;

				private readonly Dictionary<System.Collections.Immutable.ImmutableArray<byte>, BlobHandle> _blobs = new Dictionary<System.Collections.Immutable.ImmutableArray<byte>, BlobHandle>(1024, ByteSequenceComparer.Instance);

				private readonly int _blobHeapStartOffset;

				private int _blobHeapSize;

				private readonly Dictionary<Guid, GuidHandle> _guids = new Dictionary<Guid, GuidHandle>();

				private readonly HeapBlobBuilder _guidBuilder = new HeapBlobBuilder(16);

				internal SerializedMetadata GetSerializedMetadata(System.Collections.Immutable.ImmutableArray<int> externalRowCounts, int metadataVersionByteCount, bool isStandaloneDebugMetadata)
				{
					HeapBlobBuilder heapBlobBuilder = new HeapBlobBuilder(_stringHeapCapacity);
					System.Collections.Immutable.ImmutableArray<int> stringMap = SerializeStringHeap(heapBlobBuilder, _strings, _stringHeapStartOffset);
					System.Collections.Immutable.ImmutableArray<int> heapSizes = System.Collections.Immutable.ImmutableArray.Create<int>(_userStringBuilder.Count, heapBlobBuilder.Count, _blobHeapSize, _guidBuilder.Count);
					MetadataSizes sizes = new MetadataSizes(GetRowCounts(), externalRowCounts, heapSizes, metadataVersionByteCount, isStandaloneDebugMetadata);
					return new SerializedMetadata(sizes, heapBlobBuilder, stringMap);
				}

				internal static void SerializeMetadataHeader(BlobBuilder builder, string metadataVersion, MetadataSizes sizes)
				{
					int count = builder.Count;
					builder.WriteUInt32(1112167234u);
					builder.WriteUInt16(1);
					builder.WriteUInt16(1);
					builder.WriteUInt32(0u);
					builder.WriteInt32(sizes.MetadataVersionPaddedLength);
					int count2 = builder.Count;
					builder.WriteUTF8(metadataVersion);
					builder.WriteByte(0);
					int count3 = builder.Count;
					for (int i = 0; i < sizes.MetadataVersionPaddedLength - (count3 - count2); i++)
					{
						builder.WriteByte(0);
					}
					builder.WriteUInt16(0);
					builder.WriteUInt16((ushort)(5 + (sizes.IsEncDelta ? 1 : 0) + (sizes.IsStandaloneDebugMetadata ? 1 : 0)));
					int offsetFromStartOfMetadata = sizes.MetadataHeaderSize;
					if (sizes.IsStandaloneDebugMetadata)
					{
						SerializeStreamHeader(ref offsetFromStartOfMetadata, sizes.StandalonePdbStreamSize, "#Pdb", builder);
					}
					SerializeStreamHeader(ref offsetFromStartOfMetadata, sizes.MetadataTableStreamSize, sizes.IsCompressed ? "#~" : "#-", builder);
					SerializeStreamHeader(ref offsetFromStartOfMetadata, sizes.GetAlignedHeapSize(HeapIndex.String), "#Strings", builder);
					SerializeStreamHeader(ref offsetFromStartOfMetadata, sizes.GetAlignedHeapSize(HeapIndex.UserString), "#US", builder);
					SerializeStreamHeader(ref offsetFromStartOfMetadata, sizes.GetAlignedHeapSize(HeapIndex.Guid), "#GUID", builder);
					SerializeStreamHeader(ref offsetFromStartOfMetadata, sizes.GetAlignedHeapSize(HeapIndex.Blob), "#Blob", builder);
					if (sizes.IsEncDelta)
					{
						SerializeStreamHeader(ref offsetFromStartOfMetadata, 0, "#JTD", builder);
					}
					int count4 = builder.Count;
				}

				private static void SerializeStreamHeader(ref int offsetFromStartOfMetadata, int alignedStreamSize, string streamName, BlobBuilder builder)
				{
					int metadataStreamHeaderSize = MetadataSizes.GetMetadataStreamHeaderSize(streamName);
					builder.WriteInt32(offsetFromStartOfMetadata);
					builder.WriteInt32(alignedStreamSize);
					foreach (char c in streamName)
					{
						builder.WriteByte((byte)c);
					}
					for (uint num = (uint)(8 + streamName.Length); num < metadataStreamHeaderSize; num++)
					{
						builder.WriteByte(0);
					}
					offsetFromStartOfMetadata += alignedStreamSize;
				}

				/// <summary>
				/// Sets the capacity of the specified table.
				/// </summary>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="table" /> is not a valid table index.</exception>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="rowCount" /> is negative.</exception>
				/// <remarks>
				/// Use to reduce allocations if the approximate number of rows is known ahead of time.
				/// </remarks>
				public void SetCapacity(TableIndex table, int rowCount)
				{
					if (rowCount < 0)
					{
						System.Reflection.Throw.ArgumentOutOfRange("rowCount");
					}
					switch (table)
					{
						case TableIndex.TypeRef:
							SetTableCapacity(_typeRefTable, rowCount);
							break;
						case TableIndex.TypeDef:
							SetTableCapacity(_typeDefTable, rowCount);
							break;
						case TableIndex.Field:
							SetTableCapacity(_fieldTable, rowCount);
							break;
						case TableIndex.MethodDef:
							SetTableCapacity(_methodDefTable, rowCount);
							break;
						case TableIndex.Param:
							SetTableCapacity(_paramTable, rowCount);
							break;
						case TableIndex.InterfaceImpl:
							SetTableCapacity(_interfaceImplTable, rowCount);
							break;
						case TableIndex.MemberRef:
							SetTableCapacity(_memberRefTable, rowCount);
							break;
						case TableIndex.Constant:
							SetTableCapacity(_constantTable, rowCount);
							break;
						case TableIndex.CustomAttribute:
							SetTableCapacity(_customAttributeTable, rowCount);
							break;
						case TableIndex.FieldMarshal:
							SetTableCapacity(_fieldMarshalTable, rowCount);
							break;
						case TableIndex.DeclSecurity:
							SetTableCapacity(_declSecurityTable, rowCount);
							break;
						case TableIndex.ClassLayout:
							SetTableCapacity(_classLayoutTable, rowCount);
							break;
						case TableIndex.FieldLayout:
							SetTableCapacity(_fieldLayoutTable, rowCount);
							break;
						case TableIndex.StandAloneSig:
							SetTableCapacity(_standAloneSigTable, rowCount);
							break;
						case TableIndex.EventMap:
							SetTableCapacity(_eventMapTable, rowCount);
							break;
						case TableIndex.Event:
							SetTableCapacity(_eventTable, rowCount);
							break;
						case TableIndex.PropertyMap:
							SetTableCapacity(_propertyMapTable, rowCount);
							break;
						case TableIndex.Property:
							SetTableCapacity(_propertyTable, rowCount);
							break;
						case TableIndex.MethodSemantics:
							SetTableCapacity(_methodSemanticsTable, rowCount);
							break;
						case TableIndex.MethodImpl:
							SetTableCapacity(_methodImplTable, rowCount);
							break;
						case TableIndex.ModuleRef:
							SetTableCapacity(_moduleRefTable, rowCount);
							break;
						case TableIndex.TypeSpec:
							SetTableCapacity(_typeSpecTable, rowCount);
							break;
						case TableIndex.ImplMap:
							SetTableCapacity(_implMapTable, rowCount);
							break;
						case TableIndex.FieldRva:
							SetTableCapacity(_fieldRvaTable, rowCount);
							break;
						case TableIndex.EncLog:
							SetTableCapacity(_encLogTable, rowCount);
							break;
						case TableIndex.EncMap:
							SetTableCapacity(_encMapTable, rowCount);
							break;
						case TableIndex.AssemblyRef:
							SetTableCapacity(_assemblyRefTable, rowCount);
							break;
						case TableIndex.File:
							SetTableCapacity(_fileTable, rowCount);
							break;
						case TableIndex.ExportedType:
							SetTableCapacity(_exportedTypeTable, rowCount);
							break;
						case TableIndex.ManifestResource:
							SetTableCapacity(_manifestResourceTable, rowCount);
							break;
						case TableIndex.NestedClass:
							SetTableCapacity(_nestedClassTable, rowCount);
							break;
						case TableIndex.GenericParam:
							SetTableCapacity(_genericParamTable, rowCount);
							break;
						case TableIndex.MethodSpec:
							SetTableCapacity(_methodSpecTable, rowCount);
							break;
						case TableIndex.GenericParamConstraint:
							SetTableCapacity(_genericParamConstraintTable, rowCount);
							break;
						case TableIndex.Document:
							SetTableCapacity(_documentTable, rowCount);
							break;
						case TableIndex.MethodDebugInformation:
							SetTableCapacity(_methodDebugInformationTable, rowCount);
							break;
						case TableIndex.LocalScope:
							SetTableCapacity(_localScopeTable, rowCount);
							break;
						case TableIndex.LocalVariable:
							SetTableCapacity(_localVariableTable, rowCount);
							break;
						case TableIndex.LocalConstant:
							SetTableCapacity(_localConstantTable, rowCount);
							break;
						case TableIndex.ImportScope:
							SetTableCapacity(_importScopeTable, rowCount);
							break;
						case TableIndex.StateMachineMethod:
							SetTableCapacity(_stateMachineMethodTable, rowCount);
							break;
						case TableIndex.CustomDebugInformation:
							SetTableCapacity(_customDebugInformationTable, rowCount);
							break;
						default:
							throw new ArgumentOutOfRangeException("table");
						case TableIndex.Module:
						case TableIndex.FieldPtr:
						case TableIndex.MethodPtr:
						case TableIndex.ParamPtr:
						case TableIndex.EventPtr:
						case TableIndex.PropertyPtr:
						case TableIndex.Assembly:
						case TableIndex.AssemblyProcessor:
						case TableIndex.AssemblyOS:
						case TableIndex.AssemblyRefProcessor:
						case TableIndex.AssemblyRefOS:
							break;
					}
				}

				private static void SetTableCapacity<T>(List<T> table, int rowCount)
				{
					if (rowCount > table.Count)
					{
						table.Capacity = rowCount;
					}
				}

				/// <summary>
				/// Returns the current number of entires in the specified table.
				/// </summary>
				/// <param name="table">Table index.</param>
				/// <returns>The number of entires in the table.</returns>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="table" /> is not a valid table index.</exception>
				public int GetRowCount(TableIndex table)
				{
					switch (table)
					{
						case TableIndex.Assembly:
							if (!_assemblyRow.HasValue)
							{
								return 0;
							}
							return 1;
						case TableIndex.AssemblyRef:
							return _assemblyRefTable.Count;
						case TableIndex.ClassLayout:
							return _classLayoutTable.Count;
						case TableIndex.Constant:
							return _constantTable.Count;
						case TableIndex.CustomAttribute:
							return _customAttributeTable.Count;
						case TableIndex.DeclSecurity:
							return _declSecurityTable.Count;
						case TableIndex.EncLog:
							return _encLogTable.Count;
						case TableIndex.EncMap:
							return _encMapTable.Count;
						case TableIndex.EventMap:
							return _eventMapTable.Count;
						case TableIndex.Event:
							return _eventTable.Count;
						case TableIndex.ExportedType:
							return _exportedTypeTable.Count;
						case TableIndex.FieldLayout:
							return _fieldLayoutTable.Count;
						case TableIndex.FieldMarshal:
							return _fieldMarshalTable.Count;
						case TableIndex.FieldRva:
							return _fieldRvaTable.Count;
						case TableIndex.Field:
							return _fieldTable.Count;
						case TableIndex.File:
							return _fileTable.Count;
						case TableIndex.GenericParamConstraint:
							return _genericParamConstraintTable.Count;
						case TableIndex.GenericParam:
							return _genericParamTable.Count;
						case TableIndex.ImplMap:
							return _implMapTable.Count;
						case TableIndex.InterfaceImpl:
							return _interfaceImplTable.Count;
						case TableIndex.ManifestResource:
							return _manifestResourceTable.Count;
						case TableIndex.MemberRef:
							return _memberRefTable.Count;
						case TableIndex.MethodImpl:
							return _methodImplTable.Count;
						case TableIndex.MethodSemantics:
							return _methodSemanticsTable.Count;
						case TableIndex.MethodSpec:
							return _methodSpecTable.Count;
						case TableIndex.MethodDef:
							return _methodDefTable.Count;
						case TableIndex.ModuleRef:
							return _moduleRefTable.Count;
						case TableIndex.Module:
							if (!_moduleRow.HasValue)
							{
								return 0;
							}
							return 1;
						case TableIndex.NestedClass:
							return _nestedClassTable.Count;
						case TableIndex.Param:
							return _paramTable.Count;
						case TableIndex.PropertyMap:
							return _propertyMapTable.Count;
						case TableIndex.Property:
							return _propertyTable.Count;
						case TableIndex.StandAloneSig:
							return _standAloneSigTable.Count;
						case TableIndex.TypeDef:
							return _typeDefTable.Count;
						case TableIndex.TypeRef:
							return _typeRefTable.Count;
						case TableIndex.TypeSpec:
							return _typeSpecTable.Count;
						case TableIndex.Document:
							return _documentTable.Count;
						case TableIndex.MethodDebugInformation:
							return _methodDebugInformationTable.Count;
						case TableIndex.LocalScope:
							return _localScopeTable.Count;
						case TableIndex.LocalVariable:
							return _localVariableTable.Count;
						case TableIndex.LocalConstant:
							return _localConstantTable.Count;
						case TableIndex.StateMachineMethod:
							return _stateMachineMethodTable.Count;
						case TableIndex.ImportScope:
							return _importScopeTable.Count;
						case TableIndex.CustomDebugInformation:
							return _customDebugInformationTable.Count;
						case TableIndex.FieldPtr:
						case TableIndex.MethodPtr:
						case TableIndex.ParamPtr:
						case TableIndex.EventPtr:
						case TableIndex.PropertyPtr:
						case TableIndex.AssemblyProcessor:
						case TableIndex.AssemblyOS:
						case TableIndex.AssemblyRefProcessor:
						case TableIndex.AssemblyRefOS:
							return 0;
						default:
							throw new ArgumentOutOfRangeException("table");
					}
				}

				/// <summary>
				/// Returns the current number of entires in each table.
				/// </summary>
				/// <returns>
				/// An array of size <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" /> with each item filled with the current row count of the corresponding table.
				/// </returns>
				public System.Collections.Immutable.ImmutableArray<int> GetRowCounts()
				{
					System.Collections.Immutable.ImmutableArray<int>.Builder builder = System.Collections.Immutable.ImmutableArray.CreateBuilder<int>(MetadataTokens.TableCount);
					builder.Count = MetadataTokens.TableCount;
					builder[32] = (_assemblyRow.HasValue ? 1 : 0);
					builder[35] = _assemblyRefTable.Count;
					builder[15] = _classLayoutTable.Count;
					builder[11] = _constantTable.Count;
					builder[12] = _customAttributeTable.Count;
					builder[14] = _declSecurityTable.Count;
					builder[30] = _encLogTable.Count;
					builder[31] = _encMapTable.Count;
					builder[18] = _eventMapTable.Count;
					builder[20] = _eventTable.Count;
					builder[39] = _exportedTypeTable.Count;
					builder[16] = _fieldLayoutTable.Count;
					builder[13] = _fieldMarshalTable.Count;
					builder[29] = _fieldRvaTable.Count;
					builder[4] = _fieldTable.Count;
					builder[38] = _fileTable.Count;
					builder[44] = _genericParamConstraintTable.Count;
					builder[42] = _genericParamTable.Count;
					builder[28] = _implMapTable.Count;
					builder[9] = _interfaceImplTable.Count;
					builder[40] = _manifestResourceTable.Count;
					builder[10] = _memberRefTable.Count;
					builder[25] = _methodImplTable.Count;
					builder[24] = _methodSemanticsTable.Count;
					builder[43] = _methodSpecTable.Count;
					builder[6] = _methodDefTable.Count;
					builder[26] = _moduleRefTable.Count;
					builder[0] = (_moduleRow.HasValue ? 1 : 0);
					builder[41] = _nestedClassTable.Count;
					builder[8] = _paramTable.Count;
					builder[21] = _propertyMapTable.Count;
					builder[23] = _propertyTable.Count;
					builder[17] = _standAloneSigTable.Count;
					builder[2] = _typeDefTable.Count;
					builder[1] = _typeRefTable.Count;
					builder[27] = _typeSpecTable.Count;
					builder[48] = _documentTable.Count;
					builder[49] = _methodDebugInformationTable.Count;
					builder[50] = _localScopeTable.Count;
					builder[51] = _localVariableTable.Count;
					builder[52] = _localConstantTable.Count;
					builder[54] = _stateMachineMethodTable.Count;
					builder[53] = _importScopeTable.Count;
					builder[55] = _customDebugInformationTable.Count;
					return builder.MoveToImmutable();
				}

				public ModuleDefinitionHandle AddModule(int generation, StringHandle moduleName, GuidHandle mvid, GuidHandle encId, GuidHandle encBaseId)
				{
					if ((uint)generation > 65535u)
					{
						System.Reflection.Throw.ArgumentOutOfRange("generation");
					}
					if (_moduleRow.HasValue)
					{
						System.Reflection.Throw.InvalidOperation(MDCFR.Properties.Resources.ModuleAlreadyAdded);
					}
					_moduleRow = new ModuleRow
					{
						Generation = (ushort)generation,
						Name = moduleName,
						ModuleVersionId = mvid,
						EncId = encId,
						EncBaseId = encBaseId
					};
					return EntityHandle.ModuleDefinition;
				}

				public AssemblyDefinitionHandle AddAssembly(StringHandle name, Version version, StringHandle culture, BlobHandle publicKey, AssemblyFlags flags, AssemblyHashAlgorithm hashAlgorithm)
				{
					if ((object)version == null)
					{
						System.Reflection.Throw.ArgumentNull("version");
					}
					if (_assemblyRow.HasValue)
					{
						System.Reflection.Throw.InvalidOperation(MDCFR.Properties.Resources.AssemblyAlreadyAdded);
					}
					_assemblyRow = new AssemblyRow
					{
						Flags = (ushort)flags,
						HashAlgorithm = (uint)hashAlgorithm,
						Version = version,
						AssemblyKey = publicKey,
						AssemblyName = name,
						AssemblyCulture = culture
					};
					return EntityHandle.AssemblyDefinition;
				}

				public AssemblyReferenceHandle AddAssemblyReference(StringHandle name, Version version, StringHandle culture, BlobHandle publicKeyOrToken, AssemblyFlags flags, BlobHandle hashValue)
				{
					if ((object)version == null)
					{
						System.Reflection.Throw.ArgumentNull("version");
					}
					_assemblyRefTable.Add(new AssemblyRefTableRow
					{
						Name = name,
						Version = version,
						Culture = culture,
						PublicKeyToken = publicKeyOrToken,
						Flags = (uint)flags,
						HashValue = hashValue
					});
					return AssemblyReferenceHandle.FromRowId(_assemblyRefTable.Count);
				}

				/// <summary>
				/// Adds a type definition.
				/// </summary>
				/// <param name="attributes">Attributes</param>
				/// <param name="namespace">Namespace</param>
				/// <param name="name">Type name</param>
				/// <param name="baseType"><see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> or nil.</param>
				/// <param name="fieldList">
				/// If the type declares fields the handle of the first one, otherwise the handle of the first field declared by the next type definition.
				/// If no type defines any fields in the module, <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.FieldDefinitionHandle(System.Int32)" />(1).
				/// </param>
				/// <param name="methodList">
				/// If the type declares methods the handle of the first one, otherwise the handle of the first method declared by the next type definition.
				/// If no type defines any methods in the module, <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.MethodDefinitionHandle(System.Int32)" />(1).
				/// </param>
				/// <exception cref="T:System.ArgumentException"><paramref name="baseType" /> doesn't have the expected handle kind.</exception>
				public TypeDefinitionHandle AddTypeDefinition(TypeAttributes attributes, StringHandle @namespace, StringHandle name, EntityHandle baseType, FieldDefinitionHandle fieldList, MethodDefinitionHandle methodList)
				{
					_typeDefTable.Add(new TypeDefRow
					{
						Flags = (uint)attributes,
						Name = name,
						Namespace = @namespace,
						Extends = ((!baseType.IsNil) ? CodedIndex.TypeDefOrRefOrSpec(baseType) : 0),
						FieldList = fieldList.RowId,
						MethodList = methodList.RowId
					});
					return TypeDefinitionHandle.FromRowId(_typeDefTable.Count);
				}

				/// <summary>
				/// Defines a type layout of a type definition.
				/// </summary>
				/// <param name="type">Type definition.</param>
				/// <param name="packingSize">
				/// Specifies that fields should be placed within the type instance at byte addresses which are a multiple of the value,
				/// or at natural alignment for that field type, whichever is smaller. Shall be one of the following: 0, 1, 2, 4, 8, 16, 32, 64, or 128.
				/// A value of zero indicates that the packing size used should match the default for the current platform.
				/// </param>
				/// <param name="size">
				/// Indicates a minimum size of the type instance, and is intended to allow for padding.
				/// The amount of memory allocated is the maximum of the size calculated from the layout and <paramref name="size" />.
				/// Note that if this directive applies to a value type, then the size shall be less than 1 MB.
				/// </param>
				/// <remarks>
				/// Entires must be added in the same order as the corresponding type definitions.
				/// </remarks>
				public void AddTypeLayout(TypeDefinitionHandle type, ushort packingSize, uint size)
				{
					_classLayoutTable.Add(new ClassLayoutRow
					{
						Parent = type.RowId,
						PackingSize = packingSize,
						ClassSize = size
					});
				}

				/// <summary>
				/// Adds an interface implementation to a type.
				/// </summary>
				/// <param name="type">The type implementing the interface.</param>
				/// <param name="implementedInterface">
				/// The interface being implemented:
				/// <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> or <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.
				/// </param>
				/// <remarks>
				/// Interface implementations must be added in the same order as the corresponding type definitions implementing the interface.
				/// If a type implements multiple interfaces the corresponding entries must be added in the order determined by their coded indices (<see cref="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeDefOrRefOrSpec(System.Reflection.Metadata.EntityHandle)" />).
				/// </remarks>
				/// <exception cref="T:System.ArgumentException"><paramref name="implementedInterface" /> doesn't have the expected handle kind.</exception>
				public InterfaceImplementationHandle AddInterfaceImplementation(TypeDefinitionHandle type, EntityHandle implementedInterface)
				{
					_interfaceImplTable.Add(new InterfaceImplRow
					{
						Class = type.RowId,
						Interface = CodedIndex.TypeDefOrRefOrSpec(implementedInterface)
					});
					return InterfaceImplementationHandle.FromRowId(_interfaceImplTable.Count);
				}

				/// <summary>
				/// Defines a nesting relationship to specified type definitions.
				/// </summary>
				/// <param name="type">The nested type definition handle.</param>
				/// <param name="enclosingType">The enclosing type definition handle.</param>
				/// <remarks>
				/// Entries must be added in the same order as the corresponding nested type definitions.
				/// </remarks>
				public void AddNestedType(TypeDefinitionHandle type, TypeDefinitionHandle enclosingType)
				{
					_nestedClassTable.Add(new NestedClassRow
					{
						NestedClass = type.RowId,
						EnclosingClass = enclosingType.RowId
					});
				}

				/// <summary>
				/// Add a type reference.
				/// </summary>
				/// <param name="resolutionScope">
				/// The entity declaring the target type:
				/// <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, or nil.
				/// </param>
				/// <param name="namespace">Namespace.</param>
				/// <param name="name">Type name.</param>
				/// <exception cref="T:System.ArgumentException"><paramref name="resolutionScope" /> doesn't have the expected handle kind.</exception>
				public TypeReferenceHandle AddTypeReference(EntityHandle resolutionScope, StringHandle @namespace, StringHandle name)
				{
					_typeRefTable.Add(new TypeRefRow
					{
						ResolutionScope = ((!resolutionScope.IsNil) ? CodedIndex.ResolutionScope(resolutionScope) : 0),
						Name = name,
						Namespace = @namespace
					});
					return TypeReferenceHandle.FromRowId(_typeRefTable.Count);
				}

				public TypeSpecificationHandle AddTypeSpecification(BlobHandle signature)
				{
					_typeSpecTable.Add(new TypeSpecRow
					{
						Signature = signature
					});
					return TypeSpecificationHandle.FromRowId(_typeSpecTable.Count);
				}

				public StandaloneSignatureHandle AddStandaloneSignature(BlobHandle signature)
				{
					_standAloneSigTable.Add(new StandaloneSigRow
					{
						Signature = signature
					});
					return StandaloneSignatureHandle.FromRowId(_standAloneSigTable.Count);
				}

				/// <summary>
				/// Adds a property definition.
				/// </summary>
				/// <param name="attributes">Attributes</param>
				/// <param name="name">Name</param>
				/// <param name="signature">Signature of the property.</param>
				public PropertyDefinitionHandle AddProperty(PropertyAttributes attributes, StringHandle name, BlobHandle signature)
				{
					_propertyTable.Add(new PropertyRow
					{
						PropFlags = (ushort)attributes,
						Name = name,
						Type = signature
					});
					return PropertyDefinitionHandle.FromRowId(_propertyTable.Count);
				}

				public void AddPropertyMap(TypeDefinitionHandle declaringType, PropertyDefinitionHandle propertyList)
				{
					_propertyMapTable.Add(new PropertyMapRow
					{
						Parent = declaringType.RowId,
						PropertyList = propertyList.RowId
					});
				}

				/// <summary>
				/// Adds an event definition.
				/// </summary>
				/// <param name="attributes">Attributes</param>
				/// <param name="name">Name</param>
				/// <param name="type">Type of the event: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />, or <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /></param>
				/// <exception cref="T:System.ArgumentException"><paramref name="type" /> doesn't have the expected handle kind.</exception>
				public EventDefinitionHandle AddEvent(EventAttributes attributes, StringHandle name, EntityHandle type)
				{
					_eventTable.Add(new EventRow
					{
						EventFlags = (ushort)attributes,
						Name = name,
						EventType = CodedIndex.TypeDefOrRefOrSpec(type)
					});
					return EventDefinitionHandle.FromRowId(_eventTable.Count);
				}

				public void AddEventMap(TypeDefinitionHandle declaringType, EventDefinitionHandle eventList)
				{
					_eventMapTable.Add(new EventMapRow
					{
						Parent = declaringType.RowId,
						EventList = eventList.RowId
					});
				}

				/// <summary>
				/// Adds a default value for a parameter, field or property.
				/// </summary>
				/// <param name="parent"><see cref="T:System.Reflection.Metadata.ParameterHandle" />, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />, or <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" /></param>
				/// <param name="value">The constant value.</param>
				/// <remarks>
				/// Entries may be added in any order. The table is automatically sorted when serialized.
				/// </remarks>
				/// <exception cref="T:System.ArgumentException"><paramref name="parent" /> doesn't have the expected handle kind.</exception>
				public ConstantHandle AddConstant(EntityHandle parent, object? value)
				{
					int num = CodedIndex.HasConstant(parent);
					_constantTableNeedsSorting |= num < _constantTableLastParent;
					_constantTableLastParent = num;
					_constantTable.Add(new ConstantRow
					{
						Type = (byte)MetadataWriterUtilities.GetConstantTypeCode(value),
						Parent = num,
						Value = GetOrAddConstantBlob(value)
					});
					return ConstantHandle.FromRowId(_constantTable.Count);
				}

				/// <summary>
				/// Associates a method (a getter, a setter, an adder, etc.) with a property or an event.
				/// </summary>
				/// <param name="association"><see cref="T:System.Reflection.Metadata.EventDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />.</param>
				/// <param name="semantics">Semantics.</param>
				/// <param name="methodDefinition">Method definition.</param>
				/// <exception cref="T:System.ArgumentException"><paramref name="association" /> doesn't have the expected handle kind.</exception>
				/// <remarks>
				/// Entries may be added in any order. The table is automatically sorted when serialized.
				/// </remarks>
				public void AddMethodSemantics(EntityHandle association, MethodSemanticsAttributes semantics, MethodDefinitionHandle methodDefinition)
				{
					int num = CodedIndex.HasSemantics(association);
					_methodSemanticsTableNeedsSorting |= num < _methodSemanticsTableLastAssociation;
					_methodSemanticsTableLastAssociation = num;
					_methodSemanticsTable.Add(new MethodSemanticsRow
					{
						Association = num,
						Method = methodDefinition.RowId,
						Semantic = (ushort)semantics
					});
				}

				/// <summary>
				/// Add a custom attribute.
				/// </summary>
				/// <param name="parent">
				/// An entity to attach the custom attribute to:
				/// <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ParameterHandle" />,
				/// <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />,
				/// <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />,
				/// <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />,
				/// <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />,
				/// <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" /> or
				/// <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />.
				/// </param>
				/// <param name="constructor">
				/// Custom attribute constructor: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />
				/// </param>
				/// <param name="value">
				/// Custom attribute value blob.
				/// </param>
				/// <remarks>
				/// Entries may be added in any order. The table is automatically sorted when serialized.
				/// </remarks>
				/// <exception cref="T:System.ArgumentException"><paramref name="parent" /> doesn't have the expected handle kind.</exception>
				public CustomAttributeHandle AddCustomAttribute(EntityHandle parent, EntityHandle constructor, BlobHandle value)
				{
					int num = CodedIndex.HasCustomAttribute(parent);
					_customAttributeTableNeedsSorting |= num < _customAttributeTableLastParent;
					_customAttributeTableLastParent = num;
					_customAttributeTable.Add(new CustomAttributeRow
					{
						Parent = num,
						Type = CodedIndex.CustomAttributeType(constructor),
						Value = value
					});
					return CustomAttributeHandle.FromRowId(_customAttributeTable.Count);
				}

				/// <summary>
				/// Adds a method specification (instantiation).
				/// </summary>
				/// <param name="method">Generic method: <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /></param>
				/// <param name="instantiation">Instantiation blob encoding the generic arguments of the method.</param>
				/// <exception cref="T:System.ArgumentException"><paramref name="method" /> doesn't have the expected handle kind.</exception>
				public MethodSpecificationHandle AddMethodSpecification(EntityHandle method, BlobHandle instantiation)
				{
					_methodSpecTable.Add(new MethodSpecRow
					{
						Method = CodedIndex.MethodDefOrRef(method),
						Instantiation = instantiation
					});
					return MethodSpecificationHandle.FromRowId(_methodSpecTable.Count);
				}

				public ModuleReferenceHandle AddModuleReference(StringHandle moduleName)
				{
					_moduleRefTable.Add(new ModuleRefRow
					{
						Name = moduleName
					});
					return ModuleReferenceHandle.FromRowId(_moduleRefTable.Count);
				}

				/// <summary>
				/// Adds a parameter definition.
				/// </summary>
				/// <param name="attributes"><see cref="T:System.Reflection.ParameterAttributes" /></param>
				/// <param name="name">Parameter name (optional).</param>
				/// <param name="sequenceNumber">Sequence number of the parameter. Value of 0 refers to the owner method's return type; its parameters are then numbered from 1 onwards.</param>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="sequenceNumber" /> is greater than <see cref="F:System.UInt16.MaxValue" />.</exception>
				public ParameterHandle AddParameter(ParameterAttributes attributes, StringHandle name, int sequenceNumber)
				{
					if ((uint)sequenceNumber > 65535u)
					{
						System.Reflection.Throw.ArgumentOutOfRange("sequenceNumber");
					}
					_paramTable.Add(new ParamRow
					{
						Flags = (ushort)attributes,
						Name = name,
						Sequence = (ushort)sequenceNumber
					});
					return ParameterHandle.FromRowId(_paramTable.Count);
				}

				/// <summary>
				/// Adds a generic parameter definition.
				/// </summary>
				/// <param name="parent">Parent entity handle: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /></param>
				/// <param name="attributes">Attributes.</param>
				/// <param name="name">Parameter name.</param>
				/// <param name="index">Zero-based parameter index.</param>
				/// <remarks>
				/// Generic parameters must be added in an order determined by the coded index of their parent entity (<see cref="M:System.Reflection.Metadata.Ecma335.CodedIndex.TypeOrMethodDef(System.Reflection.Metadata.EntityHandle)" />).
				/// Generic parameters with the same parent must be ordered by their <paramref name="index" />.
				/// </remarks>
				/// <exception cref="T:System.ArgumentException"><paramref name="parent" /> doesn't have the expected handle kind.</exception>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is greater than <see cref="F:System.UInt16.MaxValue" />.</exception>
				public GenericParameterHandle AddGenericParameter(EntityHandle parent, GenericParameterAttributes attributes, StringHandle name, int index)
				{
					if ((uint)index > 65535u)
					{
						System.Reflection.Throw.ArgumentOutOfRange("index");
					}
					_genericParamTable.Add(new GenericParamRow
					{
						Flags = (ushort)attributes,
						Name = name,
						Number = (ushort)index,
						Owner = CodedIndex.TypeOrMethodDef(parent)
					});
					return GenericParameterHandle.FromRowId(_genericParamTable.Count);
				}

				/// <summary>
				/// Adds a type constraint to a generic parameter.
				/// </summary>
				/// <param name="genericParameter">Generic parameter to constrain.</param>
				/// <param name="constraint">Type constraint: <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" /> or <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /></param>
				/// <exception cref="T:System.ArgumentException"><paramref name="genericParameter" /> doesn't have the expected handle kind.</exception>
				/// <remarks>
				/// Constraints must be added in the same order as the corresponding generic parameters.
				/// </remarks>
				public GenericParameterConstraintHandle AddGenericParameterConstraint(GenericParameterHandle genericParameter, EntityHandle constraint)
				{
					_genericParamConstraintTable.Add(new GenericParamConstraintRow
					{
						Owner = genericParameter.RowId,
						Constraint = CodedIndex.TypeDefOrRefOrSpec(constraint)
					});
					return GenericParameterConstraintHandle.FromRowId(_genericParamConstraintTable.Count);
				}

				/// <summary>
				/// Adds a field definition.
				/// </summary>
				/// <param name="attributes">Field attributes.</param>
				/// <param name="name">Field name.</param>
				/// <param name="signature">Field signature. Use <see cref="M:System.Reflection.Metadata.Ecma335.BlobEncoder.FieldSignature" /> to construct the blob.</param>
				public FieldDefinitionHandle AddFieldDefinition(FieldAttributes attributes, StringHandle name, BlobHandle signature)
				{
					_fieldTable.Add(new FieldDefRow
					{
						Flags = (ushort)attributes,
						Name = name,
						Signature = signature
					});
					return FieldDefinitionHandle.FromRowId(_fieldTable.Count);
				}

				/// <summary>
				/// Defines a field layout of a field definition.
				/// </summary>
				/// <param name="field">Field definition.</param>
				/// <param name="offset">The byte offset of the field within the declaring type instance.</param>
				/// <remarks>
				/// Entires must be added in the same order as the corresponding field definitions.
				/// </remarks>
				public void AddFieldLayout(FieldDefinitionHandle field, int offset)
				{
					_fieldLayoutTable.Add(new FieldLayoutRow
					{
						Field = field.RowId,
						Offset = offset
					});
				}

				/// <summary>
				/// Add marshalling information to a field or a parameter.
				/// </summary>
				/// <param name="parent"><see cref="T:System.Reflection.Metadata.ParameterHandle" /> or <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />.</param>
				/// <param name="descriptor">Descriptor blob.</param>
				/// <exception cref="T:System.ArgumentException"><paramref name="parent" /> doesn't have the expected handle kind.</exception>
				/// <remarks>
				/// Entries may be added in any order. The table is automatically sorted when serialized.
				/// </remarks>
				public void AddMarshallingDescriptor(EntityHandle parent, BlobHandle descriptor)
				{
					int num = CodedIndex.HasFieldMarshal(parent);
					_fieldMarshalTableNeedsSorting |= num < _fieldMarshalTableLastParent;
					_fieldMarshalTableLastParent = num;
					_fieldMarshalTable.Add(new FieldMarshalRow
					{
						Parent = num,
						NativeType = descriptor
					});
				}

				/// <summary>
				/// Adds a mapping from a field to its initial value stored in the PE image.
				/// </summary>
				/// <param name="field">Field definition handle.</param>
				/// <param name="offset">
				/// Offset within the block in the PE image that stores initial values of mapped fields (usually in .text section).
				/// The final relative virtual address stored in the metadata is calculated when the metadata is serialized
				/// by adding the offset to the virtual address of the block start.
				/// </param>
				/// <remarks>
				/// Entires must be added in the same order as the corresponding field definitions.
				/// </remarks>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> is negative.</exception>
				public void AddFieldRelativeVirtualAddress(FieldDefinitionHandle field, int offset)
				{
					if (offset < 0)
					{
						System.Reflection.Throw.ArgumentOutOfRange("offset");
					}
					_fieldRvaTable.Add(new FieldRvaRow
					{
						Field = field.RowId,
						Offset = offset
					});
				}

				/// <summary>
				/// Adds a method definition.
				/// </summary>
				/// <param name="attributes"><see cref="T:System.Reflection.MethodAttributes" /></param>
				/// <param name="implAttributes"><see cref="T:System.Reflection.MethodImplAttributes" /></param>
				/// <param name="name">Method name/</param>
				/// <param name="signature">Method signature.</param>
				/// <param name="bodyOffset">
				/// Offset within the block in the PE image that stores method bodies (IL stream),
				/// or -1 if the method doesn't have a body.
				///
				/// The final relative virtual address stored in the metadata is calculated when the metadata is serialized
				/// by adding the offset to the virtual address of the beginning of the block.
				/// </param>
				/// <param name="parameterList">
				/// If the method declares parameters in Params table the handle of the first one, otherwise the handle of the first parameter declared by the next method definition.
				/// If no parameters are declared in the module, <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.ParameterHandle(System.Int32)" />(1).
				/// </param>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="bodyOffset" /> is less than -1.</exception>
				public MethodDefinitionHandle AddMethodDefinition(MethodAttributes attributes, MethodImplAttributes implAttributes, StringHandle name, BlobHandle signature, int bodyOffset, ParameterHandle parameterList)
				{
					if (bodyOffset < -1)
					{
						System.Reflection.Throw.ArgumentOutOfRange("bodyOffset");
					}
					_methodDefTable.Add(new MethodRow
					{
						Flags = (ushort)attributes,
						ImplFlags = (ushort)implAttributes,
						Name = name,
						Signature = signature,
						BodyOffset = bodyOffset,
						ParamList = parameterList.RowId
					});
					return MethodDefinitionHandle.FromRowId(_methodDefTable.Count);
				}

				/// <summary>
				/// Adds import information to a method definition (P/Invoke).
				/// </summary>
				/// <param name="method">Method definition handle.</param>
				/// <param name="attributes">Attributes.</param>
				/// <param name="name">Unmanaged method name.</param>
				/// <param name="module">Module containing the unmanaged method.</param>
				/// <remarks>
				/// Method imports must be added in the same order as the corresponding method definitions.
				/// </remarks>
				public void AddMethodImport(MethodDefinitionHandle method, MethodImportAttributes attributes, StringHandle name, ModuleReferenceHandle module)
				{
					_implMapTable.Add(new ImplMapRow
					{
						MemberForwarded = CodedIndex.MemberForwarded(method),
						ImportName = name,
						ImportScope = module.RowId,
						MappingFlags = (ushort)attributes
					});
				}

				/// <summary>
				/// Defines an implementation for a method declaration within a type.
				/// </summary>
				/// <param name="type">Type</param>
				/// <param name="methodBody"><see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /> which provides the implementation.</param>
				/// <param name="methodDeclaration"><see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" /> the method being implemented.</param>
				/// <remarks>
				/// Method implementations must be added in the same order as the corresponding type definitions.
				/// </remarks>
				/// <exception cref="T:System.ArgumentException"><paramref name="methodBody" /> or <paramref name="methodDeclaration" /> doesn't have the expected handle kind.</exception>
				public MethodImplementationHandle AddMethodImplementation(TypeDefinitionHandle type, EntityHandle methodBody, EntityHandle methodDeclaration)
				{
					_methodImplTable.Add(new MethodImplRow
					{
						Class = type.RowId,
						MethodBody = CodedIndex.MethodDefOrRef(methodBody),
						MethodDecl = CodedIndex.MethodDefOrRef(methodDeclaration)
					});
					return MethodImplementationHandle.FromRowId(_methodImplTable.Count);
				}

				/// <summary>
				/// Adds a MemberRef table row.
				/// </summary>
				/// <param name="parent">Containing entity:
				/// <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, or
				/// <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />.
				/// </param>
				/// <param name="name">Member name.</param>
				/// <param name="signature">Member signature.</param>
				/// <exception cref="T:System.ArgumentException"><paramref name="parent" /> doesn't have the expected handle kind.</exception>
				public MemberReferenceHandle AddMemberReference(EntityHandle parent, StringHandle name, BlobHandle signature)
				{
					_memberRefTable.Add(new MemberRefRow
					{
						Class = CodedIndex.MemberRefParent(parent),
						Name = name,
						Signature = signature
					});
					return MemberReferenceHandle.FromRowId(_memberRefTable.Count);
				}

				/// <summary>
				/// Adds a manifest resource.
				/// </summary>
				/// <param name="attributes">Attributes</param>
				/// <param name="name">Resource name</param>
				/// <param name="implementation"><see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />, or nil</param>
				/// <param name="offset">Specifies the byte offset within the referenced file at which this resource record begins.</param>
				/// <exception cref="T:System.ArgumentException"><paramref name="implementation" /> doesn't have the expected handle kind.</exception>
				public ManifestResourceHandle AddManifestResource(ManifestResourceAttributes attributes, StringHandle name, EntityHandle implementation, uint offset)
				{
					_manifestResourceTable.Add(new ManifestResourceRow
					{
						Flags = (uint)attributes,
						Name = name,
						Implementation = ((!implementation.IsNil) ? CodedIndex.Implementation(implementation) : 0),
						Offset = offset
					});
					return ManifestResourceHandle.FromRowId(_manifestResourceTable.Count);
				}

				public AssemblyFileHandle AddAssemblyFile(StringHandle name, BlobHandle hashValue, bool containsMetadata)
				{
					_fileTable.Add(new FileTableRow
					{
						FileName = name,
						Flags = ((!containsMetadata) ? 1u : 0u),
						HashValue = hashValue
					});
					return AssemblyFileHandle.FromRowId(_fileTable.Count);
				}

				/// <summary>
				/// Adds an exported type.
				/// </summary>
				/// <param name="attributes">Attributes</param>
				/// <param name="namespace">Namespace</param>
				/// <param name="name">Type name</param>
				/// <param name="implementation"><see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />, <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" /> or <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" /></param>
				/// <param name="typeDefinitionId">Type definition id</param>
				/// <exception cref="T:System.ArgumentException"><paramref name="implementation" /> doesn't have the expected handle kind.</exception>
				public ExportedTypeHandle AddExportedType(TypeAttributes attributes, StringHandle @namespace, StringHandle name, EntityHandle implementation, int typeDefinitionId)
				{
					_exportedTypeTable.Add(new ExportedTypeRow
					{
						Flags = (uint)attributes,
						Implementation = CodedIndex.Implementation(implementation),
						TypeNamespace = @namespace,
						TypeName = name,
						TypeDefId = typeDefinitionId
					});
					return ExportedTypeHandle.FromRowId(_exportedTypeTable.Count);
				}

				/// <summary>
				/// Adds declarative security attribute to a type, method or an assembly.
				/// </summary>
				/// <param name="parent"><see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />, or <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" /></param>
				/// <param name="action">Security action</param>
				/// <param name="permissionSet">Permission set blob.</param>
				/// <exception cref="T:System.ArgumentException"><paramref name="parent" /> doesn't have the expected handle kind.</exception>
				/// <remarks>
				/// Entries may be added in any order. The table is automatically sorted when serialized.
				/// </remarks>
				public DeclarativeSecurityAttributeHandle AddDeclarativeSecurityAttribute(EntityHandle parent, DeclarativeSecurityAction action, BlobHandle permissionSet)
				{
					int num = CodedIndex.HasDeclSecurity(parent);
					_declSecurityTableNeedsSorting |= num < _declSecurityTableLastParent;
					_declSecurityTableLastParent = num;
					_declSecurityTable.Add(new DeclSecurityRow
					{
						Parent = num,
						Action = (ushort)action,
						PermissionSet = permissionSet
					});
					return DeclarativeSecurityAttributeHandle.FromRowId(_declSecurityTable.Count);
				}

				public void AddEncLogEntry(EntityHandle entity, EditAndContinueOperation code)
				{
					_encLogTable.Add(new EncLogRow
					{
						Token = entity.Token,
						FuncCode = (byte)code
					});
				}

				public void AddEncMapEntry(EntityHandle entity)
				{
					_encMapTable.Add(new EncMapRow
					{
						Token = entity.Token
					});
				}

				/// <summary>
				/// Add document debug information.
				/// </summary>
				/// <param name="name">
				/// Document Name blob.
				/// </param>
				/// <param name="hashAlgorithm">
				/// GUID of the hash algorithm used to calculate the value of <paramref name="hash" />.
				/// </param>
				/// <param name="hash">
				/// The hash of the document content.
				/// </param>
				/// <param name="language">
				/// GUID of the language.
				/// </param>
				/// See https://github.com/dotnet/runtime/blob/main/src/libraries/System.Reflection.Metadata/specs/PortablePdb-Metadata.md
				public DocumentHandle AddDocument(BlobHandle name, GuidHandle hashAlgorithm, BlobHandle hash, GuidHandle language)
				{
					_documentTable.Add(new DocumentRow
					{
						Name = name,
						HashAlgorithm = hashAlgorithm,
						Hash = hash,
						Language = language
					});
					return DocumentHandle.FromRowId(_documentTable.Count);
				}

				/// <summary>
				/// Add method debug information.
				/// </summary>
				/// <param name="document">
				/// The handle of a single document containing all sequence points of the method, or nil if the method doesn't have sequence points or spans multiple documents.
				/// </param>
				/// <param name="sequencePoints">
				/// Sequence Points blob, or nil if the method doesn't have sequence points.
				/// See https://github.com/dotnet/runtime/blob/main/src/libraries/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#sequence-points-blob.
				/// </param>
				public MethodDebugInformationHandle AddMethodDebugInformation(DocumentHandle document, BlobHandle sequencePoints)
				{
					_methodDebugInformationTable.Add(new MethodDebugInformationRow
					{
						Document = document.RowId,
						SequencePoints = sequencePoints
					});
					return MethodDebugInformationHandle.FromRowId(_methodDebugInformationTable.Count);
				}

				/// <summary>
				/// Add local scope debug information.
				/// </summary>
				/// <param name="method">The containing method.</param>
				/// <param name="importScope">Handle of the associated import scope.</param>
				/// <param name="variableList">
				/// If the scope declares variables the handle of the first one, otherwise the handle of the first variable declared by the next scope definition.
				/// If no scope defines any variables, <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalVariableHandle(System.Int32)" />(1).
				/// </param>
				/// <param name="constantList">
				/// If the scope declares constants the handle of the first one, otherwise the handle of the first constant declared by the next scope definition.
				/// If no scope defines any constants, <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.LocalConstantHandle(System.Int32)" />(1).
				/// </param>
				/// <param name="startOffset">Offset of the first instruction covered by the scope.</param>
				/// <param name="length">The length (in bytes) of the scope.</param>
				/// <remarks>
				/// Local scopes should be added in the same order as the corresponding method definition.
				/// Within a method they should be ordered by ascending <paramref name="startOffset" /> and then by descending <paramref name="length" />.
				/// </remarks>
				public LocalScopeHandle AddLocalScope(MethodDefinitionHandle method, ImportScopeHandle importScope, LocalVariableHandle variableList, LocalConstantHandle constantList, int startOffset, int length)
				{
					_localScopeTable.Add(new LocalScopeRow
					{
						Method = method.RowId,
						ImportScope = importScope.RowId,
						VariableList = variableList.RowId,
						ConstantList = constantList.RowId,
						StartOffset = startOffset,
						Length = length
					});
					return LocalScopeHandle.FromRowId(_localScopeTable.Count);
				}

				/// <summary>
				/// Add local variable debug information.
				/// </summary>
				/// <param name="attributes"><see cref="T:System.Reflection.Metadata.LocalVariableAttributes" /></param>
				/// <param name="index">Local variable index in the local signature (zero-based).</param>
				/// <param name="name">Name of the variable.</param>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="index" /> is greater than <see cref="F:System.UInt16.MaxValue" />.</exception>
				public LocalVariableHandle AddLocalVariable(LocalVariableAttributes attributes, int index, StringHandle name)
				{
					if ((uint)index > 65535u)
					{
						System.Reflection.Throw.ArgumentOutOfRange("index");
					}
					_localVariableTable.Add(new LocalVariableRow
					{
						Attributes = (ushort)attributes,
						Index = (ushort)index,
						Name = name
					});
					return LocalVariableHandle.FromRowId(_localVariableTable.Count);
				}

				/// <summary>
				/// Add local constant debug information.
				/// </summary>
				/// <param name="name">Name of the variable.</param>
				/// <param name="signature">
				/// LocalConstantSig blob, see https://github.com/dotnet/runtime/blob/main/src/libraries/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#localconstantsig-blob.
				/// </param>
				public LocalConstantHandle AddLocalConstant(StringHandle name, BlobHandle signature)
				{
					_localConstantTable.Add(new LocalConstantRow
					{
						Name = name,
						Signature = signature
					});
					return LocalConstantHandle.FromRowId(_localConstantTable.Count);
				}

				/// <summary>
				/// Add local scope debug information.
				/// </summary>
				/// <param name="parentScope">Parent scope handle.</param>
				/// <param name="imports">
				/// Imports blob, see https://github.com/dotnet/runtime/blob/main/src/libraries/System.Reflection.Metadata/specs/PortablePdb-Metadata.md#imports-blob.
				/// </param>
				public ImportScopeHandle AddImportScope(ImportScopeHandle parentScope, BlobHandle imports)
				{
					_importScopeTable.Add(new ImportScopeRow
					{
						Parent = parentScope.RowId,
						Imports = imports
					});
					return ImportScopeHandle.FromRowId(_importScopeTable.Count);
				}

				/// <summary>
				/// Add state machine method debug information.
				/// </summary>
				/// <param name="moveNextMethod">Handle of the MoveNext method of the state machine (the compiler-generated method).</param>
				/// <param name="kickoffMethod">Handle of the kickoff method (the user defined iterator/async method)</param>
				/// <remarks>
				/// Entries should be added in the same order as the corresponding MoveNext method definitions.
				/// </remarks>
				public void AddStateMachineMethod(MethodDefinitionHandle moveNextMethod, MethodDefinitionHandle kickoffMethod)
				{
					_stateMachineMethodTable.Add(new StateMachineMethodRow
					{
						MoveNextMethod = moveNextMethod.RowId,
						KickoffMethod = kickoffMethod.RowId
					});
				}

				/// <summary>
				/// Add custom debug information.
				/// </summary>
				/// <param name="parent">
				/// An entity to attach the debug information to:
				/// <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ParameterHandle" />,
				/// <see cref="T:System.Reflection.Metadata.InterfaceImplementationHandle" />,
				/// <see cref="T:System.Reflection.Metadata.MemberReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ModuleDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.DeclarativeSecurityAttributeHandle" />,
				/// <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.EventDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.StandaloneSignatureHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ModuleReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" />,
				/// <see cref="T:System.Reflection.Metadata.AssemblyDefinitionHandle" />,
				/// <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.AssemblyFileHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ExportedTypeHandle" />,
				/// <see cref="T:System.Reflection.Metadata.ManifestResourceHandle" />,
				/// <see cref="T:System.Reflection.Metadata.GenericParameterHandle" />,
				/// <see cref="T:System.Reflection.Metadata.GenericParameterConstraintHandle" />,
				/// <see cref="T:System.Reflection.Metadata.MethodSpecificationHandle" />,
				/// <see cref="T:System.Reflection.Metadata.DocumentHandle" />,
				/// <see cref="T:System.Reflection.Metadata.LocalScopeHandle" />,
				/// <see cref="T:System.Reflection.Metadata.LocalVariableHandle" />,
				/// <see cref="T:System.Reflection.Metadata.LocalConstantHandle" /> or
				/// <see cref="T:System.Reflection.Metadata.ImportScopeHandle" />.
				/// </param>
				/// <param name="kind">Information kind. Determines the structure of the <paramref name="value" /> blob.</param>
				/// <param name="value">Custom debug information blob.</param>
				/// <exception cref="T:System.ArgumentException"><paramref name="parent" /> doesn't have the expected handle kind.</exception>
				/// <remarks>
				/// Entries may be added in any order. The table is automatically sorted when serialized.
				/// </remarks>
				public CustomDebugInformationHandle AddCustomDebugInformation(EntityHandle parent, GuidHandle kind, BlobHandle value)
				{
					_customDebugInformationTable.Add(new CustomDebugInformationRow
					{
						Parent = CodedIndex.HasCustomDebugInformation(parent),
						Kind = kind,
						Value = value
					});
					return CustomDebugInformationHandle.FromRowId(_customDebugInformationTable.Count);
				}

				internal void ValidateOrder()
				{
					ValidateClassLayoutTable();
					ValidateFieldLayoutTable();
					ValidateFieldRvaTable();
					ValidateGenericParamTable();
					ValidateGenericParamConstaintTable();
					ValidateImplMapTable();
					ValidateInterfaceImplTable();
					ValidateMethodImplTable();
					ValidateNestedClassTable();
					ValidateLocalScopeTable();
					ValidateStateMachineMethodTable();
				}

				private void ValidateClassLayoutTable()
				{
					for (int i = 1; i < _classLayoutTable.Count; i++)
					{
						if (_classLayoutTable[i - 1].Parent >= _classLayoutTable[i].Parent)
						{
							System.Reflection.Throw.InvalidOperation_TableNotSorted(TableIndex.ClassLayout);
						}
					}
				}

				private void ValidateFieldLayoutTable()
				{
					for (int i = 1; i < _fieldLayoutTable.Count; i++)
					{
						if (_fieldLayoutTable[i - 1].Field >= _fieldLayoutTable[i].Field)
						{
							System.Reflection.Throw.InvalidOperation_TableNotSorted(TableIndex.FieldLayout);
						}
					}
				}

				private void ValidateFieldRvaTable()
				{
					for (int i = 1; i < _fieldRvaTable.Count; i++)
					{
						if (_fieldRvaTable[i - 1].Field >= _fieldRvaTable[i].Field)
						{
							System.Reflection.Throw.InvalidOperation_TableNotSorted(TableIndex.FieldRva);
						}
					}
				}

				private void ValidateGenericParamTable()
				{
					if (_genericParamTable.Count == 0)
					{
						return;
					}
					GenericParamRow genericParamRow = _genericParamTable[0];
					int num = 1;
					while (num < _genericParamTable.Count)
					{
						GenericParamRow genericParamRow2 = _genericParamTable[num];
						if (genericParamRow2.Owner <= genericParamRow.Owner && (genericParamRow.Owner != genericParamRow2.Owner || genericParamRow2.Number <= genericParamRow.Number))
						{
							System.Reflection.Throw.InvalidOperation_TableNotSorted(TableIndex.GenericParam);
						}
						num++;
						genericParamRow = genericParamRow2;
					}
				}

				private void ValidateGenericParamConstaintTable()
				{
					for (int i = 1; i < _genericParamConstraintTable.Count; i++)
					{
						if (_genericParamConstraintTable[i - 1].Owner > _genericParamConstraintTable[i].Owner)
						{
							System.Reflection.Throw.InvalidOperation_TableNotSorted(TableIndex.GenericParamConstraint);
						}
					}
				}

				private void ValidateImplMapTable()
				{
					for (int i = 1; i < _implMapTable.Count; i++)
					{
						if (_implMapTable[i - 1].MemberForwarded >= _implMapTable[i].MemberForwarded)
						{
							System.Reflection.Throw.InvalidOperation_TableNotSorted(TableIndex.ImplMap);
						}
					}
				}

				private void ValidateInterfaceImplTable()
				{
					for (int i = 1; i < _interfaceImplTable.Count; i++)
					{
						if (_interfaceImplTable[i - 1].Class > _interfaceImplTable[i].Class)
						{
							System.Reflection.Throw.InvalidOperation_TableNotSorted(TableIndex.InterfaceImpl);
						}
					}
				}

				private void ValidateMethodImplTable()
				{
					for (int i = 1; i < _methodImplTable.Count; i++)
					{
						if (_methodImplTable[i - 1].Class > _methodImplTable[i].Class)
						{
							System.Reflection.Throw.InvalidOperation_TableNotSorted(TableIndex.MethodImpl);
						}
					}
				}

				private void ValidateNestedClassTable()
				{
					for (int i = 1; i < _nestedClassTable.Count; i++)
					{
						if (_nestedClassTable[i - 1].NestedClass >= _nestedClassTable[i].NestedClass)
						{
							System.Reflection.Throw.InvalidOperation_TableNotSorted(TableIndex.NestedClass);
						}
					}
				}

				private void ValidateLocalScopeTable()
				{
					if (_localScopeTable.Count == 0)
					{
						return;
					}
					LocalScopeRow localScopeRow = _localScopeTable[0];
					int num = 1;
					while (num < _localScopeTable.Count)
					{
						LocalScopeRow localScopeRow2 = _localScopeTable[num];
						if (localScopeRow2.Method <= localScopeRow.Method && (localScopeRow2.Method != localScopeRow.Method || (localScopeRow2.StartOffset <= localScopeRow.StartOffset && (localScopeRow2.StartOffset != localScopeRow.StartOffset || localScopeRow.Length < localScopeRow2.Length))))
						{
							System.Reflection.Throw.InvalidOperation_TableNotSorted(TableIndex.LocalScope);
						}
						num++;
						localScopeRow = localScopeRow2;
					}
				}

				private void ValidateStateMachineMethodTable()
				{
					for (int i = 1; i < _stateMachineMethodTable.Count; i++)
					{
						if (_stateMachineMethodTable[i - 1].MoveNextMethod >= _stateMachineMethodTable[i].MoveNextMethod)
						{
							System.Reflection.Throw.InvalidOperation_TableNotSorted(TableIndex.StateMachineMethod);
						}
					}
				}

				internal void SerializeMetadataTables(BlobBuilder writer, MetadataSizes metadataSizes, System.Collections.Immutable.ImmutableArray<int> stringMap, int methodBodyStreamRva, int mappedFieldDataStreamRva)
				{
					int count = writer.Count;
					SerializeTablesHeader(writer, metadataSizes);
					if (metadataSizes.IsPresent(TableIndex.Module))
					{
						SerializeModuleTable(writer, stringMap, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.TypeRef))
					{
						SerializeTypeRefTable(writer, stringMap, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.TypeDef))
					{
						SerializeTypeDefTable(writer, stringMap, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.Field))
					{
						SerializeFieldTable(writer, stringMap, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.MethodDef))
					{
						SerializeMethodDefTable(writer, stringMap, metadataSizes, methodBodyStreamRva);
					}
					if (metadataSizes.IsPresent(TableIndex.Param))
					{
						SerializeParamTable(writer, stringMap, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.InterfaceImpl))
					{
						SerializeInterfaceImplTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.MemberRef))
					{
						SerializeMemberRefTable(writer, stringMap, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.Constant))
					{
						SerializeConstantTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.CustomAttribute))
					{
						SerializeCustomAttributeTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.FieldMarshal))
					{
						SerializeFieldMarshalTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.DeclSecurity))
					{
						SerializeDeclSecurityTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.ClassLayout))
					{
						SerializeClassLayoutTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.FieldLayout))
					{
						SerializeFieldLayoutTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.StandAloneSig))
					{
						SerializeStandAloneSigTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.EventMap))
					{
						SerializeEventMapTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.Event))
					{
						SerializeEventTable(writer, stringMap, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.PropertyMap))
					{
						SerializePropertyMapTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.Property))
					{
						SerializePropertyTable(writer, stringMap, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.MethodSemantics))
					{
						SerializeMethodSemanticsTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.MethodImpl))
					{
						SerializeMethodImplTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.ModuleRef))
					{
						SerializeModuleRefTable(writer, stringMap, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.TypeSpec))
					{
						SerializeTypeSpecTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.ImplMap))
					{
						SerializeImplMapTable(writer, stringMap, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.FieldRva))
					{
						SerializeFieldRvaTable(writer, metadataSizes, mappedFieldDataStreamRva);
					}
					if (metadataSizes.IsPresent(TableIndex.EncLog))
					{
						SerializeEncLogTable(writer);
					}
					if (metadataSizes.IsPresent(TableIndex.EncMap))
					{
						SerializeEncMapTable(writer);
					}
					if (metadataSizes.IsPresent(TableIndex.Assembly))
					{
						SerializeAssemblyTable(writer, stringMap, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.AssemblyRef))
					{
						SerializeAssemblyRefTable(writer, stringMap, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.File))
					{
						SerializeFileTable(writer, stringMap, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.ExportedType))
					{
						SerializeExportedTypeTable(writer, stringMap, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.ManifestResource))
					{
						SerializeManifestResourceTable(writer, stringMap, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.NestedClass))
					{
						SerializeNestedClassTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.GenericParam))
					{
						SerializeGenericParamTable(writer, stringMap, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.MethodSpec))
					{
						SerializeMethodSpecTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.GenericParamConstraint))
					{
						SerializeGenericParamConstraintTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.Document))
					{
						SerializeDocumentTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.MethodDebugInformation))
					{
						SerializeMethodDebugInformationTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.LocalScope))
					{
						SerializeLocalScopeTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.LocalVariable))
					{
						SerializeLocalVariableTable(writer, stringMap, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.LocalConstant))
					{
						SerializeLocalConstantTable(writer, stringMap, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.ImportScope))
					{
						SerializeImportScopeTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.StateMachineMethod))
					{
						SerializeStateMachineMethodTable(writer, metadataSizes);
					}
					if (metadataSizes.IsPresent(TableIndex.CustomDebugInformation))
					{
						SerializeCustomDebugInformationTable(writer, metadataSizes);
					}
					writer.WriteByte(0);
					writer.Align(4);
					int count2 = writer.Count;
				}

				private static void SerializeTablesHeader(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					int count = writer.Count;
					System.Reflection.Metadata.Ecma335.HeapSizeFlag heapSizeFlag = (System.Reflection.Metadata.Ecma335.HeapSizeFlag)0;
					if (!metadataSizes.StringReferenceIsSmall)
					{
						heapSizeFlag |= System.Reflection.Metadata.Ecma335.HeapSizeFlag.StringHeapLarge;
					}
					if (!metadataSizes.GuidReferenceIsSmall)
					{
						heapSizeFlag |= System.Reflection.Metadata.Ecma335.HeapSizeFlag.GuidHeapLarge;
					}
					if (!metadataSizes.BlobReferenceIsSmall)
					{
						heapSizeFlag |= System.Reflection.Metadata.Ecma335.HeapSizeFlag.BlobHeapLarge;
					}
					if (metadataSizes.IsEncDelta)
					{
						heapSizeFlag |= (System.Reflection.Metadata.Ecma335.HeapSizeFlag)160;
					}
					ulong num = metadataSizes.PresentTablesMask & 0xC4000000000000uL;
					ulong value = num | (metadataSizes.IsStandaloneDebugMetadata ? 0 : 24190111578624uL);
					writer.WriteUInt32(0u);
					writer.WriteByte(2);
					writer.WriteByte(0);
					writer.WriteByte((byte)heapSizeFlag);
					writer.WriteByte(1);
					writer.WriteUInt64(metadataSizes.PresentTablesMask);
					writer.WriteUInt64(value);
					MetadataWriterUtilities.SerializeRowCounts(writer, metadataSizes.RowCounts);
					int count2 = writer.Count;
				}

				internal void SerializeModuleTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes)
				{
					if (_moduleRow.HasValue)
					{
						writer.WriteUInt16(_moduleRow.Value.Generation);
						writer.WriteReference(SerializeHandle(stringMap, _moduleRow.Value.Name), metadataSizes.StringReferenceIsSmall);
						writer.WriteReference(SerializeHandle(_moduleRow.Value.ModuleVersionId), metadataSizes.GuidReferenceIsSmall);
						writer.WriteReference(SerializeHandle(_moduleRow.Value.EncId), metadataSizes.GuidReferenceIsSmall);
						writer.WriteReference(SerializeHandle(_moduleRow.Value.EncBaseId), metadataSizes.GuidReferenceIsSmall);
					}
				}

				private void SerializeEncLogTable(BlobBuilder writer)
				{
					foreach (EncLogRow item in _encLogTable)
					{
						writer.WriteInt32(item.Token);
						writer.WriteUInt32(item.FuncCode);
					}
				}

				private void SerializeEncMapTable(BlobBuilder writer)
				{
					foreach (EncMapRow item in _encMapTable)
					{
						writer.WriteInt32(item.Token);
					}
				}

				private void SerializeTypeRefTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes)
				{
					foreach (TypeRefRow item in _typeRefTable)
					{
						writer.WriteReference(item.ResolutionScope, metadataSizes.ResolutionScopeCodedIndexIsSmall);
						writer.WriteReference(SerializeHandle(stringMap, item.Name), metadataSizes.StringReferenceIsSmall);
						writer.WriteReference(SerializeHandle(stringMap, item.Namespace), metadataSizes.StringReferenceIsSmall);
					}
				}

				private void SerializeTypeDefTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes)
				{
					foreach (TypeDefRow item in _typeDefTable)
					{
						writer.WriteUInt32(item.Flags);
						writer.WriteReference(SerializeHandle(stringMap, item.Name), metadataSizes.StringReferenceIsSmall);
						writer.WriteReference(SerializeHandle(stringMap, item.Namespace), metadataSizes.StringReferenceIsSmall);
						writer.WriteReference(item.Extends, metadataSizes.TypeDefOrRefCodedIndexIsSmall);
						writer.WriteReference(item.FieldList, metadataSizes.FieldDefReferenceIsSmall);
						writer.WriteReference(item.MethodList, metadataSizes.MethodDefReferenceIsSmall);
					}
				}

				private void SerializeFieldTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes)
				{
					foreach (FieldDefRow item in _fieldTable)
					{
						writer.WriteUInt16(item.Flags);
						writer.WriteReference(SerializeHandle(stringMap, item.Name), metadataSizes.StringReferenceIsSmall);
						writer.WriteReference(SerializeHandle(item.Signature), metadataSizes.BlobReferenceIsSmall);
					}
				}

				private void SerializeMethodDefTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes, int methodBodyStreamRva)
				{
					foreach (MethodRow item in _methodDefTable)
					{
						if (item.BodyOffset == -1)
						{
							writer.WriteUInt32(0u);
						}
						else
						{
							writer.WriteInt32(methodBodyStreamRva + item.BodyOffset);
						}
						writer.WriteUInt16(item.ImplFlags);
						writer.WriteUInt16(item.Flags);
						writer.WriteReference(SerializeHandle(stringMap, item.Name), metadataSizes.StringReferenceIsSmall);
						writer.WriteReference(SerializeHandle(item.Signature), metadataSizes.BlobReferenceIsSmall);
						writer.WriteReference(item.ParamList, metadataSizes.ParameterReferenceIsSmall);
					}
				}

				private void SerializeParamTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes)
				{
					foreach (ParamRow item in _paramTable)
					{
						writer.WriteUInt16(item.Flags);
						writer.WriteUInt16(item.Sequence);
						writer.WriteReference(SerializeHandle(stringMap, item.Name), metadataSizes.StringReferenceIsSmall);
					}
				}

				private void SerializeInterfaceImplTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					foreach (InterfaceImplRow item in _interfaceImplTable)
					{
						writer.WriteReference(item.Class, metadataSizes.TypeDefReferenceIsSmall);
						writer.WriteReference(item.Interface, metadataSizes.TypeDefOrRefCodedIndexIsSmall);
					}
				}

				private void SerializeMemberRefTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes)
				{
					foreach (MemberRefRow item in _memberRefTable)
					{
						writer.WriteReference(item.Class, metadataSizes.MemberRefParentCodedIndexIsSmall);
						writer.WriteReference(SerializeHandle(stringMap, item.Name), metadataSizes.StringReferenceIsSmall);
						writer.WriteReference(SerializeHandle(item.Signature), metadataSizes.BlobReferenceIsSmall);
					}
				}

				private void SerializeConstantTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					IEnumerable<ConstantRow> enumerable;
					if (!_constantTableNeedsSorting)
					{
						IEnumerable<ConstantRow> constantTable = _constantTable;
						enumerable = constantTable;
					}
					else
					{
						enumerable = _constantTable.OrderBy((ConstantRow x, ConstantRow y) => x.Parent - y.Parent);
					}
					IEnumerable<ConstantRow> enumerable2 = enumerable;
					foreach (ConstantRow item in enumerable2)
					{
						writer.WriteByte(item.Type);
						writer.WriteByte(0);
						writer.WriteReference(item.Parent, metadataSizes.HasConstantCodedIndexIsSmall);
						writer.WriteReference(SerializeHandle(item.Value), metadataSizes.BlobReferenceIsSmall);
					}
				}

				private void SerializeCustomAttributeTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					IEnumerable<CustomAttributeRow> enumerable;
					if (!_customAttributeTableNeedsSorting)
					{
						IEnumerable<CustomAttributeRow> customAttributeTable = _customAttributeTable;
						enumerable = customAttributeTable;
					}
					else
					{
						enumerable = _customAttributeTable.OrderBy((CustomAttributeRow x, CustomAttributeRow y) => x.Parent - y.Parent);
					}
					IEnumerable<CustomAttributeRow> enumerable2 = enumerable;
					foreach (CustomAttributeRow item in enumerable2)
					{
						writer.WriteReference(item.Parent, metadataSizes.HasCustomAttributeCodedIndexIsSmall);
						writer.WriteReference(item.Type, metadataSizes.CustomAttributeTypeCodedIndexIsSmall);
						writer.WriteReference(SerializeHandle(item.Value), metadataSizes.BlobReferenceIsSmall);
					}
				}

				private void SerializeFieldMarshalTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					IEnumerable<FieldMarshalRow> enumerable;
					if (!_fieldMarshalTableNeedsSorting)
					{
						IEnumerable<FieldMarshalRow> fieldMarshalTable = _fieldMarshalTable;
						enumerable = fieldMarshalTable;
					}
					else
					{
						enumerable = _fieldMarshalTable.OrderBy((FieldMarshalRow x, FieldMarshalRow y) => x.Parent - y.Parent);
					}
					IEnumerable<FieldMarshalRow> enumerable2 = enumerable;
					foreach (FieldMarshalRow item in enumerable2)
					{
						writer.WriteReference(item.Parent, metadataSizes.HasFieldMarshalCodedIndexIsSmall);
						writer.WriteReference(SerializeHandle(item.NativeType), metadataSizes.BlobReferenceIsSmall);
					}
				}

				private void SerializeDeclSecurityTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					IEnumerable<DeclSecurityRow> enumerable;
					if (!_declSecurityTableNeedsSorting)
					{
						IEnumerable<DeclSecurityRow> declSecurityTable = _declSecurityTable;
						enumerable = declSecurityTable;
					}
					else
					{
						enumerable = _declSecurityTable.OrderBy((DeclSecurityRow x, DeclSecurityRow y) => x.Parent - y.Parent);
					}
					IEnumerable<DeclSecurityRow> enumerable2 = enumerable;
					foreach (DeclSecurityRow item in enumerable2)
					{
						writer.WriteUInt16(item.Action);
						writer.WriteReference(item.Parent, metadataSizes.DeclSecurityCodedIndexIsSmall);
						writer.WriteReference(SerializeHandle(item.PermissionSet), metadataSizes.BlobReferenceIsSmall);
					}
				}

				private void SerializeClassLayoutTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					foreach (ClassLayoutRow item in _classLayoutTable)
					{
						writer.WriteUInt16(item.PackingSize);
						writer.WriteUInt32(item.ClassSize);
						writer.WriteReference(item.Parent, metadataSizes.TypeDefReferenceIsSmall);
					}
				}

				private void SerializeFieldLayoutTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					foreach (FieldLayoutRow item in _fieldLayoutTable)
					{
						writer.WriteInt32(item.Offset);
						writer.WriteReference(item.Field, metadataSizes.FieldDefReferenceIsSmall);
					}
				}

				private void SerializeStandAloneSigTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					foreach (StandaloneSigRow item in _standAloneSigTable)
					{
						writer.WriteReference(SerializeHandle(item.Signature), metadataSizes.BlobReferenceIsSmall);
					}
				}

				private void SerializeEventMapTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					foreach (EventMapRow item in _eventMapTable)
					{
						writer.WriteReference(item.Parent, metadataSizes.TypeDefReferenceIsSmall);
						writer.WriteReference(item.EventList, metadataSizes.EventDefReferenceIsSmall);
					}
				}

				private void SerializeEventTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes)
				{
					foreach (EventRow item in _eventTable)
					{
						writer.WriteUInt16(item.EventFlags);
						writer.WriteReference(SerializeHandle(stringMap, item.Name), metadataSizes.StringReferenceIsSmall);
						writer.WriteReference(item.EventType, metadataSizes.TypeDefOrRefCodedIndexIsSmall);
					}
				}

				private void SerializePropertyMapTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					foreach (PropertyMapRow item in _propertyMapTable)
					{
						writer.WriteReference(item.Parent, metadataSizes.TypeDefReferenceIsSmall);
						writer.WriteReference(item.PropertyList, metadataSizes.PropertyDefReferenceIsSmall);
					}
				}

				private void SerializePropertyTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes)
				{
					foreach (PropertyRow item in _propertyTable)
					{
						writer.WriteUInt16(item.PropFlags);
						writer.WriteReference(SerializeHandle(stringMap, item.Name), metadataSizes.StringReferenceIsSmall);
						writer.WriteReference(SerializeHandle(item.Type), metadataSizes.BlobReferenceIsSmall);
					}
				}

				private void SerializeMethodSemanticsTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					IEnumerable<MethodSemanticsRow> enumerable;
					if (!_methodSemanticsTableNeedsSorting)
					{
						IEnumerable<MethodSemanticsRow> methodSemanticsTable = _methodSemanticsTable;
						enumerable = methodSemanticsTable;
					}
					else
					{
						enumerable = _methodSemanticsTable.OrderBy((MethodSemanticsRow x, MethodSemanticsRow y) => x.Association - y.Association);
					}
					IEnumerable<MethodSemanticsRow> enumerable2 = enumerable;
					foreach (MethodSemanticsRow item in enumerable2)
					{
						writer.WriteUInt16(item.Semantic);
						writer.WriteReference(item.Method, metadataSizes.MethodDefReferenceIsSmall);
						writer.WriteReference(item.Association, metadataSizes.HasSemanticsCodedIndexIsSmall);
					}
				}

				private void SerializeMethodImplTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					foreach (MethodImplRow item in _methodImplTable)
					{
						writer.WriteReference(item.Class, metadataSizes.TypeDefReferenceIsSmall);
						writer.WriteReference(item.MethodBody, metadataSizes.MethodDefOrRefCodedIndexIsSmall);
						writer.WriteReference(item.MethodDecl, metadataSizes.MethodDefOrRefCodedIndexIsSmall);
					}
				}

				private void SerializeModuleRefTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes)
				{
					foreach (ModuleRefRow item in _moduleRefTable)
					{
						writer.WriteReference(SerializeHandle(stringMap, item.Name), metadataSizes.StringReferenceIsSmall);
					}
				}

				private void SerializeTypeSpecTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					foreach (TypeSpecRow item in _typeSpecTable)
					{
						writer.WriteReference(SerializeHandle(item.Signature), metadataSizes.BlobReferenceIsSmall);
					}
				}

				private void SerializeImplMapTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes)
				{
					foreach (ImplMapRow item in _implMapTable)
					{
						writer.WriteUInt16(item.MappingFlags);
						writer.WriteReference(item.MemberForwarded, metadataSizes.MemberForwardedCodedIndexIsSmall);
						writer.WriteReference(SerializeHandle(stringMap, item.ImportName), metadataSizes.StringReferenceIsSmall);
						writer.WriteReference(item.ImportScope, metadataSizes.ModuleRefReferenceIsSmall);
					}
				}

				private void SerializeFieldRvaTable(BlobBuilder writer, MetadataSizes metadataSizes, int mappedFieldDataStreamRva)
				{
					foreach (FieldRvaRow item in _fieldRvaTable)
					{
						writer.WriteInt32(mappedFieldDataStreamRva + item.Offset);
						writer.WriteReference(item.Field, metadataSizes.FieldDefReferenceIsSmall);
					}
				}

				private void SerializeAssemblyTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes)
				{
					if (_assemblyRow.HasValue)
					{
						Version version = _assemblyRow.Value.Version;
						writer.WriteUInt32(_assemblyRow.Value.HashAlgorithm);
						writer.WriteUInt16((ushort)version.Major);
						writer.WriteUInt16((ushort)version.Minor);
						writer.WriteUInt16((ushort)version.Build);
						writer.WriteUInt16((ushort)version.Revision);
						writer.WriteUInt32(_assemblyRow.Value.Flags);
						writer.WriteReference(SerializeHandle(_assemblyRow.Value.AssemblyKey), metadataSizes.BlobReferenceIsSmall);
						writer.WriteReference(SerializeHandle(stringMap, _assemblyRow.Value.AssemblyName), metadataSizes.StringReferenceIsSmall);
						writer.WriteReference(SerializeHandle(stringMap, _assemblyRow.Value.AssemblyCulture), metadataSizes.StringReferenceIsSmall);
					}
				}

				private void SerializeAssemblyRefTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes)
				{
					foreach (AssemblyRefTableRow item in _assemblyRefTable)
					{
						writer.WriteUInt16((ushort)item.Version.Major);
						writer.WriteUInt16((ushort)item.Version.Minor);
						writer.WriteUInt16((ushort)item.Version.Build);
						writer.WriteUInt16((ushort)item.Version.Revision);
						writer.WriteUInt32(item.Flags);
						writer.WriteReference(SerializeHandle(item.PublicKeyToken), metadataSizes.BlobReferenceIsSmall);
						writer.WriteReference(SerializeHandle(stringMap, item.Name), metadataSizes.StringReferenceIsSmall);
						writer.WriteReference(SerializeHandle(stringMap, item.Culture), metadataSizes.StringReferenceIsSmall);
						writer.WriteReference(SerializeHandle(item.HashValue), metadataSizes.BlobReferenceIsSmall);
					}
				}

				private void SerializeFileTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes)
				{
					foreach (FileTableRow item in _fileTable)
					{
						writer.WriteUInt32(item.Flags);
						writer.WriteReference(SerializeHandle(stringMap, item.FileName), metadataSizes.StringReferenceIsSmall);
						writer.WriteReference(SerializeHandle(item.HashValue), metadataSizes.BlobReferenceIsSmall);
					}
				}

				private void SerializeExportedTypeTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes)
				{
					foreach (ExportedTypeRow item in _exportedTypeTable)
					{
						writer.WriteUInt32(item.Flags);
						writer.WriteInt32(item.TypeDefId);
						writer.WriteReference(SerializeHandle(stringMap, item.TypeName), metadataSizes.StringReferenceIsSmall);
						writer.WriteReference(SerializeHandle(stringMap, item.TypeNamespace), metadataSizes.StringReferenceIsSmall);
						writer.WriteReference(item.Implementation, metadataSizes.ImplementationCodedIndexIsSmall);
					}
				}

				private void SerializeManifestResourceTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes)
				{
					foreach (ManifestResourceRow item in _manifestResourceTable)
					{
						writer.WriteUInt32(item.Offset);
						writer.WriteUInt32(item.Flags);
						writer.WriteReference(SerializeHandle(stringMap, item.Name), metadataSizes.StringReferenceIsSmall);
						writer.WriteReference(item.Implementation, metadataSizes.ImplementationCodedIndexIsSmall);
					}
				}

				private void SerializeNestedClassTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					foreach (NestedClassRow item in _nestedClassTable)
					{
						writer.WriteReference(item.NestedClass, metadataSizes.TypeDefReferenceIsSmall);
						writer.WriteReference(item.EnclosingClass, metadataSizes.TypeDefReferenceIsSmall);
					}
				}

				private void SerializeGenericParamTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes)
				{
					foreach (GenericParamRow item in _genericParamTable)
					{
						writer.WriteUInt16(item.Number);
						writer.WriteUInt16(item.Flags);
						writer.WriteReference(item.Owner, metadataSizes.TypeOrMethodDefCodedIndexIsSmall);
						writer.WriteReference(SerializeHandle(stringMap, item.Name), metadataSizes.StringReferenceIsSmall);
					}
				}

				private void SerializeGenericParamConstraintTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					foreach (GenericParamConstraintRow item in _genericParamConstraintTable)
					{
						writer.WriteReference(item.Owner, metadataSizes.GenericParamReferenceIsSmall);
						writer.WriteReference(item.Constraint, metadataSizes.TypeDefOrRefCodedIndexIsSmall);
					}
				}

				private void SerializeMethodSpecTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					foreach (MethodSpecRow item in _methodSpecTable)
					{
						writer.WriteReference(item.Method, metadataSizes.MethodDefOrRefCodedIndexIsSmall);
						writer.WriteReference(SerializeHandle(item.Instantiation), metadataSizes.BlobReferenceIsSmall);
					}
				}

				private void SerializeDocumentTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					foreach (DocumentRow item in _documentTable)
					{
						writer.WriteReference(SerializeHandle(item.Name), metadataSizes.BlobReferenceIsSmall);
						writer.WriteReference(SerializeHandle(item.HashAlgorithm), metadataSizes.GuidReferenceIsSmall);
						writer.WriteReference(SerializeHandle(item.Hash), metadataSizes.BlobReferenceIsSmall);
						writer.WriteReference(SerializeHandle(item.Language), metadataSizes.GuidReferenceIsSmall);
					}
				}

				private void SerializeMethodDebugInformationTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					foreach (MethodDebugInformationRow item in _methodDebugInformationTable)
					{
						writer.WriteReference(item.Document, metadataSizes.DocumentReferenceIsSmall);
						writer.WriteReference(SerializeHandle(item.SequencePoints), metadataSizes.BlobReferenceIsSmall);
					}
				}

				private void SerializeLocalScopeTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					foreach (LocalScopeRow item in _localScopeTable)
					{
						writer.WriteReference(item.Method, metadataSizes.MethodDefReferenceIsSmall);
						writer.WriteReference(item.ImportScope, metadataSizes.ImportScopeReferenceIsSmall);
						writer.WriteReference(item.VariableList, metadataSizes.LocalVariableReferenceIsSmall);
						writer.WriteReference(item.ConstantList, metadataSizes.LocalConstantReferenceIsSmall);
						writer.WriteInt32(item.StartOffset);
						writer.WriteInt32(item.Length);
					}
				}

				private void SerializeLocalVariableTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes)
				{
					foreach (LocalVariableRow item in _localVariableTable)
					{
						writer.WriteUInt16(item.Attributes);
						writer.WriteUInt16(item.Index);
						writer.WriteReference(SerializeHandle(stringMap, item.Name), metadataSizes.StringReferenceIsSmall);
					}
				}

				private void SerializeLocalConstantTable(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> stringMap, MetadataSizes metadataSizes)
				{
					foreach (LocalConstantRow item in _localConstantTable)
					{
						writer.WriteReference(SerializeHandle(stringMap, item.Name), metadataSizes.StringReferenceIsSmall);
						writer.WriteReference(SerializeHandle(item.Signature), metadataSizes.BlobReferenceIsSmall);
					}
				}

				private void SerializeImportScopeTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					foreach (ImportScopeRow item in _importScopeTable)
					{
						writer.WriteReference(item.Parent, metadataSizes.ImportScopeReferenceIsSmall);
						writer.WriteReference(SerializeHandle(item.Imports), metadataSizes.BlobReferenceIsSmall);
					}
				}

				private void SerializeStateMachineMethodTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					foreach (StateMachineMethodRow item in _stateMachineMethodTable)
					{
						writer.WriteReference(item.MoveNextMethod, metadataSizes.MethodDefReferenceIsSmall);
						writer.WriteReference(item.KickoffMethod, metadataSizes.MethodDefReferenceIsSmall);
					}
				}

				private void SerializeCustomDebugInformationTable(BlobBuilder writer, MetadataSizes metadataSizes)
				{
					foreach (CustomDebugInformationRow item in _customDebugInformationTable.OrderBy(delegate (CustomDebugInformationRow x, CustomDebugInformationRow y)
					{
						int num = x.Parent - y.Parent;
						return (num == 0) ? (x.Kind.Index - y.Kind.Index) : num;
					}))
					{
						writer.WriteReference(item.Parent, metadataSizes.HasCustomDebugInformationCodedIndexIsSmall);
						writer.WriteReference(SerializeHandle(item.Kind), metadataSizes.GuidReferenceIsSmall);
						writer.WriteReference(SerializeHandle(item.Value), metadataSizes.BlobReferenceIsSmall);
					}
				}

				/// <summary>
				/// Creates a builder for metadata tables and heaps.
				/// </summary>
				/// <param name="userStringHeapStartOffset">
				/// Start offset of the User String heap.
				/// The cumulative size of User String heaps of all previous EnC generations. Should be 0 unless the metadata is EnC delta metadata.
				/// </param>
				/// <param name="stringHeapStartOffset">
				/// Start offset of the String heap.
				/// The cumulative size of String heaps of all previous EnC generations. Should be 0 unless the metadata is EnC delta metadata.
				/// </param>
				/// <param name="blobHeapStartOffset">
				/// Start offset of the Blob heap.
				/// The cumulative size of Blob heaps of all previous EnC generations. Should be 0 unless the metadata is EnC delta metadata.
				/// </param>
				/// <param name="guidHeapStartOffset">
				/// Start offset of the Guid heap.
				/// The cumulative size of Guid heaps of all previous EnC generations. Should be 0 unless the metadata is EnC delta metadata.
				/// </param>
				/// <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">Offset is too big.</exception>
				/// <exception cref="T:System.ArgumentOutOfRangeException">Offset is negative.</exception>
				/// <exception cref="T:System.ArgumentException"><paramref name="guidHeapStartOffset" /> is not a multiple of size of GUID.</exception>
				public MetadataBuilder(int userStringHeapStartOffset = 0, int stringHeapStartOffset = 0, int blobHeapStartOffset = 0, int guidHeapStartOffset = 0)
				{
					if (userStringHeapStartOffset >= 16777215)
					{
						System.Reflection.Throw.HeapSizeLimitExceeded(HeapIndex.UserString);
					}
					if (userStringHeapStartOffset < 0)
					{
						System.Reflection.Throw.ArgumentOutOfRange("userStringHeapStartOffset");
					}
					if (stringHeapStartOffset < 0)
					{
						System.Reflection.Throw.ArgumentOutOfRange("stringHeapStartOffset");
					}
					if (blobHeapStartOffset < 0)
					{
						System.Reflection.Throw.ArgumentOutOfRange("blobHeapStartOffset");
					}
					if (guidHeapStartOffset < 0)
					{
						System.Reflection.Throw.ArgumentOutOfRange("guidHeapStartOffset");
					}
					if (guidHeapStartOffset % 16 != 0)
					{
						throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.ValueMustBeMultiple, 16), "guidHeapStartOffset");
					}
					_userStringBuilder.WriteByte(0);
					_blobs.Add(System.Collections.Immutable.ImmutableArray<byte>.Empty, default(BlobHandle));
					_blobHeapSize = 1;
					_userStringHeapStartOffset = userStringHeapStartOffset;
					_stringHeapStartOffset = stringHeapStartOffset;
					_blobHeapStartOffset = blobHeapStartOffset;
					_guidBuilder.WriteBytes(0, guidHeapStartOffset);
				}

				/// <summary>
				/// Sets the capacity of the specified table.
				/// </summary>
				/// <param name="heap">Heap index.</param>
				/// <param name="byteCount">Number of bytes.</param>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="heap" /> is not a valid heap index.</exception>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="byteCount" /> is negative.</exception>
				/// <remarks>
				/// Use to reduce allocations if the approximate number of bytes is known ahead of time.
				/// </remarks>
				public void SetCapacity(HeapIndex heap, int byteCount)
				{
					if (byteCount < 0)
					{
						System.Reflection.Throw.ArgumentOutOfRange("byteCount");
					}
					switch (heap)
					{
						case HeapIndex.Guid:
							_guidBuilder.SetCapacity(byteCount);
							break;
						case HeapIndex.String:
							_stringHeapCapacity = byteCount;
							break;
						case HeapIndex.UserString:
							_userStringBuilder.SetCapacity(byteCount);
							break;
						default:
							System.Reflection.Throw.ArgumentOutOfRange("heap");
							break;
						case HeapIndex.Blob:
							break;
					}
				}

				internal static int SerializeHandle(System.Collections.Immutable.ImmutableArray<int> map, StringHandle handle)
				{
					return map[handle.GetWriterVirtualIndex()];
				}

				internal static int SerializeHandle(BlobHandle handle)
				{
					return handle.GetHeapOffset();
				}

				internal static int SerializeHandle(GuidHandle handle)
				{
					return handle.Index;
				}

				internal static int SerializeHandle(UserStringHandle handle)
				{
					return handle.GetHeapOffset();
				}

				/// <summary>
				/// Adds specified blob to Blob heap, if it's not there already.
				/// </summary>
				/// <param name="value"><see cref="T:System.Reflection.Metadata.BlobBuilder" /> containing the blob.</param>
				/// <returns>Handle to the added or existing blob.</returns>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is null.</exception>
				public BlobHandle GetOrAddBlob(BlobBuilder value)
				{
					if (value == null)
					{
						System.Reflection.Throw.ArgumentNull("value");
					}
					return GetOrAddBlob(value.ToImmutableArray());
				}

				/// <summary>
				/// Adds specified blob to Blob heap, if it's not there already.
				/// </summary>
				/// <param name="value">Array containing the blob.</param>
				/// <returns>Handle to the added or existing blob.</returns>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is null.</exception>
				public BlobHandle GetOrAddBlob(byte[] value)
				{
					if (value == null)
					{
						System.Reflection.Throw.ArgumentNull("value");
					}
					return GetOrAddBlob(System.Collections.Immutable.ImmutableArray.Create<byte>(value));
				}

				/// <summary>
				/// Adds specified blob to Blob heap, if it's not there already.
				/// </summary>
				/// <param name="value">Array containing the blob.</param>
				/// <returns>Handle to the added or existing blob.</returns>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is null.</exception>
				public BlobHandle GetOrAddBlob(System.Collections.Immutable.ImmutableArray<byte> value)
				{
					if (value.IsDefault)
					{
						System.Reflection.Throw.ArgumentNull("value");
					}
					if (!_blobs.TryGetValue(value, out var value2))
					{
						value2 = BlobHandle.FromOffset(_blobHeapStartOffset + _blobHeapSize);
						_blobs.Add(value, value2);
						_blobHeapSize += BlobWriterImpl.GetCompressedIntegerSize(value.Length) + value.Length;
					}
					return value2;
				}

				/// <summary>
				/// Encodes a constant value to a blob and adds it to the Blob heap, if it's not there already.
				/// Uses UTF16 to encode string constants.
				/// </summary>
				/// <param name="value">Constant value.</param>
				/// <returns>Handle to the added or existing blob.</returns>
				public BlobHandle GetOrAddConstantBlob(object? value)
				{
					if (value is string value2)
					{
						return GetOrAddBlobUTF16(value2);
					}
					PooledBlobBuilder instance = PooledBlobBuilder.GetInstance();
					instance.WriteConstant(value);
					BlobHandle orAddBlob = GetOrAddBlob(instance);
					instance.Free();
					return orAddBlob;
				}

				/// <summary>
				/// Encodes a string using UTF16 encoding to a blob and adds it to the Blob heap, if it's not there already.
				/// </summary>
				/// <param name="value">String.</param>
				/// <returns>Handle to the added or existing blob.</returns>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is null.</exception>
				public BlobHandle GetOrAddBlobUTF16(string value)
				{
					PooledBlobBuilder instance = PooledBlobBuilder.GetInstance();
					instance.WriteUTF16(value);
					BlobHandle orAddBlob = GetOrAddBlob(instance);
					instance.Free();
					return orAddBlob;
				}

				/// <summary>
				/// Encodes a string using UTF8 encoding to a blob and adds it to the Blob heap, if it's not there already.
				/// </summary>
				/// <param name="value">Constant value.</param>
				/// <param name="allowUnpairedSurrogates">
				/// True to encode unpaired surrogates as specified, otherwise replace them with U+FFFD character.
				/// </param>
				/// <returns>Handle to the added or existing blob.</returns>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is null.</exception>
				public BlobHandle GetOrAddBlobUTF8(string value, bool allowUnpairedSurrogates = true)
				{
					PooledBlobBuilder instance = PooledBlobBuilder.GetInstance();
					instance.WriteUTF8(value, allowUnpairedSurrogates);
					BlobHandle orAddBlob = GetOrAddBlob(instance);
					instance.Free();
					return orAddBlob;
				}

				/// <summary>
				/// Encodes a debug document name and adds it to the Blob heap, if it's not there already.
				/// </summary>
				/// <param name="value">Document name.</param>
				/// <returns>
				/// Handle to the added or existing document name blob
				/// (see https://github.com/dotnet/runtime/blob/main/docs/design/specs/PortablePdb-Metadata.md#DocumentNameBlob).
				/// </returns>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is null.</exception>
				public BlobHandle GetOrAddDocumentName(string value)
				{
					if (value == null)
					{
						System.Reflection.Throw.ArgumentNull("value");
					}
					char c = ChooseSeparator(value);
					PooledBlobBuilder instance = PooledBlobBuilder.GetInstance();
					instance.WriteByte((byte)c);
					PooledBlobBuilder instance2 = PooledBlobBuilder.GetInstance();
					int num = 0;
					while (true)
					{
						int num2 = value.IndexOf(c, num);
						instance2.WriteUTF8(value, num, ((num2 >= 0) ? num2 : value.Length) - num, allowUnpairedSurrogates: true, prependSize: false);
						instance.WriteCompressedInteger(GetOrAddBlob(instance2).GetHeapOffset());
						if (num2 == -1)
						{
							break;
						}
						if (num2 == value.Length - 1)
						{
							instance.WriteByte(0);
							break;
						}
						instance2.Clear();
						num = num2 + 1;
					}
					instance2.Free();
					BlobHandle orAddBlob = GetOrAddBlob(instance);
					instance.Free();
					return orAddBlob;
				}

				private static char ChooseSeparator(string str)
				{
					int num = 0;
					int num2 = 0;
					for (int i = 0; i < str.Length; i++)
					{
						switch (str[i])
						{
							case '/':
								num++;
								break;
							case '\\':
								num2++;
								break;
						}
					}
					if (num < num2)
					{
						return '\\';
					}
					return '/';
				}

				/// <summary>
				/// Adds specified Guid to Guid heap, if it's not there already.
				/// </summary>
				/// <param name="guid">Guid to add.</param>
				/// <returns>Handle to the added or existing Guid.</returns>
				public GuidHandle GetOrAddGuid(Guid guid)
				{
					if (guid == Guid.Empty)
					{
						return default(GuidHandle);
					}
					if (_guids.TryGetValue(guid, out var value))
					{
						return value;
					}
					value = GetNewGuidHandle();
					_guids.Add(guid, value);
					_guidBuilder.WriteGuid(guid);
					return value;
				}

				/// <summary>
				/// Reserves space on the Guid heap for a GUID.
				/// </summary>
				/// <returns>
				/// Handle to the reserved Guid and a <see cref="T:System.Reflection.Metadata.Blob" /> representing the GUID blob as stored on the heap.
				/// </returns>
				/// <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">The remaining space on the heap is too small to fit the string.</exception>
				public ReservedBlob<GuidHandle> ReserveGuid()
				{
					GuidHandle newGuidHandle = GetNewGuidHandle();
					Blob content = _guidBuilder.ReserveBytes(16);
					return new ReservedBlob<GuidHandle>(newGuidHandle, content);
				}

				private GuidHandle GetNewGuidHandle()
				{
					return GuidHandle.FromIndex((_guidBuilder.Count >> 4) + 1);
				}

				/// <summary>
				/// Adds specified string to String heap, if it's not there already.
				/// </summary>
				/// <param name="value">Array containing the blob.</param>
				/// <returns>Handle to the added or existing blob.</returns>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is null.</exception>
				public StringHandle GetOrAddString(string value)
				{
					if (value == null)
					{
						System.Reflection.Throw.ArgumentNull("value");
					}
					StringHandle value2;
					if (value.Length == 0)
					{
						value2 = default(StringHandle);
					}
					else if (!_strings.TryGetValue(value, out value2))
					{
						value2 = StringHandle.FromWriterVirtualIndex(_strings.Count + 1);
						_strings.Add(value, value2);
					}
					return value2;
				}

				/// <summary>
				/// Reserves space on the User String heap for a string of specified length.
				/// </summary>
				/// <param name="length">The number of characters to reserve.</param>
				/// <returns>
				/// Handle to the reserved User String and a <see cref="T:System.Reflection.Metadata.Blob" /> representing the entire User String blob (including its length and terminal character).
				///
				/// Handle may be used in <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />.
				/// Use <see cref="M:System.Reflection.Metadata.BlobWriter.WriteUserString(System.String)" /> to fill in the blob content.
				/// </returns>
				/// <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">The remaining space on the heap is too small to fit the string.</exception>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length" /> is negative.</exception>
				public ReservedBlob<UserStringHandle> ReserveUserString(int length)
				{
					if (length < 0)
					{
						System.Reflection.Throw.ArgumentOutOfRange("length");
					}
					UserStringHandle newUserStringHandle = GetNewUserStringHandle();
					int userStringByteLength = System.Reflection.BlobUtilities.GetUserStringByteLength(length);
					Blob content = _userStringBuilder.ReserveBytes(BlobWriterImpl.GetCompressedIntegerSize(userStringByteLength) + userStringByteLength);
					return new ReservedBlob<UserStringHandle>(newUserStringHandle, content);
				}

				/// <summary>
				/// Adds specified string to User String heap, if it's not there already.
				/// </summary>
				/// <param name="value">String to add.</param>
				/// <returns>
				/// Handle to the added or existing string.
				/// May be used in <see cref="M:System.Reflection.Metadata.Ecma335.InstructionEncoder.LoadString(System.Reflection.Metadata.UserStringHandle)" />.
				/// </returns>
				/// <exception cref="T:System.Reflection.Metadata.ImageFormatLimitationException">The remaining space on the heap is too small to fit the string.</exception>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="value" /> is null.</exception>
				public UserStringHandle GetOrAddUserString(string value)
				{
					if (value == null)
					{
						System.Reflection.Throw.ArgumentNull("value");
					}
					if (!_userStrings.TryGetValue(value, out var value2))
					{
						value2 = GetNewUserStringHandle();
						_userStrings.Add(value, value2);
						_userStringBuilder.WriteUserString(value);
					}
					return value2;
				}

				private UserStringHandle GetNewUserStringHandle()
				{
					int num = _userStringHeapStartOffset + _userStringBuilder.Count;
					if (num >= 16777216)
					{
						System.Reflection.Throw.HeapSizeLimitExceeded(HeapIndex.UserString);
					}
					return UserStringHandle.FromOffset(num);
				}

				/// <summary>
				/// Fills in stringIndexMap with data from stringIndex and write to stringWriter.
				/// Releases stringIndex as the stringTable is sealed after this point.
				/// </summary>
				private static System.Collections.Immutable.ImmutableArray<int> SerializeStringHeap(BlobBuilder heapBuilder, Dictionary<string, StringHandle> strings, int stringHeapStartOffset)
				{
					List<KeyValuePair<string, StringHandle>> list = new List<KeyValuePair<string, StringHandle>>(strings);
					list.Sort(SuffixSort.Instance);
					int num = list.Count + 1;
					System.Collections.Immutable.ImmutableArray<int>.Builder builder = System.Collections.Immutable.ImmutableArray.CreateBuilder<int>(num);
					builder.Count = num;
					builder[0] = 0;
					heapBuilder.WriteByte(0);
					string text = string.Empty;
					foreach (KeyValuePair<string, StringHandle> item in list)
					{
						int num2 = stringHeapStartOffset + heapBuilder.Count;
						if (text.EndsWith(item.Key, StringComparison.Ordinal) && !System.Reflection.BlobUtilities.IsLowSurrogateChar(item.Key[0]))
						{
							builder[item.Value.GetWriterVirtualIndex()] = num2 - (System.Reflection.BlobUtilities.GetUTF8ByteCount(item.Key) + 1);
						}
						else
						{
							builder[item.Value.GetWriterVirtualIndex()] = num2;
							heapBuilder.WriteUTF8(item.Key, allowUnpairedSurrogates: false);
							heapBuilder.WriteByte(0);
						}
						text = item.Key;
					}
					return builder.MoveToImmutable();
				}

				internal void WriteHeapsTo(BlobBuilder builder, BlobBuilder stringHeap)
				{
					WriteAligned(stringHeap, builder);
					WriteAligned(_userStringBuilder, builder);
					WriteAligned(_guidBuilder, builder);
					WriteAlignedBlobHeap(builder);
				}

				private void WriteAlignedBlobHeap(BlobBuilder builder)
				{
					int num = BitArithmetic.Align(_blobHeapSize, 4) - _blobHeapSize;
					BlobWriter blobWriter = new BlobWriter(builder.ReserveBytes(_blobHeapSize + num));
					int blobHeapStartOffset = _blobHeapStartOffset;
					foreach (KeyValuePair<System.Collections.Immutable.ImmutableArray<byte>, BlobHandle> blob in _blobs)
					{
						int heapOffset = blob.Value.GetHeapOffset();
						System.Collections.Immutable.ImmutableArray<byte> key = blob.Key;
						blobWriter.Offset = ((heapOffset != 0) ? (heapOffset - blobHeapStartOffset) : 0);
						blobWriter.WriteCompressedInteger(key.Length);
						blobWriter.WriteBytes(key);
					}
					blobWriter.Offset = _blobHeapSize;
					blobWriter.WriteBytes(0, num);
				}

				private static void WriteAligned(BlobBuilder source, BlobBuilder target)
				{
					int count = source.Count;
					target.LinkSuffix(source);
					target.WriteBytes(0, BitArithmetic.Align(count, 4) - count);
				}
			}

			/// <summary>
			/// Provides extension methods for working with certain raw elements of the ECMA-335 metadata tables and heaps.
			/// </summary>
			public static class MetadataReaderExtensions
			{
				/// <summary>
				/// Returns the number of rows in the specified table.
				/// </summary>
				/// <exception cref="System.ArgumentNullException"><paramref name="reader" /> is null.</exception>
				/// <exception cref="System.ArgumentOutOfRangeException"><paramref name="tableIndex" /> is not a valid table index.</exception>
				public static int GetTableRowCount(this MetadataReader reader, TableIndex tableIndex)
				{
					if (reader == null)
					{
						System.Reflection.Throw.ArgumentNull("reader");
					}
					if ((int)tableIndex >= MetadataTokens.TableCount)
					{
						System.Reflection.Throw.TableIndexOutOfRange();
					}
					return reader.TableRowCounts[(uint)tableIndex];
				}

				/// <summary>
				/// Returns the size of a row in the specified table.
				/// </summary>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> is null.</exception>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="tableIndex" /> is not a valid table index.</exception>
				public static int GetTableRowSize(this MetadataReader reader, TableIndex tableIndex)
				{
					if (reader == null)
					{
						System.Reflection.Throw.ArgumentNull("reader");
					}
					return tableIndex switch
					{
						TableIndex.Module => reader.ModuleTable.RowSize,
						TableIndex.TypeRef => reader.TypeRefTable.RowSize,
						TableIndex.TypeDef => reader.TypeDefTable.RowSize,
						TableIndex.FieldPtr => reader.FieldPtrTable.RowSize,
						TableIndex.Field => reader.FieldTable.RowSize,
						TableIndex.MethodPtr => reader.MethodPtrTable.RowSize,
						TableIndex.MethodDef => reader.MethodDefTable.RowSize,
						TableIndex.ParamPtr => reader.ParamPtrTable.RowSize,
						TableIndex.Param => reader.ParamTable.RowSize,
						TableIndex.InterfaceImpl => reader.InterfaceImplTable.RowSize,
						TableIndex.MemberRef => reader.MemberRefTable.RowSize,
						TableIndex.Constant => reader.ConstantTable.RowSize,
						TableIndex.CustomAttribute => reader.CustomAttributeTable.RowSize,
						TableIndex.FieldMarshal => reader.FieldMarshalTable.RowSize,
						TableIndex.DeclSecurity => reader.DeclSecurityTable.RowSize,
						TableIndex.ClassLayout => reader.ClassLayoutTable.RowSize,
						TableIndex.FieldLayout => reader.FieldLayoutTable.RowSize,
						TableIndex.StandAloneSig => reader.StandAloneSigTable.RowSize,
						TableIndex.EventMap => reader.EventMapTable.RowSize,
						TableIndex.EventPtr => reader.EventPtrTable.RowSize,
						TableIndex.Event => reader.EventTable.RowSize,
						TableIndex.PropertyMap => reader.PropertyMapTable.RowSize,
						TableIndex.PropertyPtr => reader.PropertyPtrTable.RowSize,
						TableIndex.Property => reader.PropertyTable.RowSize,
						TableIndex.MethodSemantics => reader.MethodSemanticsTable.RowSize,
						TableIndex.MethodImpl => reader.MethodImplTable.RowSize,
						TableIndex.ModuleRef => reader.ModuleRefTable.RowSize,
						TableIndex.TypeSpec => reader.TypeSpecTable.RowSize,
						TableIndex.ImplMap => reader.ImplMapTable.RowSize,
						TableIndex.FieldRva => reader.FieldRvaTable.RowSize,
						TableIndex.EncLog => reader.EncLogTable.RowSize,
						TableIndex.EncMap => reader.EncMapTable.RowSize,
						TableIndex.Assembly => reader.AssemblyTable.RowSize,
						TableIndex.AssemblyProcessor => reader.AssemblyProcessorTable.RowSize,
						TableIndex.AssemblyOS => reader.AssemblyOSTable.RowSize,
						TableIndex.AssemblyRef => reader.AssemblyRefTable.RowSize,
						TableIndex.AssemblyRefProcessor => reader.AssemblyRefProcessorTable.RowSize,
						TableIndex.AssemblyRefOS => reader.AssemblyRefOSTable.RowSize,
						TableIndex.File => reader.FileTable.RowSize,
						TableIndex.ExportedType => reader.ExportedTypeTable.RowSize,
						TableIndex.ManifestResource => reader.ManifestResourceTable.RowSize,
						TableIndex.NestedClass => reader.NestedClassTable.RowSize,
						TableIndex.GenericParam => reader.GenericParamTable.RowSize,
						TableIndex.MethodSpec => reader.MethodSpecTable.RowSize,
						TableIndex.GenericParamConstraint => reader.GenericParamConstraintTable.RowSize,
						TableIndex.Document => reader.DocumentTable.RowSize,
						TableIndex.MethodDebugInformation => reader.MethodDebugInformationTable.RowSize,
						TableIndex.LocalScope => reader.LocalScopeTable.RowSize,
						TableIndex.LocalVariable => reader.LocalVariableTable.RowSize,
						TableIndex.LocalConstant => reader.LocalConstantTable.RowSize,
						TableIndex.ImportScope => reader.ImportScopeTable.RowSize,
						TableIndex.StateMachineMethod => reader.StateMachineMethodTable.RowSize,
						TableIndex.CustomDebugInformation => reader.CustomDebugInformationTable.RowSize,
						_ => throw new ArgumentOutOfRangeException("tableIndex"),
					};
				}

				/// <summary>
				/// Returns the offset from the start of metadata to the specified table.
				/// </summary>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> is null.</exception>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="tableIndex" /> is not a valid table index.</exception>
				public unsafe static int GetTableMetadataOffset(this MetadataReader reader, TableIndex tableIndex)
				{
					if (reader == null)
					{
						System.Reflection.Throw.ArgumentNull("reader");
					}
					return (int)(reader.GetTableMetadataBlock(tableIndex).Pointer - reader.Block.Pointer);
				}

				private static System.Reflection.Internal.MemoryBlock GetTableMetadataBlock(this MetadataReader reader, TableIndex tableIndex)
				{
					return tableIndex switch
					{
						TableIndex.Module => reader.ModuleTable.Block,
						TableIndex.TypeRef => reader.TypeRefTable.Block,
						TableIndex.TypeDef => reader.TypeDefTable.Block,
						TableIndex.FieldPtr => reader.FieldPtrTable.Block,
						TableIndex.Field => reader.FieldTable.Block,
						TableIndex.MethodPtr => reader.MethodPtrTable.Block,
						TableIndex.MethodDef => reader.MethodDefTable.Block,
						TableIndex.ParamPtr => reader.ParamPtrTable.Block,
						TableIndex.Param => reader.ParamTable.Block,
						TableIndex.InterfaceImpl => reader.InterfaceImplTable.Block,
						TableIndex.MemberRef => reader.MemberRefTable.Block,
						TableIndex.Constant => reader.ConstantTable.Block,
						TableIndex.CustomAttribute => reader.CustomAttributeTable.Block,
						TableIndex.FieldMarshal => reader.FieldMarshalTable.Block,
						TableIndex.DeclSecurity => reader.DeclSecurityTable.Block,
						TableIndex.ClassLayout => reader.ClassLayoutTable.Block,
						TableIndex.FieldLayout => reader.FieldLayoutTable.Block,
						TableIndex.StandAloneSig => reader.StandAloneSigTable.Block,
						TableIndex.EventMap => reader.EventMapTable.Block,
						TableIndex.EventPtr => reader.EventPtrTable.Block,
						TableIndex.Event => reader.EventTable.Block,
						TableIndex.PropertyMap => reader.PropertyMapTable.Block,
						TableIndex.PropertyPtr => reader.PropertyPtrTable.Block,
						TableIndex.Property => reader.PropertyTable.Block,
						TableIndex.MethodSemantics => reader.MethodSemanticsTable.Block,
						TableIndex.MethodImpl => reader.MethodImplTable.Block,
						TableIndex.ModuleRef => reader.ModuleRefTable.Block,
						TableIndex.TypeSpec => reader.TypeSpecTable.Block,
						TableIndex.ImplMap => reader.ImplMapTable.Block,
						TableIndex.FieldRva => reader.FieldRvaTable.Block,
						TableIndex.EncLog => reader.EncLogTable.Block,
						TableIndex.EncMap => reader.EncMapTable.Block,
						TableIndex.Assembly => reader.AssemblyTable.Block,
						TableIndex.AssemblyProcessor => reader.AssemblyProcessorTable.Block,
						TableIndex.AssemblyOS => reader.AssemblyOSTable.Block,
						TableIndex.AssemblyRef => reader.AssemblyRefTable.Block,
						TableIndex.AssemblyRefProcessor => reader.AssemblyRefProcessorTable.Block,
						TableIndex.AssemblyRefOS => reader.AssemblyRefOSTable.Block,
						TableIndex.File => reader.FileTable.Block,
						TableIndex.ExportedType => reader.ExportedTypeTable.Block,
						TableIndex.ManifestResource => reader.ManifestResourceTable.Block,
						TableIndex.NestedClass => reader.NestedClassTable.Block,
						TableIndex.GenericParam => reader.GenericParamTable.Block,
						TableIndex.MethodSpec => reader.MethodSpecTable.Block,
						TableIndex.GenericParamConstraint => reader.GenericParamConstraintTable.Block,
						TableIndex.Document => reader.DocumentTable.Block,
						TableIndex.MethodDebugInformation => reader.MethodDebugInformationTable.Block,
						TableIndex.LocalScope => reader.LocalScopeTable.Block,
						TableIndex.LocalVariable => reader.LocalVariableTable.Block,
						TableIndex.LocalConstant => reader.LocalConstantTable.Block,
						TableIndex.ImportScope => reader.ImportScopeTable.Block,
						TableIndex.StateMachineMethod => reader.StateMachineMethodTable.Block,
						TableIndex.CustomDebugInformation => reader.CustomDebugInformationTable.Block,
						_ => throw new ArgumentOutOfRangeException("tableIndex"),
					};
				}

				/// <summary>
				/// Returns the size of the specified heap.
				/// </summary>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> is null.</exception>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="heapIndex" /> is not a valid heap index.</exception>
				public static int GetHeapSize(this MetadataReader reader, HeapIndex heapIndex)
				{
					if (reader == null)
					{
						System.Reflection.Throw.ArgumentNull("reader");
					}
					return reader.GetMetadataBlock(heapIndex).Length;
				}

				/// <summary>
				/// Returns the offset from the start of metadata to the specified heap.
				/// </summary>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> is null.</exception>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="heapIndex" /> is not a valid heap index.</exception>
				public unsafe static int GetHeapMetadataOffset(this MetadataReader reader, HeapIndex heapIndex)
				{
					if (reader == null)
					{
						System.Reflection.Throw.ArgumentNull("reader");
					}
					return (int)(reader.GetMetadataBlock(heapIndex).Pointer - reader.Block.Pointer);
				}

				/// <summary>
				/// Returns the size of the specified heap.
				/// </summary>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> is null.</exception>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="heapIndex" /> is not a valid heap index.</exception>
				private static System.Reflection.Internal.MemoryBlock GetMetadataBlock(this MetadataReader reader, HeapIndex heapIndex)
				{
					return heapIndex switch
					{
						HeapIndex.UserString => reader.UserStringHeap.Block,
						HeapIndex.String => reader.StringHeap.Block,
						HeapIndex.Blob => reader.BlobHeap.Block,
						HeapIndex.Guid => reader.GuidHeap.Block,
						_ => throw new ArgumentOutOfRangeException("heapIndex"),
					};
				}

				/// <summary>
				/// Returns the a handle to the UserString that follows the given one in the UserString heap or a nil handle if it is the last one.
				/// </summary>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> is null.</exception>
				public static UserStringHandle GetNextHandle(this MetadataReader reader, UserStringHandle handle)
				{
					if (reader == null)
					{
						System.Reflection.Throw.ArgumentNull("reader");
					}
					return reader.UserStringHeap.GetNextHandle(handle);
				}

				/// <summary>
				/// Returns the a handle to the Blob that follows the given one in the Blob heap or a nil handle if it is the last one.
				/// </summary>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> is null.</exception>
				public static BlobHandle GetNextHandle(this MetadataReader reader, BlobHandle handle)
				{
					if (reader == null)
					{
						System.Reflection.Throw.ArgumentNull("reader");
					}
					return reader.BlobHeap.GetNextHandle(handle);
				}

				/// <summary>
				/// Returns the a handle to the String that follows the given one in the String heap or a nil handle if it is the last one.
				/// </summary>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> is null.</exception>
				public static StringHandle GetNextHandle(this MetadataReader reader, StringHandle handle)
				{
					if (reader == null)
					{
						System.Reflection.Throw.ArgumentNull("reader");
					}
					return reader.StringHeap.GetNextHandle(handle);
				}

				/// <summary>
				/// Enumerates entries of EnC log.
				/// </summary>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> is null.</exception>
				public static IEnumerable<EditAndContinueLogEntry> GetEditAndContinueLogEntries(this MetadataReader reader)
				{
					if (reader == null)
					{
						System.Reflection.Throw.ArgumentNull("reader");
					}
					return Core(reader);
					static IEnumerable<EditAndContinueLogEntry> Core(MetadataReader reader)
					{
						for (int rid = 1; rid <= reader.EncLogTable.NumberOfRows; rid++)
						{
							yield return new EditAndContinueLogEntry(new EntityHandle(reader.EncLogTable.GetToken(rid)), reader.EncLogTable.GetFuncCode(rid));
						}
					}
				}

				/// <summary>
				/// Enumerates entries of EnC map.
				/// </summary>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="reader" /> is null.</exception>
				public static IEnumerable<EntityHandle> GetEditAndContinueMapEntries(this MetadataReader reader)
				{
					if (reader == null)
					{
						System.Reflection.Throw.ArgumentNull("reader");
					}
					return Core(reader);
					static IEnumerable<EntityHandle> Core(MetadataReader reader)
					{
						for (int rid = 1; rid <= reader.EncMapTable.NumberOfRows; rid++)
						{
							yield return new EntityHandle(reader.EncMapTable.GetToken(rid));
						}
					}
				}

				/// <summary>
				/// Enumerate types that define one or more properties.
				/// </summary>
				/// <returns>
				/// The resulting sequence corresponds exactly to entries in PropertyMap table,
				/// i.e. n-th returned <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> is stored in n-th row of PropertyMap.
				/// </returns>
				public static IEnumerable<TypeDefinitionHandle> GetTypesWithProperties(this MetadataReader reader)
				{
					if (reader == null)
					{
						System.Reflection.Throw.ArgumentNull("reader");
					}
					return Core(reader);
					static IEnumerable<TypeDefinitionHandle> Core(MetadataReader reader)
					{
						for (int rid = 1; rid <= reader.PropertyMapTable.NumberOfRows; rid++)
						{
							yield return reader.PropertyMapTable.GetParentType(rid);
						}
					}
				}

				/// <summary>
				/// Enumerate types that define one or more events.
				/// </summary>
				/// <returns>
				/// The resulting sequence corresponds exactly to entries in EventMap table,
				/// i.e. n-th returned <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> is stored in n-th row of EventMap.
				/// </returns>
				public static IEnumerable<TypeDefinitionHandle> GetTypesWithEvents(this MetadataReader reader)
				{
					if (reader == null)
					{
						System.Reflection.Throw.ArgumentNull("reader");
					}
					return Core(reader);
					static IEnumerable<TypeDefinitionHandle> Core(MetadataReader reader)
					{
						for (int rid = 1; rid <= reader.EventMapTable.NumberOfRows; rid++)
						{
							yield return reader.EventMapTable.GetParentType(rid);
						}
					}
				}

				/// <summary>
				/// Given a type handle and a raw type kind found in a signature blob determines whether the target type is a value type or a reference type.
				/// </summary>
				public static SignatureTypeKind ResolveSignatureTypeKind(this MetadataReader reader, EntityHandle typeHandle, byte rawTypeKind)
				{
					if (reader == null)
					{
						System.Reflection.Throw.ArgumentNull("reader");
					}
					SignatureTypeKind signatureTypeKind = (SignatureTypeKind)rawTypeKind;
					switch (signatureTypeKind)
					{
						case SignatureTypeKind.Unknown:
							return SignatureTypeKind.Unknown;
						default:
							throw new ArgumentOutOfRangeException("rawTypeKind");
						case SignatureTypeKind.ValueType:
						case SignatureTypeKind.Class:
							switch (typeHandle.Kind)
							{
								case HandleKind.TypeDefinition:
									return signatureTypeKind;
								case HandleKind.TypeReference:
									{
										TypeRefSignatureTreatment signatureTreatment = reader.GetTypeReference((TypeReferenceHandle)typeHandle).SignatureTreatment;
										return signatureTreatment switch
										{
											TypeRefSignatureTreatment.ProjectedToClass => SignatureTypeKind.Class,
											TypeRefSignatureTreatment.ProjectedToValueType => SignatureTypeKind.ValueType,
											TypeRefSignatureTreatment.None => signatureTypeKind,
											_ => throw ExceptionUtilities.UnexpectedValue(signatureTreatment),
										};
									}
								case HandleKind.TypeSpecification:
									return SignatureTypeKind.Unknown;
								default:
									throw new ArgumentOutOfRangeException("typeHandle", System.SR.Format(MDCFR.Properties.Resources.UnexpectedHandleKind, typeHandle.Kind));
							}
					}
				}
			}

			/// <summary>
			/// Builder of a Metadata Root to be embedded in a Portable Executable image.
			/// </summary>
			/// <remarks>
			/// Metadata root constitutes of a metadata header followed by metadata streams (#~, #Strings, #US, #Guid and #Blob).
			/// </remarks>
			public sealed class MetadataRootBuilder
			{
				private const string DefaultMetadataVersionString = "v4.0.30319";

				internal static readonly System.Collections.Immutable.ImmutableArray<int> EmptyRowCounts = System.Collections.Immutable.ImmutableArray.Create<int>(new int[MetadataTokens.TableCount]);

				private readonly MetadataBuilder _tablesAndHeaps;

				private readonly SerializedMetadata _serializedMetadata;

				/// <summary>
				/// Metadata version string.
				/// </summary>
				public string MetadataVersion { get; }

				/// <summary>
				/// True to suppresses basic validation of metadata tables.
				/// The validation verifies that entries in the tables were added in order required by the ECMA specification.
				/// It does not enforce all specification requirements on metadata tables.
				/// </summary>
				public bool SuppressValidation { get; }

				/// <summary>
				/// Returns sizes of various metadata structures.
				/// </summary>
				public MetadataSizes Sizes => _serializedMetadata.Sizes;

				/// <summary>
				/// Creates a builder of a metadata root.
				/// </summary>
				/// <param name="tablesAndHeaps">
				/// Builder populated with metadata entities stored in tables and values stored in heaps.
				/// The entities and values will be enumerated when serializing the metadata root.
				/// </param>
				/// <param name="metadataVersion">
				/// The version string written to the metadata header. The default value is "v4.0.30319".
				/// </param>
				/// <param name="suppressValidation">
				/// True to suppresses basic validation of metadata tables during serialization.
				/// The validation verifies that entries in the tables were added in order required by the ECMA specification.
				/// It does not enforce all specification requirements on metadata tables.
				/// </param>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="tablesAndHeaps" /> is null.</exception>
				/// <exception cref="T:System.ArgumentException"><paramref name="metadataVersion" /> is too long (the number of bytes when UTF8-encoded must be less than 255).</exception>
				public MetadataRootBuilder(MetadataBuilder tablesAndHeaps, string? metadataVersion = null, bool suppressValidation = false)
				{
					if (tablesAndHeaps == null)
					{
						System.Reflection.Throw.ArgumentNull("tablesAndHeaps");
					}
					int num = ((metadataVersion != null) ? System.Reflection.BlobUtilities.GetUTF8ByteCount(metadataVersion) : "v4.0.30319".Length);
					if (num > 254)
					{
						System.Reflection.Throw.InvalidArgument(MDCFR.Properties.Resources.MetadataVersionTooLong, "metadataVersion");
					}
					_tablesAndHeaps = tablesAndHeaps;
					MetadataVersion = metadataVersion ?? "v4.0.30319";
					SuppressValidation = suppressValidation;
					_serializedMetadata = tablesAndHeaps.GetSerializedMetadata(EmptyRowCounts, num, isStandaloneDebugMetadata: false);
				}

				/// <summary>
				/// Serializes metadata root content into the given <see cref="T:System.Reflection.Metadata.BlobBuilder" />.
				/// </summary>
				/// <param name="builder">Builder to write to.</param>
				/// <param name="methodBodyStreamRva">
				/// The relative virtual address of the start of the method body stream.
				/// Used to calculate the final value of RVA fields of MethodDef table.
				/// </param>
				/// <param name="mappedFieldDataStreamRva">
				/// The relative virtual address of the start of the field init data stream.
				/// Used to calculate the final value of RVA fields of FieldRVA table.
				/// </param>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="builder" /> is null.</exception>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="methodBodyStreamRva" /> or <paramref name="mappedFieldDataStreamRva" /> is negative.</exception>
				/// <exception cref="T:System.InvalidOperationException">
				/// A metadata table is not ordered as required by the specification and <see cref="P:System.Reflection.Metadata.Ecma335.MetadataRootBuilder.SuppressValidation" /> is false.
				/// </exception>
				public void Serialize(BlobBuilder builder, int methodBodyStreamRva, int mappedFieldDataStreamRva)
				{
					if (builder == null)
					{
						System.Reflection.Throw.ArgumentNull("builder");
					}
					if (methodBodyStreamRva < 0)
					{
						System.Reflection.Throw.ArgumentOutOfRange("methodBodyStreamRva");
					}
					if (mappedFieldDataStreamRva < 0)
					{
						System.Reflection.Throw.ArgumentOutOfRange("mappedFieldDataStreamRva");
					}
					if (!SuppressValidation)
					{
						_tablesAndHeaps.ValidateOrder();
					}
					MetadataBuilder.SerializeMetadataHeader(builder, MetadataVersion, _serializedMetadata.Sizes);
					_tablesAndHeaps.SerializeMetadataTables(builder, _serializedMetadata.Sizes, _serializedMetadata.StringMap, methodBodyStreamRva, mappedFieldDataStreamRva);
					_tablesAndHeaps.WriteHeapsTo(builder, _serializedMetadata.StringHeap);
				}
			}

			/// <summary>
			/// Provides information on sizes of various metadata structures.
			/// </summary>
			public sealed class MetadataSizes
			{
				private const int StreamAlignment = 4;

				internal const int MaxMetadataVersionByteCount = 254;

				internal readonly int MetadataVersionPaddedLength;

				internal const ulong SortedDebugTables = 55169095435288576uL;

				internal readonly bool IsEncDelta;

				internal readonly bool IsCompressed;

				internal readonly bool BlobReferenceIsSmall;

				internal readonly bool StringReferenceIsSmall;

				internal readonly bool GuidReferenceIsSmall;

				internal readonly bool CustomAttributeTypeCodedIndexIsSmall;

				internal readonly bool DeclSecurityCodedIndexIsSmall;

				internal readonly bool EventDefReferenceIsSmall;

				internal readonly bool FieldDefReferenceIsSmall;

				internal readonly bool GenericParamReferenceIsSmall;

				internal readonly bool HasConstantCodedIndexIsSmall;

				internal readonly bool HasCustomAttributeCodedIndexIsSmall;

				internal readonly bool HasFieldMarshalCodedIndexIsSmall;

				internal readonly bool HasSemanticsCodedIndexIsSmall;

				internal readonly bool ImplementationCodedIndexIsSmall;

				internal readonly bool MemberForwardedCodedIndexIsSmall;

				internal readonly bool MemberRefParentCodedIndexIsSmall;

				internal readonly bool MethodDefReferenceIsSmall;

				internal readonly bool MethodDefOrRefCodedIndexIsSmall;

				internal readonly bool ModuleRefReferenceIsSmall;

				internal readonly bool ParameterReferenceIsSmall;

				internal readonly bool PropertyDefReferenceIsSmall;

				internal readonly bool ResolutionScopeCodedIndexIsSmall;

				internal readonly bool TypeDefReferenceIsSmall;

				internal readonly bool TypeDefOrRefCodedIndexIsSmall;

				internal readonly bool TypeOrMethodDefCodedIndexIsSmall;

				internal readonly bool DocumentReferenceIsSmall;

				internal readonly bool LocalVariableReferenceIsSmall;

				internal readonly bool LocalConstantReferenceIsSmall;

				internal readonly bool ImportScopeReferenceIsSmall;

				internal readonly bool HasCustomDebugInformationCodedIndexIsSmall;

				/// <summary>
				/// Non-empty tables that are emitted into the metadata table stream.
				/// </summary>
				internal readonly ulong PresentTablesMask;

				/// <summary>
				/// Non-empty tables stored in an external metadata table stream that might be referenced from the metadata table stream being emitted.
				/// </summary>
				internal readonly ulong ExternalTablesMask;

				/// <summary>
				/// Overall size of metadata stream storage (stream headers, table stream, heaps, additional streams).
				/// Aligned to <see cref="F:System.Reflection.Metadata.Ecma335.MetadataSizes.StreamAlignment" />.
				/// </summary>
				internal readonly int MetadataStreamStorageSize;

				/// <summary>
				/// The size of metadata stream (#- or #~). Aligned.
				/// Aligned to <see cref="F:System.Reflection.Metadata.Ecma335.MetadataSizes.StreamAlignment" />.
				/// </summary>
				internal readonly int MetadataTableStreamSize;

				/// <summary>
				/// The size of #Pdb stream. Aligned.
				/// </summary>
				internal readonly int StandalonePdbStreamSize;

				internal const int PdbIdSize = 20;

				/// <summary>
				/// Exact (unaligned) heap sizes.
				/// </summary>
				/// <remarks>Use <see cref="M:System.Reflection.Metadata.Ecma335.MetadataSizes.GetAlignedHeapSize(System.Reflection.Metadata.Ecma335.HeapIndex)" /> to get an aligned heap size.</remarks>
				public System.Collections.Immutable.ImmutableArray<int> HeapSizes { get; }

				/// <summary>
				/// Table row counts.
				/// </summary>
				public System.Collections.Immutable.ImmutableArray<int> RowCounts { get; }

				/// <summary>
				/// External table row counts.
				/// </summary>
				public System.Collections.Immutable.ImmutableArray<int> ExternalRowCounts { get; }

				internal bool IsStandaloneDebugMetadata => StandalonePdbStreamSize > 0;

				/// <summary>
				/// Metadata header size.
				/// Includes:
				/// - metadata storage signature
				/// - storage header
				/// - stream headers
				/// </summary>
				internal int MetadataHeaderSize => 16 + MetadataVersionPaddedLength + 2 + 2 + (IsStandaloneDebugMetadata ? 16 : 0) + 76 + (IsEncDelta ? 16 : 0);

				/// <summary>
				/// Total size of metadata (header and all streams).
				/// </summary>
				internal int MetadataSize => MetadataHeaderSize + MetadataStreamStorageSize;

				internal MetadataSizes(System.Collections.Immutable.ImmutableArray<int> rowCounts, System.Collections.Immutable.ImmutableArray<int> externalRowCounts, System.Collections.Immutable.ImmutableArray<int> heapSizes, int metadataVersionByteCount, bool isStandaloneDebugMetadata)
				{
					RowCounts = rowCounts;
					ExternalRowCounts = externalRowCounts;
					HeapSizes = heapSizes;
					MetadataVersionPaddedLength = BitArithmetic.Align(metadataVersionByteCount + 1, 4);
					PresentTablesMask = ComputeNonEmptyTableMask(rowCounts);
					ExternalTablesMask = ComputeNonEmptyTableMask(externalRowCounts);
					bool flag = IsPresent(TableIndex.EncLog) || IsPresent(TableIndex.EncMap);
					bool flag2 = !flag;
					IsEncDelta = flag;
					IsCompressed = flag2;
					BlobReferenceIsSmall = flag2 && heapSizes[2] <= 65535;
					StringReferenceIsSmall = flag2 && heapSizes[1] <= 65535;
					GuidReferenceIsSmall = flag2 && heapSizes[3] <= 65535;
					CustomAttributeTypeCodedIndexIsSmall = IsReferenceSmall(3, TableIndex.MethodDef, TableIndex.MemberRef);
					DeclSecurityCodedIndexIsSmall = IsReferenceSmall(2, TableIndex.MethodDef, TableIndex.TypeDef);
					EventDefReferenceIsSmall = IsReferenceSmall(0, TableIndex.Event);
					FieldDefReferenceIsSmall = IsReferenceSmall(0, TableIndex.Field);
					GenericParamReferenceIsSmall = IsReferenceSmall(0, TableIndex.GenericParam);
					HasConstantCodedIndexIsSmall = IsReferenceSmall(2, TableIndex.Field, TableIndex.Param, TableIndex.Property);
					HasCustomAttributeCodedIndexIsSmall = IsReferenceSmall(5, TableIndex.MethodDef, TableIndex.Field, TableIndex.TypeRef, TableIndex.TypeDef, TableIndex.Param, TableIndex.InterfaceImpl, TableIndex.MemberRef, TableIndex.Module, TableIndex.DeclSecurity, TableIndex.Property, TableIndex.Event, TableIndex.StandAloneSig, TableIndex.ModuleRef, TableIndex.TypeSpec, TableIndex.Assembly, TableIndex.AssemblyRef, TableIndex.File, TableIndex.ExportedType, TableIndex.ManifestResource, TableIndex.GenericParam, TableIndex.GenericParamConstraint, TableIndex.MethodSpec);
					HasFieldMarshalCodedIndexIsSmall = IsReferenceSmall(1, TableIndex.Field, TableIndex.Param);
					HasSemanticsCodedIndexIsSmall = IsReferenceSmall(1, TableIndex.Event, TableIndex.Property);
					ImplementationCodedIndexIsSmall = IsReferenceSmall(2, TableIndex.File, TableIndex.AssemblyRef, TableIndex.ExportedType);
					MemberForwardedCodedIndexIsSmall = IsReferenceSmall(1, TableIndex.Field, TableIndex.MethodDef);
					MemberRefParentCodedIndexIsSmall = IsReferenceSmall(3, TableIndex.TypeDef, TableIndex.TypeRef, TableIndex.ModuleRef, TableIndex.MethodDef, TableIndex.TypeSpec);
					MethodDefReferenceIsSmall = IsReferenceSmall(0, TableIndex.MethodDef);
					MethodDefOrRefCodedIndexIsSmall = IsReferenceSmall(1, TableIndex.MethodDef, TableIndex.MemberRef);
					ModuleRefReferenceIsSmall = IsReferenceSmall(0, TableIndex.ModuleRef);
					ParameterReferenceIsSmall = IsReferenceSmall(0, TableIndex.Param);
					PropertyDefReferenceIsSmall = IsReferenceSmall(0, TableIndex.Property);
					ResolutionScopeCodedIndexIsSmall = IsReferenceSmall(2, TableIndex.Module, TableIndex.ModuleRef, TableIndex.AssemblyRef, TableIndex.TypeRef);
					TypeDefReferenceIsSmall = IsReferenceSmall(0, TableIndex.TypeDef);
					TypeDefOrRefCodedIndexIsSmall = IsReferenceSmall(2, TableIndex.TypeDef, TableIndex.TypeRef, TableIndex.TypeSpec);
					TypeOrMethodDefCodedIndexIsSmall = IsReferenceSmall(1, TableIndex.TypeDef, TableIndex.MethodDef);
					DocumentReferenceIsSmall = IsReferenceSmall(0, TableIndex.Document);
					LocalVariableReferenceIsSmall = IsReferenceSmall(0, TableIndex.LocalVariable);
					LocalConstantReferenceIsSmall = IsReferenceSmall(0, TableIndex.LocalConstant);
					ImportScopeReferenceIsSmall = IsReferenceSmall(0, TableIndex.ImportScope);
					HasCustomDebugInformationCodedIndexIsSmall = IsReferenceSmall(5, TableIndex.MethodDef, TableIndex.Field, TableIndex.TypeRef, TableIndex.TypeDef, TableIndex.Param, TableIndex.InterfaceImpl, TableIndex.MemberRef, TableIndex.Module, TableIndex.DeclSecurity, TableIndex.Property, TableIndex.Event, TableIndex.StandAloneSig, TableIndex.ModuleRef, TableIndex.TypeSpec, TableIndex.Assembly, TableIndex.AssemblyRef, TableIndex.File, TableIndex.ExportedType, TableIndex.ManifestResource, TableIndex.GenericParam, TableIndex.GenericParamConstraint, TableIndex.MethodSpec, TableIndex.Document, TableIndex.LocalScope, TableIndex.LocalVariable, TableIndex.LocalConstant, TableIndex.ImportScope);
					int num = CalculateTableStreamHeaderSize();
					byte b = (byte)(BlobReferenceIsSmall ? 2 : 4);
					byte b2 = (byte)(StringReferenceIsSmall ? 2 : 4);
					byte b3 = (byte)(GuidReferenceIsSmall ? 2 : 4);
					byte b4 = (byte)(CustomAttributeTypeCodedIndexIsSmall ? 2 : 4);
					byte b5 = (byte)(DeclSecurityCodedIndexIsSmall ? 2 : 4);
					byte b6 = (byte)(EventDefReferenceIsSmall ? 2 : 4);
					byte b7 = (byte)(FieldDefReferenceIsSmall ? 2 : 4);
					byte b8 = (byte)(GenericParamReferenceIsSmall ? 2 : 4);
					byte b9 = (byte)(HasConstantCodedIndexIsSmall ? 2 : 4);
					byte b10 = (byte)(HasCustomAttributeCodedIndexIsSmall ? 2 : 4);
					byte b11 = (byte)(HasFieldMarshalCodedIndexIsSmall ? 2 : 4);
					byte b12 = (byte)(HasSemanticsCodedIndexIsSmall ? 2 : 4);
					byte b13 = (byte)(ImplementationCodedIndexIsSmall ? 2 : 4);
					byte b14 = (byte)(MemberForwardedCodedIndexIsSmall ? 2 : 4);
					byte b15 = (byte)(MemberRefParentCodedIndexIsSmall ? 2 : 4);
					byte b16 = (byte)(MethodDefReferenceIsSmall ? 2 : 4);
					byte b17 = (byte)(MethodDefOrRefCodedIndexIsSmall ? 2 : 4);
					byte b18 = (byte)(ModuleRefReferenceIsSmall ? 2 : 4);
					byte b19 = (byte)(ParameterReferenceIsSmall ? 2 : 4);
					byte b20 = (byte)(PropertyDefReferenceIsSmall ? 2 : 4);
					byte b21 = (byte)(ResolutionScopeCodedIndexIsSmall ? 2 : 4);
					byte b22 = (byte)(TypeDefReferenceIsSmall ? 2 : 4);
					byte b23 = (byte)(TypeDefOrRefCodedIndexIsSmall ? 2 : 4);
					byte b24 = (byte)(TypeOrMethodDefCodedIndexIsSmall ? 2 : 4);
					byte b25 = (byte)(DocumentReferenceIsSmall ? 2 : 4);
					byte b26 = (byte)(LocalVariableReferenceIsSmall ? 2 : 4);
					byte b27 = (byte)(LocalConstantReferenceIsSmall ? 2 : 4);
					byte b28 = (byte)(ImportScopeReferenceIsSmall ? 2 : 4);
					byte b29 = (byte)(HasCustomDebugInformationCodedIndexIsSmall ? 2 : 4);
					num += GetTableSize(TableIndex.Module, 2 + 3 * b3 + b2);
					num += GetTableSize(TableIndex.TypeRef, b21 + b2 + b2);
					num += GetTableSize(TableIndex.TypeDef, 4 + b2 + b2 + b23 + b7 + b16);
					num += GetTableSize(TableIndex.Field, 2 + b2 + b);
					num += GetTableSize(TableIndex.MethodDef, 8 + b2 + b + b19);
					num += GetTableSize(TableIndex.Param, 4 + b2);
					num += GetTableSize(TableIndex.InterfaceImpl, b22 + b23);
					num += GetTableSize(TableIndex.MemberRef, b15 + b2 + b);
					num += GetTableSize(TableIndex.Constant, 2 + b9 + b);
					num += GetTableSize(TableIndex.CustomAttribute, b10 + b4 + b);
					num += GetTableSize(TableIndex.FieldMarshal, b11 + b);
					num += GetTableSize(TableIndex.DeclSecurity, 2 + b5 + b);
					num += GetTableSize(TableIndex.ClassLayout, 6 + b22);
					num += GetTableSize(TableIndex.FieldLayout, 4 + b7);
					num += GetTableSize(TableIndex.StandAloneSig, b);
					num += GetTableSize(TableIndex.EventMap, b22 + b6);
					num += GetTableSize(TableIndex.Event, 2 + b2 + b23);
					num += GetTableSize(TableIndex.PropertyMap, b22 + b20);
					num += GetTableSize(TableIndex.Property, 2 + b2 + b);
					num += GetTableSize(TableIndex.MethodSemantics, 2 + b16 + b12);
					num += GetTableSize(TableIndex.MethodImpl, b22 + b17 + b17);
					num += GetTableSize(TableIndex.ModuleRef, b2);
					num += GetTableSize(TableIndex.TypeSpec, b);
					num += GetTableSize(TableIndex.ImplMap, 2 + b14 + b2 + b18);
					num += GetTableSize(TableIndex.FieldRva, 4 + b7);
					num += GetTableSize(TableIndex.EncLog, 8);
					num += GetTableSize(TableIndex.EncMap, 4);
					num += GetTableSize(TableIndex.Assembly, 16 + b + b2 + b2);
					num += GetTableSize(TableIndex.AssemblyRef, 12 + b + b2 + b2 + b);
					num += GetTableSize(TableIndex.File, 4 + b2 + b);
					num += GetTableSize(TableIndex.ExportedType, 8 + b2 + b2 + b13);
					num += GetTableSize(TableIndex.ManifestResource, 8 + b2 + b13);
					num += GetTableSize(TableIndex.NestedClass, b22 + b22);
					num += GetTableSize(TableIndex.GenericParam, 4 + b24 + b2);
					num += GetTableSize(TableIndex.MethodSpec, b17 + b);
					num += GetTableSize(TableIndex.GenericParamConstraint, b8 + b23);
					num += GetTableSize(TableIndex.Document, b + b3 + b + b3);
					num += GetTableSize(TableIndex.MethodDebugInformation, b25 + b);
					num += GetTableSize(TableIndex.LocalScope, b16 + b28 + b26 + b27 + 4 + 4);
					num += GetTableSize(TableIndex.LocalVariable, 4 + b2);
					num += GetTableSize(TableIndex.LocalConstant, b2 + b);
					num += GetTableSize(TableIndex.ImportScope, b28 + b);
					num += GetTableSize(TableIndex.StateMachineMethod, b16 + b16);
					num += GetTableSize(TableIndex.CustomDebugInformation, b29 + b3 + b);
					num = (MetadataTableStreamSize = BitArithmetic.Align(num + 1, 4)) + GetAlignedHeapSize(HeapIndex.String) + GetAlignedHeapSize(HeapIndex.UserString) + GetAlignedHeapSize(HeapIndex.Guid) + GetAlignedHeapSize(HeapIndex.Blob);
					StandalonePdbStreamSize = (isStandaloneDebugMetadata ? CalculateStandalonePdbStreamSize() : 0);
					num += StandalonePdbStreamSize;
					MetadataStreamStorageSize = num;
				}

				internal bool IsPresent(TableIndex table)
				{
					return (PresentTablesMask & (ulong)(1L << (int)table)) != 0;
				}

				internal static int GetMetadataStreamHeaderSize(string streamName)
				{
					return 8 + BitArithmetic.Align(streamName.Length + 1, 4);
				}

				/// <summary>
				/// Returns aligned size of the specified heap.
				/// </summary>
				public int GetAlignedHeapSize(HeapIndex index)
				{
					if (index < HeapIndex.UserString || (int)index > HeapSizes.Length)
					{
						System.Reflection.Throw.ArgumentOutOfRange("index");
					}
					return BitArithmetic.Align(HeapSizes[(int)index], 4);
				}

				internal int CalculateTableStreamHeaderSize()
				{
					int num = 24;
					for (int i = 0; i < RowCounts.Length; i++)
					{
						if (((ulong)(1L << i) & PresentTablesMask) != 0L)
						{
							num += 4;
						}
					}
					return num;
				}

				internal int CalculateStandalonePdbStreamSize()
				{
					return 32 + BitArithmetic.CountBits(ExternalTablesMask) * 4;
				}

				private static ulong ComputeNonEmptyTableMask(System.Collections.Immutable.ImmutableArray<int> rowCounts)
				{
					ulong num = 0uL;
					for (int i = 0; i < rowCounts.Length; i++)
					{
						if (rowCounts[i] > 0)
						{
							num |= (ulong)(1L << i);
						}
					}
					return num;
				}

				private int GetTableSize(TableIndex index, int rowSize)
				{
					return RowCounts[(int)index] * rowSize;
				}

				private bool IsReferenceSmall(int tagBitSize, params TableIndex[] tables)
				{
					if (IsCompressed)
					{
						return ReferenceFits(16 - tagBitSize, tables);
					}
					return false;
				}

				private bool ReferenceFits(int bitCount, TableIndex[] tables)
				{
					int num = (1 << bitCount) - 1;
					foreach (TableIndex index in tables)
					{
						if (RowCounts[(int)index] + ExternalRowCounts[(int)index] > num)
						{
							return false;
						}
					}
					return true;
				}
			}

			internal static class MetadataStreamConstants
			{
				internal const int SizeOfMetadataTableHeader = 24;

				internal const uint LargeTableRowCount = 65536u;
			}

			internal enum MetadataStreamKind { Illegal, Compressed, Uncompressed }

			public static class MetadataTokens
			{
				/// <summary>
				/// Maximum number of tables that can be present in Ecma335 metadata.
				/// </summary>
				public static readonly int TableCount = 64;

				/// <summary>
				/// Maximum number of tables that can be present in Ecma335 metadata.
				/// </summary>
				public static readonly int HeapCount = 4;

				/// <summary>
				/// Returns the row number of a metadata table entry that corresponds
				/// to the specified <paramref name="handle" /> in the context of <paramref name="reader" />.
				/// </summary>
				/// <returns>One based row number.</returns>
				/// <exception cref="T:System.ArgumentException">The <paramref name="handle" /> is not a valid metadata table handle.</exception>
				public static int GetRowNumber(this MetadataReader reader, EntityHandle handle)
				{
					if (handle.IsVirtual)
					{
						return MapVirtualHandleRowId(reader, handle);
					}
					return handle.RowId;
				}

				/// <summary>
				/// Returns the offset of metadata heap data that corresponds
				/// to the specified <paramref name="handle" /> in the context of <paramref name="reader" />.
				/// </summary>
				/// <returns>Zero based offset, or -1 if <paramref name="handle" /> isn't a metadata heap handle.</returns>
				/// <exception cref="T:System.NotSupportedException">The operation is not supported for the specified <paramref name="handle" />.</exception>
				/// <exception cref="T:System.ArgumentException">The <paramref name="handle" /> is invalid.</exception>
				public static int GetHeapOffset(this MetadataReader reader, Handle handle)
				{
					if (!handle.IsHeapHandle)
					{
						System.Reflection.Throw.HeapHandleRequired();
					}
					if (handle.IsVirtual)
					{
						return MapVirtualHandleRowId(reader, handle);
					}
					return handle.Offset;
				}

				/// <summary>
				/// Returns the metadata token of the specified <paramref name="handle" /> in the context of <paramref name="reader" />.
				/// </summary>
				/// <returns>Metadata token.</returns>
				/// <exception cref="T:System.NotSupportedException">The operation is not supported for the specified <paramref name="handle" />.</exception>
				public static int GetToken(this MetadataReader reader, EntityHandle handle)
				{
					if (handle.IsVirtual)
					{
						return (int)handle.Type | MapVirtualHandleRowId(reader, handle);
					}
					return handle.Token;
				}

				/// <summary>
				/// Returns the metadata token of the specified <paramref name="handle" /> in the context of <paramref name="reader" />.
				/// </summary>
				/// <returns>Metadata token.</returns>
				/// <exception cref="T:System.ArgumentException">
				/// Handle represents a metadata entity that doesn't have a token.
				/// A token can only be retrieved for a metadata table handle or a heap handle of type <see cref="F:System.Reflection.Metadata.HandleKind.UserString" />.
				/// </exception>
				/// <exception cref="T:System.NotSupportedException">The operation is not supported for the specified <paramref name="handle" />.</exception>
				public static int GetToken(this MetadataReader reader, Handle handle)
				{
					if (!handle.IsEntityOrUserStringHandle)
					{
						System.Reflection.Throw.EntityOrUserStringHandleRequired();
					}
					if (handle.IsVirtual)
					{
						return (int)handle.EntityHandleType | MapVirtualHandleRowId(reader, handle);
					}
					return handle.Token;
				}

				private static int MapVirtualHandleRowId(MetadataReader reader, Handle handle)
				{
					switch (handle.Kind)
					{
						case HandleKind.AssemblyReference:
							return reader.AssemblyRefTable.NumberOfNonVirtualRows + 1 + handle.RowId;
						case HandleKind.Blob:
						case HandleKind.String:
							throw new NotSupportedException(MDCFR.Properties.Resources.CantGetOffsetForVirtualHeapHandle);
						default:
							System.Reflection.Throw.InvalidArgument_UnexpectedHandleKind(handle.Kind);
							return 0;
					}
				}

				/// <summary>
				/// Returns the row number of a metadata table entry that corresponds
				/// to the specified <paramref name="handle" />.
				/// </summary>
				/// <returns>
				/// One based row number, or -1 if <paramref name="handle" /> can only be interpreted in a context of a specific <see cref="T:System.Reflection.Metadata.MetadataReader" />.
				/// See <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)" />.
				/// </returns>
				public static int GetRowNumber(EntityHandle handle)
				{
					if (!handle.IsVirtual)
					{
						return handle.RowId;
					}
					return -1;
				}

				/// <summary>
				/// Returns the offset of metadata heap data that corresponds
				/// to the specified <paramref name="handle" />.
				/// </summary>
				/// <returns>
				/// An offset in the corresponding heap, or -1 if <paramref name="handle" /> can only be interpreted in a context of a specific <see cref="T:System.Reflection.Metadata.MetadataReader" /> or <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" />.
				/// See <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)" />.
				/// </returns>
				public static int GetHeapOffset(Handle handle)
				{
					if (!handle.IsHeapHandle)
					{
						System.Reflection.Throw.HeapHandleRequired();
					}
					if (handle.IsVirtual)
					{
						return -1;
					}
					return handle.Offset;
				}

				/// <summary>
				/// Returns the offset of metadata heap data that corresponds
				/// to the specified <paramref name="handle" />.
				/// </summary>
				/// <returns>
				/// Zero based offset, or -1 if <paramref name="handle" /> can only be interpreted in a context of a specific <see cref="T:System.Reflection.Metadata.MetadataReader" /> or <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" />.
				/// See <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)" />.
				/// </returns>
				public static int GetHeapOffset(BlobHandle handle)
				{
					if (!handle.IsVirtual)
					{
						return handle.GetHeapOffset();
					}
					return -1;
				}

				/// <summary>
				/// Returns the offset of metadata heap data that corresponds
				/// to the specified <paramref name="handle" />.
				/// </summary>
				/// <returns>
				/// 1-based index into the #Guid heap. Unlike other heaps, which are essentially byte arrays, the #Guid heap is an array of 16-byte GUIDs.
				/// </returns>
				public static int GetHeapOffset(GuidHandle handle)
				{
					return handle.Index;
				}

				/// <summary>
				/// Returns the offset of metadata heap data that corresponds
				/// to the specified <paramref name="handle" />.
				/// </summary>
				/// <returns>
				/// Zero based offset.
				/// </returns>
				public static int GetHeapOffset(UserStringHandle handle)
				{
					return handle.GetHeapOffset();
				}

				/// <summary>
				/// Returns the offset of metadata heap data that corresponds
				/// to the specified <paramref name="handle" />.
				/// </summary>
				/// <returns>
				/// Zero based offset, or -1 if <paramref name="handle" /> can only be interpreted in a context of a specific <see cref="T:System.Reflection.Metadata.MetadataReader" /> or <see cref="T:System.Reflection.Metadata.Ecma335.MetadataBuilder" />.
				/// See <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)" />.
				/// </returns>
				public static int GetHeapOffset(StringHandle handle)
				{
					if (!handle.IsVirtual)
					{
						return handle.GetHeapOffset();
					}
					return -1;
				}

				/// <summary>
				/// Returns the metadata token of the specified <paramref name="handle" />.
				/// </summary>
				/// <returns>
				/// Metadata token, or 0 if <paramref name="handle" /> can only be interpreted in a context of a specific <see cref="T:System.Reflection.Metadata.MetadataReader" />.
				/// See <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)" />.
				/// </returns>
				/// <exception cref="T:System.ArgumentException">
				/// Handle represents a metadata entity that doesn't have a token.
				/// A token can only be retrieved for a metadata table handle or a heap handle of type <see cref="F:System.Reflection.Metadata.HandleKind.UserString" />.
				/// </exception>
				public static int GetToken(Handle handle)
				{
					if (!handle.IsEntityOrUserStringHandle)
					{
						System.Reflection.Throw.EntityOrUserStringHandleRequired();
					}
					if (handle.IsVirtual)
					{
						return 0;
					}
					return handle.Token;
				}

				/// <summary>
				/// Returns the metadata token of the specified <paramref name="handle" />.
				/// </summary>
				/// <returns>
				/// Metadata token, or 0 if <paramref name="handle" /> can only be interpreted in a context of a specific <see cref="T:System.Reflection.Metadata.MetadataReader" />.
				/// See <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)" />.
				/// </returns>
				public static int GetToken(EntityHandle handle)
				{
					if (!handle.IsVirtual)
					{
						return handle.Token;
					}
					return 0;
				}

				/// <summary>
				/// Gets the <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" /> of the table corresponding to the specified <see cref="T:System.Reflection.Metadata.HandleKind" />.
				/// </summary>
				/// <param name="type">Handle type.</param>
				/// <param name="index">Table index.</param>
				/// <returns>True if the handle type corresponds to an Ecma335 or Portable PDB table, false otherwise.</returns>
				public static bool TryGetTableIndex(HandleKind type, out TableIndex index)
				{
					if ((int)type < TableCount && ((1L << (int)type) & 0xFF1FC9FFFFFFFFL) != 0L)
					{
						index = (TableIndex)type;
						return true;
					}
					index = TableIndex.Module;
					return false;
				}

				/// <summary>
				/// Gets the <see cref="T:System.Reflection.Metadata.Ecma335.HeapIndex" /> of the heap corresponding to the specified <see cref="T:System.Reflection.Metadata.HandleKind" />.
				/// </summary>
				/// <param name="type">Handle type.</param>
				/// <param name="index">Heap index.</param>
				/// <returns>True if the handle type corresponds to an Ecma335 heap, false otherwise.</returns>
				public static bool TryGetHeapIndex(HandleKind type, out HeapIndex index)
				{
					switch (type)
					{
						case HandleKind.UserString:
							index = HeapIndex.UserString;
							return true;
						case HandleKind.String:
						case HandleKind.NamespaceDefinition:
							index = HeapIndex.String;
							return true;
						case HandleKind.Blob:
							index = HeapIndex.Blob;
							return true;
						case HandleKind.Guid:
							index = HeapIndex.Guid;
							return true;
						default:
							index = HeapIndex.UserString;
							return false;
					}
				}

				/// <summary>
				/// Creates a handle from a token value.
				/// </summary>
				/// <exception cref="T:System.ArgumentException">
				/// <paramref name="token" /> is not a valid metadata token.
				/// It must encode a metadata table entity or an offset in <see cref="F:System.Reflection.Metadata.HandleKind.UserString" /> heap.
				/// </exception>
				public static Handle Handle(int token)
				{
					if (!System.Reflection.Metadata.Ecma335.TokenTypeIds.IsEntityOrUserStringToken((uint)token))
					{
						System.Reflection.Throw.InvalidToken();
					}
					return System.Reflection.Metadata.Handle.FromVToken((uint)token);
				}

				/// <summary>
				/// Creates an entity handle from a token value.
				/// </summary>
				/// <exception cref="T:System.ArgumentException"><paramref name="token" /> is not a valid metadata entity token.</exception>
				public static EntityHandle EntityHandle(int token)
				{
					if (!System.Reflection.Metadata.Ecma335.TokenTypeIds.IsEntityToken((uint)token))
					{
						System.Reflection.Throw.InvalidToken();
					}
					return new EntityHandle((uint)token);
				}

				/// <summary>
				/// Creates an <see cref="T:System.Reflection.Metadata.EntityHandle" /> from a token value.
				/// </summary>
				/// <exception cref="T:System.ArgumentException">
				/// <paramref name="tableIndex" /> is not a valid table index.</exception>
				public static EntityHandle EntityHandle(TableIndex tableIndex, int rowNumber)
				{
					return Handle(tableIndex, rowNumber);
				}

				/// <summary>
				/// Creates an <see cref="T:System.Reflection.Metadata.EntityHandle" /> from a token value.
				/// </summary>
				/// <exception cref="T:System.ArgumentException">
				/// <paramref name="tableIndex" /> is not a valid table index.</exception>
				public static EntityHandle Handle(TableIndex tableIndex, int rowNumber)
				{
					int vToken = (int)((uint)tableIndex << 24) | rowNumber;
					if (!System.Reflection.Metadata.Ecma335.TokenTypeIds.IsEntityOrUserStringToken((uint)vToken))
					{
						System.Reflection.Throw.TableIndexOutOfRange();
					}
					return new EntityHandle((uint)vToken);
				}

				private static int ToRowId(int rowNumber)
				{
					return rowNumber & 0xFFFFFF;
				}

				public static MethodDefinitionHandle MethodDefinitionHandle(int rowNumber)
				{
					return System.Reflection.Metadata.MethodDefinitionHandle.FromRowId(ToRowId(rowNumber));
				}

				public static MethodImplementationHandle MethodImplementationHandle(int rowNumber)
				{
					return System.Reflection.Metadata.MethodImplementationHandle.FromRowId(ToRowId(rowNumber));
				}

				public static MethodSpecificationHandle MethodSpecificationHandle(int rowNumber)
				{
					return System.Reflection.Metadata.MethodSpecificationHandle.FromRowId(ToRowId(rowNumber));
				}

				public static TypeDefinitionHandle TypeDefinitionHandle(int rowNumber)
				{
					return System.Reflection.Metadata.TypeDefinitionHandle.FromRowId(ToRowId(rowNumber));
				}

				public static ExportedTypeHandle ExportedTypeHandle(int rowNumber)
				{
					return System.Reflection.Metadata.ExportedTypeHandle.FromRowId(ToRowId(rowNumber));
				}

				public static TypeReferenceHandle TypeReferenceHandle(int rowNumber)
				{
					return System.Reflection.Metadata.TypeReferenceHandle.FromRowId(ToRowId(rowNumber));
				}

				public static TypeSpecificationHandle TypeSpecificationHandle(int rowNumber)
				{
					return System.Reflection.Metadata.TypeSpecificationHandle.FromRowId(ToRowId(rowNumber));
				}

				public static InterfaceImplementationHandle InterfaceImplementationHandle(int rowNumber)
				{
					return System.Reflection.Metadata.InterfaceImplementationHandle.FromRowId(ToRowId(rowNumber));
				}

				public static MemberReferenceHandle MemberReferenceHandle(int rowNumber)
				{
					return System.Reflection.Metadata.MemberReferenceHandle.FromRowId(ToRowId(rowNumber));
				}

				public static FieldDefinitionHandle FieldDefinitionHandle(int rowNumber)
				{
					return System.Reflection.Metadata.FieldDefinitionHandle.FromRowId(ToRowId(rowNumber));
				}

				public static EventDefinitionHandle EventDefinitionHandle(int rowNumber)
				{
					return System.Reflection.Metadata.EventDefinitionHandle.FromRowId(ToRowId(rowNumber));
				}

				public static PropertyDefinitionHandle PropertyDefinitionHandle(int rowNumber)
				{
					return System.Reflection.Metadata.PropertyDefinitionHandle.FromRowId(ToRowId(rowNumber));
				}

				public static StandaloneSignatureHandle StandaloneSignatureHandle(int rowNumber)
				{
					return System.Reflection.Metadata.StandaloneSignatureHandle.FromRowId(ToRowId(rowNumber));
				}

				public static ParameterHandle ParameterHandle(int rowNumber)
				{
					return System.Reflection.Metadata.ParameterHandle.FromRowId(ToRowId(rowNumber));
				}

				public static GenericParameterHandle GenericParameterHandle(int rowNumber)
				{
					return System.Reflection.Metadata.GenericParameterHandle.FromRowId(ToRowId(rowNumber));
				}

				public static GenericParameterConstraintHandle GenericParameterConstraintHandle(int rowNumber)
				{
					return System.Reflection.Metadata.GenericParameterConstraintHandle.FromRowId(ToRowId(rowNumber));
				}

				public static ModuleReferenceHandle ModuleReferenceHandle(int rowNumber)
				{
					return System.Reflection.Metadata.ModuleReferenceHandle.FromRowId(ToRowId(rowNumber));
				}

				public static AssemblyReferenceHandle AssemblyReferenceHandle(int rowNumber)
				{
					return System.Reflection.Metadata.AssemblyReferenceHandle.FromRowId(ToRowId(rowNumber));
				}

				public static CustomAttributeHandle CustomAttributeHandle(int rowNumber)
				{
					return System.Reflection.Metadata.CustomAttributeHandle.FromRowId(ToRowId(rowNumber));
				}

				public static DeclarativeSecurityAttributeHandle DeclarativeSecurityAttributeHandle(int rowNumber)
				{
					return System.Reflection.Metadata.DeclarativeSecurityAttributeHandle.FromRowId(ToRowId(rowNumber));
				}

				public static ConstantHandle ConstantHandle(int rowNumber)
				{
					return System.Reflection.Metadata.ConstantHandle.FromRowId(ToRowId(rowNumber));
				}

				public static ManifestResourceHandle ManifestResourceHandle(int rowNumber)
				{
					return System.Reflection.Metadata.ManifestResourceHandle.FromRowId(ToRowId(rowNumber));
				}

				public static AssemblyFileHandle AssemblyFileHandle(int rowNumber)
				{
					return System.Reflection.Metadata.AssemblyFileHandle.FromRowId(ToRowId(rowNumber));
				}

				public static DocumentHandle DocumentHandle(int rowNumber)
				{
					return System.Reflection.Metadata.DocumentHandle.FromRowId(ToRowId(rowNumber));
				}

				public static MethodDebugInformationHandle MethodDebugInformationHandle(int rowNumber)
				{
					return System.Reflection.Metadata.MethodDebugInformationHandle.FromRowId(ToRowId(rowNumber));
				}

				public static LocalScopeHandle LocalScopeHandle(int rowNumber)
				{
					return System.Reflection.Metadata.LocalScopeHandle.FromRowId(ToRowId(rowNumber));
				}

				public static LocalVariableHandle LocalVariableHandle(int rowNumber)
				{
					return System.Reflection.Metadata.LocalVariableHandle.FromRowId(ToRowId(rowNumber));
				}

				public static LocalConstantHandle LocalConstantHandle(int rowNumber)
				{
					return System.Reflection.Metadata.LocalConstantHandle.FromRowId(ToRowId(rowNumber));
				}

				public static ImportScopeHandle ImportScopeHandle(int rowNumber)
				{
					return System.Reflection.Metadata.ImportScopeHandle.FromRowId(ToRowId(rowNumber));
				}

				public static CustomDebugInformationHandle CustomDebugInformationHandle(int rowNumber)
				{
					return System.Reflection.Metadata.CustomDebugInformationHandle.FromRowId(ToRowId(rowNumber));
				}

				public static UserStringHandle UserStringHandle(int offset)
				{
					return System.Reflection.Metadata.UserStringHandle.FromOffset(offset & 0xFFFFFF);
				}

				public static StringHandle StringHandle(int offset)
				{
					return System.Reflection.Metadata.StringHandle.FromOffset(offset);
				}

				public static BlobHandle BlobHandle(int offset)
				{
					return System.Reflection.Metadata.BlobHandle.FromOffset(offset);
				}

				public static GuidHandle GuidHandle(int offset)
				{
					return System.Reflection.Metadata.GuidHandle.FromIndex(offset);
				}

				public static DocumentNameBlobHandle DocumentNameBlobHandle(int offset)
				{
					return System.Reflection.Metadata.DocumentNameBlobHandle.FromOffset(offset);
				}
			}

			internal static class MetadataWriterUtilities
			{
				public static SignatureTypeCode GetConstantTypeCode(object? value)
				{
					if (value == null)
					{
						return (SignatureTypeCode)18;
					}
					if (value.GetType() == typeof(int))
					{
						return SignatureTypeCode.Int32;
					}
					if (value.GetType() == typeof(string))
					{
						return SignatureTypeCode.String;
					}
					if (value.GetType() == typeof(bool))
					{
						return SignatureTypeCode.Boolean;
					}
					if (value.GetType() == typeof(char))
					{
						return SignatureTypeCode.Char;
					}
					if (value.GetType() == typeof(byte))
					{
						return SignatureTypeCode.Byte;
					}
					if (value.GetType() == typeof(long))
					{
						return SignatureTypeCode.Int64;
					}
					if (value.GetType() == typeof(double))
					{
						return SignatureTypeCode.Double;
					}
					if (value.GetType() == typeof(short))
					{
						return SignatureTypeCode.Int16;
					}
					if (value.GetType() == typeof(ushort))
					{
						return SignatureTypeCode.UInt16;
					}
					if (value.GetType() == typeof(uint))
					{
						return SignatureTypeCode.UInt32;
					}
					if (value.GetType() == typeof(sbyte))
					{
						return SignatureTypeCode.SByte;
					}
					if (value.GetType() == typeof(ulong))
					{
						return SignatureTypeCode.UInt64;
					}
					if (value.GetType() == typeof(float))
					{
						return SignatureTypeCode.Single;
					}
					throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.InvalidConstantValueOfType, value.GetType()), "value");
				}

				internal static void SerializeRowCounts(BlobBuilder writer, System.Collections.Immutable.ImmutableArray<int> rowCounts)
				{
					for (int i = 0; i < rowCounts.Length; i++)
					{
						int num = rowCounts[i];
						if (num > 0)
						{
							writer.WriteInt32(num);
						}
					}
				}
			}

			/// <summary>
			/// Method body attributes.
			/// </summary>
			[Flags]
			public enum MethodBodyAttributes
			{
				/// <summary>
				/// No local memory initialization is performed.
				/// </summary>
				None = 0,
				/// <summary>
				/// Zero-initialize any locals the method defines and dynamically allocated local memory.
				/// </summary>
				InitLocals = 1
			}

			/// <summary>
			/// Encodes method body stream.
			/// </summary>
			public readonly struct MethodBodyStreamEncoder
			{
				public readonly struct MethodBody
				{
					/// <summary>
					/// Offset of the encoded method body in method body stream.
					/// </summary>
					public int Offset { get; }

					/// <summary>
					/// Blob reserved for instructions.
					/// </summary>
					public Blob Instructions { get; }

					/// <summary>
					/// Use to encode exception regions to the method body.
					/// </summary>
					public ExceptionRegionEncoder ExceptionRegions { get; }

					internal MethodBody(int bodyOffset, Blob instructions, ExceptionRegionEncoder exceptionRegions)
					{
						Offset = bodyOffset;
						Instructions = instructions;
						ExceptionRegions = exceptionRegions;
					}
				}

				public BlobBuilder Builder { get; }

				public MethodBodyStreamEncoder(BlobBuilder builder)
				{
					if (builder == null)
					{
						System.Reflection.Throw.BuilderArgumentNull();
					}
					if (builder.Count % 4 != 0)
					{
						throw new ArgumentException(MDCFR.Properties.Resources.BuilderMustAligned, "builder");
					}
					Builder = builder;
				}

				/// <summary>
				/// Encodes a method body and adds it to the method body stream.
				/// </summary>
				/// <param name="codeSize">Number of bytes to be reserved for instructions.</param>
				/// <param name="maxStack">Max stack.</param>
				/// <param name="exceptionRegionCount">Number of exception regions.</param>
				/// <param name="hasSmallExceptionRegions">True if the exception regions should be encoded in 'small' format.</param>
				/// <param name="localVariablesSignature">Local variables signature handle.</param>
				/// <param name="attributes">Attributes.</param>
				/// <returns>The offset of the encoded body within the method body stream.</returns>
				/// <exception cref="T:System.ArgumentOutOfRangeException">
				/// <paramref name="codeSize" />, <paramref name="exceptionRegionCount" />, or <paramref name="maxStack" /> is out of allowed range.
				/// </exception>
				public MethodBody AddMethodBody(int codeSize, int maxStack, int exceptionRegionCount, bool hasSmallExceptionRegions, StandaloneSignatureHandle localVariablesSignature, MethodBodyAttributes attributes)
				{
					return AddMethodBody(codeSize, maxStack, exceptionRegionCount, hasSmallExceptionRegions, localVariablesSignature, attributes, hasDynamicStackAllocation: false);
				}

				/// <summary>
				/// Encodes a method body and adds it to the method body stream.
				/// </summary>
				/// <param name="codeSize">Number of bytes to be reserved for instructions.</param>
				/// <param name="maxStack">Max stack.</param>
				/// <param name="exceptionRegionCount">Number of exception regions.</param>
				/// <param name="hasSmallExceptionRegions">True if the exception regions should be encoded in 'small' format.</param>
				/// <param name="localVariablesSignature">Local variables signature handle.</param>
				/// <param name="attributes">Attributes.</param>
				/// <param name="hasDynamicStackAllocation">True if the method allocates from dynamic local memory pool (<c>localloc</c> instruction).</param>
				/// <returns>The offset of the encoded body within the method body stream.</returns>
				/// <exception cref="T:System.ArgumentOutOfRangeException">
				/// <paramref name="codeSize" />, <paramref name="exceptionRegionCount" />, or <paramref name="maxStack" /> is out of allowed range.
				/// </exception>
				public MethodBody AddMethodBody(int codeSize, int maxStack = 8, int exceptionRegionCount = 0, bool hasSmallExceptionRegions = true, StandaloneSignatureHandle localVariablesSignature = default(StandaloneSignatureHandle), MethodBodyAttributes attributes = MethodBodyAttributes.InitLocals, bool hasDynamicStackAllocation = false)
				{
					if (codeSize < 0)
					{
						System.Reflection.Throw.ArgumentOutOfRange("codeSize");
					}
					if ((uint)maxStack > 65535u)
					{
						System.Reflection.Throw.ArgumentOutOfRange("maxStack");
					}
					if (!ExceptionRegionEncoder.IsExceptionRegionCountInBounds(exceptionRegionCount))
					{
						System.Reflection.Throw.ArgumentOutOfRange("exceptionRegionCount");
					}
					int bodyOffset = SerializeHeader(codeSize, (ushort)maxStack, exceptionRegionCount, attributes, localVariablesSignature, hasDynamicStackAllocation);
					Blob instructions = Builder.ReserveBytes(codeSize);
					ExceptionRegionEncoder exceptionRegions = ((exceptionRegionCount > 0) ? ExceptionRegionEncoder.SerializeTableHeader(Builder, exceptionRegionCount, hasSmallExceptionRegions) : default(ExceptionRegionEncoder));
					return new MethodBody(bodyOffset, instructions, exceptionRegions);
				}

				/// <summary>
				/// Encodes a method body and adds it to the method body stream.
				/// </summary>
				/// <param name="instructionEncoder">Instruction encoder.</param>
				/// <param name="maxStack">Max stack.</param>
				/// <param name="localVariablesSignature">Local variables signature handle.</param>
				/// <param name="attributes">Attributes.</param>
				/// <returns>The offset of the encoded body within the method body stream.</returns>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="instructionEncoder" /> has default value.</exception>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxStack" /> is out of range [0, <see cref="F:System.UInt16.MaxValue" />].</exception>
				/// <exception cref="T:System.InvalidOperationException">
				/// A label targeted by a branch in the instruction stream has not been marked,
				/// or the distance between a branch instruction and the target label doesn't fit the size of the instruction operand.
				/// </exception>
				public int AddMethodBody(InstructionEncoder instructionEncoder, int maxStack, StandaloneSignatureHandle localVariablesSignature, MethodBodyAttributes attributes)
				{
					return AddMethodBody(instructionEncoder, maxStack, localVariablesSignature, attributes, hasDynamicStackAllocation: false);
				}

				/// <summary>
				/// Encodes a method body and adds it to the method body stream.
				/// </summary>
				/// <param name="instructionEncoder">Instruction encoder.</param>
				/// <param name="maxStack">Max stack.</param>
				/// <param name="localVariablesSignature">Local variables signature handle.</param>
				/// <param name="attributes">Attributes.</param>
				/// <param name="hasDynamicStackAllocation">True if the method allocates from dynamic local memory pool (the IL contains <c>localloc</c> instruction).
				/// </param>
				/// <returns>The offset of the encoded body within the method body stream.</returns>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="instructionEncoder" /> has default value.</exception>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="maxStack" /> is out of range [0, <see cref="F:System.UInt16.MaxValue" />].</exception>
				/// <exception cref="T:System.InvalidOperationException">
				/// A label targeted by a branch in the instruction stream has not been marked,
				/// or the distance between a branch instruction and the target label doesn't fit the size of the instruction operand.
				/// </exception>
				public int AddMethodBody(InstructionEncoder instructionEncoder, int maxStack = 8, StandaloneSignatureHandle localVariablesSignature = default(StandaloneSignatureHandle), MethodBodyAttributes attributes = MethodBodyAttributes.InitLocals, bool hasDynamicStackAllocation = false)
				{
					if ((uint)maxStack > 65535u)
					{
						System.Reflection.Throw.ArgumentOutOfRange("maxStack");
					}
					BlobBuilder codeBuilder = instructionEncoder.CodeBuilder;
					ControlFlowBuilder controlFlowBuilder = instructionEncoder.ControlFlowBuilder;
					if (codeBuilder == null)
					{
						System.Reflection.Throw.ArgumentNull("instructionEncoder");
					}
					int exceptionRegionCount = controlFlowBuilder?.ExceptionHandlerCount ?? 0;
					if (!ExceptionRegionEncoder.IsExceptionRegionCountInBounds(exceptionRegionCount))
					{
						System.Reflection.Throw.ArgumentOutOfRange("instructionEncoder", MDCFR.Properties.Resources.TooManyExceptionRegions);
					}
					int result = SerializeHeader(codeBuilder.Count, (ushort)maxStack, exceptionRegionCount, attributes, localVariablesSignature, hasDynamicStackAllocation);
					if (controlFlowBuilder != null && controlFlowBuilder.BranchCount > 0)
					{
						controlFlowBuilder.CopyCodeAndFixupBranches(codeBuilder, Builder);
					}
					else
					{
						codeBuilder.WriteContentTo(Builder);
					}
					controlFlowBuilder?.SerializeExceptionTable(Builder);
					return result;
				}

				private int SerializeHeader(int codeSize, ushort maxStack, int exceptionRegionCount, MethodBodyAttributes attributes, StandaloneSignatureHandle localVariablesSignature, bool hasDynamicStackAllocation)
				{
					bool flag = (attributes & MethodBodyAttributes.InitLocals) != 0;
					int count;
					if (codeSize < 64 && maxStack <= 8 && localVariablesSignature.IsNil && (!hasDynamicStackAllocation || !flag) && exceptionRegionCount == 0)
					{
						count = Builder.Count;
						Builder.WriteByte((byte)((uint)(codeSize << 2) | 2u));
					}
					else
					{
						Builder.Align(4);
						count = Builder.Count;
						ushort num = 12291;
						if (exceptionRegionCount > 0)
						{
							num = (ushort)(num | 8u);
						}
						if (flag)
						{
							num = (ushort)(num | 0x10u);
						}
						Builder.WriteUInt16((ushort)((uint)attributes | (uint)num));
						Builder.WriteUInt16(maxStack);
						Builder.WriteInt32(codeSize);
						Builder.WriteInt32((!localVariablesSignature.IsNil) ? MetadataTokens.GetToken(localVariablesSignature) : 0);
					}
					return count;
				}
			}

			internal readonly struct MethodDebugInformationTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _isDocumentRefSmall;

				private readonly bool _isBlobHeapRefSizeSmall;

				private const int DocumentOffset = 0;

				private readonly int _sequencePointsOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal MethodDebugInformationTableReader(int numberOfRows, int documentRefSize, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_isDocumentRefSmall = documentRefSize == 2;
					_isBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_sequencePointsOffset = documentRefSize;
					RowSize = _sequencePointsOffset + blobHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal DocumentHandle GetDocument(MethodDebugInformationHandle handle)
				{
					int offset = (handle.RowId - 1) * RowSize;
					return DocumentHandle.FromRowId(Block.PeekReference(offset, _isDocumentRefSmall));
				}

				internal BlobHandle GetSequencePoints(MethodDebugInformationHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _sequencePointsOffset, _isBlobHeapRefSizeSmall));
				}
			}

			internal static class MethodDefOrRefTag
			{
				internal const int NumberOfBits = 1;

				internal const int LargeRowSize = 32768;

				internal const uint MethodDef = 0u;

				internal const uint MemberRef = 1u;

				internal const uint TagMask = 1u;

				internal const System.Reflection.Metadata.Ecma335.TableMask TablesReferenced = System.Reflection.Metadata.Ecma335.TableMask.MethodDef | System.Reflection.Metadata.Ecma335.TableMask.MemberRef;

				internal const uint TagToTokenTypeByteVector = 2566u;

				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				internal static EntityHandle ConvertToHandle(uint methodDefOrRef)
				{
					uint num = 2566u >> (int)((methodDefOrRef & 1) << 3) << 24;
					uint num2 = methodDefOrRef >> 1;
					if ((num2 & 0xFF000000u) != 0)
					{
						System.Reflection.Throw.InvalidCodedIndex();
					}
					return new EntityHandle(num | num2);
				}
			}

			[Flags]
			internal enum MethodDefTreatment : byte
			{
				None = 0,
				KindMask = 0xF,
				Other = 1,
				DelegateMethod = 2,
				AttributeMethod = 3,
				InterfaceMethod = 4,
				Implementation = 5,
				HiddenInterfaceImplementation = 6,
				DisposeMethod = 7,
				MarkAbstractFlag = 0x10,
				MarkPublicFlag = 0x20
			}

			internal readonly struct MethodImplTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsTypeDefTableRowRefSizeSmall;

				private readonly bool _IsMethodDefOrRefRefSizeSmall;

				private readonly int _ClassOffset;

				private readonly int _MethodBodyOffset;

				private readonly int _MethodDeclarationOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal MethodImplTableReader(int numberOfRows, bool declaredSorted, int typeDefTableRowRefSize, int methodDefOrRefRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;
					_IsMethodDefOrRefRefSizeSmall = methodDefOrRefRefSize == 2;
					_ClassOffset = 0;
					_MethodBodyOffset = _ClassOffset + typeDefTableRowRefSize;
					_MethodDeclarationOffset = _MethodBodyOffset + methodDefOrRefRefSize;
					RowSize = _MethodDeclarationOffset + methodDefOrRefRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
					if (!declaredSorted && !CheckSorted())
					{
						System.Reflection.Throw.TableNotSorted(TableIndex.MethodImpl);
					}
				}

				internal TypeDefinitionHandle GetClass(MethodImplementationHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return TypeDefinitionHandle.FromRowId(Block.PeekReference(num + _ClassOffset, _IsTypeDefTableRowRefSizeSmall));
				}

				internal EntityHandle GetMethodBody(MethodImplementationHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return MethodDefOrRefTag.ConvertToHandle(Block.PeekTaggedReference(num + _MethodBodyOffset, _IsMethodDefOrRefRefSizeSmall));
				}

				internal EntityHandle GetMethodDeclaration(MethodImplementationHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return MethodDefOrRefTag.ConvertToHandle(Block.PeekTaggedReference(num + _MethodDeclarationOffset, _IsMethodDefOrRefRefSizeSmall));
				}

				internal void GetMethodImplRange(TypeDefinitionHandle typeDef, out int firstImplRowId, out int lastImplRowId)
				{
					Block.BinarySearchReferenceRange(NumberOfRows, RowSize, _ClassOffset, (uint)typeDef.RowId, _IsTypeDefTableRowRefSizeSmall, out var startRowNumber, out var endRowNumber);
					if (startRowNumber == -1)
					{
						firstImplRowId = 1;
						lastImplRowId = 0;
					}
					else
					{
						firstImplRowId = startRowNumber + 1;
						lastImplRowId = endRowNumber + 1;
					}
				}

				private bool CheckSorted()
				{
					return Block.IsOrderedByReferenceAscending(RowSize, _ClassOffset, _IsTypeDefTableRowRefSizeSmall);
				}
			}

			internal readonly struct MethodPtrTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsMethodTableRowRefSizeSmall;

				private readonly int _MethodOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal MethodPtrTableReader(int numberOfRows, int methodTableRowRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsMethodTableRowRefSizeSmall = methodTableRowRefSize == 2;
					_MethodOffset = 0;
					RowSize = _MethodOffset + methodTableRowRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal MethodDefinitionHandle GetMethodFor(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return MethodDefinitionHandle.FromRowId(Block.PeekReference(num + _MethodOffset, _IsMethodTableRowRefSizeSmall));
				}

				internal int GetRowIdForMethodDefRow(int methodDefRowId)
				{
					return Block.LinearSearchReference(RowSize, _MethodOffset, (uint)methodDefRowId, _IsMethodTableRowRefSizeSmall) + 1;
				}
			}

			internal readonly struct MethodSemanticsTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsMethodTableRowRefSizeSmall;

				private readonly bool _IsHasSemanticRefSizeSmall;

				private readonly int _SemanticsFlagOffset;

				private readonly int _MethodOffset;

				private readonly int _AssociationOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal MethodSemanticsTableReader(int numberOfRows, bool declaredSorted, int methodTableRowRefSize, int hasSemanticRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsMethodTableRowRefSizeSmall = methodTableRowRefSize == 2;
					_IsHasSemanticRefSizeSmall = hasSemanticRefSize == 2;
					_SemanticsFlagOffset = 0;
					_MethodOffset = _SemanticsFlagOffset + 2;
					_AssociationOffset = _MethodOffset + methodTableRowRefSize;
					RowSize = _AssociationOffset + hasSemanticRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
					if (!declaredSorted && !CheckSorted())
					{
						System.Reflection.Throw.TableNotSorted(TableIndex.MethodSemantics);
					}
				}

				internal MethodDefinitionHandle GetMethod(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return MethodDefinitionHandle.FromRowId(Block.PeekReference(num + _MethodOffset, _IsMethodTableRowRefSizeSmall));
				}

				internal MethodSemanticsAttributes GetSemantics(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return (MethodSemanticsAttributes)Block.PeekUInt16(num + _SemanticsFlagOffset);
				}

				internal EntityHandle GetAssociation(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return HasSemanticsTag.ConvertToHandle(Block.PeekTaggedReference(num + _AssociationOffset, _IsHasSemanticRefSizeSmall));
				}

				internal int FindSemanticMethodsForEvent(EventDefinitionHandle eventDef, out ushort methodCount)
				{
					methodCount = 0;
					uint searchCodedTag = HasSemanticsTag.ConvertEventHandleToTag(eventDef);
					return BinarySearchTag(searchCodedTag, ref methodCount);
				}

				internal int FindSemanticMethodsForProperty(PropertyDefinitionHandle propertyDef, out ushort methodCount)
				{
					methodCount = 0;
					uint searchCodedTag = HasSemanticsTag.ConvertPropertyHandleToTag(propertyDef);
					return BinarySearchTag(searchCodedTag, ref methodCount);
				}

				private int BinarySearchTag(uint searchCodedTag, ref ushort methodCount)
				{
					Block.BinarySearchReferenceRange(NumberOfRows, RowSize, _AssociationOffset, searchCodedTag, _IsHasSemanticRefSizeSmall, out var startRowNumber, out var endRowNumber);
					if (startRowNumber == -1)
					{
						methodCount = 0;
						return 0;
					}
					methodCount = (ushort)(endRowNumber - startRowNumber + 1);
					return startRowNumber + 1;
				}

				private bool CheckSorted()
				{
					return Block.IsOrderedByReferenceAscending(RowSize, _AssociationOffset, _IsHasSemanticRefSizeSmall);
				}
			}

			public readonly struct MethodSignatureEncoder
			{
				public BlobBuilder Builder { get; }

				public bool HasVarArgs { get; }

				public MethodSignatureEncoder(BlobBuilder builder, bool hasVarArgs)
				{
					Builder = builder;
					HasVarArgs = hasVarArgs;
				}

				/// <summary>
				/// Encodes return type and parameters.
				/// Returns a pair of encoders that must be used in the order they appear in the parameter list.
				/// </summary>
				/// <param name="parameterCount">Number of parameters.</param>
				/// <param name="returnType">Use first, to encode the return types.</param>
				/// <param name="parameters">Use second, to encode the actual parameters.</param>
				public void Parameters(int parameterCount, out ReturnTypeEncoder returnType, out ParametersEncoder parameters)
				{
					if ((uint)parameterCount > 536870911u)
					{
						System.Reflection.Throw.ArgumentOutOfRange("parameterCount");
					}
					Builder.WriteCompressedInteger(parameterCount);
					returnType = new ReturnTypeEncoder(Builder);
					parameters = new ParametersEncoder(Builder, HasVarArgs);
				}

				/// <summary>
				/// Encodes return type and parameters.
				/// </summary>
				/// <param name="parameterCount">Number of parameters.</param>
				/// <param name="returnType">Called first, to encode the return type.</param>
				/// <param name="parameters">Called second, to encode the actual parameters.</param>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="returnType" /> or <paramref name="parameters" /> is null.</exception>
				public void Parameters(int parameterCount, Action<ReturnTypeEncoder> returnType, Action<ParametersEncoder> parameters)
				{
					if (returnType == null)
					{
						System.Reflection.Throw.ArgumentNull("returnType");
					}
					if (parameters == null)
					{
						System.Reflection.Throw.ArgumentNull("parameters");
					}
					Parameters(parameterCount, out var returnType2, out var parameters2);
					returnType(returnType2);
					parameters(parameters2);
				}
			}

			internal readonly struct MethodSpecTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsMethodDefOrRefRefSizeSmall;

				private readonly bool _IsBlobHeapRefSizeSmall;

				private readonly int _MethodOffset;

				private readonly int _InstantiationOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal MethodSpecTableReader(int numberOfRows, int methodDefOrRefRefSize, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsMethodDefOrRefRefSizeSmall = methodDefOrRefRefSize == 2;
					_IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_MethodOffset = 0;
					_InstantiationOffset = _MethodOffset + methodDefOrRefRefSize;
					RowSize = _InstantiationOffset + blobHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal EntityHandle GetMethod(MethodSpecificationHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return MethodDefOrRefTag.ConvertToHandle(Block.PeekTaggedReference(num + _MethodOffset, _IsMethodDefOrRefRefSizeSmall));
				}

				internal BlobHandle GetInstantiation(MethodSpecificationHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _InstantiationOffset, _IsBlobHeapRefSizeSmall));
				}
			}

			internal readonly struct MethodTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsParamRefSizeSmall;

				private readonly bool _IsStringHeapRefSizeSmall;

				private readonly bool _IsBlobHeapRefSizeSmall;

				private readonly int _RvaOffset;

				private readonly int _ImplFlagsOffset;

				private readonly int _FlagsOffset;

				private readonly int _NameOffset;

				private readonly int _SignatureOffset;

				private readonly int _ParamListOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal MethodTableReader(int numberOfRows, int paramRefSize, int stringHeapRefSize, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsParamRefSizeSmall = paramRefSize == 2;
					_IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_RvaOffset = 0;
					_ImplFlagsOffset = _RvaOffset + 4;
					_FlagsOffset = _ImplFlagsOffset + 2;
					_NameOffset = _FlagsOffset + 2;
					_SignatureOffset = _NameOffset + stringHeapRefSize;
					_ParamListOffset = _SignatureOffset + blobHeapRefSize;
					RowSize = _ParamListOffset + paramRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal int GetParamStart(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return Block.PeekReference(num + _ParamListOffset, _IsParamRefSizeSmall);
				}

				internal BlobHandle GetSignature(MethodDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _SignatureOffset, _IsBlobHeapRefSizeSmall));
				}

				internal int GetRva(MethodDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return Block.PeekInt32(num + _RvaOffset);
				}

				internal StringHandle GetName(MethodDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _NameOffset, _IsStringHeapRefSizeSmall));
				}

				internal MethodAttributes GetFlags(MethodDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return (MethodAttributes)Block.PeekUInt16(num + _FlagsOffset);
				}

				internal MethodImplAttributes GetImplFlags(MethodDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return (MethodImplAttributes)Block.PeekUInt16(num + _ImplFlagsOffset);
				}
			}

			internal readonly struct ModuleRefTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsStringHeapRefSizeSmall;

				private readonly int _NameOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal ModuleRefTableReader(int numberOfRows, int stringHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_NameOffset = 0;
					RowSize = _NameOffset + stringHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal StringHandle GetName(ModuleReferenceHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _NameOffset, _IsStringHeapRefSizeSmall));
				}
			}

			internal readonly struct ModuleTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsStringHeapRefSizeSmall;

				private readonly bool _IsGUIDHeapRefSizeSmall;

				private readonly int _GenerationOffset;

				private readonly int _NameOffset;

				private readonly int _MVIdOffset;

				private readonly int _EnCIdOffset;

				private readonly int _EnCBaseIdOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal ModuleTableReader(int numberOfRows, int stringHeapRefSize, int guidHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_IsGUIDHeapRefSizeSmall = guidHeapRefSize == 2;
					_GenerationOffset = 0;
					_NameOffset = _GenerationOffset + 2;
					_MVIdOffset = _NameOffset + stringHeapRefSize;
					_EnCIdOffset = _MVIdOffset + guidHeapRefSize;
					_EnCBaseIdOffset = _EnCIdOffset + guidHeapRefSize;
					RowSize = _EnCBaseIdOffset + guidHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal ushort GetGeneration()
				{
					return Block.PeekUInt16(_GenerationOffset);
				}

				internal StringHandle GetName()
				{
					return StringHandle.FromOffset(Block.PeekHeapReference(_NameOffset, _IsStringHeapRefSizeSmall));
				}

				internal GuidHandle GetMvid()
				{
					return GuidHandle.FromIndex(Block.PeekHeapReference(_MVIdOffset, _IsGUIDHeapRefSizeSmall));
				}

				internal GuidHandle GetEncId()
				{
					return GuidHandle.FromIndex(Block.PeekHeapReference(_EnCIdOffset, _IsGUIDHeapRefSizeSmall));
				}

				internal GuidHandle GetEncBaseId()
				{
					return GuidHandle.FromIndex(Block.PeekHeapReference(_EnCBaseIdOffset, _IsGUIDHeapRefSizeSmall));
				}
			}

			public readonly struct NamedArgumentsEncoder
			{
				public BlobBuilder Builder { get; }

				public NamedArgumentsEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				/// <summary>
				/// Encodes a named argument (field or property).
				/// Returns a triplet of encoders that must be used in the order they appear in the parameter list.
				/// </summary>
				/// <param name="isField">True to encode a field, false to encode a property.</param>
				/// <param name="type">Use first, to encode the type of the argument.</param>
				/// <param name="name">Use second, to encode the name of the field or property.</param>
				/// <param name="literal">Use third, to encode the literal value of the argument.</param>
				public void AddArgument(bool isField, out NamedArgumentTypeEncoder type, out NameEncoder name, out LiteralEncoder literal)
				{
					Builder.WriteByte((byte)(isField ? 83 : 84));
					type = new NamedArgumentTypeEncoder(Builder);
					name = new NameEncoder(Builder);
					literal = new LiteralEncoder(Builder);
				}

				/// <summary>
				/// Encodes a named argument (field or property).
				/// </summary>
				/// <param name="isField">True to encode a field, false to encode a property.</param>
				/// <param name="type">Called first, to encode the type of the argument.</param>
				/// <param name="name">Called second, to encode the name of the field or property.</param>
				/// <param name="literal">Called third, to encode the literal value of the argument.</param>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="type" />, <paramref name="name" /> or <paramref name="literal" /> is null.</exception>
				public void AddArgument(bool isField, Action<NamedArgumentTypeEncoder> type, Action<NameEncoder> name, Action<LiteralEncoder> literal)
				{
					if (type == null)
					{
						System.Reflection.Throw.ArgumentNull("type");
					}
					if (name == null)
					{
						System.Reflection.Throw.ArgumentNull("name");
					}
					if (literal == null)
					{
						System.Reflection.Throw.ArgumentNull("literal");
					}
					AddArgument(isField, out var type2, out var name2, out var literal2);
					type(type2);
					name(name2);
					literal(literal2);
				}
			}

			public readonly struct NamedArgumentTypeEncoder
			{
				public BlobBuilder Builder { get; }

				public NamedArgumentTypeEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				public CustomAttributeElementTypeEncoder ScalarType()
				{
					return new CustomAttributeElementTypeEncoder(Builder);
				}

				public void Object()
				{
					Builder.WriteByte(81);
				}

				public CustomAttributeArrayTypeEncoder SZArray()
				{
					return new CustomAttributeArrayTypeEncoder(Builder);
				}
			}

			public readonly struct NameEncoder
			{
				public BlobBuilder Builder { get; }

				public NameEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				public void Name(string name)
				{
					if (name == null)
					{
						System.Reflection.Throw.ArgumentNull("name");
					}
					if (name.Length == 0)
					{
						System.Reflection.Throw.ArgumentEmptyString("name");
					}
					Builder.WriteSerializedString(name);
				}
			}

			internal sealed class NamespaceCache
			{
				/// <summary>
				/// An intermediate class used to build NamespaceData instances. This was created because we wanted to
				/// use ImmutableArrays in NamespaceData, but having ArrayBuilders and ImmutableArrays that served the
				/// same purpose in NamespaceData got ugly. With the current design of how we create our Namespace
				/// dictionary, this needs to be a class because we have a many-to-one mapping between NamespaceHandles
				/// and NamespaceData. So, the pointer semantics must be preserved.
				///
				/// This class assumes that the builders will not be modified in any way after the first call to
				/// Freeze().
				/// </summary>
				private sealed class NamespaceDataBuilder
				{
					public readonly NamespaceDefinitionHandle Handle;

					public readonly StringHandle Name;

					public readonly string FullName;

					public NamespaceDefinitionHandle Parent;

					public System.Collections.Immutable.ImmutableArray<NamespaceDefinitionHandle>.Builder Namespaces;

					public System.Collections.Immutable.ImmutableArray<TypeDefinitionHandle>.Builder TypeDefinitions;

					public System.Collections.Immutable.ImmutableArray<ExportedTypeHandle>.Builder ExportedTypes;

					private NamespaceData _frozen;

					public NamespaceDataBuilder(NamespaceDefinitionHandle handle, StringHandle name, string fullName)
					{
						Handle = handle;
						Name = name;
						FullName = fullName;
						Namespaces = System.Collections.Immutable.ImmutableArray.CreateBuilder<NamespaceDefinitionHandle>();
						TypeDefinitions = System.Collections.Immutable.ImmutableArray.CreateBuilder<TypeDefinitionHandle>();
						ExportedTypes = System.Collections.Immutable.ImmutableArray.CreateBuilder<ExportedTypeHandle>();
					}

					/// <summary>
					/// Returns a NamespaceData that represents this NamespaceDataBuilder instance. After calling
					/// this method, it is an error to use any methods or fields except Freeze() on the target
					/// NamespaceDataBuilder.
					/// </summary>
					public NamespaceData Freeze()
					{
						if (_frozen == null)
						{
							System.Collections.Immutable.ImmutableArray<NamespaceDefinitionHandle> namespaceDefinitions = Namespaces.ToImmutable();
							Namespaces = null;
							System.Collections.Immutable.ImmutableArray<TypeDefinitionHandle> typeDefinitions = TypeDefinitions.ToImmutable();
							TypeDefinitions = null;
							System.Collections.Immutable.ImmutableArray<ExportedTypeHandle> exportedTypes = ExportedTypes.ToImmutable();
							ExportedTypes = null;
							_frozen = new NamespaceData(Name, FullName, Parent, namespaceDefinitions, typeDefinitions, exportedTypes);
						}
						return _frozen;
					}

					public void MergeInto(NamespaceDataBuilder other)
					{
						Parent = default(NamespaceDefinitionHandle);
						other.Namespaces.AddRange(Namespaces);
						other.TypeDefinitions.AddRange(TypeDefinitions);
						other.ExportedTypes.AddRange(ExportedTypes);
					}
				}

				private readonly MetadataReader _metadataReader;

				private readonly object _namespaceTableAndListLock = new object();

				private volatile Dictionary<NamespaceDefinitionHandle, NamespaceData> _namespaceTable;

				private NamespaceData _rootNamespace;

				private uint _virtualNamespaceCounter;

				/// <summary>
				/// Returns whether the namespaceTable has been created. If it hasn't, calling a GetXXX method
				/// on this will probably have a very high amount of overhead.
				/// </summary>
				internal bool CacheIsRealized => _namespaceTable != null;

				internal NamespaceCache(MetadataReader reader)
				{
					_metadataReader = reader;
				}

				internal string GetFullName(NamespaceDefinitionHandle handle)
				{
					NamespaceData namespaceData = GetNamespaceData(handle);
					return namespaceData.FullName;
				}

				internal NamespaceData GetRootNamespace()
				{
					EnsureNamespaceTableIsPopulated();
					return _rootNamespace;
				}

				internal NamespaceData GetNamespaceData(NamespaceDefinitionHandle handle)
				{
					EnsureNamespaceTableIsPopulated();
					if (!_namespaceTable.TryGetValue(handle, out var value))
					{
						System.Reflection.Throw.InvalidHandle();
					}
					return value;
				}

				/// <summary>
				/// This will return a StringHandle for the simple name of a namespace name at the given segment index.
				/// If no segment index is passed explicitly or the "segment" index is greater than or equal to the number
				/// of segments, then the last segment is used. "Segment" in this context refers to part of a namespace
				/// name between dots.
				///
				/// Example: Given a NamespaceDefinitionHandle to "System.Collections.Generic.Test" called 'handle':
				///
				///   reader.GetString(GetSimpleName(handle)) == "Test"
				///   reader.GetString(GetSimpleName(handle, 0)) == "System"
				///   reader.GetString(GetSimpleName(handle, 1)) == "Collections"
				///   reader.GetString(GetSimpleName(handle, 2)) == "Generic"
				///   reader.GetString(GetSimpleName(handle, 3)) == "Test"
				///   reader.GetString(GetSimpleName(handle, 1000)) == "Test"
				/// </summary>
				private StringHandle GetSimpleName(NamespaceDefinitionHandle fullNamespaceHandle, int segmentIndex = int.MaxValue)
				{
					StringHandle fullName = fullNamespaceHandle.GetFullName();
					int num = fullNamespaceHandle.GetHeapOffset() - 1;
					for (int i = 0; i < segmentIndex; i++)
					{
						int num2 = _metadataReader.StringHeap.IndexOfRaw(num + 1, '.');
						if (num2 == -1)
						{
							break;
						}
						num = num2;
					}
					int heapOffset = num + 1;
					return StringHandle.FromOffset(heapOffset).WithDotTermination();
				}

				/// <summary>
				/// Two distinct namespace handles represent the same namespace if their full names are the same. This
				/// method merges builders corresponding to such namespace handles.
				/// </summary>
				private void PopulateNamespaceTable()
				{
					lock (_namespaceTableAndListLock)
					{
						if (_namespaceTable != null)
						{
							return;
						}
						Dictionary<NamespaceDefinitionHandle, NamespaceDataBuilder> dictionary = new Dictionary<NamespaceDefinitionHandle, NamespaceDataBuilder>();
						NamespaceDefinitionHandle namespaceDefinitionHandle = NamespaceDefinitionHandle.FromFullNameOffset(0);
						dictionary.Add(namespaceDefinitionHandle, new NamespaceDataBuilder(namespaceDefinitionHandle, namespaceDefinitionHandle.GetFullName(), string.Empty));
						PopulateTableWithTypeDefinitions(dictionary);
						PopulateTableWithExportedTypes(dictionary);
						MergeDuplicateNamespaces(dictionary, out var stringTable);
						ResolveParentChildRelationships(stringTable, out var virtualNamespaces);
						Dictionary<NamespaceDefinitionHandle, NamespaceData> dictionary2 = new Dictionary<NamespaceDefinitionHandle, NamespaceData>();
						foreach (KeyValuePair<NamespaceDefinitionHandle, NamespaceDataBuilder> item in dictionary)
						{
							dictionary2.Add(item.Key, item.Value.Freeze());
						}
						if (virtualNamespaces != null)
						{
							foreach (NamespaceDataBuilder item2 in virtualNamespaces)
							{
								dictionary2.Add(item2.Handle, item2.Freeze());
							}
						}
						_rootNamespace = dictionary2[namespaceDefinitionHandle];
						_namespaceTable = dictionary2;
					}
				}

				/// <summary>
				/// This will take 'table' and merge all of the NamespaceData instances that point to the same
				/// namespace. It has to create 'stringTable' as an intermediate dictionary, so it will hand it
				/// back to the caller should the caller want to use it.
				/// </summary>
				private static void MergeDuplicateNamespaces(Dictionary<NamespaceDefinitionHandle, NamespaceDataBuilder> table, out Dictionary<string, NamespaceDataBuilder> stringTable)
				{
					Dictionary<string, NamespaceDataBuilder> dictionary = new Dictionary<string, NamespaceDataBuilder>();
					List<KeyValuePair<NamespaceDefinitionHandle, NamespaceDataBuilder>> list = null;
					foreach (KeyValuePair<NamespaceDefinitionHandle, NamespaceDataBuilder> item in table)
					{
						NamespaceDataBuilder value = item.Value;
						if (dictionary.TryGetValue(value.FullName, out var value2))
						{
							value.MergeInto(value2);
							if (list == null)
							{
								list = new List<KeyValuePair<NamespaceDefinitionHandle, NamespaceDataBuilder>>();
							}
							list.Add(new KeyValuePair<NamespaceDefinitionHandle, NamespaceDataBuilder>(item.Key, value2));
						}
						else
						{
							dictionary.Add(value.FullName, value);
						}
					}
					if (list != null)
					{
						foreach (KeyValuePair<NamespaceDefinitionHandle, NamespaceDataBuilder> item2 in list)
						{
							table[item2.Key] = item2.Value;
						}
					}
					stringTable = dictionary;
				}

				/// <summary>
				/// Creates a NamespaceDataBuilder instance that contains a synthesized NamespaceDefinitionHandle,
				/// as well as the name provided.
				/// </summary>
				private NamespaceDataBuilder SynthesizeNamespaceData(string fullName, NamespaceDefinitionHandle realChild)
				{
					int num = 0;
					foreach (char c in fullName)
					{
						if (c == '.')
						{
							num++;
						}
					}
					StringHandle simpleName = GetSimpleName(realChild, num);
					NamespaceDefinitionHandle handle = NamespaceDefinitionHandle.FromVirtualIndex(++_virtualNamespaceCounter);
					return new NamespaceDataBuilder(handle, simpleName, fullName);
				}

				/// <summary>
				/// Quick convenience method that handles linking together child + parent
				/// </summary>
				private static void LinkChildDataToParentData(NamespaceDataBuilder child, NamespaceDataBuilder parent)
				{
					child.Parent = parent.Handle;
					parent.Namespaces.Add(child.Handle);
				}

				/// <summary>
				/// Links a child to its parent namespace. If the parent namespace doesn't exist, this will create a
				/// virtual one. This will automatically link any virtual namespaces it creates up to its parents.
				/// </summary>
				private void LinkChildToParentNamespace(Dictionary<string, NamespaceDataBuilder> existingNamespaces, NamespaceDataBuilder realChild, ref List<NamespaceDataBuilder> virtualNamespaces)
				{
					string fullName = realChild.FullName;
					NamespaceDataBuilder child = realChild;
					NamespaceDataBuilder value;
					while (true)
					{
						int num = fullName.LastIndexOf('.');
						string text;
						if (num == -1)
						{
							if (fullName.Length == 0)
							{
								return;
							}
							text = string.Empty;
						}
						else
						{
							text = fullName.Substring(0, num);
						}
						if (existingNamespaces.TryGetValue(text, out value))
						{
							break;
						}
						if (virtualNamespaces != null)
						{
							foreach (NamespaceDataBuilder virtualNamespace in virtualNamespaces)
							{
								if (virtualNamespace.FullName == text)
								{
									LinkChildDataToParentData(child, virtualNamespace);
									return;
								}
							}
						}
						else
						{
							virtualNamespaces = new List<NamespaceDataBuilder>();
						}
						NamespaceDataBuilder namespaceDataBuilder = SynthesizeNamespaceData(text, realChild.Handle);
						LinkChildDataToParentData(child, namespaceDataBuilder);
						virtualNamespaces.Add(namespaceDataBuilder);
						fullName = namespaceDataBuilder.FullName;
						child = namespaceDataBuilder;
					}
					LinkChildDataToParentData(child, value);
				}

				/// <summary>
				/// This will link all parents/children in the given namespaces dictionary up to each other.
				///
				/// In some cases, we need to synthesize namespaces that do not have any type definitions or forwarders
				/// of their own, but do have child namespaces. These are returned via the virtualNamespaces out
				/// parameter.
				/// </summary>
				private void ResolveParentChildRelationships(Dictionary<string, NamespaceDataBuilder> namespaces, out List<NamespaceDataBuilder> virtualNamespaces)
				{
					virtualNamespaces = null;
					foreach (KeyValuePair<string, NamespaceDataBuilder> @namespace in namespaces)
					{
						LinkChildToParentNamespace(namespaces, @namespace.Value, ref virtualNamespaces);
					}
				}

				/// <summary>
				/// Loops through all type definitions in metadata, adding them to the given table
				/// </summary>
				private void PopulateTableWithTypeDefinitions(Dictionary<NamespaceDefinitionHandle, NamespaceDataBuilder> table)
				{
					foreach (TypeDefinitionHandle typeDefinition in _metadataReader.TypeDefinitions)
					{
						if (!_metadataReader.GetTypeDefinition(typeDefinition).Attributes.IsNested())
						{
							NamespaceDefinitionHandle namespaceDefinition = _metadataReader.TypeDefTable.GetNamespaceDefinition(typeDefinition);
							if (table.TryGetValue(namespaceDefinition, out var value))
							{
								value.TypeDefinitions.Add(typeDefinition);
								continue;
							}
							StringHandle simpleName = GetSimpleName(namespaceDefinition);
							string @string = _metadataReader.GetString(namespaceDefinition);
							NamespaceDataBuilder namespaceDataBuilder = new NamespaceDataBuilder(namespaceDefinition, simpleName, @string);
							namespaceDataBuilder.TypeDefinitions.Add(typeDefinition);
							table.Add(namespaceDefinition, namespaceDataBuilder);
						}
					}
				}

				/// <summary>
				/// Loops through all type forwarders in metadata, adding them to the given table
				/// </summary>
				private void PopulateTableWithExportedTypes(Dictionary<NamespaceDefinitionHandle, NamespaceDataBuilder> table)
				{
					foreach (ExportedTypeHandle exportedType2 in _metadataReader.ExportedTypes)
					{
						ExportedType exportedType = _metadataReader.GetExportedType(exportedType2);
						if (exportedType.Implementation.Kind != HandleKind.ExportedType)
						{
							NamespaceDefinitionHandle namespaceDefinition = exportedType.NamespaceDefinition;
							if (table.TryGetValue(namespaceDefinition, out var value))
							{
								value.ExportedTypes.Add(exportedType2);
								continue;
							}
							StringHandle simpleName = GetSimpleName(namespaceDefinition);
							string @string = _metadataReader.GetString(namespaceDefinition);
							NamespaceDataBuilder namespaceDataBuilder = new NamespaceDataBuilder(namespaceDefinition, simpleName, @string);
							namespaceDataBuilder.ExportedTypes.Add(exportedType2);
							table.Add(namespaceDefinition, namespaceDataBuilder);
						}
					}
				}

				/// <summary>
				/// If the namespace table doesn't exist, populates it!
				/// </summary>
				private void EnsureNamespaceTableIsPopulated()
				{
					if (_namespaceTable == null)
					{
						PopulateNamespaceTable();
					}
				}
			}

			internal sealed class NamespaceData
			{
				public readonly StringHandle Name;

				public readonly string FullName;

				public readonly NamespaceDefinitionHandle Parent;

				public readonly System.Collections.Immutable.ImmutableArray<NamespaceDefinitionHandle> NamespaceDefinitions;

				public readonly System.Collections.Immutable.ImmutableArray<TypeDefinitionHandle> TypeDefinitions;

				public readonly System.Collections.Immutable.ImmutableArray<ExportedTypeHandle> ExportedTypes;

				public NamespaceData(StringHandle name, string fullName, NamespaceDefinitionHandle parent, System.Collections.Immutable.ImmutableArray<NamespaceDefinitionHandle> namespaceDefinitions, System.Collections.Immutable.ImmutableArray<TypeDefinitionHandle> typeDefinitions, System.Collections.Immutable.ImmutableArray<ExportedTypeHandle> exportedTypes)
				{
					Name = name;
					FullName = fullName;
					Parent = parent;
					NamespaceDefinitions = namespaceDefinitions;
					TypeDefinitions = typeDefinitions;
					ExportedTypes = exportedTypes;
				}
			}

			internal readonly struct NestedClassTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsTypeDefTableRowRefSizeSmall;

				private readonly int _NestedClassOffset;

				private readonly int _EnclosingClassOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal NestedClassTableReader(int numberOfRows, bool declaredSorted, int typeDefTableRowRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;
					_NestedClassOffset = 0;
					_EnclosingClassOffset = _NestedClassOffset + typeDefTableRowRefSize;
					RowSize = _EnclosingClassOffset + typeDefTableRowRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
					if (!declaredSorted && !CheckSorted())
					{
						System.Reflection.Throw.TableNotSorted(TableIndex.NestedClass);
					}
				}

				internal TypeDefinitionHandle GetNestedClass(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return TypeDefinitionHandle.FromRowId(Block.PeekReference(num + _NestedClassOffset, _IsTypeDefTableRowRefSizeSmall));
				}

				internal TypeDefinitionHandle GetEnclosingClass(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return TypeDefinitionHandle.FromRowId(Block.PeekReference(num + _EnclosingClassOffset, _IsTypeDefTableRowRefSizeSmall));
				}

				internal TypeDefinitionHandle FindEnclosingType(TypeDefinitionHandle nestedTypeDef)
				{
					int num = Block.BinarySearchReference(NumberOfRows, RowSize, _NestedClassOffset, (uint)nestedTypeDef.RowId, _IsTypeDefTableRowRefSizeSmall);
					if (num == -1)
					{
						return default(TypeDefinitionHandle);
					}
					return TypeDefinitionHandle.FromRowId(Block.PeekReference(num * RowSize + _EnclosingClassOffset, _IsTypeDefTableRowRefSizeSmall));
				}

				private bool CheckSorted()
				{
					return Block.IsOrderedByReferenceAscending(RowSize, _NestedClassOffset, _IsTypeDefTableRowRefSizeSmall);
				}
			}

			public readonly struct ParametersEncoder
			{
				public BlobBuilder Builder { get; }

				public bool HasVarArgs { get; }

				public ParametersEncoder(BlobBuilder builder, bool hasVarArgs = false)
				{
					Builder = builder;
					HasVarArgs = hasVarArgs;
				}

				public ParameterTypeEncoder AddParameter()
				{
					return new ParameterTypeEncoder(Builder);
				}

				public ParametersEncoder StartVarArgs()
				{
					if (!HasVarArgs)
					{
						System.Reflection.Throw.SignatureNotVarArg();
					}
					Builder.WriteByte(65);
					return new ParametersEncoder(Builder);
				}
			}

			public readonly struct ParameterTypeEncoder
			{
				public BlobBuilder Builder { get; }

				public ParameterTypeEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				public CustomModifiersEncoder CustomModifiers()
				{
					return new CustomModifiersEncoder(Builder);
				}

				public SignatureTypeEncoder Type(bool isByRef = false)
				{
					if (isByRef)
					{
						Builder.WriteByte(16);
					}
					return new SignatureTypeEncoder(Builder);
				}

				public void TypedReference()
				{
					Builder.WriteByte(22);
				}
			}

			internal readonly struct ParamPtrTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsParamTableRowRefSizeSmall;

				private readonly int _ParamOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal ParamPtrTableReader(int numberOfRows, int paramTableRowRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsParamTableRowRefSizeSmall = paramTableRowRefSize == 2;
					_ParamOffset = 0;
					RowSize = _ParamOffset + paramTableRowRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal ParameterHandle GetParamFor(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return ParameterHandle.FromRowId(Block.PeekReference(num + _ParamOffset, _IsParamTableRowRefSizeSmall));
				}
			}

			internal readonly struct ParamTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsStringHeapRefSizeSmall;

				private readonly int _FlagsOffset;

				private readonly int _SequenceOffset;

				private readonly int _NameOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal ParamTableReader(int numberOfRows, int stringHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_FlagsOffset = 0;
					_SequenceOffset = _FlagsOffset + 2;
					_NameOffset = _SequenceOffset + 2;
					RowSize = _NameOffset + stringHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal ParameterAttributes GetFlags(ParameterHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return (ParameterAttributes)Block.PeekUInt16(num + _FlagsOffset);
				}

				internal ushort GetSequence(ParameterHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return Block.PeekUInt16(num + _SequenceOffset);
				}

				internal StringHandle GetName(ParameterHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _NameOffset, _IsStringHeapRefSizeSmall));
				}
			}

			public readonly struct PermissionSetEncoder
			{
				public BlobBuilder Builder { get; }

				public PermissionSetEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				public PermissionSetEncoder AddPermission(string typeName, System.Collections.Immutable.ImmutableArray<byte> encodedArguments)
				{
					if (typeName == null)
					{
						System.Reflection.Throw.ArgumentNull("typeName");
					}
					if (encodedArguments.IsDefault)
					{
						System.Reflection.Throw.ArgumentNull("encodedArguments");
					}
					if (encodedArguments.Length > 536870911)
					{
						System.Reflection.Throw.BlobTooLarge("encodedArguments");
					}
					Builder.WriteSerializedString(typeName);
					Builder.WriteCompressedInteger(encodedArguments.Length);
					Builder.WriteBytes(encodedArguments);
					return this;
				}

				public PermissionSetEncoder AddPermission(string typeName, BlobBuilder encodedArguments)
				{
					if (typeName == null)
					{
						System.Reflection.Throw.ArgumentNull("typeName");
					}
					if (encodedArguments == null)
					{
						System.Reflection.Throw.ArgumentNull("encodedArguments");
					}
					if (encodedArguments.Count > 536870911)
					{
						System.Reflection.Throw.BlobTooLarge("encodedArguments");
					}
					Builder.WriteSerializedString(typeName);
					Builder.WriteCompressedInteger(encodedArguments.Count);
					encodedArguments.WriteContentTo(Builder);
					return this;
				}
			}

			/// <summary>
			/// Builder of a Portable PDB image.
			/// </summary>
			public sealed class PortablePdbBuilder
			{
				private Blob _pdbIdBlob;

				private readonly MethodDefinitionHandle _entryPoint;

				private readonly MetadataBuilder _builder;

				private readonly SerializedMetadata _serializedMetadata;

				public string MetadataVersion => "PDB v1.0";

				public ushort FormatVersion => 256;

				public Func<IEnumerable<Blob>, BlobContentId> IdProvider { get; }

				/// <summary>
				/// Creates a builder of a Portable PDB image.
				/// </summary>
				/// <param name="tablesAndHeaps">
				/// Builder populated with debug metadata entities stored in tables and values stored in heaps.
				/// The entities and values will be enumerated when serializing the Portable PDB image.
				/// </param>
				/// <param name="typeSystemRowCounts">
				/// Row counts of all tables that the associated type-system metadata contain.
				/// Each slot in the array corresponds to a table (<see cref="T:System.Reflection.Metadata.Ecma335.TableIndex" />).
				/// The length of the array must be equal to <see cref="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount" />.
				/// </param>
				/// <param name="entryPoint">
				/// Entry point method definition handle.
				/// </param>
				/// <param name="idProvider">
				/// Function calculating id of content represented as a sequence of blobs.
				/// If not specified a default function that ignores the content and returns current time-based content id is used
				/// (<see cref="M:System.Reflection.Metadata.BlobContentId.GetTimeBasedProvider" />).
				/// You must specify a deterministic function to produce a deterministic Portable PDB image.
				/// </param>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="tablesAndHeaps" /> or <paramref name="typeSystemRowCounts" /> is null.</exception>
				public PortablePdbBuilder(MetadataBuilder tablesAndHeaps, System.Collections.Immutable.ImmutableArray<int> typeSystemRowCounts, MethodDefinitionHandle entryPoint, Func<IEnumerable<Blob>, BlobContentId>? idProvider = null)
				{
					if (tablesAndHeaps == null)
					{
						System.Reflection.Throw.ArgumentNull("tablesAndHeaps");
					}
					ValidateTypeSystemRowCounts(typeSystemRowCounts);
					_builder = tablesAndHeaps;
					_entryPoint = entryPoint;
					_serializedMetadata = tablesAndHeaps.GetSerializedMetadata(typeSystemRowCounts, MetadataVersion.Length, isStandaloneDebugMetadata: true);
					IdProvider = idProvider ?? BlobContentId.GetTimeBasedProvider();
				}

				private static void ValidateTypeSystemRowCounts(System.Collections.Immutable.ImmutableArray<int> typeSystemRowCounts)
				{
					if (typeSystemRowCounts.IsDefault)
					{
						System.Reflection.Throw.ArgumentNull("typeSystemRowCounts");
					}
					if (typeSystemRowCounts.Length != MetadataTokens.TableCount)
					{
						throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.ExpectedArrayOfSize, MetadataTokens.TableCount), "typeSystemRowCounts");
					}
					for (int i = 0; i < typeSystemRowCounts.Length; i++)
					{
						if (typeSystemRowCounts[i] != 0)
						{
							if (((uint)typeSystemRowCounts[i] & 0xFF000000u) != 0)
							{
								throw new ArgumentOutOfRangeException("typeSystemRowCounts", System.SR.Format(MDCFR.Properties.Resources.RowCountOutOfRange, i));
							}
							if (((1L << i) & 0x1FC93FB7FF57L) == 0L)
							{
								throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.RowCountMustBeZero, i), "typeSystemRowCounts");
							}
						}
					}
				}

				/// <summary>
				/// Serialized #Pdb stream.
				/// </summary>
				private void SerializeStandalonePdbStream(BlobBuilder builder)
				{
					int count = builder.Count;
					_pdbIdBlob = builder.ReserveBytes(20);
					builder.WriteInt32((!_entryPoint.IsNil) ? MetadataTokens.GetToken(_entryPoint) : 0);
					builder.WriteUInt64(_serializedMetadata.Sizes.ExternalTablesMask);
					MetadataWriterUtilities.SerializeRowCounts(builder, _serializedMetadata.Sizes.ExternalRowCounts);
					int count2 = builder.Count;
				}

				/// <summary>
				/// Serializes Portable PDB content into the given <see cref="T:System.Reflection.Metadata.BlobBuilder" />.
				/// </summary>
				/// <param name="builder">Builder to write to.</param>
				/// <returns>The id of the serialized content.</returns>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="builder" /> is null.</exception>
				public BlobContentId Serialize(BlobBuilder builder)
				{
					if (builder == null)
					{
						System.Reflection.Throw.ArgumentNull("builder");
					}
					MetadataBuilder.SerializeMetadataHeader(builder, MetadataVersion, _serializedMetadata.Sizes);
					SerializeStandalonePdbStream(builder);
					_builder.SerializeMetadataTables(builder, _serializedMetadata.Sizes, _serializedMetadata.StringMap, 0, 0);
					_builder.WriteHeapsTo(builder, _serializedMetadata.StringHeap);
					BlobContentId result = IdProvider(builder.GetBlobs());
					BlobWriter blobWriter = new BlobWriter(_pdbIdBlob);
					blobWriter.WriteGuid(result.Guid);
					blobWriter.WriteUInt32(result.Stamp);
					return result;
				}
			}

			internal readonly struct PropertyMapTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsTypeDefTableRowRefSizeSmall;

				private readonly bool _IsPropertyRefSizeSmall;

				private readonly int _ParentOffset;

				private readonly int _PropertyListOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal PropertyMapTableReader(int numberOfRows, int typeDefTableRowRefSize, int propertyRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsTypeDefTableRowRefSizeSmall = typeDefTableRowRefSize == 2;
					_IsPropertyRefSizeSmall = propertyRefSize == 2;
					_ParentOffset = 0;
					_PropertyListOffset = _ParentOffset + typeDefTableRowRefSize;
					RowSize = _PropertyListOffset + propertyRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal int FindPropertyMapRowIdFor(TypeDefinitionHandle typeDef)
				{
					int num = Block.LinearSearchReference(RowSize, _ParentOffset, (uint)typeDef.RowId, _IsTypeDefTableRowRefSizeSmall);
					return num + 1;
				}

				internal TypeDefinitionHandle GetParentType(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return TypeDefinitionHandle.FromRowId(Block.PeekReference(num + _ParentOffset, _IsTypeDefTableRowRefSizeSmall));
				}

				internal int GetPropertyListStartFor(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return Block.PeekReference(num + _PropertyListOffset, _IsPropertyRefSizeSmall);
				}
			}

			internal readonly struct PropertyPtrTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsPropertyTableRowRefSizeSmall;

				private readonly int _PropertyOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal PropertyPtrTableReader(int numberOfRows, int propertyTableRowRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsPropertyTableRowRefSizeSmall = propertyTableRowRefSize == 2;
					_PropertyOffset = 0;
					RowSize = _PropertyOffset + propertyTableRowRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal PropertyDefinitionHandle GetPropertyFor(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return PropertyDefinitionHandle.FromRowId(Block.PeekReference(num + _PropertyOffset, _IsPropertyTableRowRefSizeSmall));
				}
			}

			internal readonly struct PropertyTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsStringHeapRefSizeSmall;

				private readonly bool _IsBlobHeapRefSizeSmall;

				private readonly int _FlagsOffset;

				private readonly int _NameOffset;

				private readonly int _SignatureOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal PropertyTableReader(int numberOfRows, int stringHeapRefSize, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_FlagsOffset = 0;
					_NameOffset = _FlagsOffset + 2;
					_SignatureOffset = _NameOffset + stringHeapRefSize;
					RowSize = _SignatureOffset + blobHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal PropertyAttributes GetFlags(PropertyDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return (PropertyAttributes)Block.PeekUInt16(num + _FlagsOffset);
				}

				internal StringHandle GetName(PropertyDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _NameOffset, _IsStringHeapRefSizeSmall));
				}

				internal BlobHandle GetSignature(PropertyDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _SignatureOffset, _IsBlobHeapRefSizeSmall));
				}
			}

			internal static class ResolutionScopeTag
			{
				internal const int NumberOfBits = 2;

				internal const int LargeRowSize = 16384;

				internal const uint Module = 0u;

				internal const uint ModuleRef = 1u;

				internal const uint AssemblyRef = 2u;

				internal const uint TypeRef = 3u;

				internal const uint TagMask = 3u;

				internal const uint TagToTokenTypeByteVector = 19077632u;

				internal const System.Reflection.Metadata.Ecma335.TableMask TablesReferenced = System.Reflection.Metadata.Ecma335.TableMask.Module | System.Reflection.Metadata.Ecma335.TableMask.TypeRef | System.Reflection.Metadata.Ecma335.TableMask.ModuleRef | System.Reflection.Metadata.Ecma335.TableMask.AssemblyRef;

				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				internal static EntityHandle ConvertToHandle(uint resolutionScope)
				{
					uint num = 19077632u >> (int)((resolutionScope & 3) << 3) << 24;
					uint num2 = resolutionScope >> 2;
					if ((num2 & 0xFF000000u) != 0)
					{
						System.Reflection.Throw.InvalidCodedIndex();
					}
					return new EntityHandle(num | num2);
				}
			}

			public readonly struct ReturnTypeEncoder
			{
				public BlobBuilder Builder { get; }

				public ReturnTypeEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				public CustomModifiersEncoder CustomModifiers()
				{
					return new CustomModifiersEncoder(Builder);
				}

				public SignatureTypeEncoder Type(bool isByRef = false)
				{
					if (isByRef)
					{
						Builder.WriteByte(16);
					}
					return new SignatureTypeEncoder(Builder);
				}

				public void TypedReference()
				{
					Builder.WriteByte(22);
				}

				public void Void()
				{
					Builder.WriteByte(1);
				}
			}

			public readonly struct ScalarEncoder
			{
				public BlobBuilder Builder { get; }

				public ScalarEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				/// <summary>
				/// Encodes <c>null</c> literal of type <see cref="T:System.Array" />.
				/// </summary>
				public void NullArray()
				{
					Builder.WriteInt32(-1);
				}

				/// <summary>
				/// Encodes constant literal.
				/// </summary>
				/// <param name="value">
				/// Constant of type
				/// <see cref="T:System.Boolean" />,
				/// <see cref="T:System.Byte" />,
				/// <see cref="T:System.SByte" />,
				/// <see cref="T:System.Int16" />,
				/// <see cref="T:System.UInt16" />,
				/// <see cref="T:System.Int32" />,
				/// <see cref="T:System.UInt32" />,
				/// <see cref="T:System.Int64" />,
				/// <see cref="T:System.UInt64" />,
				/// <see cref="T:System.Single" />,
				/// <see cref="T:System.Double" />,
				/// <see cref="T:System.Char" /> (encoded as two-byte Unicode character),
				/// <see cref="T:System.String" /> (encoded as SerString), or
				/// <see cref="T:System.Enum" /> (encoded as the underlying integer value).
				/// </param>
				/// <exception cref="T:System.ArgumentException">Unexpected constant type.</exception>
				public void Constant(object? value)
				{
					string text = value as string;
					if (text != null || value == null)
					{
						String(text);
					}
					else
					{
						Builder.WriteConstant(value);
					}
				}

				/// <summary>
				/// Encodes literal of type <see cref="T:System.Type" /> (possibly null).
				/// </summary>
				/// <param name="serializedTypeName">The name of the type, or null.</param>
				/// <exception cref="T:System.ArgumentException"><paramref name="serializedTypeName" /> is empty.</exception>
				public void SystemType(string? serializedTypeName)
				{
					if (serializedTypeName != null && serializedTypeName.Length == 0)
					{
						System.Reflection.Throw.ArgumentEmptyString("serializedTypeName");
					}
					String(serializedTypeName);
				}

				private void String(string value)
				{
					Builder.WriteSerializedString(value);
				}
			}

			internal sealed class SerializedMetadata
			{
				internal readonly System.Collections.Immutable.ImmutableArray<int> StringMap;

				internal readonly BlobBuilder StringHeap;

				internal readonly MetadataSizes Sizes;

				public SerializedMetadata(MetadataSizes sizes, BlobBuilder stringHeap, System.Collections.Immutable.ImmutableArray<int> stringMap)
				{
					Sizes = sizes;
					StringHeap = stringHeap;
					StringMap = stringMap;
				}
			}

			/// <summary>
			/// Decodes signature blobs.
			/// See Metadata Specification section II.23.2: Blobs and signatures.
			/// </summary>
			public readonly struct SignatureDecoder<TType, TGenericContext>
			{
				private readonly ISignatureTypeProvider<TType, TGenericContext> _provider;

				private readonly MetadataReader _metadataReaderOpt;

				private readonly TGenericContext _genericContext;

				/// <summary>
				/// Creates a new SignatureDecoder.
				/// </summary>
				/// <param name="provider">The provider used to obtain type symbols as the signature is decoded.</param>
				/// <param name="metadataReader">
				/// The metadata reader from which the signature was obtained. It may be null if the given provider allows it.
				/// </param>
				/// <param name="genericContext">
				/// Additional context needed to resolve generic parameters.
				/// </param>
				public SignatureDecoder(ISignatureTypeProvider<TType, TGenericContext> provider, MetadataReader metadataReader, TGenericContext genericContext)
				{
					if (provider == null)
					{
						System.Reflection.Throw.ArgumentNull("provider");
					}
					_metadataReaderOpt = metadataReader;
					_provider = provider;
					_genericContext = genericContext;
				}

				/// <summary>
				/// Decodes a type embedded in a signature and advances the reader past the type.
				/// </summary>
				/// <param name="blobReader">The blob reader positioned at the leading SignatureTypeCode</param>
				/// <param name="allowTypeSpecifications">Allow a <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle" /> to follow a (CLASS | VALUETYPE) in the signature.
				/// At present, the only context where that would be valid is in a LocalConstantSig as defined by the Portable PDB specification.
				/// </param>
				/// <returns>The decoded type.</returns>
				/// <exception cref="T:System.BadImageFormatException">The reader was not positioned at a valid signature type.</exception>
				public TType DecodeType(ref BlobReader blobReader, bool allowTypeSpecifications = false)
				{
					return DecodeType(ref blobReader, allowTypeSpecifications, blobReader.ReadCompressedInteger());
				}

				private TType DecodeType(ref BlobReader blobReader, bool allowTypeSpecifications, int typeCode)
				{
					switch (typeCode)
					{
						case 1:
						case 2:
						case 3:
						case 4:
						case 5:
						case 6:
						case 7:
						case 8:
						case 9:
						case 10:
						case 11:
						case 12:
						case 13:
						case 14:
						case 22:
						case 24:
						case 25:
						case 28:
							return _provider.GetPrimitiveType((PrimitiveTypeCode)typeCode);
						case 15:
							{
								TType elementType = DecodeType(ref blobReader);
								return _provider.GetPointerType(elementType);
							}
						case 16:
							{
								TType elementType = DecodeType(ref blobReader);
								return _provider.GetByReferenceType(elementType);
							}
						case 69:
							{
								TType elementType = DecodeType(ref blobReader);
								return _provider.GetPinnedType(elementType);
							}
						case 29:
							{
								TType elementType = DecodeType(ref blobReader);
								return _provider.GetSZArrayType(elementType);
							}
						case 27:
							{
								MethodSignature<TType> signature = DecodeMethodSignature(ref blobReader);
								return _provider.GetFunctionPointerType(signature);
							}
						case 20:
							return DecodeArrayType(ref blobReader);
						case 31:
							return DecodeModifiedType(ref blobReader, isRequired: true);
						case 32:
							return DecodeModifiedType(ref blobReader, isRequired: false);
						case 21:
							return DecodeGenericTypeInstance(ref blobReader);
						case 19:
							{
								int index = blobReader.ReadCompressedInteger();
								return _provider.GetGenericTypeParameter(_genericContext, index);
							}
						case 30:
							{
								int index = blobReader.ReadCompressedInteger();
								return _provider.GetGenericMethodParameter(_genericContext, index);
							}
						case 17:
						case 18:
							return DecodeTypeHandle(ref blobReader, (byte)typeCode, allowTypeSpecifications);
						default:
							throw new BadImageFormatException(System.SR.Format(MDCFR.Properties.Resources.UnexpectedSignatureTypeCode, typeCode));
					}
				}

				/// <summary>
				/// Decodes a list of types, with at least one instance that is preceded by its count as a compressed integer.
				/// </summary>
				private System.Collections.Immutable.ImmutableArray<TType> DecodeTypeSequence(ref BlobReader blobReader)
				{
					int num = blobReader.ReadCompressedInteger();
					if (num == 0)
					{
						throw new BadImageFormatException(MDCFR.Properties.Resources.SignatureTypeSequenceMustHaveAtLeastOneElement);
					}
					System.Collections.Immutable.ImmutableArray<TType>.Builder builder = System.Collections.Immutable.ImmutableArray.CreateBuilder<TType>(num);
					for (int i = 0; i < num; i++)
					{
						builder.Add(DecodeType(ref blobReader));
					}
					return builder.MoveToImmutable();
				}

				/// <summary>
				/// Decodes a method (definition, reference, or standalone) or property signature blob.
				/// </summary>
				/// <param name="blobReader">BlobReader positioned at a method signature.</param>
				/// <returns>The decoded method signature.</returns>
				/// <exception cref="System.BadImageFormatException">The method signature is invalid.</exception>
				public MethodSignature<TType> DecodeMethodSignature(ref BlobReader blobReader)
				{
					SignatureHeader header = blobReader.ReadSignatureHeader();
					CheckMethodOrPropertyHeader(header);
					int genericParameterCount = 0;
					if (header.IsGeneric)
					{
						genericParameterCount = blobReader.ReadCompressedInteger();
					}
					int num = blobReader.ReadCompressedInteger();
					TType returnType = DecodeType(ref blobReader);
					int requiredParameterCount;
					System.Collections.Immutable.ImmutableArray<TType> parameterTypes;
					if (num == 0)
					{
						requiredParameterCount = 0;
						parameterTypes = System.Collections.Immutable.ImmutableArray<TType>.Empty;
					}
					else
					{
						System.Collections.Immutable.ImmutableArray<TType>.Builder builder = System.Collections.Immutable.ImmutableArray.CreateBuilder<TType>(num);
						int i;
						for (i = 0; i < num; i++)
						{
							int num2 = blobReader.ReadCompressedInteger();
							if (num2 == 65)
							{
								break;
							}
							builder.Add(DecodeType(ref blobReader, allowTypeSpecifications: false, num2));
						}
						requiredParameterCount = i;
						for (; i < num; i++)
						{
							builder.Add(DecodeType(ref blobReader));
						}
						parameterTypes = builder.MoveToImmutable();
					}
					return new MethodSignature<TType>(header, returnType, requiredParameterCount, genericParameterCount, parameterTypes);
				}

				/// <summary>
				/// Decodes a method specification signature blob and advances the reader past the signature.
				/// </summary>
				/// <param name="blobReader">A BlobReader positioned at a valid method specification signature.</param>
				/// <returns>The types used to instantiate a generic method via the method specification.</returns>
				public System.Collections.Immutable.ImmutableArray<TType> DecodeMethodSpecificationSignature(ref BlobReader blobReader)
				{
					SignatureHeader header = blobReader.ReadSignatureHeader();
					CheckHeader(header, SignatureKind.MethodSpecification);
					return DecodeTypeSequence(ref blobReader);
				}

				/// <summary>
				/// Decodes a local variable signature blob and advances the reader past the signature.
				/// </summary>
				/// <param name="blobReader">The blob reader positioned at a local variable signature.</param>
				/// <returns>The local variable types.</returns>
				/// <exception cref="T:System.BadImageFormatException">The local variable signature is invalid.</exception>
				public System.Collections.Immutable.ImmutableArray<TType> DecodeLocalSignature(ref BlobReader blobReader)
				{
					SignatureHeader header = blobReader.ReadSignatureHeader();
					CheckHeader(header, SignatureKind.LocalVariables);
					return DecodeTypeSequence(ref blobReader);
				}

				/// <summary>
				/// Decodes a field signature blob and advances the reader past the signature.
				/// </summary>
				/// <param name="blobReader">The blob reader positioned at a field signature.</param>
				/// <returns>The decoded field type.</returns>
				public TType DecodeFieldSignature(ref BlobReader blobReader)
				{
					SignatureHeader header = blobReader.ReadSignatureHeader();
					CheckHeader(header, SignatureKind.Field);
					return DecodeType(ref blobReader);
				}

				private TType DecodeArrayType(ref BlobReader blobReader)
				{
					TType elementType = DecodeType(ref blobReader);
					int rank = blobReader.ReadCompressedInteger();
					System.Collections.Immutable.ImmutableArray<int> sizes = System.Collections.Immutable.ImmutableArray<int>.Empty;
					System.Collections.Immutable.ImmutableArray<int> lowerBounds = System.Collections.Immutable.ImmutableArray<int>.Empty;
					int num = blobReader.ReadCompressedInteger();
					if (num > 0)
					{
						System.Collections.Immutable.ImmutableArray<int>.Builder builder = System.Collections.Immutable.ImmutableArray.CreateBuilder<int>(num);
						for (int i = 0; i < num; i++)
						{
							builder.Add(blobReader.ReadCompressedInteger());
						}
						sizes = builder.MoveToImmutable();
					}
					int num2 = blobReader.ReadCompressedInteger();
					if (num2 > 0)
					{
						System.Collections.Immutable.ImmutableArray<int>.Builder builder2 = System.Collections.Immutable.ImmutableArray.CreateBuilder<int>(num2);
						for (int j = 0; j < num2; j++)
						{
							builder2.Add(blobReader.ReadCompressedSignedInteger());
						}
						lowerBounds = builder2.MoveToImmutable();
					}
					ArrayShape shape = new ArrayShape(rank, sizes, lowerBounds);
					return _provider.GetArrayType(elementType, shape);
				}

				private TType DecodeGenericTypeInstance(ref BlobReader blobReader)
				{
					TType genericType = DecodeType(ref blobReader);
					System.Collections.Immutable.ImmutableArray<TType> typeArguments = DecodeTypeSequence(ref blobReader);
					return _provider.GetGenericInstantiation(genericType, typeArguments);
				}

				private TType DecodeModifiedType(ref BlobReader blobReader, bool isRequired)
				{
					TType modifier = DecodeTypeHandle(ref blobReader, 0, allowTypeSpecifications: true);
					TType unmodifiedType = DecodeType(ref blobReader);
					return _provider.GetModifiedType(modifier, unmodifiedType, isRequired);
				}

				private TType DecodeTypeHandle(ref BlobReader blobReader, byte rawTypeKind, bool allowTypeSpecifications)
				{
					EntityHandle entityHandle = blobReader.ReadTypeHandle();
					if (!entityHandle.IsNil)
					{
						switch (entityHandle.Kind)
						{
							case HandleKind.TypeDefinition:
								return _provider.GetTypeFromDefinition(_metadataReaderOpt, (TypeDefinitionHandle)entityHandle, rawTypeKind);
							case HandleKind.TypeReference:
								return _provider.GetTypeFromReference(_metadataReaderOpt, (TypeReferenceHandle)entityHandle, rawTypeKind);
							case HandleKind.TypeSpecification:
								if (!allowTypeSpecifications)
								{
									throw new BadImageFormatException(MDCFR.Properties.Resources.NotTypeDefOrRefHandle);
								}
								return _provider.GetTypeFromSpecification(_metadataReaderOpt, _genericContext, (TypeSpecificationHandle)entityHandle, rawTypeKind);
						}
					}
					throw new BadImageFormatException(MDCFR.Properties.Resources.NotTypeDefOrRefOrSpecHandle);
				}

				private static void CheckHeader(SignatureHeader header, SignatureKind expectedKind)
				{
					if (header.Kind != expectedKind)
					{
						throw new BadImageFormatException(System.SR.Format(MDCFR.Properties.Resources.UnexpectedSignatureHeader, expectedKind, header.Kind, header.RawValue));
					}
				}

				private static void CheckMethodOrPropertyHeader(SignatureHeader header)
				{
					SignatureKind kind = header.Kind;
					if (kind != 0 && kind != SignatureKind.Property)
					{
						throw new BadImageFormatException(System.SR.Format(MDCFR.Properties.Resources.UnexpectedSignatureHeader2, SignatureKind.Property, SignatureKind.Method, header.Kind, header.RawValue));
					}
				}
			}

			public readonly struct SignatureTypeEncoder
			{
				public BlobBuilder Builder { get; }

				public SignatureTypeEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				private void WriteTypeCode(SignatureTypeCode value)
				{
					Builder.WriteByte((byte)value);
				}

				private void ClassOrValue(bool isValueType)
				{
					Builder.WriteByte((byte)(isValueType ? 17 : 18));
				}

				public void Boolean()
				{
					WriteTypeCode(SignatureTypeCode.Boolean);
				}

				public void Char()
				{
					WriteTypeCode(SignatureTypeCode.Char);
				}

				public void SByte()
				{
					WriteTypeCode(SignatureTypeCode.SByte);
				}

				public void Byte()
				{
					WriteTypeCode(SignatureTypeCode.Byte);
				}

				public void Int16()
				{
					WriteTypeCode(SignatureTypeCode.Int16);
				}

				public void UInt16()
				{
					WriteTypeCode(SignatureTypeCode.UInt16);
				}

				public void Int32()
				{
					WriteTypeCode(SignatureTypeCode.Int32);
				}

				public void UInt32()
				{
					WriteTypeCode(SignatureTypeCode.UInt32);
				}

				public void Int64()
				{
					WriteTypeCode(SignatureTypeCode.Int64);
				}

				public void UInt64()
				{
					WriteTypeCode(SignatureTypeCode.UInt64);
				}

				public void Single()
				{
					WriteTypeCode(SignatureTypeCode.Single);
				}

				public void Double()
				{
					WriteTypeCode(SignatureTypeCode.Double);
				}

				public void String()
				{
					WriteTypeCode(SignatureTypeCode.String);
				}

				public void IntPtr()
				{
					WriteTypeCode(SignatureTypeCode.IntPtr);
				}

				public void UIntPtr()
				{
					WriteTypeCode(SignatureTypeCode.UIntPtr);
				}

				public void Object()
				{
					WriteTypeCode(SignatureTypeCode.Object);
				}

				/// <summary>
				/// Writes primitive type code.
				/// </summary>
				/// <param name="type">Any primitive type code except for <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.TypedReference" /> and <see cref="F:System.Reflection.Metadata.PrimitiveTypeCode.Void" />.</param>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="type" /> is not valid in this context.</exception>
				public void PrimitiveType(PrimitiveTypeCode type)
				{
					switch (type)
					{
						case PrimitiveTypeCode.Boolean:
						case PrimitiveTypeCode.Char:
						case PrimitiveTypeCode.SByte:
						case PrimitiveTypeCode.Byte:
						case PrimitiveTypeCode.Int16:
						case PrimitiveTypeCode.UInt16:
						case PrimitiveTypeCode.Int32:
						case PrimitiveTypeCode.UInt32:
						case PrimitiveTypeCode.Int64:
						case PrimitiveTypeCode.UInt64:
						case PrimitiveTypeCode.Single:
						case PrimitiveTypeCode.Double:
						case PrimitiveTypeCode.String:
						case PrimitiveTypeCode.IntPtr:
						case PrimitiveTypeCode.UIntPtr:
						case PrimitiveTypeCode.Object:
							Builder.WriteByte((byte)type);
							break;
						default:
							System.Reflection.Throw.ArgumentOutOfRange("type");
							break;
					}
				}

				/// <summary>
				/// Encodes an array type.
				/// Returns a pair of encoders that must be used in the order they appear in the parameter list.
				/// </summary>
				/// <param name="elementType">Use first, to encode the type of the element.</param>
				/// <param name="arrayShape">Use second, to encode the shape of the array.</param>
				public void Array(out SignatureTypeEncoder elementType, out ArrayShapeEncoder arrayShape)
				{
					Builder.WriteByte(20);
					elementType = this;
					arrayShape = new ArrayShapeEncoder(Builder);
				}

				/// <summary>
				/// Encodes an array type.
				/// </summary>
				/// <param name="elementType">Called first, to encode the type of the element.</param>
				/// <param name="arrayShape">Called second, to encode the shape of the array.</param>
				/// <exception cref="T:System.ArgumentNullException"><paramref name="elementType" /> or <paramref name="arrayShape" /> is null.</exception>
				public void Array(Action<SignatureTypeEncoder> elementType, Action<ArrayShapeEncoder> arrayShape)
				{
					if (elementType == null)
					{
						System.Reflection.Throw.ArgumentNull("elementType");
					}
					if (arrayShape == null)
					{
						System.Reflection.Throw.ArgumentNull("arrayShape");
					}
					Array(out var elementType2, out var arrayShape2);
					elementType(elementType2);
					arrayShape(arrayShape2);
				}

				/// <summary>
				/// Encodes a reference to a type.
				/// </summary>
				/// <param name="type"><see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
				/// <param name="isValueType">True to mark the type as value type, false to mark it as a reference type in the signature.</param>
				/// <exception cref="T:System.ArgumentException"><paramref name="type" /> doesn't have the expected handle kind.</exception>
				public void Type(EntityHandle type, bool isValueType)
				{
					int value = CodedIndex.TypeDefOrRef(type);
					ClassOrValue(isValueType);
					Builder.WriteCompressedInteger(value);
				}

				/// <summary>
				/// Starts a function pointer signature.
				/// </summary>
				/// <param name="convention">Calling convention.</param>
				/// <param name="attributes">Function pointer attributes.</param>
				/// <param name="genericParameterCount">Generic parameter count.</param>
				/// <exception cref="T:System.ArgumentException"><paramref name="attributes" /> is invalid.</exception>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="genericParameterCount" /> is not in range [0, 0xffff].</exception>
				public MethodSignatureEncoder FunctionPointer(SignatureCallingConvention convention = SignatureCallingConvention.Default, FunctionPointerAttributes attributes = FunctionPointerAttributes.None, int genericParameterCount = 0)
				{
					if (attributes != 0 && attributes != FunctionPointerAttributes.HasThis && attributes != FunctionPointerAttributes.HasExplicitThis)
					{
						throw new ArgumentException(MDCFR.Properties.Resources.InvalidSignature, "attributes");
					}
					if ((uint)genericParameterCount > 65535u)
					{
						System.Reflection.Throw.ArgumentOutOfRange("genericParameterCount");
					}
					Builder.WriteByte(27);
					Builder.WriteByte(new SignatureHeader(SignatureKind.Method, convention, (SignatureAttributes)attributes).RawValue);
					if (genericParameterCount != 0)
					{
						Builder.WriteCompressedInteger(genericParameterCount);
					}
					return new MethodSignatureEncoder(Builder, convention == SignatureCallingConvention.VarArgs);
				}

				/// <summary>
				/// Starts a generic instantiation signature.
				/// </summary>
				/// <param name="genericType"><see cref="T:System.Reflection.Metadata.TypeDefinitionHandle" /> or <see cref="T:System.Reflection.Metadata.TypeReferenceHandle" />.</param>
				/// <param name="genericArgumentCount">Generic argument count.</param>
				/// <param name="isValueType">True to mark the type as value type, false to mark it as a reference type in the signature.</param>
				/// <exception cref="T:System.ArgumentException"><paramref name="genericType" /> doesn't have the expected handle kind.</exception>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="genericArgumentCount" /> is not in range [1, 0xffff].</exception>
				public GenericTypeArgumentsEncoder GenericInstantiation(EntityHandle genericType, int genericArgumentCount, bool isValueType)
				{
					if ((uint)(genericArgumentCount - 1) > 65534u)
					{
						System.Reflection.Throw.ArgumentOutOfRange("genericArgumentCount");
					}
					int value = CodedIndex.TypeDefOrRef(genericType);
					Builder.WriteByte(21);
					ClassOrValue(isValueType);
					Builder.WriteCompressedInteger(value);
					Builder.WriteCompressedInteger(genericArgumentCount);
					return new GenericTypeArgumentsEncoder(Builder);
				}

				/// <summary>
				/// Encodes a reference to type parameter of a containing generic method.
				/// </summary>
				/// <param name="parameterIndex">Parameter index.</param>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="parameterIndex" /> is not in range [0, 0xffff].</exception>
				public void GenericMethodTypeParameter(int parameterIndex)
				{
					if ((uint)parameterIndex > 65535u)
					{
						System.Reflection.Throw.ArgumentOutOfRange("parameterIndex");
					}
					Builder.WriteByte(30);
					Builder.WriteCompressedInteger(parameterIndex);
				}

				/// <summary>
				/// Encodes a reference to type parameter of a containing generic type.
				/// </summary>
				/// <param name="parameterIndex">Parameter index.</param>
				/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="parameterIndex" /> is not in range [0, 0xffff].</exception>
				public void GenericTypeParameter(int parameterIndex)
				{
					if ((uint)parameterIndex > 65535u)
					{
						System.Reflection.Throw.ArgumentOutOfRange("parameterIndex");
					}
					Builder.WriteByte(19);
					Builder.WriteCompressedInteger(parameterIndex);
				}

				/// <summary>
				/// Starts pointer signature.
				/// </summary>
				public SignatureTypeEncoder Pointer()
				{
					Builder.WriteByte(15);
					return this;
				}

				/// <summary>
				/// Encodes <code>void*</code>.
				/// </summary>
				public void VoidPointer()
				{
					Builder.WriteByte(15);
					Builder.WriteByte(1);
				}

				/// <summary>
				/// Starts SZ array (vector) signature.
				/// </summary>
				public SignatureTypeEncoder SZArray()
				{
					Builder.WriteByte(29);
					return this;
				}

				/// <summary>
				/// Starts a signature of a type with custom modifiers.
				/// </summary>
				public CustomModifiersEncoder CustomModifiers()
				{
					return new CustomModifiersEncoder(Builder);
				}
			}

			internal readonly struct StandAloneSigTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsBlobHeapRefSizeSmall;

				private readonly int _SignatureOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal StandAloneSigTableReader(int numberOfRows, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_SignatureOffset = 0;
					RowSize = _SignatureOffset + blobHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal BlobHandle GetSignature(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _SignatureOffset, _IsBlobHeapRefSizeSmall));
				}
			}

			internal readonly struct StateMachineMethodTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _isMethodRefSizeSmall;

				private const int MoveNextMethodOffset = 0;

				private readonly int _kickoffMethodOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal StateMachineMethodTableReader(int numberOfRows, bool declaredSorted, int methodRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_isMethodRefSizeSmall = methodRefSize == 2;
					_kickoffMethodOffset = methodRefSize;
					RowSize = _kickoffMethodOffset + methodRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
					if (numberOfRows > 0 && !declaredSorted)
					{
						System.Reflection.Throw.TableNotSorted(TableIndex.StateMachineMethod);
					}
				}

				internal MethodDefinitionHandle FindKickoffMethod(int moveNextMethodRowId)
				{
					int num = Block.BinarySearchReference(NumberOfRows, RowSize, 0, (uint)moveNextMethodRowId, _isMethodRefSizeSmall);
					if (num < 0)
					{
						return default(MethodDefinitionHandle);
					}
					return GetKickoffMethod(num + 1);
				}

				private MethodDefinitionHandle GetKickoffMethod(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return MethodDefinitionHandle.FromRowId(Block.PeekReference(num + _kickoffMethodOffset, _isMethodRefSizeSmall));
				}
			}

			internal struct StreamHeader
			{
				internal uint Offset;

				internal int Size;

				internal string Name;
			}

			internal static class StringHandleType
			{
				internal const uint TypeMask = 3758096384u;

				internal const uint NonVirtualTypeMask = 1610612736u;

				internal const uint String = 0u;

				internal const uint DotTerminatedString = 536870912u;

				internal const uint ReservedString1 = 1073741824u;

				internal const uint ReservedString2 = 1610612736u;

				internal const uint VirtualString = 2147483648u;

				internal const uint WinRTPrefixedString = 2684354560u;

				internal const uint ReservedVirtualString1 = 3221225472u;

				internal const uint ReservedVirtualString2 = 3758096384u;
			}

			internal struct StringHeap
			{
				private static string[] s_virtualValues;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				private VirtualHeap _lazyVirtualHeap;

				internal StringHeap(System.Reflection.Internal.MemoryBlock block, MetadataKind metadataKind)
				{
					_lazyVirtualHeap = null;
					if (s_virtualValues == null && metadataKind != 0)
					{
						s_virtualValues = new string[71]
						{
					"System.Runtime.WindowsRuntime", "System.Runtime", "System.ObjectModel", "System.Runtime.WindowsRuntime.UI.Xaml", "System.Runtime.InteropServices.WindowsRuntime", "System.Numerics.Vectors", "Dispose", "AttributeTargets", "AttributeUsageAttribute", "Color",
					"CornerRadius", "DateTimeOffset", "Duration", "DurationType", "EventHandler`1", "EventRegistrationToken", "Exception", "GeneratorPosition", "GridLength", "GridUnitType",
					"ICommand", "IDictionary`2", "IDisposable", "IEnumerable", "IEnumerable`1", "IList", "IList`1", "INotifyCollectionChanged", "INotifyPropertyChanged", "IReadOnlyDictionary`2",
					"IReadOnlyList`1", "KeyTime", "KeyValuePair`2", "Matrix", "Matrix3D", "Matrix3x2", "Matrix4x4", "NotifyCollectionChangedAction", "NotifyCollectionChangedEventArgs", "NotifyCollectionChangedEventHandler",
					"Nullable`1", "Plane", "Point", "PropertyChangedEventArgs", "PropertyChangedEventHandler", "Quaternion", "Rect", "RepeatBehavior", "RepeatBehaviorType", "Size",
					"System", "System.Collections", "System.Collections.Generic", "System.Collections.Specialized", "System.ComponentModel", "System.Numerics", "System.Windows.Input", "Thickness", "TimeSpan", "Type",
					"Uri", "Vector2", "Vector3", "Vector4", "Windows.Foundation", "Windows.UI", "Windows.UI.Xaml", "Windows.UI.Xaml.Controls.Primitives", "Windows.UI.Xaml.Media", "Windows.UI.Xaml.Media.Animation",
					"Windows.UI.Xaml.Media.Media3D"
						};
					}
					Block = TrimEnd(block);
				}

				[Conditional("DEBUG")]
				private static void AssertFilled()
				{
					for (int i = 0; i < s_virtualValues.Length; i++)
					{
					}
				}

				private static System.Reflection.Internal.MemoryBlock TrimEnd(System.Reflection.Internal.MemoryBlock block)
				{
					if (block.Length == 0)
					{
						return block;
					}
					int num = block.Length - 1;
					while (num >= 0 && block.PeekByte(num) == 0)
					{
						num--;
					}
					if (num == block.Length - 1)
					{
						return block;
					}
					return block.GetMemoryBlockAt(0, num + 2);
				}

				internal string GetString(StringHandle handle, MetadataStringDecoder utf8Decoder)
				{
					if (!handle.IsVirtual)
					{
						return GetNonVirtualString(handle, utf8Decoder, null);
					}
					return GetVirtualHandleString(handle, utf8Decoder);
				}

				internal System.Reflection.Internal.MemoryBlock GetMemoryBlock(StringHandle handle)
				{
					if (!handle.IsVirtual)
					{
						return GetNonVirtualStringMemoryBlock(handle);
					}
					return GetVirtualHandleMemoryBlock(handle);
				}

				internal static string GetVirtualString(StringHandle.VirtualIndex index)
				{
					return s_virtualValues[(int)index];
				}

				private string GetNonVirtualString(StringHandle handle, MetadataStringDecoder utf8Decoder, byte[] prefixOpt)
				{
					char terminator = ((handle.StringKind == System.Reflection.Metadata.Ecma335.StringKind.DotTerminated) ? '.' : '\0');
					int numberOfBytesRead;
					return Block.PeekUtf8NullTerminated(handle.GetHeapOffset(), prefixOpt, utf8Decoder, out numberOfBytesRead, terminator);
				}

				private unsafe System.Reflection.Internal.MemoryBlock GetNonVirtualStringMemoryBlock(StringHandle handle)
				{
					char terminator = ((handle.StringKind == System.Reflection.Metadata.Ecma335.StringKind.DotTerminated) ? '.' : '\0');
					int heapOffset = handle.GetHeapOffset();
					int numberOfBytesRead;
					int utf8NullTerminatedLength = Block.GetUtf8NullTerminatedLength(heapOffset, out numberOfBytesRead, terminator);
					return new System.Reflection.Internal.MemoryBlock(Block.Pointer + heapOffset, utf8NullTerminatedLength);
				}

				private unsafe byte[] GetNonVirtualStringBytes(StringHandle handle, byte[] prefix)
				{
					System.Reflection.Internal.MemoryBlock nonVirtualStringMemoryBlock = GetNonVirtualStringMemoryBlock(handle);
					byte[] array = new byte[prefix.Length + nonVirtualStringMemoryBlock.Length];
					Buffer.BlockCopy(prefix, 0, array, 0, prefix.Length);
					Marshal.Copy((IntPtr)nonVirtualStringMemoryBlock.Pointer, array, prefix.Length, nonVirtualStringMemoryBlock.Length);
					return array;
				}

				private string GetVirtualHandleString(StringHandle handle, MetadataStringDecoder utf8Decoder)
				{
					return handle.StringKind switch
					{
						System.Reflection.Metadata.Ecma335.StringKind.Virtual => GetVirtualString(handle.GetVirtualIndex()),
						System.Reflection.Metadata.Ecma335.StringKind.WinRTPrefixed => GetNonVirtualString(handle, utf8Decoder, MetadataReader.WinRTPrefix),
						_ => throw ExceptionUtilities.UnexpectedValue(handle.StringKind),
					};
				}

				private System.Reflection.Internal.MemoryBlock GetVirtualHandleMemoryBlock(StringHandle handle)
				{
					VirtualHeap orCreateVirtualHeap = VirtualHeap.GetOrCreateVirtualHeap(ref _lazyVirtualHeap);
					lock (orCreateVirtualHeap)
					{
						if (!orCreateVirtualHeap.TryGetMemoryBlock(handle.RawValue, out var block))
						{
							byte[] value = handle.StringKind switch
							{
								System.Reflection.Metadata.Ecma335.StringKind.Virtual => Encoding.UTF8.GetBytes(GetVirtualString(handle.GetVirtualIndex())),
								System.Reflection.Metadata.Ecma335.StringKind.WinRTPrefixed => GetNonVirtualStringBytes(handle, MetadataReader.WinRTPrefix),
								_ => throw ExceptionUtilities.UnexpectedValue(handle.StringKind),
							};
							return orCreateVirtualHeap.AddBlob(handle.RawValue, value);
						}
						return block;
					}
				}

				internal BlobReader GetBlobReader(StringHandle handle)
				{
					return new BlobReader(GetMemoryBlock(handle));
				}

				internal StringHandle GetNextHandle(StringHandle handle)
				{
					if (handle.IsVirtual)
					{
						return default(StringHandle);
					}
					int num = Block.IndexOf(0, handle.GetHeapOffset());
					if (num == -1 || num == Block.Length - 1)
					{
						return default(StringHandle);
					}
					return StringHandle.FromOffset(num + 1);
				}

				internal bool Equals(StringHandle handle, string value, MetadataStringDecoder utf8Decoder, bool ignoreCase)
				{
					if (handle.IsVirtual)
					{
						return string.Equals(GetString(handle, utf8Decoder), value, ignoreCase ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);
					}
					if (handle.IsNil)
					{
						return value.Length == 0;
					}
					char terminator = ((handle.StringKind == System.Reflection.Metadata.Ecma335.StringKind.DotTerminated) ? '.' : '\0');
					return Block.Utf8NullTerminatedEquals(handle.GetHeapOffset(), value, utf8Decoder, terminator, ignoreCase);
				}

				internal bool StartsWith(StringHandle handle, string value, MetadataStringDecoder utf8Decoder, bool ignoreCase)
				{
					if (handle.IsVirtual)
					{
						return GetString(handle, utf8Decoder).StartsWith(value, ignoreCase ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal);
					}
					if (handle.IsNil)
					{
						return value.Length == 0;
					}
					char terminator = ((handle.StringKind == System.Reflection.Metadata.Ecma335.StringKind.DotTerminated) ? '.' : '\0');
					return Block.Utf8NullTerminatedStartsWith(handle.GetHeapOffset(), value, utf8Decoder, terminator, ignoreCase);
				}

				/// <summary>
				/// Returns true if the given raw (non-virtual) handle represents the same string as given ASCII string.
				/// </summary>
				internal bool EqualsRaw(StringHandle rawHandle, string asciiString)
				{
					return Block.CompareUtf8NullTerminatedStringWithAsciiString(rawHandle.GetHeapOffset(), asciiString) == 0;
				}

				/// <summary>
				/// Returns the heap index of the given ASCII character or -1 if not found prior null terminator or end of heap.
				/// </summary>
				internal int IndexOfRaw(int startIndex, char asciiChar)
				{
					return Block.Utf8NullTerminatedOffsetOfAsciiChar(startIndex, asciiChar);
				}

				/// <summary>
				/// Returns true if the given raw (non-virtual) handle represents a string that starts with given ASCII prefix.
				/// </summary>
				internal bool StartsWithRaw(StringHandle rawHandle, string asciiPrefix)
				{
					return Block.Utf8NullTerminatedStringStartsWithAsciiPrefix(rawHandle.GetHeapOffset(), asciiPrefix);
				}

				/// <summary>
				/// Equivalent to Array.BinarySearch, searches for given raw (non-virtual) handle in given array of ASCII strings.
				/// </summary>
				internal int BinarySearchRaw(string[] asciiKeys, StringHandle rawHandle)
				{
					return Block.BinarySearch(asciiKeys, rawHandle.GetHeapOffset());
				}
			}

			internal enum StringKind : byte { Plain = 0, Virtual = 4, WinRTPrefixed = 5, DotTerminated = 1 }

			public enum TableIndex : byte
			{
				Module = 0,
				TypeRef = 1,
				TypeDef = 2,
				FieldPtr = 3,
				Field = 4,
				MethodPtr = 5,
				MethodDef = 6,
				ParamPtr = 7,
				Param = 8,
				InterfaceImpl = 9,
				MemberRef = 10,
				Constant = 11,
				CustomAttribute = 12,
				FieldMarshal = 13,
				DeclSecurity = 14,
				ClassLayout = 15,
				FieldLayout = 16,
				StandAloneSig = 17,
				EventMap = 18,
				EventPtr = 19,
				Event = 20,
				PropertyMap = 21,
				PropertyPtr = 22,
				Property = 23,
				MethodSemantics = 24,
				MethodImpl = 25,
				ModuleRef = 26,
				TypeSpec = 27,
				ImplMap = 28,
				FieldRva = 29,
				EncLog = 30,
				EncMap = 31,
				Assembly = 32,
				AssemblyProcessor = 33,
				AssemblyOS = 34,
				AssemblyRef = 35,
				AssemblyRefProcessor = 36,
				AssemblyRefOS = 37,
				File = 38,
				ExportedType = 39,
				ManifestResource = 40,
				NestedClass = 41,
				GenericParam = 42,
				MethodSpec = 43,
				GenericParamConstraint = 44,
				Document = 48,
				MethodDebugInformation = 49,
				LocalScope = 50,
				LocalVariable = 51,
				LocalConstant = 52,
				ImportScope = 53,
				StateMachineMethod = 54,
				CustomDebugInformation = 55
			}

			[Flags]
			internal enum TableMask : ulong
			{
				Module = 1uL,
				TypeRef = 2uL,
				TypeDef = 4uL,
				FieldPtr = 8uL,
				Field = 0x10uL,
				MethodPtr = 0x20uL,
				MethodDef = 0x40uL,
				ParamPtr = 0x80uL,
				Param = 0x100uL,
				InterfaceImpl = 0x200uL,
				MemberRef = 0x400uL,
				Constant = 0x800uL,
				CustomAttribute = 0x1000uL,
				FieldMarshal = 0x2000uL,
				DeclSecurity = 0x4000uL,
				ClassLayout = 0x8000uL,
				FieldLayout = 0x10000uL,
				StandAloneSig = 0x20000uL,
				EventMap = 0x40000uL,
				EventPtr = 0x80000uL,
				Event = 0x100000uL,
				PropertyMap = 0x200000uL,
				PropertyPtr = 0x400000uL,
				Property = 0x800000uL,
				MethodSemantics = 0x1000000uL,
				MethodImpl = 0x2000000uL,
				ModuleRef = 0x4000000uL,
				TypeSpec = 0x8000000uL,
				ImplMap = 0x10000000uL,
				FieldRva = 0x20000000uL,
				EnCLog = 0x40000000uL,
				EnCMap = 0x80000000uL,
				Assembly = 0x100000000uL,
				AssemblyRef = 0x800000000uL,
				File = 0x4000000000uL,
				ExportedType = 0x8000000000uL,
				ManifestResource = 0x10000000000uL,
				NestedClass = 0x20000000000uL,
				GenericParam = 0x40000000000uL,
				MethodSpec = 0x80000000000uL,
				GenericParamConstraint = 0x100000000000uL,
				Document = 0x1000000000000uL,
				MethodDebugInformation = 0x2000000000000uL,
				LocalScope = 0x4000000000000uL,
				LocalVariable = 0x8000000000000uL,
				LocalConstant = 0x10000000000000uL,
				ImportScope = 0x20000000000000uL,
				StateMachineMethod = 0x40000000000000uL,
				CustomDebugInformation = 0x80000000000000uL,
				PtrTables = 0x4800A8uL,
				EncTables = 0xC0000000uL,
				TypeSystemTables = 0x1FC9FFFFFFFFuL,
				DebugTables = 0xFF000000000000uL,
				AllTables = 0xFF1FC9FFFFFFFFuL,
				ValidPortablePdbExternalTables = 0x1FC93FB7FF57uL
			}

			internal static class TokenTypeIds
			{
				internal const uint Module = 0u;

				internal const uint TypeRef = 16777216u;

				internal const uint TypeDef = 33554432u;

				internal const uint FieldDef = 67108864u;

				internal const uint MethodDef = 100663296u;

				internal const uint ParamDef = 134217728u;

				internal const uint InterfaceImpl = 150994944u;

				internal const uint MemberRef = 167772160u;

				internal const uint Constant = 184549376u;

				internal const uint CustomAttribute = 201326592u;

				internal const uint DeclSecurity = 234881024u;

				internal const uint Signature = 285212672u;

				internal const uint EventMap = 301989888u;

				internal const uint Event = 335544320u;

				internal const uint PropertyMap = 352321536u;

				internal const uint Property = 385875968u;

				internal const uint MethodSemantics = 402653184u;

				internal const uint MethodImpl = 419430400u;

				internal const uint ModuleRef = 436207616u;

				internal const uint TypeSpec = 452984832u;

				internal const uint Assembly = 536870912u;

				internal const uint AssemblyRef = 587202560u;

				internal const uint File = 637534208u;

				internal const uint ExportedType = 654311424u;

				internal const uint ManifestResource = 671088640u;

				internal const uint NestedClass = 687865856u;

				internal const uint GenericParam = 704643072u;

				internal const uint MethodSpec = 721420288u;

				internal const uint GenericParamConstraint = 738197504u;

				internal const uint Document = 805306368u;

				internal const uint MethodDebugInformation = 822083584u;

				internal const uint LocalScope = 838860800u;

				internal const uint LocalVariable = 855638016u;

				internal const uint LocalConstant = 872415232u;

				internal const uint ImportScope = 889192448u;

				internal const uint AsyncMethod = 905969664u;

				internal const uint CustomDebugInformation = 922746880u;

				internal const uint UserString = 1879048192u;

				internal const int RowIdBitCount = 24;

				internal const uint RIDMask = 16777215u;

				internal const uint TypeMask = 2130706432u;

				/// <summary>
				/// Use the highest bit to mark tokens that are virtual (synthesized).
				/// We create virtual tokens to represent projected WinMD entities.
				/// </summary>
				internal const uint VirtualBit = 2147483648u;

				/// <summary>
				/// Returns true if the token value can escape the metadata reader.
				/// We don't allow virtual tokens and heap tokens other than UserString to escape
				/// since the token type ids are internal to the reader and not specified by ECMA spec.
				///
				/// Spec (Partition III, 1.9 Metadata tokens):
				/// Many CIL instructions are followed by a "metadata token". This is a 4-byte value, that specifies a row in a
				/// metadata table, or a starting byte offset in the User String heap.
				///
				/// For example, a value of 0x02 specifies the TypeDef table; a value of 0x70 specifies the User
				/// String heap.The value corresponds to the number assigned to that metadata table (see Partition II for the full
				/// list of tables) or to 0x70 for the User String heap.The least-significant 3 bytes specify the target row within that
				/// metadata table, or starting byte offset within the User String heap.
				/// </summary>
				internal static bool IsEntityOrUserStringToken(uint vToken)
				{
					return (vToken & 0x7F000000) <= 1879048192;
				}

				internal static bool IsEntityToken(uint vToken)
				{
					return (vToken & 0x7F000000) < 1879048192;
				}

				internal static bool IsValidRowId(uint rowId)
				{
					return (rowId & 0xFF000000u) == 0;
				}

				internal static bool IsValidRowId(int rowId)
				{
					return (rowId & 0xFF000000u) == 0;
				}
			}

			internal static class TypeDefOrRefTag
			{
				internal const int NumberOfBits = 2;

				internal const int LargeRowSize = 16384;

				internal const uint TypeDef = 0u;

				internal const uint TypeRef = 1u;

				internal const uint TypeSpec = 2u;

				internal const uint TagMask = 3u;

				internal const uint TagToTokenTypeByteVector = 1769730u;

				internal const System.Reflection.Metadata.Ecma335.TableMask TablesReferenced = System.Reflection.Metadata.Ecma335.TableMask.TypeRef | System.Reflection.Metadata.Ecma335.TableMask.TypeDef | System.Reflection.Metadata.Ecma335.TableMask.TypeSpec;

				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				internal static EntityHandle ConvertToHandle(uint typeDefOrRefTag)
				{
					uint num = 1769730u >> (int)((typeDefOrRefTag & 3) << 3) << 24;
					uint num2 = typeDefOrRefTag >> 2;
					if (num == 0 || (num2 & 0xFF000000u) != 0)
					{
						System.Reflection.Throw.InvalidCodedIndex();
					}
					return new EntityHandle(num | num2);
				}
			}

			internal struct TypeDefTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsFieldRefSizeSmall;

				private readonly bool _IsMethodRefSizeSmall;

				private readonly bool _IsTypeDefOrRefRefSizeSmall;

				private readonly bool _IsStringHeapRefSizeSmall;

				private readonly int _FlagsOffset;

				private readonly int _NameOffset;

				private readonly int _NamespaceOffset;

				private readonly int _ExtendsOffset;

				private readonly int _FieldListOffset;

				private readonly int _MethodListOffset;

				internal readonly int RowSize;

				internal System.Reflection.Internal.MemoryBlock Block;

				internal TypeDefTableReader(int numberOfRows, int fieldRefSize, int methodRefSize, int typeDefOrRefRefSize, int stringHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsFieldRefSizeSmall = fieldRefSize == 2;
					_IsMethodRefSizeSmall = methodRefSize == 2;
					_IsTypeDefOrRefRefSizeSmall = typeDefOrRefRefSize == 2;
					_IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_FlagsOffset = 0;
					_NameOffset = _FlagsOffset + 4;
					_NamespaceOffset = _NameOffset + stringHeapRefSize;
					_ExtendsOffset = _NamespaceOffset + stringHeapRefSize;
					_FieldListOffset = _ExtendsOffset + typeDefOrRefRefSize;
					_MethodListOffset = _FieldListOffset + fieldRefSize;
					RowSize = _MethodListOffset + methodRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal TypeAttributes GetFlags(TypeDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return (TypeAttributes)Block.PeekUInt32(num + _FlagsOffset);
				}

				internal NamespaceDefinitionHandle GetNamespaceDefinition(TypeDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return NamespaceDefinitionHandle.FromFullNameOffset(Block.PeekHeapReference(num + _NamespaceOffset, _IsStringHeapRefSizeSmall));
				}

				internal StringHandle GetNamespace(TypeDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _NamespaceOffset, _IsStringHeapRefSizeSmall));
				}

				internal StringHandle GetName(TypeDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _NameOffset, _IsStringHeapRefSizeSmall));
				}

				internal EntityHandle GetExtends(TypeDefinitionHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return TypeDefOrRefTag.ConvertToHandle(Block.PeekTaggedReference(num + _ExtendsOffset, _IsTypeDefOrRefRefSizeSmall));
				}

				internal int GetFieldStart(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return Block.PeekReference(num + _FieldListOffset, _IsFieldRefSizeSmall);
				}

				internal int GetMethodStart(int rowId)
				{
					int num = (rowId - 1) * RowSize;
					return Block.PeekReference(num + _MethodListOffset, _IsMethodRefSizeSmall);
				}

				internal TypeDefinitionHandle FindTypeContainingMethod(int methodDefOrPtrRowId, int numberOfMethods)
				{
					int numberOfRows = NumberOfRows;
					int num = Block.BinarySearchForSlot(numberOfRows, RowSize, _MethodListOffset, (uint)methodDefOrPtrRowId, _IsMethodRefSizeSmall);
					int num2 = num + 1;
					if (num2 == 0)
					{
						return default(TypeDefinitionHandle);
					}
					if (num2 > numberOfRows)
					{
						if (methodDefOrPtrRowId <= numberOfMethods)
						{
							return TypeDefinitionHandle.FromRowId(numberOfRows);
						}
						return default(TypeDefinitionHandle);
					}
					int methodStart = GetMethodStart(num2);
					if (methodStart == methodDefOrPtrRowId)
					{
						while (num2 < numberOfRows)
						{
							int num3 = num2 + 1;
							methodStart = GetMethodStart(num3);
							if (methodStart != methodDefOrPtrRowId)
							{
								break;
							}
							num2 = num3;
						}
					}
					return TypeDefinitionHandle.FromRowId(num2);
				}

				internal TypeDefinitionHandle FindTypeContainingField(int fieldDefOrPtrRowId, int numberOfFields)
				{
					int numberOfRows = NumberOfRows;
					int num = Block.BinarySearchForSlot(numberOfRows, RowSize, _FieldListOffset, (uint)fieldDefOrPtrRowId, _IsFieldRefSizeSmall);
					int num2 = num + 1;
					if (num2 == 0)
					{
						return default(TypeDefinitionHandle);
					}
					if (num2 > numberOfRows)
					{
						if (fieldDefOrPtrRowId <= numberOfFields)
						{
							return TypeDefinitionHandle.FromRowId(numberOfRows);
						}
						return default(TypeDefinitionHandle);
					}
					int fieldStart = GetFieldStart(num2);
					if (fieldStart == fieldDefOrPtrRowId)
					{
						while (num2 < numberOfRows)
						{
							int num3 = num2 + 1;
							fieldStart = GetFieldStart(num3);
							if (fieldStart != fieldDefOrPtrRowId)
							{
								break;
							}
							num2 = num3;
						}
					}
					return TypeDefinitionHandle.FromRowId(num2);
				}
			}

			[Flags]
			internal enum TypeDefTreatment : byte
			{
				None = 0,
				KindMask = 0xF,
				NormalNonAttribute = 1,
				NormalAttribute = 2,
				UnmangleWinRTName = 3,
				PrefixWinRTName = 4,
				RedirectedToClrType = 5,
				RedirectedToClrAttribute = 6,
				MarkAbstractFlag = 0x10,
				MarkInternalFlag = 0x20
			}

			internal static class TypeOrMethodDefTag
			{
				internal const int NumberOfBits = 1;

				internal const int LargeRowSize = 32768;

				internal const uint TypeDef = 0u;

				internal const uint MethodDef = 1u;

				internal const uint TagMask = 1u;

				internal const uint TagToTokenTypeByteVector = 1538u;

				internal const System.Reflection.Metadata.Ecma335.TableMask TablesReferenced = System.Reflection.Metadata.Ecma335.TableMask.TypeDef | System.Reflection.Metadata.Ecma335.TableMask.MethodDef;

				[MethodImpl(MethodImplOptions.AggressiveInlining)]
				internal static EntityHandle ConvertToHandle(uint typeOrMethodDef)
				{
					uint num = 1538u >> (int)((typeOrMethodDef & 1) << 3) << 24;
					uint num2 = typeOrMethodDef >> 1;
					if ((num2 & 0xFF000000u) != 0)
					{
						System.Reflection.Throw.InvalidCodedIndex();
					}
					return new EntityHandle(num | num2);
				}

				internal static uint ConvertTypeDefRowIdToTag(TypeDefinitionHandle typeDef)
				{
					return (uint)(typeDef.RowId << 1) | 0u;
				}

				internal static uint ConvertMethodDefToTag(MethodDefinitionHandle methodDef)
				{
					return (uint)(methodDef.RowId << 1) | 1u;
				}
			}

			internal enum TypeRefSignatureTreatment : byte { None, ProjectedToClass, ProjectedToValueType }

			internal readonly struct TypeRefTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsResolutionScopeRefSizeSmall;

				private readonly bool _IsStringHeapRefSizeSmall;

				private readonly int _ResolutionScopeOffset;

				private readonly int _NameOffset;

				private readonly int _NamespaceOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal TypeRefTableReader(int numberOfRows, int resolutionScopeRefSize, int stringHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsResolutionScopeRefSizeSmall = resolutionScopeRefSize == 2;
					_IsStringHeapRefSizeSmall = stringHeapRefSize == 2;
					_ResolutionScopeOffset = 0;
					_NameOffset = _ResolutionScopeOffset + resolutionScopeRefSize;
					_NamespaceOffset = _NameOffset + stringHeapRefSize;
					RowSize = _NamespaceOffset + stringHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal EntityHandle GetResolutionScope(TypeReferenceHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return ResolutionScopeTag.ConvertToHandle(Block.PeekTaggedReference(num + _ResolutionScopeOffset, _IsResolutionScopeRefSizeSmall));
				}

				internal StringHandle GetName(TypeReferenceHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _NameOffset, _IsStringHeapRefSizeSmall));
				}

				internal StringHandle GetNamespace(TypeReferenceHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return StringHandle.FromOffset(Block.PeekHeapReference(num + _NamespaceOffset, _IsStringHeapRefSizeSmall));
				}
			}

			internal enum TypeRefTreatment : byte { None, SystemDelegate, SystemAttribute, UseProjectionInfo }

			internal readonly struct TypeSpecTableReader
			{
				internal readonly int NumberOfRows;

				private readonly bool _IsBlobHeapRefSizeSmall;

				private readonly int _SignatureOffset;

				internal readonly int RowSize;

				internal readonly System.Reflection.Internal.MemoryBlock Block;

				internal TypeSpecTableReader(int numberOfRows, int blobHeapRefSize, System.Reflection.Internal.MemoryBlock containingBlock, int containingBlockOffset)
				{
					NumberOfRows = numberOfRows;
					_IsBlobHeapRefSizeSmall = blobHeapRefSize == 2;
					_SignatureOffset = 0;
					RowSize = _SignatureOffset + blobHeapRefSize;
					Block = containingBlock.GetMemoryBlockAt(containingBlockOffset, RowSize * numberOfRows);
				}

				internal BlobHandle GetSignature(TypeSpecificationHandle handle)
				{
					int num = (handle.RowId - 1) * RowSize;
					return BlobHandle.FromOffset(Block.PeekHeapReference(num + _SignatureOffset, _IsBlobHeapRefSizeSmall));
				}
			}

			internal readonly struct UserStringHeap
			{
				internal readonly System.Reflection.Internal.MemoryBlock Block;

				public UserStringHeap(System.Reflection.Internal.MemoryBlock block)
				{
					Block = block;
				}

				internal string GetString(UserStringHandle handle)
				{
					if (!Block.PeekHeapValueOffsetAndSize(handle.GetHeapOffset(), out var offset, out var size))
					{
						return string.Empty;
					}
					return Block.PeekUtf16(offset, size & -2);
				}

				internal UserStringHandle GetNextHandle(UserStringHandle handle)
				{
					if (!Block.PeekHeapValueOffsetAndSize(handle.GetHeapOffset(), out var offset, out var size))
					{
						return default(UserStringHandle);
					}
					int num = offset + size;
					if (num >= Block.Length)
					{
						return default(UserStringHandle);
					}
					return UserStringHandle.FromOffset(num);
				}
			}

			public readonly struct VectorEncoder
			{
				public BlobBuilder Builder { get; }

				public VectorEncoder(BlobBuilder builder)
				{
					Builder = builder;
				}

				public LiteralsEncoder Count(int count)
				{
					if (count < 0)
					{
						System.Reflection.Throw.ArgumentOutOfRange("count");
					}
					Builder.WriteUInt32((uint)count);
					return new LiteralsEncoder(Builder);
				}
			}

			internal sealed class VirtualHeap : System.Reflection.Internal.CriticalDisposableObject
			{
				private struct PinnedBlob
				{
					public GCHandle Handle;

					public readonly int Length;

					public PinnedBlob(GCHandle handle, int length)
					{
						Handle = handle;
						Length = length;
					}

					public unsafe System.Reflection.Internal.MemoryBlock GetMemoryBlock()
					{
						return new System.Reflection.Internal.MemoryBlock((byte*)(void*)Handle.AddrOfPinnedObject(), Length);
					}
				}

				private Dictionary<uint, PinnedBlob> _blobs;

				private VirtualHeap()
				{
					_blobs = new Dictionary<uint, PinnedBlob>();
				}

				protected override void Release()
				{
					RuntimeHelpers.PrepareConstrainedRegions();
					try
					{
					}
					finally
					{
						Dictionary<uint, PinnedBlob> dictionary = Interlocked.Exchange(ref _blobs, null);
						if (dictionary != null)
						{
							foreach (KeyValuePair<uint, PinnedBlob> item in dictionary)
							{
								item.Value.Handle.Free();
							}
						}
					}
				}

				private Dictionary<uint, PinnedBlob> GetBlobs()
				{
					Dictionary<uint, PinnedBlob> blobs = _blobs;
					if (blobs == null)
					{
						throw new ObjectDisposedException("VirtualHeap");
					}
					return blobs;
				}

				public bool TryGetMemoryBlock(uint rawHandle, out System.Reflection.Internal.MemoryBlock block)
				{
					if (!GetBlobs().TryGetValue(rawHandle, out var value))
					{
						block = default(System.Reflection.Internal.MemoryBlock);
						return false;
					}
					block = value.GetMemoryBlock();
					return true;
				}

				internal System.Reflection.Internal.MemoryBlock AddBlob(uint rawHandle, byte[] value)
				{
					Dictionary<uint, PinnedBlob> blobs = GetBlobs();
					RuntimeHelpers.PrepareConstrainedRegions();
					System.Reflection.Internal.MemoryBlock memoryBlock;
					try
					{
					}
					finally
					{
						PinnedBlob value2 = new PinnedBlob(GCHandle.Alloc(value, GCHandleType.Pinned), value.Length);
						blobs.Add(rawHandle, value2);
						memoryBlock = value2.GetMemoryBlock();
					}
					return memoryBlock;
				}

				internal static VirtualHeap GetOrCreateVirtualHeap(ref VirtualHeap? lazyHeap)
				{
					if (lazyHeap == null)
					{
						Interlocked.CompareExchange(ref lazyHeap, new VirtualHeap(), null);
					}
					return lazyHeap;
				}
			}
		}
	}

	namespace PortableExecutable
	{
		using System.Reflection.Internal;
        using System.Reflection.Metadata;
        using System.Runtime.ExceptionServices;
		
		[Flags]
		public enum Characteristics : ushort
		{
			RelocsStripped = 1,
			ExecutableImage = 2,
			LineNumsStripped = 4,
			LocalSymsStripped = 8,
			AggressiveWSTrim = 0x10,
			LargeAddressAware = 0x20,
			BytesReversedLo = 0x80,
			Bit32Machine = 0x100,
			DebugStripped = 0x200,
			RemovableRunFromSwap = 0x400,
			NetRunFromSwap = 0x800,
			System = 0x1000,
			Dll = 0x2000,
			UpSystemOnly = 0x4000,
			BytesReversedHi = 0x8000
		}

		public readonly struct CodeViewDebugDirectoryData
		{
			/// <summary>
			/// GUID (Globally Unique Identifier) of the associated PDB.
			/// </summary>
			public Guid Guid { get; }

			/// <summary>
			/// Iteration of the PDB. The first iteration is 1. The iteration is incremented each time the PDB content is augmented.
			/// </summary>
			public int Age { get; }

			/// <summary>
			/// Path to the .pdb file containing debug information for the PE/COFF file.
			/// </summary>
			public string Path { get; }

			internal CodeViewDebugDirectoryData(Guid guid, int age, string path)
			{
				Path = path;
				Guid = guid;
				Age = age;
			}
		}

		public sealed class CoffHeader
		{
			internal const int Size = 20;

			/// <summary>
			/// The type of target machine.
			/// </summary>
			public Machine Machine { get; }

			/// <summary>
			/// The number of sections. This indicates the size of the section table, which immediately follows the headers.
			/// </summary>
			public short NumberOfSections { get; }

			/// <summary>
			/// The low 32 bits of the number of seconds since 00:00 January 1, 1970, that indicates when the file was created.
			/// </summary>
			public int TimeDateStamp { get; }

			/// <summary>
			/// The file pointer to the COFF symbol table, or zero if no COFF symbol table is present.
			/// This value should be zero for a PE image.
			/// </summary>
			public int PointerToSymbolTable { get; }

			/// <summary>
			/// The number of entries in the symbol table. This data can be used to locate the string table,
			/// which immediately follows the symbol table. This value should be zero for a PE image.
			/// </summary>
			public int NumberOfSymbols { get; }

			/// <summary>
			/// The size of the optional header, which is required for executable files but not for object files.
			/// This value should be zero for an object file.
			/// </summary>
			public short SizeOfOptionalHeader { get; }

			/// <summary>
			/// The flags that indicate the attributes of the file.
			/// </summary>
			public Characteristics Characteristics { get; }

			internal CoffHeader(ref System.Reflection.PortableExecutable.PEBinaryReader reader)
			{
				Machine = (Machine)reader.ReadUInt16();
				NumberOfSections = reader.ReadInt16();
				TimeDateStamp = reader.ReadInt32();
				PointerToSymbolTable = reader.ReadInt32();
				NumberOfSymbols = reader.ReadInt32();
				SizeOfOptionalHeader = reader.ReadInt16();
				Characteristics = (Characteristics)reader.ReadUInt16();
			}
		}

		/// <summary>
		/// COR20Flags
		/// </summary>
		[Flags]
		public enum CorFlags
		{
			ILOnly = 1,
			Requires32Bit = 2,
			ILLibrary = 4,
			StrongNameSigned = 8,
			NativeEntryPoint = 0x10,
			TrackDebugData = 0x10000,
			Prefers32Bit = 0x20000
		}

		public sealed class CorHeader
		{
			public ushort MajorRuntimeVersion { get; }

			public ushort MinorRuntimeVersion { get; }

			public DirectoryEntry MetadataDirectory { get; }

			public CorFlags Flags { get; }

			public int EntryPointTokenOrRelativeVirtualAddress { get; }

			public DirectoryEntry ResourcesDirectory { get; }

			public DirectoryEntry StrongNameSignatureDirectory { get; }

			public DirectoryEntry CodeManagerTableDirectory { get; }

			public DirectoryEntry VtableFixupsDirectory { get; }

			public DirectoryEntry ExportAddressTableJumpsDirectory { get; }

			public DirectoryEntry ManagedNativeHeaderDirectory { get; }

			internal CorHeader(ref System.Reflection.PortableExecutable.PEBinaryReader reader)
			{
				reader.ReadInt32();
				MajorRuntimeVersion = reader.ReadUInt16();
				MinorRuntimeVersion = reader.ReadUInt16();
				MetadataDirectory = new DirectoryEntry(ref reader);
				Flags = (CorFlags)reader.ReadUInt32();
				EntryPointTokenOrRelativeVirtualAddress = reader.ReadInt32();
				ResourcesDirectory = new DirectoryEntry(ref reader);
				StrongNameSignatureDirectory = new DirectoryEntry(ref reader);
				CodeManagerTableDirectory = new DirectoryEntry(ref reader);
				VtableFixupsDirectory = new DirectoryEntry(ref reader);
				ExportAddressTableJumpsDirectory = new DirectoryEntry(ref reader);
				ManagedNativeHeaderDirectory = new DirectoryEntry(ref reader);
			}
		}

		public sealed class DebugDirectoryBuilder
		{
			private struct Entry
			{
				public uint Stamp;

				public uint Version;

				public DebugDirectoryEntryType Type;

				public int DataSize;
			}

			private readonly List<Entry> _entries;

			private readonly BlobBuilder _dataBuilder;

			internal int TableSize => 28 * _entries.Count;

			internal int Size => (TableSize + _dataBuilder?.Count).GetValueOrDefault();

			public DebugDirectoryBuilder()
			{
				_entries = new List<Entry>(3);
				_dataBuilder = new BlobBuilder();
			}

			internal void AddEntry(DebugDirectoryEntryType type, uint version, uint stamp, int dataSize)
			{
				_entries.Add(new Entry
				{
					Stamp = stamp,
					Version = version,
					Type = type,
					DataSize = dataSize
				});
			}

			/// <summary>
			/// Adds an entry.
			/// </summary>
			/// <param name="type">Entry type.</param>
			/// <param name="version">Entry version.</param>
			/// <param name="stamp">Entry stamp.</param>
			public void AddEntry(DebugDirectoryEntryType type, uint version, uint stamp)
			{
				AddEntry(type, version, stamp, 0);
			}

			/// <summary>
			/// Adds an entry.
			/// </summary>
			/// <typeparam name="TData">Type of data passed to <paramref name="dataSerializer" />.</typeparam>
			/// <param name="type">Entry type.</param>
			/// <param name="version">Entry version.</param>
			/// <param name="stamp">Entry stamp.</param>
			/// <param name="data">Data passed to <paramref name="dataSerializer" />.</param>
			/// <param name="dataSerializer">Serializes data to a <see cref="T:System.Reflection.Metadata.BlobBuilder" />.</param>
			public void AddEntry<TData>(DebugDirectoryEntryType type, uint version, uint stamp, TData data, Action<BlobBuilder, TData> dataSerializer)
			{
				if (dataSerializer == null)
				{
					System.Reflection.Throw.ArgumentNull("dataSerializer");
				}
				int count = _dataBuilder.Count;
				dataSerializer(_dataBuilder, data);
				int dataSize = _dataBuilder.Count - count;
				AddEntry(type, version, stamp, dataSize);
			}

			/// <summary>
			/// Adds a CodeView entry.
			/// </summary>
			/// <param name="pdbPath">Path to the PDB. Shall not be empty.</param>
			/// <param name="pdbContentId">Unique id of the PDB content.</param>
			/// <param name="portablePdbVersion">Version of Portable PDB format (e.g. 0x0100 for 1.0), or 0 if the PDB is not portable.</param>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="pdbPath" /> is null.</exception>
			/// <exception cref="T:System.ArgumentException"><paramref name="pdbPath" /> contains NUL character.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="portablePdbVersion" /> is smaller than 0x0100.</exception>
			public void AddCodeViewEntry(string pdbPath, BlobContentId pdbContentId, ushort portablePdbVersion)
			{
				AddCodeViewEntry(pdbPath, pdbContentId, portablePdbVersion, 1);
			}

			/// <summary>
			/// Adds a CodeView entry.
			/// </summary>
			/// <param name="pdbPath">Path to the PDB. Shall not be empty.</param>
			/// <param name="pdbContentId">Unique id of the PDB content.</param>
			/// <param name="portablePdbVersion">Version of Portable PDB format (e.g. 0x0100 for 1.0), or 0 if the PDB is not portable.</param>
			/// <param name="age">Age (iteration) of the PDB. Shall be 1 for Portable PDBs.</param>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="pdbPath" /> is null.</exception>
			/// <exception cref="T:System.ArgumentException"><paramref name="pdbPath" /> contains NUL character.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="age" /> is less than 1.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="portablePdbVersion" /> is smaller than 0x0100.</exception>
			public void AddCodeViewEntry(string pdbPath, BlobContentId pdbContentId, ushort portablePdbVersion, int age)
			{
				if (pdbPath == null)
				{
					System.Reflection.Throw.ArgumentNull("pdbPath");
				}
				if (age < 1)
				{
					System.Reflection.Throw.ArgumentOutOfRange("age");
				}
				if (pdbPath.Length == 0 || pdbPath.IndexOf('\0') == 0)
				{
					System.Reflection.Throw.InvalidArgument(MDCFR.Properties.Resources.ExpectedNonEmptyString, "pdbPath");
				}
				if (portablePdbVersion > 0 && portablePdbVersion < 256)
				{
					System.Reflection.Throw.ArgumentOutOfRange("portablePdbVersion");
				}
				int dataSize = WriteCodeViewData(_dataBuilder, pdbPath, pdbContentId.Guid, age);
				AddEntry(DebugDirectoryEntryType.CodeView, (portablePdbVersion != 0) ? System.Reflection.Metadata.PortablePdbVersions.DebugDirectoryEntryVersion(portablePdbVersion) : 0u, pdbContentId.Stamp, dataSize);
			}

			/// <summary>
			/// Adds Reproducible entry.
			/// </summary>
			public void AddReproducibleEntry()
			{
				AddEntry(DebugDirectoryEntryType.Reproducible, 0u, 0u);
			}

			private static int WriteCodeViewData(BlobBuilder builder, string pdbPath, Guid pdbGuid, int age)
			{
				int count = builder.Count;
				builder.WriteByte(82);
				builder.WriteByte(83);
				builder.WriteByte(68);
				builder.WriteByte(83);
				builder.WriteGuid(pdbGuid);
				builder.WriteInt32(age);
				builder.WriteUTF8(pdbPath);
				builder.WriteByte(0);
				return builder.Count - count;
			}

			/// <summary>
			/// Adds PDB checksum entry.
			/// </summary>
			/// <param name="algorithmName">Hash algorithm name (e.g. "SHA256").</param>
			/// <param name="checksum">Checksum.</param>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="algorithmName" /> or <paramref name="checksum" /> is null.</exception>
			/// <exception cref="T:System.ArgumentException"><paramref name="algorithmName" /> or <paramref name="checksum" /> is empty.</exception>
			public void AddPdbChecksumEntry(string algorithmName, System.Collections.Immutable.ImmutableArray<byte> checksum)
			{
				if (algorithmName == null)
				{
					System.Reflection.Throw.ArgumentNull("algorithmName");
				}
				if (algorithmName.Length == 0)
				{
					System.Reflection.Throw.ArgumentEmptyString("algorithmName");
				}
				if (checksum.IsDefault)
				{
					System.Reflection.Throw.ArgumentNull("checksum");
				}
				if (checksum.Length == 0)
				{
					System.Reflection.Throw.ArgumentEmptyArray("checksum");
				}
				int dataSize = WritePdbChecksumData(_dataBuilder, algorithmName, checksum);
				AddEntry(DebugDirectoryEntryType.PdbChecksum, 1u, 0u, dataSize);
			}

			private static int WritePdbChecksumData(BlobBuilder builder, string algorithmName, System.Collections.Immutable.ImmutableArray<byte> checksum)
			{
				int count = builder.Count;
				builder.WriteUTF8(algorithmName);
				builder.WriteByte(0);
				builder.WriteBytes(checksum);
				return builder.Count - count;
			}

			/// <summary>
			/// Serialize the Debug Table and Data.
			/// </summary>
			/// <param name="builder">Builder.</param>
			/// <param name="sectionLocation">The containing PE section location.</param>
			/// <param name="sectionOffset">Offset of the table within the containing section.</param>
			internal void Serialize(BlobBuilder builder, SectionLocation sectionLocation, int sectionOffset)
			{
				int num = sectionOffset + TableSize;
				foreach (Entry entry in _entries)
				{
					int value;
					int value2;
					if (entry.DataSize > 0)
					{
						value = sectionLocation.RelativeVirtualAddress + num;
						value2 = sectionLocation.PointerToRawData + num;
					}
					else
					{
						value = 0;
						value2 = 0;
					}
					builder.WriteUInt32(0u);
					builder.WriteUInt32(entry.Stamp);
					builder.WriteUInt32(entry.Version);
					builder.WriteInt32((int)entry.Type);
					builder.WriteInt32(entry.DataSize);
					builder.WriteInt32(value);
					builder.WriteInt32(value2);
					num += entry.DataSize;
				}
				builder.LinkSuffix(_dataBuilder);
			}

			/// <summary>
			/// Adds Embedded Portable PDB entry.
			/// </summary>
			/// <param name="debugMetadata">Portable PDB metadata builder.</param>
			/// <param name="portablePdbVersion">Version of Portable PDB format (e.g. 0x0100 for 1.0).</param>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="debugMetadata" /> is null.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="portablePdbVersion" /> is smaller than 0x0100.</exception>
			public void AddEmbeddedPortablePdbEntry(BlobBuilder debugMetadata, ushort portablePdbVersion)
			{
				if (debugMetadata == null)
				{
					System.Reflection.Throw.ArgumentNull("debugMetadata");
				}
				if (portablePdbVersion < 256)
				{
					System.Reflection.Throw.ArgumentOutOfRange("portablePdbVersion");
				}
				int dataSize = WriteEmbeddedPortablePdbData(_dataBuilder, debugMetadata);
				AddEntry(DebugDirectoryEntryType.EmbeddedPortablePdb, System.Reflection.Metadata.PortablePdbVersions.DebugDirectoryEmbeddedVersion(portablePdbVersion), 0u, dataSize);
			}

			private static int WriteEmbeddedPortablePdbData(BlobBuilder builder, BlobBuilder debugMetadata)
			{
				int count = builder.Count;
				builder.WriteUInt32(1111773261u);
				builder.WriteInt32(debugMetadata.Count);
				MemoryStream memoryStream = new MemoryStream();
				using (DeflateStream deflateStream = new DeflateStream(memoryStream, CompressionLevel.Optimal, leaveOpen: true))
				{
					foreach (Blob blob in debugMetadata.GetBlobs())
					{
						ArraySegment<byte> bytes = blob.GetBytes();
						deflateStream.Write(bytes.Array, bytes.Offset, bytes.Count);
					}
				}
				builder.WriteBytes(memoryStream.ToArray());
				return builder.Count - count;
			}
		}

		/// <summary>
		/// Identifies the location, size and format of a block of debug information.
		/// </summary>
		public readonly struct DebugDirectoryEntry
		{
			internal const int Size = 28;

			/// <summary>
			/// The time and date that the debug data was created if the PE/COFF file is not deterministic,
			/// otherwise a value based on the hash of the content.
			/// </summary>
			/// <remarks>
			/// The algorithm used to calculate this value is an implementation
			/// detail of the tool that produced the file.
			/// </remarks>
			public uint Stamp { get; }

			/// <summary>
			/// The major version number of the debug data format.
			/// </summary>
			public ushort MajorVersion { get; }

			/// <summary>
			/// The minor version number of the debug data format.
			/// </summary>
			public ushort MinorVersion { get; }

			/// <summary>
			/// The format of debugging information.
			/// </summary>
			public DebugDirectoryEntryType Type { get; }

			/// <summary>
			/// The size of the debug data (not including the debug directory itself).
			/// </summary>
			public int DataSize { get; }

			/// <summary>
			/// The address of the debug data when loaded, relative to the image base.
			/// </summary>
			public int DataRelativeVirtualAddress { get; }

			/// <summary>
			/// The file pointer to the debug data.
			/// </summary>
			public int DataPointer { get; }

			/// <summary>
			/// True if the entry is a <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.CodeView" /> entry pointing to a Portable PDB.
			/// </summary>
			public bool IsPortableCodeView => MinorVersion == 20557;

			public DebugDirectoryEntry(uint stamp, ushort majorVersion, ushort minorVersion, DebugDirectoryEntryType type, int dataSize, int dataRelativeVirtualAddress, int dataPointer)
			{
				Stamp = stamp;
				MajorVersion = majorVersion;
				MinorVersion = minorVersion;
				Type = type;
				DataSize = dataSize;
				DataRelativeVirtualAddress = dataRelativeVirtualAddress;
				DataPointer = dataPointer;
			}
		}

		public enum DebugDirectoryEntryType
		{
			/// <summary>
			/// An unknown value that is ignored by all tools.
			/// </summary>
			Unknown = 0,
			/// <summary>
			/// The COFF debug information (line numbers, symbol table, and string table).
			/// This type of debug information is also pointed to by fields in the file headers.
			/// </summary>
			Coff = 1,
			/// <summary>
			/// Associated PDB file description.
			/// </summary>
			/// <remarks>
			/// See https://github.com/dotnet/runtime/blob/main/src/libraries/System.Reflection.Metadata/specs/PE-COFF.md#codeview-debug-directory-entry-type-2 for specification.
			/// </remarks>
			CodeView = 2,
			/// <summary>
			/// Presence of this entry indicates deterministic PE/COFF file.
			/// </summary>
			/// <remarks>
			/// <para>
			/// The tool that produced the deterministic PE/COFF file guarantees that the entire content of the file
			/// is based solely on documented inputs given to the tool (such as source files, resource files, compiler options, etc.)
			/// rather than ambient environment variables (such as the current time, the operating system,
			/// the bitness of the process running the tool, etc.).
			/// </para>
			/// <para>
			/// The value of field TimeDateStamp in COFF File Header of a deterministic PE/COFF file
			/// does not indicate the date and time when the file was produced and should not be interpreted that way.
			/// Instead the value of the field is derived from a hash of the file content. The algorithm to calculate
			/// this value is an implementation detail of the tool that produced the file.
			/// </para>
			/// <para>
			/// The debug directory entry of type <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.Reproducible" /> must have all fields, except for Type zeroed.
			/// </para>
			/// <para>
			/// See https://github.com/dotnet/runtime/blob/main/src/libraries/System.Reflection.Metadata/specs/PE-COFF.md#deterministic-debug-directory-entry-type-16 for specification.
			/// </para>
			/// </remarks>
			Reproducible = 16,
			/// <summary>
			/// The entry points to a blob containing Embedded Portable PDB.
			/// </summary>
			/// <remarks>
			/// The Embedded Portable PDB blob has the following format:
			///
			/// blob ::= uncompressed-size data
			///
			/// Data spans the remainder of the blob and contains a Deflate-compressed Portable PDB.
			///
			/// See https://github.com/dotnet/runtime/blob/main/src/libraries/System.Reflection.Metadata/specs/PE-COFF.md#embedded-portable-pdb-debug-directory-entry-type-17 for specification.
			/// </remarks>
			EmbeddedPortablePdb = 17,
			/// <summary>
			/// The entry stores crypto hash of the content of the symbol file the PE/COFF file was built with.
			/// </summary>
			/// <remarks>
			/// The hash can be used to validate that a given PDB file was built with the PE/COFF file and not altered in any way.
			/// More than one entry can be present, in case multiple PDBs were produced during the build of the PE/COFF file (e.g. private and public symbols).
			///
			/// See https://github.com/dotnet/runtime/blob/main/src/libraries/System.Reflection.Metadata/specs/PE-COFF.md#pdb-checksum-debug-directory-entry-type-19 for specification.
			/// </remarks>
			PdbChecksum = 19
		}

		public readonly struct DirectoryEntry
		{
			public readonly int RelativeVirtualAddress;

			public readonly int Size;

			public DirectoryEntry(int relativeVirtualAddress, int size)
			{
				RelativeVirtualAddress = relativeVirtualAddress;
				Size = size;
			}

			internal DirectoryEntry(ref System.Reflection.PortableExecutable.PEBinaryReader reader)
			{
				RelativeVirtualAddress = reader.ReadInt32();
				Size = reader.ReadInt32();
			}
		}

		[Flags]
		public enum DllCharacteristics : ushort
		{
			/// <summary>
			/// Reserved.
			/// </summary>
			ProcessInit = 1,
			/// <summary>
			/// Reserved.
			/// </summary>
			ProcessTerm = 2,
			/// <summary>
			/// Reserved.
			/// </summary>
			ThreadInit = 4,
			/// <summary>
			/// Reserved.
			/// </summary>
			ThreadTerm = 8,
			/// <summary>
			/// Image can handle a high entropy 64-bit virtual address space.
			/// </summary>
			HighEntropyVirtualAddressSpace = 0x20,
			/// <summary>
			/// DLL can move.
			/// </summary>
			DynamicBase = 0x40,
			/// <summary>
			/// Image is NX compatible.
			/// </summary>
			NxCompatible = 0x100,
			/// <summary>
			/// Image understands isolation and doesn't want it.
			/// </summary>
			NoIsolation = 0x200,
			/// <summary>
			/// Image does not use SEH.  No SE handler may reside in this image.
			/// </summary>
			NoSeh = 0x400,
			/// <summary>
			/// Do not bind this image.
			/// </summary>
			NoBind = 0x800,
			/// <summary>
			/// The image must run inside an AppContainer.
			/// </summary>
			AppContainer = 0x1000,
			/// <summary>
			/// Driver uses WDM model.
			/// </summary>
			WdmDriver = 0x2000,
			TerminalServerAware = 0x8000
		}

		public enum Machine : ushort
		{
			/// <summary>
			/// The target CPU is unknown or not specified.
			/// </summary>
			Unknown = 0,
			/// <summary>
			/// Intel 386.
			/// </summary>
			I386 = 332,
			/// <summary>
			/// MIPS little-endian WCE v2
			/// </summary>
			WceMipsV2 = 361,
			/// <summary>
			/// Alpha
			/// </summary>
			Alpha = 388,
			/// <summary>
			/// Hitachi SH3 little endian
			/// </summary>
			SH3 = 418,
			/// <summary>
			/// Hitachi SH3 DSP.
			/// </summary>
			SH3Dsp = 419,
			/// <summary>
			/// Hitachi SH3 little endian.
			/// </summary>
			SH3E = 420,
			/// <summary>
			/// Hitachi SH4 little endian.
			/// </summary>
			SH4 = 422,
			/// <summary>
			/// Hitachi SH5.
			/// </summary>
			SH5 = 424,
			/// <summary>
			/// ARM little endian
			/// </summary>
			Arm = 448,
			/// <summary>
			/// Thumb.
			/// </summary>
			Thumb = 450,
			/// <summary>
			/// ARM Thumb-2 little endian.
			/// </summary>
			ArmThumb2 = 452,
			/// <summary>
			/// Matsushita AM33.
			/// </summary>
			AM33 = 467,
			/// <summary>
			/// IBM PowerPC little endian.
			/// </summary>
			PowerPC = 496,
			/// <summary>
			/// PowerPCFP
			/// </summary>
			PowerPCFP = 497,
			/// <summary>
			/// Intel 64
			/// </summary>
			IA64 = 512,
			/// <summary>
			/// MIPS
			/// </summary>
			MIPS16 = 614,
			/// <summary>
			/// ALPHA64
			/// </summary>
			Alpha64 = 644,
			/// <summary>
			/// MIPS with FPU.
			/// </summary>
			MipsFpu = 870,
			/// <summary>
			/// MIPS16 with FPU.
			/// </summary>
			MipsFpu16 = 1126,
			/// <summary>
			/// Infineon
			/// </summary>
			Tricore = 1312,
			/// <summary>
			/// EFI Byte Code
			/// </summary>
			Ebc = 3772,
			/// <summary>
			/// AMD64 (K8)
			/// </summary>
			Amd64 = 34404,
			/// <summary>
			/// M32R little-endian
			/// </summary>
			M32R = 36929,
			/// <summary>
			/// ARM64
			/// </summary>
			Arm64 = 43620,
			/// <summary>
			/// LOONGARCH32
			/// </summary>
			LoongArch32 = 25138,
			/// <summary>
			/// LOONGARCH64
			/// </summary>
			LoongArch64 = 25188
		}

		public class ManagedPEBuilder : PEBuilder
		{
			public const int ManagedResourcesDataAlignment = 8;

			public const int MappedFieldDataAlignment = 8;

			private const int DefaultStrongNameSignatureSize = 128;

			private const string TextSectionName = ".text";

			private const string ResourceSectionName = ".rsrc";

			private const string RelocationSectionName = ".reloc";

			private readonly PEDirectoriesBuilder _peDirectoriesBuilder;

			private readonly MetadataRootBuilder _metadataRootBuilder;

			private readonly BlobBuilder _ilStream;

			private readonly BlobBuilder _mappedFieldDataOpt;

			private readonly BlobBuilder _managedResourcesOpt;

			private readonly ResourceSectionBuilder _nativeResourcesOpt;

			private readonly int _strongNameSignatureSize;

			private readonly MethodDefinitionHandle _entryPointOpt;

			private readonly DebugDirectoryBuilder _debugDirectoryBuilderOpt;

			private readonly CorFlags _corFlags;

			private int _lazyEntryPointAddress;

			private Blob _lazyStrongNameSignature;

			public ManagedPEBuilder(PEHeaderBuilder header, MetadataRootBuilder metadataRootBuilder, BlobBuilder ilStream, BlobBuilder? mappedFieldData = null, BlobBuilder? managedResources = null, ResourceSectionBuilder? nativeResources = null, DebugDirectoryBuilder? debugDirectoryBuilder = null, int strongNameSignatureSize = 128, MethodDefinitionHandle entryPoint = default(MethodDefinitionHandle), CorFlags flags = CorFlags.ILOnly, Func<IEnumerable<Blob>, BlobContentId>? deterministicIdProvider = null)
				: base(header, deterministicIdProvider)
			{
				if (header == null)
				{
					System.Reflection.Throw.ArgumentNull("header");
				}
				if (metadataRootBuilder == null)
				{
					System.Reflection.Throw.ArgumentNull("metadataRootBuilder");
				}
				if (ilStream == null)
				{
					System.Reflection.Throw.ArgumentNull("ilStream");
				}
				if (strongNameSignatureSize < 0)
				{
					System.Reflection.Throw.ArgumentOutOfRange("strongNameSignatureSize");
				}
				_metadataRootBuilder = metadataRootBuilder;
				_ilStream = ilStream;
				_mappedFieldDataOpt = mappedFieldData;
				_managedResourcesOpt = managedResources;
				_nativeResourcesOpt = nativeResources;
				_strongNameSignatureSize = strongNameSignatureSize;
				_entryPointOpt = entryPoint;
				_debugDirectoryBuilderOpt = debugDirectoryBuilder ?? CreateDefaultDebugDirectoryBuilder();
				_corFlags = flags;
				_peDirectoriesBuilder = new PEDirectoriesBuilder();
			}

			private DebugDirectoryBuilder CreateDefaultDebugDirectoryBuilder()
			{
				if (base.IsDeterministic)
				{
					DebugDirectoryBuilder debugDirectoryBuilder = new DebugDirectoryBuilder();
					debugDirectoryBuilder.AddReproducibleEntry();
					return debugDirectoryBuilder;
				}
				return null;
			}

			protected override System.Collections.Immutable.ImmutableArray<Section> CreateSections()
			{
				System.Collections.Immutable.ImmutableArray<Section>.Builder builder = System.Collections.Immutable.ImmutableArray.CreateBuilder<Section>(3);
				builder.Add(new Section(".text", SectionCharacteristics.ContainsCode | SectionCharacteristics.MemExecute | SectionCharacteristics.MemRead));
				if (_nativeResourcesOpt != null)
				{
					builder.Add(new Section(".rsrc", SectionCharacteristics.ContainsInitializedData | SectionCharacteristics.MemRead));
				}
				if (base.Header.Machine == Machine.I386 || base.Header.Machine == Machine.Unknown)
				{
					builder.Add(new Section(".reloc", SectionCharacteristics.ContainsInitializedData | SectionCharacteristics.MemDiscardable | SectionCharacteristics.MemRead));
				}
				return builder.ToImmutable();
			}

			protected override BlobBuilder SerializeSection(string name, SectionLocation location)
			{
				return name switch
				{
					".text" => SerializeTextSection(location), 
					".rsrc" => SerializeResourceSection(location), 
					".reloc" => SerializeRelocationSection(location), 
					_ => throw new ArgumentException(System.SR.Format(MDCFR.Properties.Resources.UnknownSectionName, name), "name"), 
				};
			}

			private BlobBuilder SerializeTextSection(SectionLocation location)
			{
				BlobBuilder blobBuilder = new BlobBuilder();
				BlobBuilder blobBuilder2 = new BlobBuilder();
				MetadataSizes sizes = _metadataRootBuilder.Sizes;
				ManagedTextSection managedTextSection = new ManagedTextSection(base.Header.ImageCharacteristics, base.Header.Machine, _ilStream.Count, sizes.MetadataSize, _managedResourcesOpt?.Count ?? 0, _strongNameSignatureSize, _debugDirectoryBuilderOpt?.Size ?? 0, _mappedFieldDataOpt?.Count ?? 0);
				int methodBodyStreamRva = location.RelativeVirtualAddress + managedTextSection.OffsetToILStream;
				int mappedFieldDataStreamRva = location.RelativeVirtualAddress + managedTextSection.CalculateOffsetToMappedFieldDataStream();
				_metadataRootBuilder.Serialize(blobBuilder2, methodBodyStreamRva, mappedFieldDataStreamRva);
				BlobBuilder blobBuilder3;
				DirectoryEntry debugTable;
				if (_debugDirectoryBuilderOpt != null)
				{
					int num = managedTextSection.ComputeOffsetToDebugDirectory();
					blobBuilder3 = new BlobBuilder(_debugDirectoryBuilderOpt.TableSize);
					_debugDirectoryBuilderOpt.Serialize(blobBuilder3, location, num);
					debugTable = new DirectoryEntry(location.RelativeVirtualAddress + num, _debugDirectoryBuilderOpt.TableSize);
				}
				else
				{
					blobBuilder3 = null;
					debugTable = default(DirectoryEntry);
				}
				_lazyEntryPointAddress = managedTextSection.GetEntryPointAddress(location.RelativeVirtualAddress);
				managedTextSection.Serialize(blobBuilder, location.RelativeVirtualAddress, (!_entryPointOpt.IsNil) ? MetadataTokens.GetToken(_entryPointOpt) : 0, _corFlags, base.Header.ImageBase, blobBuilder2, _ilStream, _mappedFieldDataOpt, _managedResourcesOpt, blobBuilder3, out _lazyStrongNameSignature);
				_peDirectoriesBuilder.AddressOfEntryPoint = _lazyEntryPointAddress;
				_peDirectoriesBuilder.DebugTable = debugTable;
				_peDirectoriesBuilder.ImportAddressTable = managedTextSection.GetImportAddressTableDirectoryEntry(location.RelativeVirtualAddress);
				_peDirectoriesBuilder.ImportTable = managedTextSection.GetImportTableDirectoryEntry(location.RelativeVirtualAddress);
				_peDirectoriesBuilder.CorHeaderTable = managedTextSection.GetCorHeaderDirectoryEntry(location.RelativeVirtualAddress);
				return blobBuilder;
			}

			private BlobBuilder SerializeResourceSection(SectionLocation location)
			{
				BlobBuilder blobBuilder = new BlobBuilder();
				_nativeResourcesOpt.Serialize(blobBuilder, location);
				_peDirectoriesBuilder.ResourceTable = new DirectoryEntry(location.RelativeVirtualAddress, blobBuilder.Count);
				return blobBuilder;
			}

			private BlobBuilder SerializeRelocationSection(SectionLocation location)
			{
				BlobBuilder blobBuilder = new BlobBuilder();
				WriteRelocationSection(blobBuilder, base.Header.Machine, _lazyEntryPointAddress);
				_peDirectoriesBuilder.BaseRelocationTable = new DirectoryEntry(location.RelativeVirtualAddress, blobBuilder.Count);
				return blobBuilder;
			}

			private static void WriteRelocationSection(BlobBuilder builder, Machine machine, int entryPointAddress)
			{
				builder.WriteUInt32((uint)(entryPointAddress + 2) / 4096u * 4096);
				builder.WriteUInt32((machine == Machine.IA64) ? 14u : 12u);
				uint num = (uint)(entryPointAddress + 2) % 4096u;
				uint num2 = ((machine == Machine.Amd64 || machine == Machine.IA64 || machine == Machine.Arm64) ? 10u : 3u);
				ushort value = (ushort)((num2 << 12) | num);
				builder.WriteUInt16(value);
				if (machine == Machine.IA64)
				{
					builder.WriteUInt32(num2 << 12);
				}
				builder.WriteUInt16(0);
			}

			protected internal override PEDirectoriesBuilder GetDirectories()
			{
				return _peDirectoriesBuilder;
			}

			public void Sign(BlobBuilder peImage, Func<IEnumerable<Blob>, byte[]> signatureProvider)
			{
				if (peImage == null)
				{
					System.Reflection.Throw.ArgumentNull("peImage");
				}
				if (signatureProvider == null)
				{
					System.Reflection.Throw.ArgumentNull("signatureProvider");
				}
				Sign(peImage, _lazyStrongNameSignature, signatureProvider);
			}
		}

		/// <summary>
		/// Managed .text PE section.
		/// </summary>
		/// <remarks>
		/// Contains in the following order:
		/// - Import Address Table
		/// - COR Header
		/// - IL
		/// - Metadata
		/// - Managed Resource Data
		/// - Strong Name Signature
		/// - Debug Data (directory and extra info)
		/// - Import Table
		/// - Name Table
		/// - Runtime Startup Stub
		/// - Mapped Field Data
		/// </remarks>
		internal sealed class ManagedTextSection
		{
			public const int ManagedResourcesDataAlignment = 8;

			private const string CorEntryPointDll = "mscoree.dll";

			public const int MappedFieldDataAlignment = 8;

			private const int CorHeaderSize = 72;

			public Characteristics ImageCharacteristics { get; }

			public Machine Machine { get; }

			/// <summary>
			/// The size of IL stream (unaligned).
			/// </summary>
			public int ILStreamSize { get; }

			/// <summary>
			/// Total size of metadata (header and all streams).
			/// </summary>
			public int MetadataSize { get; }

			/// <summary>
			/// The size of managed resource data stream.
			/// Aligned to <see cref="F:System.Reflection.PortableExecutable.ManagedTextSection.ManagedResourcesDataAlignment" />.
			/// </summary>
			public int ResourceDataSize { get; }

			/// <summary>
			/// Size of strong name hash.
			/// </summary>
			public int StrongNameSignatureSize { get; }

			/// <summary>
			/// Size of Debug data.
			/// </summary>
			public int DebugDataSize { get; }

			/// <summary>
			/// The size of mapped field data stream.
			/// Aligned to <see cref="F:System.Reflection.PortableExecutable.ManagedTextSection.MappedFieldDataAlignment" />.
			/// </summary>
			public int MappedFieldDataSize { get; }

			/// <summary>
			/// If set, the module must include a machine code stub that transfers control to the virtual execution system.
			/// </summary>
			internal bool RequiresStartupStub
			{
				get
				{
					if (Machine != Machine.I386)
					{
						return Machine == Machine.Unknown;
					}
					return true;
				}
			}

			/// <summary>
			/// If set, the module contains instructions that assume a 64 bit instruction set. For example it may depend on an address being 64 bits.
			/// This may be true even if the module contains only IL instructions because of PlatformInvoke and COM interop.
			/// </summary>
			internal bool Requires64bits
			{
				get
				{
					if (Machine != Machine.Amd64 && Machine != Machine.IA64)
					{
						return Machine == Machine.Arm64;
					}
					return true;
				}
			}

			public bool Is32Bit => !Requires64bits;

			private string CorEntryPointName
			{
				get
				{
					if ((ImageCharacteristics & Characteristics.Dll) == 0)
					{
						return "_CorExeMain";
					}
					return "_CorDllMain";
				}
			}

			private int SizeOfImportAddressTable
			{
				get
				{
					if (!RequiresStartupStub)
					{
						return 0;
					}
					if (!Is32Bit)
					{
						return 16;
					}
					return 8;
				}
			}

			private int SizeOfImportTable => 40 + (Is32Bit ? 12 : 16) + 2 + CorEntryPointName.Length + 1;

			private static int SizeOfNameTable => "mscoree.dll".Length + 1 + 2;

			private int SizeOfRuntimeStartupStub
			{
				get
				{
					if (!Is32Bit)
					{
						return 16;
					}
					return 8;
				}
			}

			public int OffsetToILStream => SizeOfImportAddressTable + 72;

			public ManagedTextSection(Characteristics imageCharacteristics, Machine machine, int ilStreamSize, int metadataSize, int resourceDataSize, int strongNameSignatureSize, int debugDataSize, int mappedFieldDataSize)
			{
				MetadataSize = metadataSize;
				ResourceDataSize = resourceDataSize;
				ILStreamSize = ilStreamSize;
				MappedFieldDataSize = mappedFieldDataSize;
				StrongNameSignatureSize = strongNameSignatureSize;
				ImageCharacteristics = imageCharacteristics;
				Machine = machine;
				DebugDataSize = debugDataSize;
			}

			internal int CalculateOffsetToMappedFieldDataStreamUnaligned()
			{
				int num = ComputeOffsetToImportTable();
				if (RequiresStartupStub)
				{
					num += SizeOfImportTable + SizeOfNameTable;
					num = BitArithmetic.Align(num, Is32Bit ? 4 : 8);
					num += SizeOfRuntimeStartupStub;
				}
				return num;
			}

			public int CalculateOffsetToMappedFieldDataStream()
			{
				int num = CalculateOffsetToMappedFieldDataStreamUnaligned();
				if (MappedFieldDataSize != 0)
				{
					num = BitArithmetic.Align(num, 8);
				}
				return num;
			}

			internal int ComputeOffsetToDebugDirectory()
			{
				return ComputeOffsetToMetadata() + MetadataSize + ResourceDataSize + StrongNameSignatureSize;
			}

			private int ComputeOffsetToImportTable()
			{
				return ComputeOffsetToDebugDirectory() + DebugDataSize;
			}

			private int ComputeOffsetToMetadata()
			{
				return OffsetToILStream + BitArithmetic.Align(ILStreamSize, 4);
			}

			public int ComputeSizeOfTextSection()
			{
				return CalculateOffsetToMappedFieldDataStream() + MappedFieldDataSize;
			}

			public int GetEntryPointAddress(int rva)
			{
				if (!RequiresStartupStub)
				{
					return 0;
				}
				return rva + CalculateOffsetToMappedFieldDataStreamUnaligned() - (Is32Bit ? 6 : 10);
			}

			public DirectoryEntry GetImportAddressTableDirectoryEntry(int rva)
			{
				if (!RequiresStartupStub)
				{
					return default(DirectoryEntry);
				}
				return new DirectoryEntry(rva, SizeOfImportAddressTable);
			}

			public DirectoryEntry GetImportTableDirectoryEntry(int rva)
			{
				if (!RequiresStartupStub)
				{
					return default(DirectoryEntry);
				}
				return new DirectoryEntry(rva + ComputeOffsetToImportTable(), (Is32Bit ? 66 : 70) + 13);
			}

			public DirectoryEntry GetCorHeaderDirectoryEntry(int rva)
			{
				return new DirectoryEntry(rva + SizeOfImportAddressTable, 72);
			}

			/// <summary>
			/// Serializes .text section data into a specified <paramref name="builder" />.
			/// </summary>
			/// <param name="builder">An empty builder to serialize section data to.</param>
			/// <param name="relativeVirtualAddess">Relative virtual address of the section within the containing PE file.</param>
			/// <param name="entryPointTokenOrRelativeVirtualAddress">Entry point token or RVA (<see cref="P:System.Reflection.PortableExecutable.CorHeader.EntryPointTokenOrRelativeVirtualAddress" />)</param>
			/// <param name="corFlags">COR Flags (<see cref="P:System.Reflection.PortableExecutable.CorHeader.Flags" />).</param>
			/// <param name="baseAddress">Base address of the PE image.</param>
			/// <param name="metadataBuilder"><see cref="T:System.Reflection.Metadata.BlobBuilder" /> containing metadata. Must be populated with data. Linked into the <paramref name="builder" /> and can't be expanded afterwards.</param>
			/// <param name="ilBuilder"><see cref="T:System.Reflection.Metadata.BlobBuilder" /> containing IL stream. Must be populated with data. Linked into the <paramref name="builder" /> and can't be expanded afterwards.</param>
			/// <param name="mappedFieldDataBuilderOpt"><see cref="T:System.Reflection.Metadata.BlobBuilder" /> containing mapped field data. Must be populated with data. Linked into the <paramref name="builder" /> and can't be expanded afterwards.</param>
			/// <param name="resourceBuilderOpt"><see cref="T:System.Reflection.Metadata.BlobBuilder" /> containing managed resource data. Must be populated with data. Linked into the <paramref name="builder" /> and can't be expanded afterwards.</param>
			/// <param name="debugDataBuilderOpt"><see cref="T:System.Reflection.Metadata.BlobBuilder" /> containing PE debug table and data. Must be populated with data. Linked into the <paramref name="builder" /> and can't be expanded afterwards.</param>
			/// <param name="strongNameSignature">Blob reserved in the <paramref name="builder" /> for strong name signature.</param>
			public void Serialize(BlobBuilder builder, int relativeVirtualAddess, int entryPointTokenOrRelativeVirtualAddress, CorFlags corFlags, ulong baseAddress, BlobBuilder metadataBuilder, BlobBuilder ilBuilder, BlobBuilder? mappedFieldDataBuilderOpt, BlobBuilder? resourceBuilderOpt, BlobBuilder? debugDataBuilderOpt, out Blob strongNameSignature)
			{
				int relativeVirtualAddress = GetImportTableDirectoryEntry(relativeVirtualAddess).RelativeVirtualAddress;
				int relativeVirtualAddress2 = GetImportAddressTableDirectoryEntry(relativeVirtualAddess).RelativeVirtualAddress;
				if (RequiresStartupStub)
				{
					WriteImportAddressTable(builder, relativeVirtualAddress);
				}
				WriteCorHeader(builder, relativeVirtualAddess, entryPointTokenOrRelativeVirtualAddress, corFlags);
				ilBuilder.Align(4);
				builder.LinkSuffix(ilBuilder);
				builder.LinkSuffix(metadataBuilder);
				if (resourceBuilderOpt != null)
				{
					builder.LinkSuffix(resourceBuilderOpt);
				}
				strongNameSignature = builder.ReserveBytes(StrongNameSignatureSize);
				new BlobWriter(strongNameSignature).WriteBytes(0, StrongNameSignatureSize);
				if (debugDataBuilderOpt != null)
				{
					builder.LinkSuffix(debugDataBuilderOpt);
				}
				if (RequiresStartupStub)
				{
					WriteImportTable(builder, relativeVirtualAddress, relativeVirtualAddress2);
					WriteNameTable(builder);
					WriteRuntimeStartupStub(builder, relativeVirtualAddress2, baseAddress);
				}
				if (mappedFieldDataBuilderOpt != null)
				{
					if (mappedFieldDataBuilderOpt.Count != 0)
					{
						builder.Align(8);
					}
					builder.LinkSuffix(mappedFieldDataBuilderOpt);
				}
			}

			private void WriteImportAddressTable(BlobBuilder builder, int importTableRva)
			{
				int count = builder.Count;
				int num = importTableRva + 40;
				int num2 = num + (Is32Bit ? 12 : 16);
				if (Is32Bit)
				{
					builder.WriteUInt32((uint)num2);
					builder.WriteUInt32(0u);
				}
				else
				{
					builder.WriteUInt64((uint)num2);
					builder.WriteUInt64(0uL);
				}
			}

			private void WriteImportTable(BlobBuilder builder, int importTableRva, int importAddressTableRva)
			{
				int count = builder.Count;
				int num = importTableRva + 40;
				int num2 = num + (Is32Bit ? 12 : 16);
				int value = num2 + 12 + 2;
				builder.WriteUInt32((uint)num);
				builder.WriteUInt32(0u);
				builder.WriteUInt32(0u);
				builder.WriteUInt32((uint)value);
				builder.WriteUInt32((uint)importAddressTableRva);
				builder.WriteBytes(0, 20);
				if (Is32Bit)
				{
					builder.WriteUInt32((uint)num2);
					builder.WriteUInt32(0u);
					builder.WriteUInt32(0u);
				}
				else
				{
					builder.WriteUInt64((uint)num2);
					builder.WriteUInt64(0uL);
				}
				builder.WriteUInt16(0);
				string corEntryPointName = CorEntryPointName;
				foreach (char c in corEntryPointName)
				{
					builder.WriteByte((byte)c);
				}
				builder.WriteByte(0);
			}

			private static void WriteNameTable(BlobBuilder builder)
			{
				int count = builder.Count;
				string text = "mscoree.dll";
				foreach (char c in text)
				{
					builder.WriteByte((byte)c);
				}
				builder.WriteByte(0);
				builder.WriteUInt16(0);
			}

			private void WriteCorHeader(BlobBuilder builder, int textSectionRva, int entryPointTokenOrRva, CorFlags corFlags)
			{
				int num = textSectionRva + ComputeOffsetToMetadata();
				int num2 = num + MetadataSize;
				int num3 = num2 + ResourceDataSize;
				int count = builder.Count;
				builder.WriteUInt32(72u);
				builder.WriteUInt16(2);
				builder.WriteUInt16(5);
				builder.WriteUInt32((uint)num);
				builder.WriteUInt32((uint)MetadataSize);
				builder.WriteUInt32((uint)corFlags);
				builder.WriteUInt32((uint)entryPointTokenOrRva);
				builder.WriteUInt32((ResourceDataSize != 0) ? ((uint)num2) : 0u);
				builder.WriteUInt32((uint)ResourceDataSize);
				builder.WriteUInt32((StrongNameSignatureSize != 0) ? ((uint)num3) : 0u);
				builder.WriteUInt32((uint)StrongNameSignatureSize);
				builder.WriteUInt32(0u);
				builder.WriteUInt32(0u);
				builder.WriteUInt32(0u);
				builder.WriteUInt32(0u);
				builder.WriteUInt32(0u);
				builder.WriteUInt32(0u);
				builder.WriteUInt32(0u);
				builder.WriteUInt32(0u);
			}

			private void WriteRuntimeStartupStub(BlobBuilder sectionBuilder, int importAddressTableRva, ulong baseAddress)
			{
				if (Is32Bit)
				{
					sectionBuilder.Align(4);
					sectionBuilder.WriteUInt16(0);
					sectionBuilder.WriteByte(byte.MaxValue);
					sectionBuilder.WriteByte(37);
					sectionBuilder.WriteUInt32((uint)(importAddressTableRva + (int)baseAddress));
				}
				else
				{
					sectionBuilder.Align(8);
					sectionBuilder.WriteUInt32(0u);
					sectionBuilder.WriteUInt16(0);
					sectionBuilder.WriteByte(byte.MaxValue);
					sectionBuilder.WriteByte(37);
					sectionBuilder.WriteUInt64((ulong)importAddressTableRva + baseAddress);
				}
			}
		}

		public readonly struct PdbChecksumDebugDirectoryData
		{
			/// <summary>
			/// Checksum algorithm name.
			/// </summary>
			public string AlgorithmName { get; }

			/// <summary>
			/// GUID (Globally Unique Identifier) of the associated PDB.
			/// </summary>
			public System.Collections.Immutable.ImmutableArray<byte> Checksum { get; }

			internal PdbChecksumDebugDirectoryData(string algorithmName, System.Collections.Immutable.ImmutableArray<byte> checksum)
			{
				AlgorithmName = algorithmName;
				Checksum = checksum;
			}
		}

		/// <summary>
		/// Simple BinaryReader wrapper to:
		///
		///  1) throw BadImageFormat instead of EndOfStream or ArgumentOutOfRange.
		///  2) limit reads to a subset of the base stream.
		///
		/// Only methods that are needed to read PE headers are implemented.
		/// </summary>
		internal readonly struct PEBinaryReader
		{
			private readonly long _startOffset;

			private readonly long _maxOffset;

			private readonly BinaryReader _reader;

			public int CurrentOffset => (int)(_reader.BaseStream.Position - _startOffset);

			public PEBinaryReader(Stream stream, int size)
			{
				_startOffset = stream.Position;
				_maxOffset = _startOffset + size;
				_reader = new BinaryReader(stream, Encoding.UTF8, leaveOpen: true);
			}

			public void Seek(int offset)
			{
				CheckBounds(_startOffset, offset);
				_reader.BaseStream.Seek(offset, SeekOrigin.Begin);
			}

			public byte[] ReadBytes(int count)
			{
				CheckBounds(_reader.BaseStream.Position, count);
				return _reader.ReadBytes(count);
			}

			public byte ReadByte()
			{
				CheckBounds(1u);
				return _reader.ReadByte();
			}

			public short ReadInt16()
			{
				CheckBounds(2u);
				return _reader.ReadInt16();
			}

			public ushort ReadUInt16()
			{
				CheckBounds(2u);
				return _reader.ReadUInt16();
			}

			public int ReadInt32()
			{
				CheckBounds(4u);
				return _reader.ReadInt32();
			}

			public uint ReadUInt32()
			{
				CheckBounds(4u);
				return _reader.ReadUInt32();
			}

			public ulong ReadUInt64()
			{
				CheckBounds(8u);
				return _reader.ReadUInt64();
			}

			/// <summary>
			/// Reads a fixed-length byte block as a null-padded UTF8-encoded string.
			/// The padding is not included in the returned string.
			///
			/// Note that it is legal for UTF8 strings to contain NUL; if NUL occurs
			/// between non-NUL codepoints, it is not considered to be padding and
			/// is included in the result.
			/// </summary>
			public string ReadNullPaddedUTF8(int byteCount)
			{
				byte[] array = ReadBytes(byteCount);
				int count = 0;
				for (int num = array.Length; num > 0; num--)
				{
					if (array[num - 1] != 0)
					{
						count = num;
						break;
					}
				}
				return Encoding.UTF8.GetString(array, 0, count);
			}

			private void CheckBounds(uint count)
			{
				if ((ulong)(_reader.BaseStream.Position + count) > (ulong)_maxOffset)
				{
					System.Reflection.Throw.ImageTooSmall();
				}
			}

			private void CheckBounds(long startPosition, int count)
			{
				if ((ulong)(startPosition + (uint)count) > (ulong)_maxOffset)
				{
					System.Reflection.Throw.ImageTooSmallOrContainsInvalidOffsetOrCount();
				}
			}
		}

		public abstract class PEBuilder
		{
			protected readonly struct Section
			{
				public readonly string Name;

				public readonly SectionCharacteristics Characteristics;

				public Section(string name, SectionCharacteristics characteristics)
				{
					if (name == null)
					{
						System.Reflection.Throw.ArgumentNull("name");
					}
					Name = name;
					Characteristics = characteristics;
				}
			}

			private readonly struct SerializedSection
			{
				public readonly BlobBuilder Builder;

				public readonly string Name;

				public readonly SectionCharacteristics Characteristics;

				public readonly int RelativeVirtualAddress;

				public readonly int SizeOfRawData;

				public readonly int PointerToRawData;

				public int VirtualSize => Builder.Count;

				public SerializedSection(BlobBuilder builder, string name, SectionCharacteristics characteristics, int relativeVirtualAddress, int sizeOfRawData, int pointerToRawData)
				{
					Name = name;
					Characteristics = characteristics;
					Builder = builder;
					RelativeVirtualAddress = relativeVirtualAddress;
					SizeOfRawData = sizeOfRawData;
					PointerToRawData = pointerToRawData;
				}
			}

			private readonly Lazy<System.Collections.Immutable.ImmutableArray<Section>> _lazySections;

			private Blob _lazyChecksum;

			internal const int DosHeaderSize = 128;

			public PEHeaderBuilder Header { get; }

			public Func<IEnumerable<Blob>, BlobContentId> IdProvider { get; }

			public bool IsDeterministic { get; }

			private static ReadOnlySpan<byte> DosHeader => new byte[128]
			{
				77, 90, 144, 0, 3, 0, 0, 0, 4, 0,
				0, 0, 255, 255, 0, 0, 184, 0, 0, 0,
				0, 0, 0, 0, 64, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
				128, 0, 0, 0, 14, 31, 186, 14, 0, 180,
				9, 205, 33, 184, 1, 76, 205, 33, 84, 104,
				105, 115, 32, 112, 114, 111, 103, 114, 97, 109,
				32, 99, 97, 110, 110, 111, 116, 32, 98, 101,
				32, 114, 117, 110, 32, 105, 110, 32, 68, 79,
				83, 32, 109, 111, 100, 101, 46, 13, 13, 10,
				36, 0, 0, 0, 0, 0, 0, 0
			};

			protected PEBuilder(PEHeaderBuilder header, Func<IEnumerable<Blob>, BlobContentId>? deterministicIdProvider)
			{
				if (header == null)
				{
					System.Reflection.Throw.ArgumentNull("header");
				}
				IdProvider = deterministicIdProvider ?? BlobContentId.GetTimeBasedProvider();
				IsDeterministic = deterministicIdProvider != null;
				Header = header;
				_lazySections = new Lazy<System.Collections.Immutable.ImmutableArray<Section>>(CreateSections);
			}

			protected System.Collections.Immutable.ImmutableArray<Section> GetSections()
			{
				System.Collections.Immutable.ImmutableArray<Section> value = _lazySections.Value;
				if (value.IsDefault)
				{
					throw new InvalidOperationException(System.SR.Format(MDCFR.Properties.Resources.MustNotReturnNull, "CreateSections"));
				}
				return value;
			}

			protected abstract System.Collections.Immutable.ImmutableArray<Section> CreateSections();

			protected abstract BlobBuilder SerializeSection(string name, SectionLocation location);

			protected internal abstract PEDirectoriesBuilder GetDirectories();

			public BlobContentId Serialize(BlobBuilder builder)
			{
				//IL_0041: Unknown result type (might be due to invalid IL or missing references)
				//IL_0046: Unknown result type (might be due to invalid IL or missing references)
				System.Collections.Immutable.ImmutableArray<SerializedSection> immutableArray = SerializeSections();
				PEDirectoriesBuilder directories = GetDirectories();
				WritePESignature(builder);
				WriteCoffHeader(builder, immutableArray, out var stampFixup);
				WritePEHeader(builder, directories, immutableArray);
				WriteSectionHeaders(builder, immutableArray);
				builder.Align(Header.FileAlignment);
                ImmutableArray<SerializedSection>.Enumerator enumerator = immutableArray.GetEnumerator();
				while (enumerator.MoveNext())
				{
					builder.LinkSuffix(enumerator.Current.Builder);
					builder.Align(Header.FileAlignment);
				}
				BlobContentId result = IdProvider(builder.GetBlobs());
				new BlobWriter(stampFixup).WriteUInt32(result.Stamp);
				return result;
			}

			private System.Collections.Immutable.ImmutableArray<SerializedSection> SerializeSections()
			{
				//IL_004e: Unknown result type (might be due to invalid IL or missing references)
				//IL_0053: Unknown result type (might be due to invalid IL or missing references)
				System.Collections.Immutable.ImmutableArray<Section> sections = GetSections();
				System.Collections.Immutable.ImmutableArray<SerializedSection>.Builder builder = System.Collections.Immutable.ImmutableArray.CreateBuilder<SerializedSection>(sections.Length);
				int position = Header.ComputeSizeOfPEHeaders(sections.Length);
				int relativeVirtualAddress = BitArithmetic.Align(position, Header.SectionAlignment);
				int pointerToRawData = BitArithmetic.Align(position, Header.FileAlignment);
                ImmutableArray<Section>.Enumerator enumerator = sections.GetEnumerator();
				while (enumerator.MoveNext())
				{
					Section current = enumerator.Current;
					BlobBuilder blobBuilder = SerializeSection(current.Name, new SectionLocation(relativeVirtualAddress, pointerToRawData));
					SerializedSection item = new SerializedSection(blobBuilder, current.Name, current.Characteristics, relativeVirtualAddress, BitArithmetic.Align(blobBuilder.Count, Header.FileAlignment), pointerToRawData);
					builder.Add(item);
					relativeVirtualAddress = BitArithmetic.Align(item.RelativeVirtualAddress + item.VirtualSize, Header.SectionAlignment);
					pointerToRawData = item.PointerToRawData + item.SizeOfRawData;
				}
				return builder.MoveToImmutable();
			}

			private unsafe static void WritePESignature(BlobBuilder builder)
			{
				ReadOnlySpan<byte> dosHeader = DosHeader;
				fixed (byte* buffer = dosHeader)
				{
					builder.WriteBytes(buffer, dosHeader.Length);
				}
				builder.WriteUInt32(17744u);
			}

			private void WriteCoffHeader(BlobBuilder builder, System.Collections.Immutable.ImmutableArray<SerializedSection> sections, out Blob stampFixup)
			{
				builder.WriteUInt16((ushort)((Header.Machine == Machine.Unknown) ? Machine.I386 : Header.Machine));
				builder.WriteUInt16((ushort)sections.Length);
				stampFixup = builder.ReserveBytes(4);
				builder.WriteUInt32(0u);
				builder.WriteUInt32(0u);
				builder.WriteUInt16((ushort)PEHeader.Size(Header.Is32Bit));
				builder.WriteUInt16((ushort)Header.ImageCharacteristics);
			}

			private void WritePEHeader(BlobBuilder builder, PEDirectoriesBuilder directories, System.Collections.Immutable.ImmutableArray<SerializedSection> sections)
			{
				builder.WriteUInt16((ushort)(Header.Is32Bit ? 267 : 523));
				builder.WriteByte(Header.MajorLinkerVersion);
				builder.WriteByte(Header.MinorLinkerVersion);
				builder.WriteUInt32((uint)SumRawDataSizes(sections, SectionCharacteristics.ContainsCode));
				builder.WriteUInt32((uint)SumRawDataSizes(sections, SectionCharacteristics.ContainsInitializedData));
				builder.WriteUInt32((uint)SumRawDataSizes(sections, SectionCharacteristics.ContainsUninitializedData));
				builder.WriteUInt32((uint)directories.AddressOfEntryPoint);
				int num = IndexOfSection(sections, SectionCharacteristics.ContainsCode);
				builder.WriteUInt32((num != -1) ? ((uint)sections[num].RelativeVirtualAddress) : 0u);
				if (Header.Is32Bit)
				{
					int num2 = IndexOfSection(sections, SectionCharacteristics.ContainsInitializedData);
					builder.WriteUInt32((num2 != -1) ? ((uint)sections[num2].RelativeVirtualAddress) : 0u);
					builder.WriteUInt32((uint)Header.ImageBase);
				}
				else
				{
					builder.WriteUInt64(Header.ImageBase);
				}
				builder.WriteUInt32((uint)Header.SectionAlignment);
				builder.WriteUInt32((uint)Header.FileAlignment);
				builder.WriteUInt16(Header.MajorOperatingSystemVersion);
				builder.WriteUInt16(Header.MinorOperatingSystemVersion);
				builder.WriteUInt16(Header.MajorImageVersion);
				builder.WriteUInt16(Header.MinorImageVersion);
				builder.WriteUInt16(Header.MajorSubsystemVersion);
				builder.WriteUInt16(Header.MinorSubsystemVersion);
				builder.WriteUInt32(0u);
				SerializedSection serializedSection = sections[sections.Length - 1];
				builder.WriteUInt32((uint)BitArithmetic.Align(serializedSection.RelativeVirtualAddress + serializedSection.VirtualSize, Header.SectionAlignment));
				builder.WriteUInt32((uint)BitArithmetic.Align(Header.ComputeSizeOfPEHeaders(sections.Length), Header.FileAlignment));
				_lazyChecksum = builder.ReserveBytes(4);
				new BlobWriter(_lazyChecksum).WriteUInt32(0u);
				builder.WriteUInt16((ushort)Header.Subsystem);
				builder.WriteUInt16((ushort)Header.DllCharacteristics);
				if (Header.Is32Bit)
				{
					builder.WriteUInt32((uint)Header.SizeOfStackReserve);
					builder.WriteUInt32((uint)Header.SizeOfStackCommit);
					builder.WriteUInt32((uint)Header.SizeOfHeapReserve);
					builder.WriteUInt32((uint)Header.SizeOfHeapCommit);
				}
				else
				{
					builder.WriteUInt64(Header.SizeOfStackReserve);
					builder.WriteUInt64(Header.SizeOfStackCommit);
					builder.WriteUInt64(Header.SizeOfHeapReserve);
					builder.WriteUInt64(Header.SizeOfHeapCommit);
				}
				builder.WriteUInt32(0u);
				builder.WriteUInt32(16u);
				builder.WriteUInt32((uint)directories.ExportTable.RelativeVirtualAddress);
				builder.WriteUInt32((uint)directories.ExportTable.Size);
				builder.WriteUInt32((uint)directories.ImportTable.RelativeVirtualAddress);
				builder.WriteUInt32((uint)directories.ImportTable.Size);
				builder.WriteUInt32((uint)directories.ResourceTable.RelativeVirtualAddress);
				builder.WriteUInt32((uint)directories.ResourceTable.Size);
				builder.WriteUInt32((uint)directories.ExceptionTable.RelativeVirtualAddress);
				builder.WriteUInt32((uint)directories.ExceptionTable.Size);
				builder.WriteUInt32(0u);
				builder.WriteUInt32(0u);
				builder.WriteUInt32((uint)directories.BaseRelocationTable.RelativeVirtualAddress);
				builder.WriteUInt32((uint)directories.BaseRelocationTable.Size);
				builder.WriteUInt32((uint)directories.DebugTable.RelativeVirtualAddress);
				builder.WriteUInt32((uint)directories.DebugTable.Size);
				builder.WriteUInt32((uint)directories.CopyrightTable.RelativeVirtualAddress);
				builder.WriteUInt32((uint)directories.CopyrightTable.Size);
				builder.WriteUInt32((uint)directories.GlobalPointerTable.RelativeVirtualAddress);
				builder.WriteUInt32((uint)directories.GlobalPointerTable.Size);
				builder.WriteUInt32((uint)directories.ThreadLocalStorageTable.RelativeVirtualAddress);
				builder.WriteUInt32((uint)directories.ThreadLocalStorageTable.Size);
				builder.WriteUInt32((uint)directories.LoadConfigTable.RelativeVirtualAddress);
				builder.WriteUInt32((uint)directories.LoadConfigTable.Size);
				builder.WriteUInt32((uint)directories.BoundImportTable.RelativeVirtualAddress);
				builder.WriteUInt32((uint)directories.BoundImportTable.Size);
				builder.WriteUInt32((uint)directories.ImportAddressTable.RelativeVirtualAddress);
				builder.WriteUInt32((uint)directories.ImportAddressTable.Size);
				builder.WriteUInt32((uint)directories.DelayImportTable.RelativeVirtualAddress);
				builder.WriteUInt32((uint)directories.DelayImportTable.Size);
				builder.WriteUInt32((uint)directories.CorHeaderTable.RelativeVirtualAddress);
				builder.WriteUInt32((uint)directories.CorHeaderTable.Size);
				builder.WriteUInt64(0uL);
			}

			private static void WriteSectionHeaders(BlobBuilder builder, System.Collections.Immutable.ImmutableArray<SerializedSection> serializedSections)
			{
                //IL_0002: Unknown result type (might be due to invalid IL or missing references)
                //IL_0007: Unknown result type (might be due to invalid IL or missing references)
                ImmutableArray<SerializedSection>.Enumerator enumerator = serializedSections.GetEnumerator();
				while (enumerator.MoveNext())
				{
					SerializedSection current = enumerator.Current;
					WriteSectionHeader(builder, current);
				}
			}

			private static void WriteSectionHeader(BlobBuilder builder, SerializedSection serializedSection)
			{
				if (serializedSection.VirtualSize == 0)
				{
					return;
				}
				int i = 0;
				int length = serializedSection.Name.Length;
				for (; i < 8; i++)
				{
					if (i < length)
					{
						builder.WriteByte((byte)serializedSection.Name[i]);
					}
					else
					{
						builder.WriteByte(0);
					}
				}
				builder.WriteUInt32((uint)serializedSection.VirtualSize);
				builder.WriteUInt32((uint)serializedSection.RelativeVirtualAddress);
				builder.WriteUInt32((uint)serializedSection.SizeOfRawData);
				builder.WriteUInt32((uint)serializedSection.PointerToRawData);
				builder.WriteUInt32(0u);
				builder.WriteUInt32(0u);
				builder.WriteUInt16(0);
				builder.WriteUInt16(0);
				builder.WriteUInt32((uint)serializedSection.Characteristics);
			}

			private static int IndexOfSection(System.Collections.Immutable.ImmutableArray<SerializedSection> sections, SectionCharacteristics characteristics)
			{
				for (int i = 0; i < sections.Length; i++)
				{
					if ((sections[i].Characteristics & characteristics) == characteristics)
					{
						return i;
					}
				}
				return -1;
			}

			private static int SumRawDataSizes(System.Collections.Immutable.ImmutableArray<SerializedSection> sections, SectionCharacteristics characteristics)
			{
				int num = 0;
				for (int i = 0; i < sections.Length; i++)
				{
					if ((sections[i].Characteristics & characteristics) == characteristics)
					{
						num += sections[i].SizeOfRawData;
					}
				}
				return num;
			}

			internal static IEnumerable<Blob> GetContentToSign(BlobBuilder peImage, int peHeadersSize, int peHeaderAlignment, Blob strongNameSignatureFixup)
			{
				int remainingHeaderToSign = peHeadersSize;
				int remainingHeader = BitArithmetic.Align(peHeadersSize, peHeaderAlignment);
				foreach (Blob blob in peImage.GetBlobs())
				{
					int blobStart = blob.Start;
					int blobLength = blob.Length;
					while (blobLength > 0)
					{
						if (remainingHeader > 0)
						{
							int length;
							if (remainingHeaderToSign > 0)
							{
								length = Math.Min(remainingHeaderToSign, blobLength);
								yield return new Blob(blob.Buffer, blobStart, length);
								remainingHeaderToSign -= length;
							}
							else
							{
								length = Math.Min(remainingHeader, blobLength);
							}
							remainingHeader -= length;
							blobStart += length;
							blobLength -= length;
							continue;
						}
						if (blob.Buffer == strongNameSignatureFixup.Buffer)
						{
							yield return GetPrefixBlob(new Blob(blob.Buffer, blobStart, blobLength), strongNameSignatureFixup);
							yield return GetSuffixBlob(new Blob(blob.Buffer, blobStart, blobLength), strongNameSignatureFixup);
						}
						else
						{
							yield return new Blob(blob.Buffer, blobStart, blobLength);
						}
						break;
					}
				}
			}

			internal static Blob GetPrefixBlob(Blob container, Blob blob)
			{
				return new Blob(container.Buffer, container.Start, blob.Start - container.Start);
			}

			internal static Blob GetSuffixBlob(Blob container, Blob blob)
			{
				return new Blob(container.Buffer, blob.Start + blob.Length, container.Start + container.Length - blob.Start - blob.Length);
			}

			internal static IEnumerable<Blob> GetContentToChecksum(BlobBuilder peImage, Blob checksumFixup)
			{
				foreach (Blob blob in peImage.GetBlobs())
				{
					if (blob.Buffer == checksumFixup.Buffer)
					{
						yield return GetPrefixBlob(blob, checksumFixup);
						yield return GetSuffixBlob(blob, checksumFixup);
					}
					else
					{
						yield return blob;
					}
				}
			}

			internal void Sign(BlobBuilder peImage, Blob strongNameSignatureFixup, Func<IEnumerable<Blob>, byte[]> signatureProvider)
			{
				int peHeadersSize = Header.ComputeSizeOfPEHeaders(GetSections().Length);
				byte[] array = signatureProvider(GetContentToSign(peImage, peHeadersSize, Header.FileAlignment, strongNameSignatureFixup));
				if (array == null || array.Length > strongNameSignatureFixup.Length)
				{
					throw new InvalidOperationException(MDCFR.Properties.Resources.SignatureProviderReturnedInvalidSignature);
				}
				new BlobWriter(strongNameSignatureFixup).WriteBytes(array);
				uint value = CalculateChecksum(peImage, _lazyChecksum);
				new BlobWriter(_lazyChecksum).WriteUInt32(value);
			}

			internal static uint CalculateChecksum(BlobBuilder peImage, Blob checksumFixup)
			{
				return CalculateChecksum(GetContentToChecksum(peImage, checksumFixup)) + (uint)peImage.Count;
			}

			private unsafe static uint CalculateChecksum(IEnumerable<Blob> blobs)
			{
				uint num = 0u;
				int num2 = -1;
				foreach (Blob blob in blobs)
				{
					ArraySegment<byte> bytes = blob.GetBytes();
					fixed (byte* ptr = bytes.Array)
					{
						byte* ptr2 = ptr + bytes.Offset;
						byte* ptr3 = ptr2 + bytes.Count;
						if (num2 >= 0)
						{
							num = AggregateChecksum(num, (ushort)((*ptr2 << 8) | num2));
							ptr2++;
						}
						if ((ptr3 - ptr2) % 2 != 0L)
						{
							ptr3--;
							num2 = *ptr3;
						}
						else
						{
							num2 = -1;
						}
						for (; ptr2 < ptr3; ptr2 += 2)
						{
							num = AggregateChecksum(num, (ushort)((ptr2[1] << 8) | *ptr2));
						}
					}
				}
				if (num2 >= 0)
				{
					num = AggregateChecksum(num, (ushort)num2);
				}
				return num;
			}

			private static uint AggregateChecksum(uint checksum, ushort value)
			{
				uint num = checksum + value;
				return (num >> 16) + (ushort)num;
			}
		}

		public sealed class PEDirectoriesBuilder
		{
			public int AddressOfEntryPoint { get; set; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_EXPORT.
			/// </remarks>
			public DirectoryEntry ExportTable { get; set; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_IMPORT.
			/// </remarks>
			public DirectoryEntry ImportTable { get; set; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_RESOURCE.
			/// </remarks>
			public DirectoryEntry ResourceTable { get; set; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_EXCEPTION.
			/// </remarks>
			public DirectoryEntry ExceptionTable { get; set; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_BASERELOC.
			/// </remarks>
			public DirectoryEntry BaseRelocationTable { get; set; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_DEBUG.
			/// </remarks>
			public DirectoryEntry DebugTable { get; set; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_COPYRIGHT or IMAGE_DIRECTORY_ENTRY_ARCHITECTURE.
			/// </remarks>
			public DirectoryEntry CopyrightTable { get; set; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_GLOBALPTR.
			/// </remarks>
			public DirectoryEntry GlobalPointerTable { get; set; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_TLS.
			/// </remarks>
			public DirectoryEntry ThreadLocalStorageTable { get; set; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG.
			/// </remarks>
			public DirectoryEntry LoadConfigTable { get; set; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT.
			/// </remarks>
			public DirectoryEntry BoundImportTable { get; set; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_IAT.
			/// </remarks>
			public DirectoryEntry ImportAddressTable { get; set; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT.
			/// </remarks>
			public DirectoryEntry DelayImportTable { get; set; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR.
			/// </remarks>
			public DirectoryEntry CorHeaderTable { get; set; }
		}

		public sealed class PEHeader
		{
			internal const int OffsetOfChecksum = 64;

			/// <summary>
			/// Identifies the format of the image file.
			/// </summary>
			public PEMagic Magic { get; }

			/// <summary>
			/// The linker major version number.
			/// </summary>
			public byte MajorLinkerVersion { get; }

			/// <summary>
			/// The linker minor version number.
			/// </summary>
			public byte MinorLinkerVersion { get; }

			/// <summary>
			/// The size of the code (text) section, or the sum of all code sections if there are multiple sections.
			/// </summary>
			public int SizeOfCode { get; }

			/// <summary>
			/// The size of the initialized data section, or the sum of all such sections if there are multiple data sections.
			/// </summary>
			public int SizeOfInitializedData { get; }

			/// <summary>
			/// The size of the uninitialized data section (BSS), or the sum of all such sections if there are multiple BSS sections.
			/// </summary>
			public int SizeOfUninitializedData { get; }

			/// <summary>
			/// The address of the entry point relative to the image base when the PE file is loaded into memory.
			/// For program images, this is the starting address. For device drivers, this is the address of the initialization function.
			/// An entry point is optional for DLLs. When no entry point is present, this field must be zero.
			/// </summary>
			public int AddressOfEntryPoint { get; }

			/// <summary>
			/// The address that is relative to the image base of the beginning-of-code section when it is loaded into memory.
			/// </summary>
			public int BaseOfCode { get; }

			/// <summary>
			/// The address that is relative to the image base of the beginning-of-data section when it is loaded into memory.
			/// </summary>
			public int BaseOfData { get; }

			/// <summary>
			/// The preferred address of the first byte of image when loaded into memory;
			/// must be a multiple of 64K.
			/// </summary>
			public ulong ImageBase { get; }

			/// <summary>
			/// The alignment (in bytes) of sections when they are loaded into memory. It must be greater than or equal to <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" />.
			/// The default is the page size for the architecture.
			/// </summary>
			public int SectionAlignment { get; }

			/// <summary>
			/// The alignment factor (in bytes) that is used to align the raw data of sections in the image file.
			/// The value should be a power of 2 between 512 and 64K, inclusive. The default is 512.
			/// If the <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment" /> is less than the architecture's page size,
			/// then <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" /> must match <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment" />.
			/// </summary>
			public int FileAlignment { get; }

			/// <summary>
			/// The major version number of the required operating system.
			/// </summary>
			public ushort MajorOperatingSystemVersion { get; }

			/// <summary>
			/// The minor version number of the required operating system.
			/// </summary>
			public ushort MinorOperatingSystemVersion { get; }

			/// <summary>
			/// The major version number of the image.
			/// </summary>
			public ushort MajorImageVersion { get; }

			/// <summary>
			/// The minor version number of the image.
			/// </summary>
			public ushort MinorImageVersion { get; }

			/// <summary>
			/// The major version number of the subsystem.
			/// </summary>
			public ushort MajorSubsystemVersion { get; }

			/// <summary>
			/// The minor version number of the subsystem.
			/// </summary>
			public ushort MinorSubsystemVersion { get; }

			/// <summary>
			/// The size (in bytes) of the image, including all headers, as the image is loaded in memory.
			/// It must be a multiple of <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment" />.
			/// </summary>
			public int SizeOfImage { get; }

			/// <summary>
			/// The combined size of an MS DOS stub, PE header, and section headers rounded up to a multiple of FileAlignment.
			/// </summary>
			public int SizeOfHeaders { get; }

			/// <summary>
			/// The image file checksum.
			/// </summary>
			public uint CheckSum { get; }

			/// <summary>
			/// The subsystem that is required to run this image.
			/// </summary>
			public Subsystem Subsystem { get; }

			public DllCharacteristics DllCharacteristics { get; }

			/// <summary>
			/// The size of the stack to reserve. Only <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit" /> is committed;
			/// the rest is made available one page at a time until the reserve size is reached.
			/// </summary>
			public ulong SizeOfStackReserve { get; }

			/// <summary>
			/// The size of the stack to commit.
			/// </summary>
			public ulong SizeOfStackCommit { get; }

			/// <summary>
			/// The size of the local heap space to reserve. Only <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit" /> is committed;
			/// the rest is made available one page at a time until the reserve size is reached.
			/// </summary>
			public ulong SizeOfHeapReserve { get; }

			/// <summary>
			/// The size of the local heap space to commit.
			/// </summary>
			public ulong SizeOfHeapCommit { get; }

			/// <summary>
			/// The number of data-directory entries in the remainder of the <see cref="T:System.Reflection.PortableExecutable.PEHeader" />. Each describes a location and size.
			/// </summary>
			public int NumberOfRvaAndSizes { get; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_EXPORT.
			/// </remarks>
			public DirectoryEntry ExportTableDirectory { get; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_IMPORT.
			/// </remarks>
			public DirectoryEntry ImportTableDirectory { get; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_RESOURCE.
			/// </remarks>
			public DirectoryEntry ResourceTableDirectory { get; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_EXCEPTION.
			/// </remarks>
			public DirectoryEntry ExceptionTableDirectory { get; }

			/// <summary>
			/// The Certificate Table entry points to a table of attribute certificates.
			/// </summary>
			/// <remarks>
			/// These certificates are not loaded into memory as part of the image.
			/// As such, the first field of this entry, which is normally an RVA, is a file pointer instead.
			///
			/// Aka IMAGE_DIRECTORY_ENTRY_SECURITY.
			/// </remarks>
			public DirectoryEntry CertificateTableDirectory { get; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_BASERELOC.
			/// </remarks>
			public DirectoryEntry BaseRelocationTableDirectory { get; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_DEBUG.
			/// </remarks>
			public DirectoryEntry DebugTableDirectory { get; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_COPYRIGHT or IMAGE_DIRECTORY_ENTRY_ARCHITECTURE.
			/// </remarks>
			public DirectoryEntry CopyrightTableDirectory { get; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_GLOBALPTR.
			/// </remarks>
			public DirectoryEntry GlobalPointerTableDirectory { get; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_TLS.
			/// </remarks>
			public DirectoryEntry ThreadLocalStorageTableDirectory { get; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG.
			/// </remarks>
			public DirectoryEntry LoadConfigTableDirectory { get; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT.
			/// </remarks>
			public DirectoryEntry BoundImportTableDirectory { get; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_IAT.
			/// </remarks>
			public DirectoryEntry ImportAddressTableDirectory { get; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT.
			/// </remarks>
			public DirectoryEntry DelayImportTableDirectory { get; }

			/// <remarks>
			/// Aka IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR.
			/// </remarks>
			public DirectoryEntry CorHeaderTableDirectory { get; }

			internal static int Size(bool is32Bit)
			{
				return 72 + 4 * (is32Bit ? 4 : 8) + 4 + 4 + 128;
			}

			internal PEHeader(ref System.Reflection.PortableExecutable.PEBinaryReader reader)
			{
				PEMagic pEMagic = (PEMagic)reader.ReadUInt16();
				if (pEMagic != PEMagic.PE32 && pEMagic != PEMagic.PE32Plus)
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.UnknownPEMagicValue);
				}
				Magic = pEMagic;
				MajorLinkerVersion = reader.ReadByte();
				MinorLinkerVersion = reader.ReadByte();
				SizeOfCode = reader.ReadInt32();
				SizeOfInitializedData = reader.ReadInt32();
				SizeOfUninitializedData = reader.ReadInt32();
				AddressOfEntryPoint = reader.ReadInt32();
				BaseOfCode = reader.ReadInt32();
				if (pEMagic == PEMagic.PE32Plus)
				{
					BaseOfData = 0;
				}
				else
				{
					BaseOfData = reader.ReadInt32();
				}
				if (pEMagic == PEMagic.PE32Plus)
				{
					ImageBase = reader.ReadUInt64();
				}
				else
				{
					ImageBase = reader.ReadUInt32();
				}
				SectionAlignment = reader.ReadInt32();
				FileAlignment = reader.ReadInt32();
				MajorOperatingSystemVersion = reader.ReadUInt16();
				MinorOperatingSystemVersion = reader.ReadUInt16();
				MajorImageVersion = reader.ReadUInt16();
				MinorImageVersion = reader.ReadUInt16();
				MajorSubsystemVersion = reader.ReadUInt16();
				MinorSubsystemVersion = reader.ReadUInt16();
				reader.ReadUInt32();
				SizeOfImage = reader.ReadInt32();
				SizeOfHeaders = reader.ReadInt32();
				CheckSum = reader.ReadUInt32();
				Subsystem = (Subsystem)reader.ReadUInt16();
				DllCharacteristics = (DllCharacteristics)reader.ReadUInt16();
				if (pEMagic == PEMagic.PE32Plus)
				{
					SizeOfStackReserve = reader.ReadUInt64();
					SizeOfStackCommit = reader.ReadUInt64();
					SizeOfHeapReserve = reader.ReadUInt64();
					SizeOfHeapCommit = reader.ReadUInt64();
				}
				else
				{
					SizeOfStackReserve = reader.ReadUInt32();
					SizeOfStackCommit = reader.ReadUInt32();
					SizeOfHeapReserve = reader.ReadUInt32();
					SizeOfHeapCommit = reader.ReadUInt32();
				}
				reader.ReadUInt32();
				NumberOfRvaAndSizes = reader.ReadInt32();
				ExportTableDirectory = new DirectoryEntry(ref reader);
				ImportTableDirectory = new DirectoryEntry(ref reader);
				ResourceTableDirectory = new DirectoryEntry(ref reader);
				ExceptionTableDirectory = new DirectoryEntry(ref reader);
				CertificateTableDirectory = new DirectoryEntry(ref reader);
				BaseRelocationTableDirectory = new DirectoryEntry(ref reader);
				DebugTableDirectory = new DirectoryEntry(ref reader);
				CopyrightTableDirectory = new DirectoryEntry(ref reader);
				GlobalPointerTableDirectory = new DirectoryEntry(ref reader);
				ThreadLocalStorageTableDirectory = new DirectoryEntry(ref reader);
				LoadConfigTableDirectory = new DirectoryEntry(ref reader);
				BoundImportTableDirectory = new DirectoryEntry(ref reader);
				ImportAddressTableDirectory = new DirectoryEntry(ref reader);
				DelayImportTableDirectory = new DirectoryEntry(ref reader);
				CorHeaderTableDirectory = new DirectoryEntry(ref reader);
				new DirectoryEntry(ref reader);
			}
		}

		public sealed class PEHeaderBuilder
		{
			public Machine Machine { get; }

			public Characteristics ImageCharacteristics { get; }

			public byte MajorLinkerVersion { get; }

			public byte MinorLinkerVersion { get; }

			public ulong ImageBase { get; }

			public int SectionAlignment { get; }

			public int FileAlignment { get; }

			public ushort MajorOperatingSystemVersion { get; }

			public ushort MinorOperatingSystemVersion { get; }

			public ushort MajorImageVersion { get; }

			public ushort MinorImageVersion { get; }

			public ushort MajorSubsystemVersion { get; }

			public ushort MinorSubsystemVersion { get; }

			public Subsystem Subsystem { get; }

			public DllCharacteristics DllCharacteristics { get; }

			public ulong SizeOfStackReserve { get; }

			public ulong SizeOfStackCommit { get; }

			public ulong SizeOfHeapReserve { get; }

			public ulong SizeOfHeapCommit { get; }

			internal bool Is32Bit
			{
				get
				{
					if (Machine != Machine.Amd64 && Machine != Machine.IA64)
					{
						return Machine != Machine.Arm64;
					}
					return false;
				}
			}

			/// <summary>
			/// Creates PE header builder.
			/// </summary>
			/// <exception cref="T:System.ArgumentOutOfRangeException">
			/// <paramref name="fileAlignment" /> is not power of 2 between 512 and 64K, or
			/// <paramref name="sectionAlignment" /> not power of 2 or it's less than <paramref name="fileAlignment" />.
			/// </exception>
			public PEHeaderBuilder(Machine machine = Machine.Unknown, int sectionAlignment = 8192, int fileAlignment = 512, ulong imageBase = 4194304uL, byte majorLinkerVersion = 48, byte minorLinkerVersion = 0, ushort majorOperatingSystemVersion = 4, ushort minorOperatingSystemVersion = 0, ushort majorImageVersion = 0, ushort minorImageVersion = 0, ushort majorSubsystemVersion = 4, ushort minorSubsystemVersion = 0, Subsystem subsystem = Subsystem.WindowsCui, DllCharacteristics dllCharacteristics = DllCharacteristics.DynamicBase | DllCharacteristics.NxCompatible | DllCharacteristics.NoSeh | DllCharacteristics.TerminalServerAware, Characteristics imageCharacteristics = Characteristics.Dll, ulong sizeOfStackReserve = 1048576uL, ulong sizeOfStackCommit = 4096uL, ulong sizeOfHeapReserve = 1048576uL, ulong sizeOfHeapCommit = 4096uL)
			{
				if (fileAlignment < 512 || fileAlignment > 65536 || BitArithmetic.CountBits(fileAlignment) != 1)
				{
					System.Reflection.Throw.ArgumentOutOfRange("fileAlignment");
				}
				if (sectionAlignment < fileAlignment || BitArithmetic.CountBits(sectionAlignment) != 1)
				{
					System.Reflection.Throw.ArgumentOutOfRange("sectionAlignment");
				}
				Machine = machine;
				SectionAlignment = sectionAlignment;
				FileAlignment = fileAlignment;
				ImageBase = imageBase;
				MajorLinkerVersion = majorLinkerVersion;
				MinorLinkerVersion = minorLinkerVersion;
				MajorOperatingSystemVersion = majorOperatingSystemVersion;
				MinorOperatingSystemVersion = minorOperatingSystemVersion;
				MajorImageVersion = majorImageVersion;
				MinorImageVersion = minorImageVersion;
				MajorSubsystemVersion = majorSubsystemVersion;
				MinorSubsystemVersion = minorSubsystemVersion;
				Subsystem = subsystem;
				DllCharacteristics = dllCharacteristics;
				ImageCharacteristics = imageCharacteristics;
				SizeOfStackReserve = sizeOfStackReserve;
				SizeOfStackCommit = sizeOfStackCommit;
				SizeOfHeapReserve = sizeOfHeapReserve;
				SizeOfHeapCommit = sizeOfHeapCommit;
			}

			public static PEHeaderBuilder CreateExecutableHeader()
			{
				return new PEHeaderBuilder(Machine.Unknown, 8192, 512, 4194304uL, 48, 0, 4, 0, 0, 0, 4, 0, Subsystem.WindowsCui, DllCharacteristics.DynamicBase | DllCharacteristics.NxCompatible | DllCharacteristics.NoSeh | DllCharacteristics.TerminalServerAware, Characteristics.ExecutableImage, 1048576uL, 4096uL, 1048576uL, 4096uL);
			}

			public static PEHeaderBuilder CreateLibraryHeader()
			{
				return new PEHeaderBuilder(Machine.Unknown, 8192, 512, 4194304uL, 48, 0, 4, 0, 0, 0, 4, 0, Subsystem.WindowsCui, DllCharacteristics.DynamicBase | DllCharacteristics.NxCompatible | DllCharacteristics.NoSeh | DllCharacteristics.TerminalServerAware, Characteristics.ExecutableImage | Characteristics.Dll, 1048576uL, 4096uL, 1048576uL, 4096uL);
			}

			internal int ComputeSizeOfPEHeaders(int sectionCount)
			{
				return 152 + PEHeader.Size(Is32Bit) + 40 * sectionCount;
			}
		}

		/// <summary>
		/// An object used to read PE (Portable Executable) and COFF (Common Object File Format) headers from a stream.
		/// </summary>
		public sealed class PEHeaders
		{
			private readonly CoffHeader _coffHeader;

			private readonly PEHeader _peHeader;

			private readonly System.Collections.Immutable.ImmutableArray<SectionHeader> _sectionHeaders;

			private readonly CorHeader _corHeader;

			private readonly bool _isLoadedImage;

			private readonly int _metadataStartOffset = -1;

			private readonly int _metadataSize;

			private readonly int _coffHeaderStartOffset = -1;

			private readonly int _corHeaderStartOffset = -1;

			private readonly int _peHeaderStartOffset = -1;

			internal const ushort DosSignature = 23117;

			internal const int PESignatureOffsetLocation = 60;

			internal const uint PESignature = 17744u;

			internal const int PESignatureSize = 4;

			/// <summary>
			/// Gets the offset (in bytes) from the start of the PE image to the start of the CLI metadata.
			/// or -1 if the image does not contain metadata.
			/// </summary>
			public int MetadataStartOffset => _metadataStartOffset;

			/// <summary>
			/// Gets the size of the CLI metadata 0 if the image does not contain metadata.)
			/// </summary>
			public int MetadataSize => _metadataSize;

			/// <summary>
			/// Gets the COFF header of the image.
			/// </summary>
			public CoffHeader CoffHeader => _coffHeader;

			/// <summary>
			/// Gets the byte offset from the start of the PE image to the start of the COFF header.
			/// </summary>
			public int CoffHeaderStartOffset => _coffHeaderStartOffset;

			/// <summary>
			/// Determines if the image is Coff only.
			/// </summary>
			public bool IsCoffOnly => _peHeader == null;

			/// <summary>
			/// Gets the PE header of the image or null if the image is COFF only.
			/// </summary>
			public PEHeader? PEHeader => _peHeader;

			/// <summary>
			/// Gets the byte offset from the start of the image to
			/// </summary>
			public int PEHeaderStartOffset => _peHeaderStartOffset;

			/// <summary>
			/// Gets the PE section headers.
			/// </summary>
			public System.Collections.Immutable.ImmutableArray<SectionHeader> SectionHeaders => _sectionHeaders;

			/// <summary>
			/// Gets the CLI header or null if the image does not have one.
			/// </summary>
			public CorHeader? CorHeader => _corHeader;

			/// <summary>
			/// Gets the byte offset from the start of the image to the COR header or -1 if the image does not have one.
			/// </summary>
			public int CorHeaderStartOffset => _corHeaderStartOffset;

			/// <summary>
			/// Determines if the image represents a Windows console application.
			/// </summary>
			public bool IsConsoleApplication
			{
				get
				{
					if (_peHeader != null)
					{
						return _peHeader.Subsystem == Subsystem.WindowsCui;
					}
					return false;
				}
			}

			/// <summary>
			/// Determines if the image represents a dynamically linked library.
			/// </summary>
			public bool IsDll => (_coffHeader.Characteristics & Characteristics.Dll) != 0;

			/// <summary>
			/// Determines if the image represents an executable.
			/// </summary>
			public bool IsExe => (_coffHeader.Characteristics & Characteristics.Dll) == 0;

			/// <summary>
			/// Reads PE headers from the current location in the stream.
			/// </summary>
			/// <param name="peStream">Stream containing PE image starting at the stream's current position and ending at the end of the stream.</param>
			/// <exception cref="T:System.BadImageFormatException">The data read from stream have invalid format.</exception>
			/// <exception cref="T:System.IO.IOException">Error reading from the stream.</exception>
			/// <exception cref="T:System.ArgumentException">The stream doesn't support seek operations.</exception>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="peStream" /> is null.</exception>
			public PEHeaders(Stream peStream)
				: this(peStream, 0)
			{
			}

			/// <summary>
			/// Reads PE headers from the current location in the stream.
			/// </summary>
			/// <param name="peStream">Stream containing PE image of the given size starting at its current position.</param>
			/// <param name="size">Size of the PE image.</param>
			/// <exception cref="T:System.BadImageFormatException">The data read from stream have invalid format.</exception>
			/// <exception cref="T:System.IO.IOException">Error reading from the stream.</exception>
			/// <exception cref="T:System.ArgumentException">The stream doesn't support seek operations.</exception>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="peStream" /> is null.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException">Size is negative or extends past the end of the stream.</exception>
			public PEHeaders(Stream peStream, int size)
				: this(peStream, size, isLoadedImage: false)
			{
			}

			/// <summary>
			/// Reads PE headers from the current location in the stream.
			/// </summary>
			/// <param name="peStream">Stream containing PE image of the given size starting at its current position.</param>
			/// <param name="size">Size of the PE image.</param>
			/// <param name="isLoadedImage">True if the PE image has been loaded into memory by the OS loader.</param>
			/// <exception cref="T:System.BadImageFormatException">The data read from stream have invalid format.</exception>
			/// <exception cref="T:System.IO.IOException">Error reading from the stream.</exception>
			/// <exception cref="T:System.ArgumentException">The stream doesn't support seek operations.</exception>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="peStream" /> is null.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException">Size is negative or extends past the end of the stream.</exception>
			public PEHeaders(Stream peStream, int size, bool isLoadedImage)
			{
				if (peStream == null)
				{
					System.Reflection.Throw.ArgumentNull("peStream");
				}
				if (!peStream.CanRead || !peStream.CanSeek)
				{
					throw new ArgumentException(MDCFR.Properties.Resources.StreamMustSupportReadAndSeek, "peStream");
				}
				_isLoadedImage = isLoadedImage;
				int andValidateSize = System.Reflection.Internal.StreamExtensions.GetAndValidateSize(peStream, size, "peStream");
				System.Reflection.PortableExecutable.PEBinaryReader reader = new System.Reflection.PortableExecutable.PEBinaryReader(peStream, andValidateSize);
				SkipDosHeader(ref reader, out var isCOFFOnly);
				_coffHeaderStartOffset = reader.CurrentOffset;
				_coffHeader = new CoffHeader(ref reader);
				if (!isCOFFOnly)
				{
					_peHeaderStartOffset = reader.CurrentOffset;
					_peHeader = new PEHeader(ref reader);
				}
				_sectionHeaders = ReadSectionHeaders(ref reader);
				if (!isCOFFOnly && TryCalculateCorHeaderOffset(andValidateSize, out var startOffset))
				{
					_corHeaderStartOffset = startOffset;
					reader.Seek(startOffset);
					_corHeader = new CorHeader(ref reader);
				}
				CalculateMetadataLocation(andValidateSize, out _metadataStartOffset, out _metadataSize);
			}

			private bool TryCalculateCorHeaderOffset(long peStreamSize, out int startOffset)
			{
				if (!TryGetDirectoryOffset(_peHeader.CorHeaderTableDirectory, out startOffset, canCrossSectionBoundary: false))
				{
					startOffset = -1;
					return false;
				}
				int size = _peHeader.CorHeaderTableDirectory.Size;
				if (size < 72)
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.InvalidCorHeaderSize);
				}
				return true;
			}

			private static void SkipDosHeader(ref System.Reflection.PortableExecutable.PEBinaryReader reader, out bool isCOFFOnly)
			{
				ushort num = reader.ReadUInt16();
				if (num != 23117)
				{
					if (num == 0 && reader.ReadUInt16() == ushort.MaxValue)
					{
						throw new BadImageFormatException(MDCFR.Properties.Resources.UnknownFileFormat);
					}
					isCOFFOnly = true;
					reader.Seek(0);
				}
				else
				{
					isCOFFOnly = false;
				}
				if (!isCOFFOnly)
				{
					reader.Seek(60);
					int offset = reader.ReadInt32();
					reader.Seek(offset);
					uint num2 = reader.ReadUInt32();
					if (num2 != 17744)
					{
						throw new BadImageFormatException(MDCFR.Properties.Resources.InvalidPESignature);
					}
				}
			}

			private System.Collections.Immutable.ImmutableArray<SectionHeader> ReadSectionHeaders(ref System.Reflection.PortableExecutable.PEBinaryReader reader)
			{
				int numberOfSections = _coffHeader.NumberOfSections;
				if (numberOfSections < 0)
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.InvalidNumberOfSections);
				}
				System.Collections.Immutable.ImmutableArray<SectionHeader>.Builder builder = System.Collections.Immutable.ImmutableArray.CreateBuilder<SectionHeader>(numberOfSections);
				for (int i = 0; i < numberOfSections; i++)
				{
					builder.Add(new SectionHeader(ref reader));
				}
				return builder.MoveToImmutable();
			}

			/// <summary>
			/// Gets the offset (in bytes) from the start of the image to the given directory data.
			/// </summary>
			/// <param name="directory">PE directory entry</param>
			/// <param name="offset">Offset from the start of the image to the given directory data</param>
			/// <returns>True if the directory data is found, false otherwise.</returns>
			public bool TryGetDirectoryOffset(DirectoryEntry directory, out int offset)
			{
				return TryGetDirectoryOffset(directory, out offset, canCrossSectionBoundary: true);
			}

			internal bool TryGetDirectoryOffset(DirectoryEntry directory, out int offset, bool canCrossSectionBoundary)
			{
				int containingSectionIndex = GetContainingSectionIndex(directory.RelativeVirtualAddress);
				if (containingSectionIndex < 0)
				{
					offset = -1;
					return false;
				}
				int num = directory.RelativeVirtualAddress - _sectionHeaders[containingSectionIndex].VirtualAddress;
				if (!canCrossSectionBoundary && directory.Size > _sectionHeaders[containingSectionIndex].VirtualSize - num)
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.SectionTooSmall);
				}
				offset = (_isLoadedImage ? directory.RelativeVirtualAddress : (_sectionHeaders[containingSectionIndex].PointerToRawData + num));
				return true;
			}

			/// <summary>
			/// Searches sections of the PE image for the one that contains specified Relative Virtual Address.
			/// </summary>
			/// <param name="relativeVirtualAddress">Address.</param>
			/// <returns>
			/// Index of the section that contains <paramref name="relativeVirtualAddress" />,
			/// or -1 if there is none.
			/// </returns>
			public int GetContainingSectionIndex(int relativeVirtualAddress)
			{
				for (int i = 0; i < _sectionHeaders.Length; i++)
				{
					if (_sectionHeaders[i].VirtualAddress <= relativeVirtualAddress && relativeVirtualAddress < _sectionHeaders[i].VirtualAddress + _sectionHeaders[i].VirtualSize)
					{
						return i;
					}
				}
				return -1;
			}

			internal int IndexOfSection(string name)
			{
				for (int i = 0; i < SectionHeaders.Length; i++)
				{
					if (SectionHeaders[i].Name.Equals(name, StringComparison.Ordinal))
					{
						return i;
					}
				}
				return -1;
			}

			private void CalculateMetadataLocation(long peImageSize, out int start, out int size)
			{
				if (IsCoffOnly)
				{
					int num = IndexOfSection(".cormeta");
					if (num == -1)
					{
						start = -1;
						size = 0;
						return;
					}
					if (_isLoadedImage)
					{
						start = SectionHeaders[num].VirtualAddress;
						size = SectionHeaders[num].VirtualSize;
					}
					else
					{
						start = SectionHeaders[num].PointerToRawData;
						size = SectionHeaders[num].SizeOfRawData;
					}
				}
				else
				{
					if (_corHeader == null)
					{
						start = 0;
						size = 0;
						return;
					}
					if (!TryGetDirectoryOffset(_corHeader.MetadataDirectory, out start, canCrossSectionBoundary: false))
					{
						throw new BadImageFormatException(MDCFR.Properties.Resources.MissingDataDirectory);
					}
					size = _corHeader.MetadataDirectory.Size;
				}
				if (start < 0 || start >= peImageSize || size <= 0 || start > peImageSize - size)
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.InvalidMetadataSectionSpan);
				}
			}
		}

		public enum PEMagic : ushort { PE32 = 267, PE32Plus = 523 }

		public readonly struct PEMemoryBlock
		{
			private readonly System.Reflection.Internal.AbstractMemoryBlock _block;

			private readonly int _offset;

			/// <summary>
			/// Pointer to the first byte of the block.
			/// </summary>
			public unsafe byte* Pointer
			{
				get
				{
					if (_block == null)
					{
						return null;
					}
					return _block.Pointer + _offset;
				}
			}

			/// <summary>
			/// Length of the block.
			/// </summary>
			public int Length => (_block?.Size - _offset).GetValueOrDefault();

			internal PEMemoryBlock(System.Reflection.Internal.AbstractMemoryBlock block, int offset = 0)
			{
				_block = block;
				_offset = offset;
			}

			/// <summary>
			/// Creates <see cref="T:System.Reflection.Metadata.BlobReader" /> for a blob spanning the entire block.
			/// </summary>
			public unsafe BlobReader GetReader()
			{
				return new BlobReader(Pointer, Length);
			}

			/// <summary>
			/// Creates <see cref="T:System.Reflection.Metadata.BlobReader" /> for a blob spanning a part of the block.
			/// </summary>
			/// <exception cref="T:System.ArgumentOutOfRangeException">Specified range is not contained within the block.</exception>
			public unsafe BlobReader GetReader(int start, int length)
			{
				System.Reflection.BlobUtilities.ValidateRange(Length, start, length, "length");
				return new BlobReader(Pointer + start, length);
			}

			/// <summary>
			/// Reads the content of the entire block into an array.
			/// </summary>
			public System.Collections.Immutable.ImmutableArray<byte> GetContent()
			{
				return _block?.GetContentUnchecked(_offset, Length) ?? System.Collections.Immutable.ImmutableArray<byte>.Empty;
			}

			/// <summary>
			/// Reads the content of a part of the block into an array.
			/// </summary>
			/// <exception cref="T:System.ArgumentOutOfRangeException">Specified range is not contained within the block.</exception>
			public System.Collections.Immutable.ImmutableArray<byte> GetContent(int start, int length)
			{
				System.Reflection.BlobUtilities.ValidateRange(Length, start, length, "length");
				return _block?.GetContentUnchecked(_offset + start, length) ?? System.Collections.Immutable.ImmutableArray<byte>.Empty;
			}
		}

		/// <summary>
		/// Portable Executable format reader.
		/// </summary>
		/// <remarks>
		/// The implementation is thread-safe, that is multiple threads can read data from the reader in parallel.
		/// Disposal of the reader is not thread-safe (see <see cref="M:System.Reflection.PortableExecutable.PEReader.Dispose" />).
		/// </remarks>
		/// <summary>
		/// Portable Executable format reader.
		/// </summary>
		/// <remarks>
		/// The implementation is thread-safe, that is multiple threads can read data from the reader in parallel.
		/// Disposal of the reader is not thread-safe (see <see cref="M:System.Reflection.PortableExecutable.PEReader.Dispose" />).
		/// </remarks>
		public sealed class PEReader : IDisposable
		{
			private System.Reflection.Internal.MemoryBlockProvider _peImage;

			private PEHeaders _lazyPEHeaders;

			private System.Reflection.Internal.AbstractMemoryBlock _lazyMetadataBlock;

			private System.Reflection.Internal.AbstractMemoryBlock _lazyImageBlock;

			private System.Reflection.Internal.AbstractMemoryBlock[] _lazyPESectionBlocks;

			/// <summary>
			/// True if the PE image has been loaded into memory by the OS loader.
			/// </summary>
			public bool IsLoadedImage { get; }

			/// <summary>
			/// Gets the PE headers.
			/// </summary>
			/// <exception cref="T:System.BadImageFormatException">The headers contain invalid data.</exception>
			/// <exception cref="T:System.IO.IOException">Error reading from the stream.</exception>
			public PEHeaders PEHeaders
			{
				get
				{
					if (_lazyPEHeaders == null)
					{
						InitializePEHeaders();
					}
					return _lazyPEHeaders;
				}
			}

			/// <summary>
			/// Return true if the reader can access the entire PE image.
			/// </summary>
			/// <remarks>
			/// Returns false if the <see cref="T:System.Reflection.PortableExecutable.PEReader" /> is constructed from a stream and only part of it is prefetched into memory.
			/// </remarks>
			public bool IsEntireImageAvailable
			{
				get
				{
					if (_lazyImageBlock == null)
					{
						return _peImage != null;
					}
					return true;
				}
			}

			/// <summary>
			/// Returns true if the PE image contains CLI metadata.
			/// </summary>
			/// <exception cref="T:System.BadImageFormatException">The PE headers contain invalid data.</exception>
			/// <exception cref="T:System.IO.IOException">Error reading from the underlying stream.</exception>
			public bool HasMetadata => PEHeaders.MetadataSize > 0;

			/// <summary>
			/// Creates a Portable Executable reader over a PE image stored in memory.
			/// </summary>
			/// <param name="peImage">Pointer to the start of the PE image.</param>
			/// <param name="size">The size of the PE image.</param>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="peImage" /> is <see cref="F:System.IntPtr.Zero" />.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> is negative.</exception>
			/// <remarks>
			/// The memory is owned by the caller and not released on disposal of the <see cref="T:System.Reflection.PortableExecutable.PEReader" />.
			/// The caller is responsible for keeping the memory alive and unmodified throughout the lifetime of the <see cref="T:System.Reflection.PortableExecutable.PEReader" />.
			/// The content of the image is not read during the construction of the <see cref="T:System.Reflection.PortableExecutable.PEReader" />
			/// </remarks>
			public unsafe PEReader(byte* peImage, int size)
				: this(peImage, size, isLoadedImage: false)
			{
			}

			/// <summary>
			/// Creates a Portable Executable reader over a PE image stored in memory.
			/// </summary>
			/// <param name="peImage">Pointer to the start of the PE image.</param>
			/// <param name="size">The size of the PE image.</param>
			/// <param name="isLoadedImage">True if the PE image has been loaded into memory by the OS loader.</param>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="peImage" /> is <see cref="F:System.IntPtr.Zero" />.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> is negative.</exception>
			/// <remarks>
			/// The memory is owned by the caller and not released on disposal of the <see cref="T:System.Reflection.PortableExecutable.PEReader" />.
			/// The caller is responsible for keeping the memory alive and unmodified throughout the lifetime of the <see cref="T:System.Reflection.PortableExecutable.PEReader" />.
			/// The content of the image is not read during the construction of the <see cref="T:System.Reflection.PortableExecutable.PEReader" />
			/// </remarks>
			public unsafe PEReader(byte* peImage, int size, bool isLoadedImage)
			{
				if (peImage == null)
				{
					System.Reflection.Throw.ArgumentNull("peImage");
				}
				if (size < 0)
				{
					throw new ArgumentOutOfRangeException("size");
				}
				_peImage = new System.Reflection.Internal.ExternalMemoryBlockProvider(peImage, size);
				IsLoadedImage = isLoadedImage;
			}

			/// <summary>
			/// Creates a Portable Executable reader over a PE image stored in a stream.
			/// </summary>
			/// <param name="peStream">PE image stream.</param>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="peStream" /> is null.</exception>
			/// <remarks>
			/// Ownership of the stream is transferred to the <see cref="T:System.Reflection.PortableExecutable.PEReader" /> upon successful validation of constructor arguments. It will be
			/// disposed by the <see cref="T:System.Reflection.PortableExecutable.PEReader" /> and the caller must not manipulate it.
			/// </remarks>
			public PEReader(Stream peStream)
				: this(peStream, PEStreamOptions.Default)
			{
			}

			/// <summary>
			/// Creates a Portable Executable reader over a PE image stored in a stream beginning at its current position and ending at the end of the stream.
			/// </summary>
			/// <param name="peStream">PE image stream.</param>
			/// <param name="options">
			/// Options specifying how sections of the PE image are read from the stream.
			///
			/// Unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" /> is specified, ownership of the stream is transferred to the <see cref="T:System.Reflection.PortableExecutable.PEReader" />
			/// upon successful argument validation. It will be disposed by the <see cref="T:System.Reflection.PortableExecutable.PEReader" /> and the caller must not manipulate it.
			///
			/// Unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> or <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage" /> is specified no data
			/// is read from the stream during the construction of the <see cref="T:System.Reflection.PortableExecutable.PEReader" />. Furthermore, the stream must not be manipulated
			/// by caller while the <see cref="T:System.Reflection.PortableExecutable.PEReader" /> is alive and undisposed.
			///
			/// If <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> or <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage" />, the <see cref="T:System.Reflection.PortableExecutable.PEReader" />
			/// will have read all of the data requested during construction. As such, if <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" /> is also
			/// specified, the caller retains full ownership of the stream and is assured that it will not be manipulated by the <see cref="T:System.Reflection.PortableExecutable.PEReader" />
			/// after construction.
			/// </param>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="peStream" /> is null.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options" /> has an invalid value.</exception>
			/// <exception cref="T:System.IO.IOException">Error reading from the stream (only when prefetching data).</exception>
			/// <exception cref="T:System.BadImageFormatException"><see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> is specified and the PE headers of the image are invalid.</exception>
			public PEReader(Stream peStream, PEStreamOptions options)
				: this(peStream, options, 0)
			{
			}

			/// <summary>
			/// Creates a Portable Executable reader over a PE image of the given size beginning at the stream's current position.
			/// </summary>
			/// <param name="peStream">PE image stream.</param>
			/// <param name="size">PE image size.</param>
			/// <param name="options">
			/// Options specifying how sections of the PE image are read from the stream.
			///
			/// Unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" /> is specified, ownership of the stream is transferred to the <see cref="T:System.Reflection.PortableExecutable.PEReader" />
			/// upon successful argument validation. It will be disposed by the <see cref="T:System.Reflection.PortableExecutable.PEReader" /> and the caller must not manipulate it.
			///
			/// Unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> or <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage" /> is specified no data
			/// is read from the stream during the construction of the <see cref="T:System.Reflection.PortableExecutable.PEReader" />. Furthermore, the stream must not be manipulated
			/// by caller while the <see cref="T:System.Reflection.PortableExecutable.PEReader" /> is alive and undisposed.
			///
			/// If <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> or <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage" />, the <see cref="T:System.Reflection.PortableExecutable.PEReader" />
			/// will have read all of the data requested during construction. As such, if <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" /> is also
			/// specified, the caller retains full ownership of the stream and is assured that it will not be manipulated by the <see cref="T:System.Reflection.PortableExecutable.PEReader" />
			/// after construction.
			/// </param>
			/// <exception cref="T:System.ArgumentOutOfRangeException">Size is negative or extends past the end of the stream.</exception>
			/// <exception cref="T:System.IO.IOException">Error reading from the stream (only when prefetching data).</exception>
			/// <exception cref="T:System.BadImageFormatException"><see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata" /> is specified and the PE headers of the image are invalid.</exception>
			public unsafe PEReader(Stream peStream, PEStreamOptions options, int size)
			{
				if (peStream == null)
				{
					System.Reflection.Throw.ArgumentNull("peStream");
				}
				if (!peStream.CanRead || !peStream.CanSeek)
				{
					throw new ArgumentException(MDCFR.Properties.Resources.StreamMustSupportReadAndSeek, "peStream");
				}
				if (!options.IsValid())
				{
					throw new ArgumentOutOfRangeException("options");
				}
				IsLoadedImage = (options & PEStreamOptions.IsLoadedImage) != 0;
				long position = peStream.Position;
				int andValidateSize = System.Reflection.Internal.StreamExtensions.GetAndValidateSize(peStream, size, "peStream");
				bool flag = true;
				try
				{
					if ((options & (PEStreamOptions.PrefetchMetadata | PEStreamOptions.PrefetchEntireImage)) == 0)
					{
						_peImage = new System.Reflection.Internal.StreamMemoryBlockProvider(peStream, position, andValidateSize, (options & PEStreamOptions.LeaveOpen) != 0);
						flag = false;
					}
					else if ((options & PEStreamOptions.PrefetchEntireImage) != 0)
					{
						System.Reflection.Internal.NativeHeapMemoryBlock nativeHeapMemoryBlock = (System.Reflection.Internal.NativeHeapMemoryBlock)(_lazyImageBlock = System.Reflection.Internal.StreamMemoryBlockProvider.ReadMemoryBlockNoLock(peStream, position, andValidateSize));
						_peImage = new System.Reflection.Internal.ExternalMemoryBlockProvider(nativeHeapMemoryBlock.Pointer, nativeHeapMemoryBlock.Size);
						if ((options & PEStreamOptions.PrefetchMetadata) != 0)
						{
							InitializePEHeaders();
						}
					}
					else
					{
						_lazyPEHeaders = new PEHeaders(peStream);
						_lazyMetadataBlock = System.Reflection.Internal.StreamMemoryBlockProvider.ReadMemoryBlockNoLock(peStream, _lazyPEHeaders.MetadataStartOffset, _lazyPEHeaders.MetadataSize);
					}
				}
				finally
				{
					if (flag && (options & PEStreamOptions.LeaveOpen) == 0)
					{
						peStream.Dispose();
					}
				}
			}

			/// <summary>
			/// Creates a Portable Executable reader over a PE image stored in a byte array.
			/// </summary>
			/// <param name="peImage">PE image.</param>
			/// <remarks>
			/// The content of the image is not read during the construction of the <see cref="T:System.Reflection.PortableExecutable.PEReader" />
			/// </remarks>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="peImage" /> is null.</exception>
			public PEReader(System.Collections.Immutable.ImmutableArray<byte> peImage)
			{
				if (peImage.IsDefault)
				{
					System.Reflection.Throw.ArgumentNull("peImage");
				}
				_peImage = new System.Reflection.Internal.ByteArrayMemoryProvider(peImage);
			}

			/// <summary>
			/// Disposes all memory allocated by the reader.
			/// </summary>
			/// <remarks>
			/// <see cref="M:System.Reflection.PortableExecutable.PEReader.Dispose" />  can be called multiple times (but not in parallel).
			/// It is not safe to call <see cref="M:System.Reflection.PortableExecutable.PEReader.Dispose" /> in parallel with any other operation on the <see cref="T:System.Reflection.PortableExecutable.PEReader" />
			/// or reading from <see cref="T:System.Reflection.PortableExecutable.PEMemoryBlock" />s retrieved from the reader.
			/// </remarks>
			public void Dispose()
			{
				_lazyPEHeaders = null;
				_peImage?.Dispose();
				_peImage = null;
				_lazyImageBlock?.Dispose();
				_lazyImageBlock = null;
				_lazyMetadataBlock?.Dispose();
				_lazyMetadataBlock = null;
				System.Reflection.Internal.AbstractMemoryBlock[] lazyPESectionBlocks = _lazyPESectionBlocks;
				if (lazyPESectionBlocks != null)
				{
					System.Reflection.Internal.AbstractMemoryBlock[] array = lazyPESectionBlocks;
					for (int i = 0; i < array.Length; i++)
					{
						array[i]?.Dispose();
					}
					_lazyPESectionBlocks = null;
				}
			}

			private System.Reflection.Internal.MemoryBlockProvider GetPEImage()
			{
				System.Reflection.Internal.MemoryBlockProvider peImage = _peImage;
				if (peImage == null)
				{
					if (_lazyPEHeaders == null)
					{
						System.Reflection.Throw.PEReaderDisposed();
					}
					System.Reflection.Throw.InvalidOperation_PEImageNotAvailable();
				}
				return peImage;
			}

			/// <exception cref="T:System.IO.IOException">Error reading from the stream.</exception>
			private void InitializePEHeaders()
			{
				System.Reflection.Internal.StreamConstraints constraints;
				Stream stream = GetPEImage().GetStream(out constraints);
				PEHeaders value;
				if (constraints.GuardOpt != null)
				{
					lock (constraints.GuardOpt)
					{
						value = ReadPEHeadersNoLock(stream, constraints.ImageStart, constraints.ImageSize, IsLoadedImage);
					}
				}
				else
				{
					value = ReadPEHeadersNoLock(stream, constraints.ImageStart, constraints.ImageSize, IsLoadedImage);
				}
				Interlocked.CompareExchange(ref _lazyPEHeaders, value, null);
			}

			/// <exception cref="T:System.IO.IOException">Error reading from the stream.</exception>
			private static PEHeaders ReadPEHeadersNoLock(Stream stream, long imageStartPosition, int imageSize, bool isLoadedImage)
			{
				stream.Seek(imageStartPosition, SeekOrigin.Begin);
				return new PEHeaders(stream, imageSize, isLoadedImage);
			}

			/// <summary>
			/// Returns a view of the entire image as a pointer and length.
			/// </summary>
			/// <exception cref="T:System.InvalidOperationException">PE image not available.</exception>
			private System.Reflection.Internal.AbstractMemoryBlock GetEntireImageBlock()
			{
				if (_lazyImageBlock == null)
				{
					System.Reflection.Internal.AbstractMemoryBlock memoryBlock = GetPEImage().GetMemoryBlock();
					if (Interlocked.CompareExchange(ref _lazyImageBlock, memoryBlock, null) != null)
					{
						memoryBlock.Dispose();
					}
				}
				return _lazyImageBlock;
			}

			/// <exception cref="T:System.IO.IOException">IO error while reading from the underlying stream.</exception>
			/// <exception cref="T:System.InvalidOperationException">PE image doesn't have metadata.</exception>
			private System.Reflection.Internal.AbstractMemoryBlock GetMetadataBlock()
			{
				if (!HasMetadata)
				{
					throw new InvalidOperationException(MDCFR.Properties.Resources.PEImageDoesNotHaveMetadata);
				}
				if (_lazyMetadataBlock == null)
				{
					System.Reflection.Internal.AbstractMemoryBlock memoryBlock = GetPEImage().GetMemoryBlock(PEHeaders.MetadataStartOffset, PEHeaders.MetadataSize);
					if (Interlocked.CompareExchange(ref _lazyMetadataBlock, memoryBlock, null) != null)
					{
						memoryBlock.Dispose();
					}
				}
				return _lazyMetadataBlock;
			}

			/// <exception cref="T:System.IO.IOException">IO error while reading from the underlying stream.</exception>
			/// <exception cref="T:System.InvalidOperationException">PE image not available.</exception>
			private System.Reflection.Internal.AbstractMemoryBlock GetPESectionBlock(int index)
			{
				System.Reflection.Internal.MemoryBlockProvider pEImage = GetPEImage();
				if (_lazyPESectionBlocks == null)
				{
					Interlocked.CompareExchange(ref _lazyPESectionBlocks, new System.Reflection.Internal.AbstractMemoryBlock[PEHeaders.SectionHeaders.Length], null);
				}
				System.Reflection.Internal.AbstractMemoryBlock memoryBlock;
				if (IsLoadedImage)
				{
					memoryBlock = pEImage.GetMemoryBlock(PEHeaders.SectionHeaders[index].VirtualAddress, PEHeaders.SectionHeaders[index].VirtualSize);
				}
				else
				{
					int size = Math.Min(PEHeaders.SectionHeaders[index].VirtualSize, PEHeaders.SectionHeaders[index].SizeOfRawData);
					memoryBlock = pEImage.GetMemoryBlock(PEHeaders.SectionHeaders[index].PointerToRawData, size);
				}
				if (Interlocked.CompareExchange(ref _lazyPESectionBlocks[index], memoryBlock, null) != null)
				{
					memoryBlock.Dispose();
				}
				return _lazyPESectionBlocks[index];
			}

			/// <summary>
			/// Gets a pointer to and size of the PE image if available (<see cref="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable" />).
			/// </summary>
			/// <exception cref="T:System.InvalidOperationException">The entire PE image is not available.</exception>
			public PEMemoryBlock GetEntireImage()
			{
				return new PEMemoryBlock(GetEntireImageBlock());
			}

			/// <summary>
			/// Loads PE section that contains CLI metadata.
			/// </summary>
			/// <exception cref="T:System.InvalidOperationException">The PE image doesn't contain metadata (<see cref="P:System.Reflection.PortableExecutable.PEReader.HasMetadata" /> returns false).</exception>
			/// <exception cref="T:System.BadImageFormatException">The PE headers contain invalid data.</exception>
			/// <exception cref="T:System.IO.IOException">IO error while reading from the underlying stream.</exception>
			public PEMemoryBlock GetMetadata()
			{
				return new PEMemoryBlock(GetMetadataBlock());
			}

			/// <summary>
			/// Loads PE section that contains the specified <paramref name="relativeVirtualAddress" /> into memory
			/// and returns a memory block that starts at <paramref name="relativeVirtualAddress" /> and ends at the end of the containing section.
			/// </summary>
			/// <param name="relativeVirtualAddress">Relative Virtual Address of the data to read.</param>
			/// <returns>
			/// An empty block if <paramref name="relativeVirtualAddress" /> doesn't represent a location in any of the PE sections of this PE image.
			/// </returns>
			/// <exception cref="T:System.BadImageFormatException">The PE headers contain invalid data.</exception>
			/// <exception cref="T:System.IO.IOException">IO error while reading from the underlying stream.</exception>
			/// <exception cref="T:System.InvalidOperationException">PE image not available.</exception>
			/// <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="relativeVirtualAddress" /> is negative.</exception>
			public PEMemoryBlock GetSectionData(int relativeVirtualAddress)
			{
				if (relativeVirtualAddress < 0)
				{
					System.Reflection.Throw.ArgumentOutOfRange("relativeVirtualAddress");
				}
				int containingSectionIndex = PEHeaders.GetContainingSectionIndex(relativeVirtualAddress);
				if (containingSectionIndex < 0)
				{
					return default(PEMemoryBlock);
				}
				System.Reflection.Internal.AbstractMemoryBlock pESectionBlock = GetPESectionBlock(containingSectionIndex);
				int num = relativeVirtualAddress - PEHeaders.SectionHeaders[containingSectionIndex].VirtualAddress;
				if (num > pESectionBlock.Size)
				{
					return default(PEMemoryBlock);
				}
				return new PEMemoryBlock(pESectionBlock, num);
			}

			/// <summary>
			/// Loads PE section of the specified name into memory and returns a memory block that spans the section.
			/// </summary>
			/// <param name="sectionName">Name of the section.</param>
			/// <returns>
			/// An empty block if no section of the given <paramref name="sectionName" /> exists in this PE image.
			/// </returns>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="sectionName" /> is null.</exception>
			/// <exception cref="T:System.InvalidOperationException">PE image not available.</exception>
			public PEMemoryBlock GetSectionData(string sectionName)
			{
				if (sectionName == null)
				{
					System.Reflection.Throw.ArgumentNull("sectionName");
				}
				int num = PEHeaders.IndexOfSection(sectionName);
				if (num < 0)
				{
					return default(PEMemoryBlock);
				}
				return new PEMemoryBlock(GetPESectionBlock(num));
			}

			/// <summary>
			/// Reads all Debug Directory table entries.
			/// </summary>
			/// <exception cref="T:System.BadImageFormatException">Bad format of the entry.</exception>
			/// <exception cref="T:System.IO.IOException">IO error while reading from the underlying stream.</exception>
			/// <exception cref="T:System.InvalidOperationException">PE image not available.</exception>
			public System.Collections.Immutable.ImmutableArray<DebugDirectoryEntry> ReadDebugDirectory()
			{
				DirectoryEntry debugTableDirectory = PEHeaders.PEHeader.DebugTableDirectory;
				if (debugTableDirectory.Size == 0)
				{
					return System.Collections.Immutable.ImmutableArray<DebugDirectoryEntry>.Empty;
				}
				if (!PEHeaders.TryGetDirectoryOffset(debugTableDirectory, out var offset))
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.InvalidDirectoryRVA);
				}
				if (debugTableDirectory.Size % 28 != 0)
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.InvalidDirectorySize);
				}
				using System.Reflection.Internal.AbstractMemoryBlock abstractMemoryBlock = GetPEImage().GetMemoryBlock(offset, debugTableDirectory.Size);
				return ReadDebugDirectoryEntries(abstractMemoryBlock.GetReader());
			}

			internal static System.Collections.Immutable.ImmutableArray<DebugDirectoryEntry> ReadDebugDirectoryEntries(BlobReader reader)
			{
				int num = reader.Length / 28;
				System.Collections.Immutable.ImmutableArray<DebugDirectoryEntry>.Builder builder = System.Collections.Immutable.ImmutableArray.CreateBuilder<DebugDirectoryEntry>(num);
				for (int i = 0; i < num; i++)
				{
					if (reader.ReadInt32() != 0)
					{
						throw new BadImageFormatException(MDCFR.Properties.Resources.InvalidDebugDirectoryEntryCharacteristics);
					}
					uint stamp = reader.ReadUInt32();
					ushort majorVersion = reader.ReadUInt16();
					ushort minorVersion = reader.ReadUInt16();
					DebugDirectoryEntryType type = (DebugDirectoryEntryType)reader.ReadInt32();
					int dataSize = reader.ReadInt32();
					int dataRelativeVirtualAddress = reader.ReadInt32();
					int dataPointer = reader.ReadInt32();
					builder.Add(new DebugDirectoryEntry(stamp, majorVersion, minorVersion, type, dataSize, dataRelativeVirtualAddress, dataPointer));
				}
				return builder.MoveToImmutable();
			}

			private System.Reflection.Internal.AbstractMemoryBlock GetDebugDirectoryEntryDataBlock(DebugDirectoryEntry entry)
			{
				int start = (IsLoadedImage ? entry.DataRelativeVirtualAddress : entry.DataPointer);
				return GetPEImage().GetMemoryBlock(start, entry.DataSize);
			}

			/// <summary>
			/// Reads the data pointed to by the specified Debug Directory entry and interprets them as CodeView.
			/// </summary>
			/// <exception cref="T:System.ArgumentException"><paramref name="entry" /> is not a CodeView entry.</exception>
			/// <exception cref="T:System.BadImageFormatException">Bad format of the data.</exception>
			/// <exception cref="T:System.IO.IOException">IO error while reading from the underlying stream.</exception>
			/// <exception cref="T:System.InvalidOperationException">PE image not available.</exception>
			public CodeViewDebugDirectoryData ReadCodeViewDebugDirectoryData(DebugDirectoryEntry entry)
			{
				if (entry.Type != DebugDirectoryEntryType.CodeView)
				{
					System.Reflection.Throw.InvalidArgument(System.SR.Format(MDCFR.Properties.Resources.UnexpectedDebugDirectoryType, "CodeView"), "entry");
				}
				using System.Reflection.Internal.AbstractMemoryBlock block = GetDebugDirectoryEntryDataBlock(entry);
				return DecodeCodeViewDebugDirectoryData(block);
			}

			internal static CodeViewDebugDirectoryData DecodeCodeViewDebugDirectoryData(System.Reflection.Internal.AbstractMemoryBlock block)
			{
				BlobReader reader = block.GetReader();
				if (reader.ReadByte() != 82 || reader.ReadByte() != 83 || reader.ReadByte() != 68 || reader.ReadByte() != 83)
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.UnexpectedCodeViewDataSignature);
				}
				Guid guid = reader.ReadGuid();
				int age = reader.ReadInt32();
				string path = reader.ReadUtf8NullTerminated();
				return new CodeViewDebugDirectoryData(guid, age, path);
			}

			/// <summary>
			/// Reads the data pointed to by the specified Debug Directory entry and interprets them as PDB Checksum entry.
			/// </summary>
			/// <exception cref="T:System.ArgumentException"><paramref name="entry" /> is not a PDB Checksum entry.</exception>
			/// <exception cref="T:System.BadImageFormatException">Bad format of the data.</exception>
			/// <exception cref="T:System.IO.IOException">IO error while reading from the underlying stream.</exception>
			/// <exception cref="T:System.InvalidOperationException">PE image not available.</exception>
			public PdbChecksumDebugDirectoryData ReadPdbChecksumDebugDirectoryData(DebugDirectoryEntry entry)
			{
				if (entry.Type != DebugDirectoryEntryType.PdbChecksum)
				{
					System.Reflection.Throw.InvalidArgument(System.SR.Format(MDCFR.Properties.Resources.UnexpectedDebugDirectoryType, "PdbChecksum"), "entry");
				}
				using System.Reflection.Internal.AbstractMemoryBlock block = GetDebugDirectoryEntryDataBlock(entry);
				return DecodePdbChecksumDebugDirectoryData(block);
			}

			internal static PdbChecksumDebugDirectoryData DecodePdbChecksumDebugDirectoryData(System.Reflection.Internal.AbstractMemoryBlock block)
			{
				BlobReader reader = block.GetReader();
				string text = reader.ReadUtf8NullTerminated();
				byte[] array = reader.ReadBytes(reader.RemainingBytes);
				if (text.Length == 0 || array.Length == 0)
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.InvalidPdbChecksumDataFormat);
				}
				return new PdbChecksumDebugDirectoryData(text, ImmutableByteArrayInterop.DangerousCreateFromUnderlyingArray(ref array));
			}

			/// <summary>
			/// Opens a Portable PDB associated with this PE image.
			/// </summary>
			/// <param name="peImagePath">
			/// The path to the PE image. The path is used to locate the PDB file located in the directory containing the PE file.
			/// </param>
			/// <param name="pdbFileStreamProvider">
			/// If specified, called to open a <see cref="T:System.IO.Stream" /> for a given file path.
			/// The provider is expected to either return a readable and seekable <see cref="T:System.IO.Stream" />,
			/// or <c>null</c> if the target file doesn't exist or should be ignored for some reason.
			///
			/// The provider shall throw <see cref="T:System.IO.IOException" /> if it fails to open the file due to an unexpected IO error.
			/// </param>
			/// <param name="pdbReaderProvider">
			/// If successful, a new instance of <see cref="T:System.Reflection.Metadata.MetadataReaderProvider" /> to be used to read the Portable PDB,.
			/// </param>
			/// <param name="pdbPath">
			/// If successful and the PDB is found in a file, the path to the file. Returns <c>null</c> if the PDB is embedded in the PE image itself.
			/// </param>
			/// <returns>
			/// True if the PE image has a PDB associated with it and the PDB has been successfully opened.
			/// </returns>
			/// <remarks>
			/// Implements a simple PDB file lookup based on the content of the PE image Debug Directory.
			/// A sophisticated tool might need to follow up with additional lookup on search paths or symbol server.
			///
			/// The method looks the PDB up in the following steps in the listed order:
			/// 1) Check for a matching PDB file of the name found in the CodeView entry in the directory containing the PE file (the directory of <paramref name="peImagePath" />).
			/// 2) Check for a PDB embedded in the PE image itself.
			///
			/// The first PDB that matches the information specified in the Debug Directory is returned.
			/// </remarks>
			/// <exception cref="T:System.ArgumentNullException"><paramref name="peImagePath" /> or <paramref name="pdbFileStreamProvider" /> is null.</exception>
			/// <exception cref="T:System.InvalidOperationException">The stream returned from <paramref name="pdbFileStreamProvider" /> doesn't support read and seek operations.</exception>
			/// <exception cref="T:System.BadImageFormatException">No matching PDB file is found due to an error: The PE image or the PDB is invalid.</exception>
			/// <exception cref="T:System.IO.IOException">No matching PDB file is found due to an error: An IO error occurred while reading the PE image or the PDB.</exception>
			public bool TryOpenAssociatedPortablePdb(string peImagePath, Func<string, Stream?> pdbFileStreamProvider, out MetadataReaderProvider? pdbReaderProvider, out string? pdbPath)
			{
				if (peImagePath == null)
				{
					System.Reflection.Throw.ArgumentNull("peImagePath");
				}
				if (pdbFileStreamProvider == null)
				{
					System.Reflection.Throw.ArgumentNull("pdbFileStreamProvider");
				}
				pdbReaderProvider = null;
				pdbPath = null;
				string directoryName;
				try
				{
					directoryName = Path.GetDirectoryName(peImagePath);
				}
				catch (Exception ex)
				{
					throw new ArgumentException(ex.Message, "peImagePath");
				}
				Exception errorToReport = null;
				System.Collections.Immutable.ImmutableArray<DebugDirectoryEntry> collection = ReadDebugDirectory();
				DebugDirectoryEntry codeViewEntry = EnumerableExtensions.FirstOrDefault(collection, (DebugDirectoryEntry e) => e.IsPortableCodeView);
				if (codeViewEntry.DataSize != 0 && TryOpenCodeViewPortablePdb(codeViewEntry, directoryName, pdbFileStreamProvider, out pdbReaderProvider, out pdbPath, ref errorToReport))
				{
					return true;
				}
				DebugDirectoryEntry embeddedPdbEntry = EnumerableExtensions.FirstOrDefault(collection, (DebugDirectoryEntry e) => e.Type == DebugDirectoryEntryType.EmbeddedPortablePdb);
				if (embeddedPdbEntry.DataSize != 0)
				{
					bool openedEmbeddedPdb = false;
					pdbReaderProvider = null;
					TryOpenEmbeddedPortablePdb(embeddedPdbEntry, ref openedEmbeddedPdb, ref pdbReaderProvider, ref errorToReport);
					if (openedEmbeddedPdb)
					{
						return true;
					}
				}
				if (errorToReport != null)
				{
					ExceptionDispatchInfo.Capture(errorToReport).Throw();
				}
				return false;
			}

			private bool TryOpenCodeViewPortablePdb(DebugDirectoryEntry codeViewEntry, string peImageDirectory, Func<string, Stream> pdbFileStreamProvider, out MetadataReaderProvider provider, out string pdbPath, ref Exception errorToReport)
			{
				pdbPath = null;
				provider = null;
				CodeViewDebugDirectoryData codeViewDebugDirectoryData;
				try
				{
					codeViewDebugDirectoryData = ReadCodeViewDebugDirectoryData(codeViewEntry);
				}
				catch (Exception ex) when (ex is BadImageFormatException || ex is IOException)
				{
					if (errorToReport == null)
					{
						errorToReport = ex;
					}
					return false;
				}
				BlobContentId id = new BlobContentId(codeViewDebugDirectoryData.Guid, codeViewEntry.Stamp);
				string text = System.Reflection.Metadata.PathUtilities.CombinePathWithRelativePath(peImageDirectory, System.Reflection.Metadata.PathUtilities.GetFileName(codeViewDebugDirectoryData.Path));
				if (TryOpenPortablePdbFile(text, id, pdbFileStreamProvider, out provider, ref errorToReport))
				{
					pdbPath = text;
					return true;
				}
				return false;
			}

			private static bool TryOpenPortablePdbFile(string path, BlobContentId id, Func<string, Stream> pdbFileStreamProvider, out MetadataReaderProvider provider, ref Exception errorToReport)
			{
				provider = null;
				MetadataReaderProvider metadataReaderProvider = null;
				try
				{
					Stream stream;
					try
					{
						stream = pdbFileStreamProvider(path);
					}
					catch (FileNotFoundException)
					{
						stream = null;
					}
					if (stream == null)
					{
						return false;
					}
					if (!stream.CanRead || !stream.CanSeek)
					{
						throw new InvalidOperationException(MDCFR.Properties.Resources.StreamMustSupportReadAndSeek);
					}
					metadataReaderProvider = MetadataReaderProvider.FromPortablePdbStream(stream);
					if (new BlobContentId(metadataReaderProvider.GetMetadataReader().DebugMetadataHeader.Id) != id)
					{
						return false;
					}
					provider = metadataReaderProvider;
					return true;
				}
				catch (Exception ex2) when (ex2 is BadImageFormatException || ex2 is IOException)
				{
					if (errorToReport == null)
					{
						errorToReport = ex2;
					}
					return false;
				}
				finally
				{
					if (provider == null)
					{
						metadataReaderProvider?.Dispose();
					}
				}
			}

			private void TryOpenEmbeddedPortablePdb(DebugDirectoryEntry embeddedPdbEntry, ref bool openedEmbeddedPdb, ref MetadataReaderProvider provider, ref Exception errorToReport)
			{
				provider = null;
				MetadataReaderProvider metadataReaderProvider = null;
				try
				{
					metadataReaderProvider = ReadEmbeddedPortablePdbDebugDirectoryData(embeddedPdbEntry);
					metadataReaderProvider.GetMetadataReader();
					provider = metadataReaderProvider;
					openedEmbeddedPdb = true;
				}
				catch (Exception ex) when (ex is BadImageFormatException || ex is IOException)
				{
					if (errorToReport == null)
					{
						errorToReport = ex;
					}
					openedEmbeddedPdb = false;
				}
				finally
				{
					if (provider == null)
					{
						metadataReaderProvider?.Dispose();
					}
				}
			}

			/// <summary>
			/// Reads the data pointed to by the specified Debug Directory entry and interprets them as Embedded Portable PDB blob.
			/// </summary>
			/// <returns>
			/// Provider of a metadata reader reading the embedded Portable PDB image.
			/// Dispose to release resources allocated for the embedded PDB.
			/// </returns>
			/// <exception cref="T:System.ArgumentException"><paramref name="entry" /> is not a <see cref="F:System.Reflection.PortableExecutable.DebugDirectoryEntryType.EmbeddedPortablePdb" /> entry.</exception>
			/// <exception cref="T:System.BadImageFormatException">Bad format of the data.</exception>
			/// <exception cref="T:System.InvalidOperationException">PE image not available.</exception>
			public MetadataReaderProvider ReadEmbeddedPortablePdbDebugDirectoryData(DebugDirectoryEntry entry)
			{
				if (entry.Type != DebugDirectoryEntryType.EmbeddedPortablePdb)
				{
					System.Reflection.Throw.InvalidArgument(System.SR.Format(MDCFR.Properties.Resources.UnexpectedDebugDirectoryType, "EmbeddedPortablePdb"), "entry");
				}
				ValidateEmbeddedPortablePdbVersion(entry);
				using System.Reflection.Internal.AbstractMemoryBlock block = GetDebugDirectoryEntryDataBlock(entry);
				return new MetadataReaderProvider(DecodeEmbeddedPortablePdbDebugDirectoryData(block));
			}

			internal static void ValidateEmbeddedPortablePdbVersion(DebugDirectoryEntry entry)
			{
				ushort majorVersion = entry.MajorVersion;
				if (majorVersion < 256)
				{
					throw new BadImageFormatException(System.SR.Format(MDCFR.Properties.Resources.UnsupportedFormatVersion, System.Reflection.Metadata.PortablePdbVersions.Format(majorVersion)));
				}
				ushort minorVersion = entry.MinorVersion;
				if (minorVersion != 256)
				{
					throw new BadImageFormatException(System.SR.Format(MDCFR.Properties.Resources.UnsupportedFormatVersion, System.Reflection.Metadata.PortablePdbVersions.Format(minorVersion)));
				}
			}

			internal unsafe static System.Reflection.Internal.NativeHeapMemoryBlock DecodeEmbeddedPortablePdbDebugDirectoryData(System.Reflection.Internal.AbstractMemoryBlock block)
			{
				BlobReader reader = block.GetReader();
				if (reader.ReadUInt32() != 1111773261)
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.UnexpectedEmbeddedPortablePdbDataSignature);
				}
				int num = reader.ReadInt32();
				System.Reflection.Internal.NativeHeapMemoryBlock nativeHeapMemoryBlock;
				try
				{
					nativeHeapMemoryBlock = new System.Reflection.Internal.NativeHeapMemoryBlock(num);
				}
				catch
				{
					throw new BadImageFormatException(MDCFR.Properties.Resources.DataTooBig);
				}
				bool flag = false;
				try
				{
					System.Reflection.Internal.ReadOnlyUnmanagedMemoryStream stream = new System.Reflection.Internal.ReadOnlyUnmanagedMemoryStream(reader.CurrentPointer, reader.RemainingBytes);
					using DeflateStream deflateStream = new DeflateStream(stream, CompressionMode.Decompress, leaveOpen: true);
					if (num > 0)
					{
						int num2;
						try
						{
							using UnmanagedMemoryStream unmanagedMemoryStream = new UnmanagedMemoryStream(nativeHeapMemoryBlock.Pointer, nativeHeapMemoryBlock.Size, nativeHeapMemoryBlock.Size, FileAccess.Write);
							deflateStream.CopyTo(unmanagedMemoryStream);
							num2 = (int)unmanagedMemoryStream.Position;
						}
						catch (Exception ex)
						{
							throw new BadImageFormatException(ex.Message, ex.InnerException);
						}
						if (num2 != nativeHeapMemoryBlock.Size)
						{
							throw new BadImageFormatException(MDCFR.Properties.Resources.SizeMismatch);
						}
					}
					if (deflateStream.ReadByte() != -1)
					{
						throw new BadImageFormatException(MDCFR.Properties.Resources.SizeMismatch);
					}
					flag = true;
				}
				finally
				{
					if (!flag)
					{
						nativeHeapMemoryBlock.Dispose();
					}
				}
				return nativeHeapMemoryBlock;
			}
		}

		[Flags]
		public enum PEStreamOptions
		{
			/// <summary>
			/// By default the stream is disposed when <see cref="T:System.Reflection.PortableExecutable.PEReader" /> is disposed and sections of the PE image are read lazily.
			/// </summary>
			Default = 0,
			/// <summary>
			/// Keep the stream open when the <see cref="T:System.Reflection.PortableExecutable.PEReader" /> is disposed.
			/// </summary>
			LeaveOpen = 1,
			/// <summary>
			/// Reads metadata section into memory right away.
			/// </summary>
			/// <remarks>
			/// Reading from other sections of the file is not allowed (<see cref="T:System.InvalidOperationException" /> is thrown by the <see cref="T:System.Reflection.PortableExecutable.PEReader" />).
			/// The underlying file may be closed and even deleted after <see cref="T:System.Reflection.PortableExecutable.PEReader" /> is constructed.
			///
			/// <see cref="T:System.Reflection.PortableExecutable.PEReader" /> closes the stream automatically by the time the constructor returns unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" /> is specified.
			/// </remarks>
			PrefetchMetadata = 2,
			/// <summary>
			/// Reads the entire image into memory right away.
			/// </summary>
			/// <remarks>
			/// <see cref="T:System.Reflection.PortableExecutable.PEReader" /> closes the stream automatically by the time the constructor returns unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen" /> is specified.
			/// </remarks>
			PrefetchEntireImage = 4,
			/// <summary>
			/// Indicates that the underlying PE image has been loaded into memory by the OS loader.
			/// </summary>
			IsLoadedImage = 8
		}

		internal static class PEStreamOptionsExtensions
		{
			public static bool IsValid(this PEStreamOptions options)
			{
				return (options & ~(PEStreamOptions.LeaveOpen | PEStreamOptions.PrefetchMetadata | PEStreamOptions.PrefetchEntireImage | PEStreamOptions.IsLoadedImage)) == 0;
			}
		}

		/// <summary>
		/// Base class for PE resource section builder. Implement to provide serialization logic for native resources.
		/// </summary>
		public abstract class ResourceSectionBuilder
		{
			protected internal abstract void Serialize(BlobBuilder builder, SectionLocation location);
		}

		[Flags]
		public enum SectionCharacteristics : uint
		{
			TypeReg = 0u,
			TypeDSect = 1u,
			TypeNoLoad = 2u,
			TypeGroup = 4u,
			TypeNoPad = 8u,
			TypeCopy = 0x10u,
			ContainsCode = 0x20u,
			ContainsInitializedData = 0x40u,
			ContainsUninitializedData = 0x80u,
			LinkerOther = 0x100u,
			LinkerInfo = 0x200u,
			TypeOver = 0x400u,
			LinkerRemove = 0x800u,
			LinkerComdat = 0x1000u,
			MemProtected = 0x4000u,
			NoDeferSpecExc = 0x4000u,
			GPRel = 0x8000u,
			MemFardata = 0x8000u,
			MemSysheap = 0x10000u,
			MemPurgeable = 0x20000u,
			Mem16Bit = 0x20000u,
			MemLocked = 0x40000u,
			MemPreload = 0x80000u,
			Align1Bytes = 0x100000u,
			Align2Bytes = 0x200000u,
			Align4Bytes = 0x300000u,
			Align8Bytes = 0x400000u,
			Align16Bytes = 0x500000u,
			Align32Bytes = 0x600000u,
			Align64Bytes = 0x700000u,
			Align128Bytes = 0x800000u,
			Align256Bytes = 0x900000u,
			Align512Bytes = 0xA00000u,
			Align1024Bytes = 0xB00000u,
			Align2048Bytes = 0xC00000u,
			Align4096Bytes = 0xD00000u,
			Align8192Bytes = 0xE00000u,
			AlignMask = 0xF00000u,
			LinkerNRelocOvfl = 0x1000000u,
			MemDiscardable = 0x2000000u,
			MemNotCached = 0x4000000u,
			MemNotPaged = 0x8000000u,
			MemShared = 0x10000000u,
			MemExecute = 0x20000000u,
			MemRead = 0x40000000u,
			MemWrite = 0x80000000u
		}

		public readonly struct SectionHeader
		{
			internal const int NameSize = 8;

			internal const int Size = 40;

			/// <summary>
			/// The name of the section.
			/// </summary>
			public string Name { get; }

			/// <summary>
			/// The total size of the section when loaded into memory.
			/// If this value is greater than <see cref="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData" />, the section is zero-padded.
			/// This field is valid only for PE images and should be set to zero for object files.
			/// </summary>
			public int VirtualSize { get; }

			/// <summary>
			/// For PE images, the address of the first byte of the section relative to the image base when the
			/// section is loaded into memory. For object files, this field is the address of the first byte before
			/// relocation is applied; for simplicity, compilers should set this to zero. Otherwise,
			/// it is an arbitrary value that is subtracted from offsets during relocation.
			/// </summary>
			public int VirtualAddress { get; }

			/// <summary>
			/// The size of the section (for object files) or the size of the initialized data on disk (for image files).
			/// For PE images, this must be a multiple of <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" />.
			/// If this is less than <see cref="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize" />, the remainder of the section is zero-filled.
			/// Because the <see cref="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData" /> field is rounded but the <see cref="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize" /> field is not,
			/// it is possible for <see cref="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData" /> to be greater than <see cref="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize" /> as well.
			///  When a section contains only uninitialized data, this field should be zero.
			/// </summary>
			public int SizeOfRawData { get; }

			/// <summary>
			/// The file pointer to the first page of the section within the COFF file.
			/// For PE images, this must be a multiple of <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment" />.
			/// For object files, the value should be aligned on a 4 byte boundary for best performance.
			/// When a section contains only uninitialized data, this field should be zero.
			/// </summary>
			public int PointerToRawData { get; }

			/// <summary>
			/// The file pointer to the beginning of relocation entries for the section.
			/// This is set to zero for PE images or if there are no relocations.
			/// </summary>
			public int PointerToRelocations { get; }

			/// <summary>
			/// The file pointer to the beginning of line-number entries for the section.
			/// This is set to zero if there are no COFF line numbers.
			/// This value should be zero for an image because COFF debugging information is deprecated.
			/// </summary>
			public int PointerToLineNumbers { get; }

			/// <summary>
			/// The number of relocation entries for the section. This is set to zero for PE images.
			/// </summary>
			public ushort NumberOfRelocations { get; }

			/// <summary>
			/// The number of line-number entries for the section.
			///  This value should be zero for an image because COFF debugging information is deprecated.
			/// </summary>
			public ushort NumberOfLineNumbers { get; }

			/// <summary>
			/// The flags that describe the characteristics of the section.
			/// </summary>
			public SectionCharacteristics SectionCharacteristics { get; }

			internal SectionHeader(ref System.Reflection.PortableExecutable.PEBinaryReader reader)
			{
				Name = reader.ReadNullPaddedUTF8(8);
				VirtualSize = reader.ReadInt32();
				VirtualAddress = reader.ReadInt32();
				SizeOfRawData = reader.ReadInt32();
				PointerToRawData = reader.ReadInt32();
				PointerToRelocations = reader.ReadInt32();
				PointerToLineNumbers = reader.ReadInt32();
				NumberOfRelocations = reader.ReadUInt16();
				NumberOfLineNumbers = reader.ReadUInt16();
				SectionCharacteristics = (SectionCharacteristics)reader.ReadUInt32();
			}
		}

		public readonly struct SectionLocation
		{
			public int RelativeVirtualAddress { get; }

			public int PointerToRawData { get; }

			public SectionLocation(int relativeVirtualAddress, int pointerToRawData)
			{
				RelativeVirtualAddress = relativeVirtualAddress;
				PointerToRawData = pointerToRawData;
			}
		}

		public enum Subsystem : ushort
		{
			Unknown = 0,
			Native = 1,
			WindowsGui = 2,
			WindowsCui = 3,
			OS2Cui = 5,
			PosixCui = 7,
			NativeWindows = 8,
			WindowsCEGui = 9,
			EfiApplication = 10,
			EfiBootServiceDriver = 11,
			EfiRuntimeDriver = 12,
			EfiRom = 13,
			Xbox = 14,
			WindowsBootApplication = 16
		}
	}
}